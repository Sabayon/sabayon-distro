diff -Nurp e2fsprogs-1.40.8/config/asm_types.h e2fsprogs/config/asm_types.h
--- e2fsprogs-1.40.8/config/asm_types.h	2007-07-04 21:58:39.000000000 +0200
+++ e2fsprogs/config/asm_types.h	1970-01-01 01:00:00.000000000 +0100
@@ -1,8 +0,0 @@
-#define __S8_TYPEDEF __signed__ char
-#define __U8_TYPEDEF unsigned char
-#define __S16_TYPEDEF __signed__ short
-#define __U16_TYPEDEF unsigned short
-#define __S32_TYPEDEF __signed__ int
-#define __U32_TYPEDEF unsigned int
-#define __S64_TYPEDEF __signed__ long long
-#define __U64_TYPEDEF unsigned long long
diff -Nurp e2fsprogs-1.40.8/configure e2fsprogs/configure
--- e2fsprogs-1.40.8/configure	2008-03-13 23:20:46.000000000 +0100
+++ e2fsprogs/configure	2008-03-29 01:20:43.000000000 +0100
@@ -684,7 +684,6 @@ CHECKER_CMT
 LIB_EXT
 STATIC_LIB_EXT
 PROFILED_LIB_EXT
-SWAPFS_CMT
 DEBUGFS_CMT
 IMAGER_CMT
 RESIZER_CMT
@@ -1371,7 +1370,6 @@ Optional Features:
   --enable-jbd-debug  	  enable journal debugging
   --enable-blkid-debug    enable blkid debugging
   --enable-testio-debug   enable the use of the test I/O manager for debugging
-  --disable-swapfs    	  disable support of legacy byte-swapped filesystems
   --disable-debugfs   	  disable support of debugfs program
   --disable-imager   	  disable support of e2image program
   --disable-resizer   	  disable support of e2resize program
@@ -4000,32 +3998,6 @@ else
 
 fi
 
-# Check whether --enable-swapfs was given.
-if test "${enable_swapfs+set}" = set; then
-  enableval=$enable_swapfs; if test "$enableval" = "no"
-then
-	SWAPFS_CMT=#
-	echo "Disabling swapfs support"
-else
-	SWAPFS_CMT=
-	cat >>confdefs.h <<\_ACEOF
-#define ENABLE_SWAPFS 1
-_ACEOF
-
-	echo "Enabling swapfs support"
-fi
-
-else
-  SWAPFS_CMT=
-echo "Enabling swapfs support by default"
-cat >>confdefs.h <<\_ACEOF
-#define ENABLE_SWAPFS 1
-_ACEOF
-
-
-fi
-
-
 # Check whether --enable-debugfs was given.
 if test "${enable_debugfs+set}" = set; then
   enableval=$enable_debugfs; if test "$enableval" = "no"
@@ -16035,11 +16007,11 @@ CHECKER_CMT!$CHECKER_CMT$ac_delim
 LIB_EXT!$LIB_EXT$ac_delim
 STATIC_LIB_EXT!$STATIC_LIB_EXT$ac_delim
 PROFILED_LIB_EXT!$PROFILED_LIB_EXT$ac_delim
-SWAPFS_CMT!$SWAPFS_CMT$ac_delim
 DEBUGFS_CMT!$DEBUGFS_CMT$ac_delim
 IMAGER_CMT!$IMAGER_CMT$ac_delim
 RESIZER_CMT!$RESIZER_CMT$ac_delim
 FSCK_PROG!$FSCK_PROG$ac_delim
+FSCK_MAN!$FSCK_MAN$ac_delim
 _ACEOF
 
   if test `sed -n "s/.*$ac_delim\$/X/p" conf$$subs.sed | grep -c X` = 76; then
@@ -16109,7 +16081,6 @@ _ACEOF
 ac_delim='%!_!# '
 for ac_last_try in false false false false false :; do
   cat >conf$$subs.sed <<_ACEOF
-FSCK_MAN!$FSCK_MAN$ac_delim
 E2INITRD_PROG!$E2INITRD_PROG$ac_delim
 E2INITRD_MAN!$E2INITRD_MAN$ac_delim
 PKG_CONFIG!$PKG_CONFIG$ac_delim
@@ -16194,7 +16165,7 @@ LIBOBJS!$LIBOBJS$ac_delim
 LTLIBOBJS!$LTLIBOBJS$ac_delim
 _ACEOF
 
-  if test `sed -n "s/.*$ac_delim\$/X/p" conf$$subs.sed | grep -c X` = 83; then
+  if test `sed -n "s/.*$ac_delim\$/X/p" conf$$subs.sed | grep -c X` = 82; then
     break
   elif $ac_last_try; then
     { { echo "$as_me:$LINENO: error: could not make $CONFIG_STATUS" >&5
diff -Nurp e2fsprogs-1.40.8/configure.in e2fsprogs/configure.in
--- e2fsprogs-1.40.8/configure.in	2008-03-13 23:20:46.000000000 +0100
+++ e2fsprogs/configure.in	2008-03-29 01:20:43.000000000 +0100
@@ -367,26 +367,6 @@ fi
 echo "Disabling testio debugging by default"
 )
 dnl
-dnl handle --enable-swapfs
-dnl
-AC_ARG_ENABLE([swapfs],
-[  --disable-swapfs    	  disable support of legacy byte-swapped filesystems],
-if test "$enableval" = "no"
-then
-	SWAPFS_CMT=#
-	echo "Disabling swapfs support"
-else
-	SWAPFS_CMT=
-	AC_DEFINE(ENABLE_SWAPFS)
-	echo "Enabling swapfs support"
-fi
-,
-SWAPFS_CMT=
-echo "Enabling swapfs support by default"
-AC_DEFINE(ENABLE_SWAPFS)
-)
-AC_SUBST(SWAPFS_CMT)
-dnl
 dnl handle --enable-debugfs
 dnl
 AC_ARG_ENABLE([debugfs],
diff -Nurp e2fsprogs-1.40.8/debian/changelog e2fsprogs/debian/changelog
--- e2fsprogs-1.40.8/debian/changelog	2008-03-14 01:00:18.000000000 +0100
+++ e2fsprogs/debian/changelog	2008-03-29 01:20:43.000000000 +0100
@@ -1,3 +1,13 @@
+e2fsprogs (1.40.8-2) unstable; urgency=low
+
+  * One more big-endian swap fix needed for resize2fs to work correctly
+      with in-inode extended attributes.
+  * Fix minor security issues identified in uuidd.
+  * Remove e2fsprogs preinstall script which contained stuff not needed
+      in well over two stable releases.
+
+ -- Theodore Y. Ts'o <tytso@mit.edu>  Fri, 14 Mar 2008 14:25:54 -0400
+
 e2fsprogs (1.40.8-1) unstable; urgency=low
 
   * Fix e2image -I so it works on image files which are larger than 2GB.
diff -Nurp e2fsprogs-1.40.8/debian/e2fsprogs.preinst e2fsprogs/debian/e2fsprogs.preinst
--- e2fsprogs-1.40.8/debian/e2fsprogs.preinst	2007-06-30 14:58:34.000000000 +0200
+++ e2fsprogs/debian/e2fsprogs.preinst	1970-01-01 01:00:00.000000000 +0100
@@ -1,23 +0,0 @@
-#!/bin/sh
-
-dpkg --assert-support-predepends 2> /dev/null
-
-case $? in
- 0) ;; # fine, supported
- 1) exit 1 ;; # dpkg writes an error message to stdio
- 2) cat <<EOT
-This package requires features of dpkg unavailable in this version.
-Please upgrade to a more recent version (>=1.1.0) of dpkg.
-EOT
-    exit 1 ;; # dpkg didn't recognise the option
- *) exit 2 ;;
-esac
-
-# Old/erroneous conffile from early post-woody sid
-if [ -f /etc/mkinitrd/scripts/e2fsprogs ]
-then
-    rm -rf /etc/mkinitrd/scripts/e2fsprogs
-fi
-rm -f /etc/mkinitrd/scripts/e2fsprogs.mkinitrd
-
-#DEBHELPER#
diff -Nurp e2fsprogs-1.40.8/debian/rules e2fsprogs/debian/rules
--- e2fsprogs-1.40.8/debian/rules	2008-03-13 23:20:46.000000000 +0100
+++ e2fsprogs/debian/rules	2008-03-29 01:20:43.000000000 +0100
@@ -103,7 +103,7 @@ STD_CONF_FLAGS = --with-ccopts="${CCOPTS
 		${DEVMAPPER}
 
 BF_CONF_FLAGS = --with-ccopts="${CCOPTS} ${BF_CCOPTS}" \
-	--disable-nls --disable-swapfs --disable-imager \
+	--disable-nls --disable-imager \
 	--disable-uuidd --disable-tls \
 	--disable-debugfs  --disable-e2initrd-helper
 
@@ -114,8 +114,7 @@ STATIC_CONF_FLAGS = --with-ccopts="${CCO
 	--with-ccopts=-fno-stack-protector
 
 MIPS_NOPIC_CONF_FLAGS = --with-ccopts="${CCOPTS}" \
-	--disable-nls \
-	--disable-swapfs --disable-imager \
+	--disable-nls --disable-imager \
 	--disable-uuidd --disable-tls \
         --disable-resizer # --disable-debugfs
 
diff -Nurp e2fsprogs-1.40.8/debugfs/debugfs.8.in e2fsprogs/debugfs/debugfs.8.in
--- e2fsprogs-1.40.8/debugfs/debugfs.8.in	2008-03-13 23:20:46.000000000 +0100
+++ e2fsprogs/debugfs/debugfs.8.in	2008-03-29 01:20:43.000000000 +0100
@@ -306,7 +306,7 @@ and 
 .I \-b
 options.
 .TP
-.I ls [-l] [-d] filespec
+.I ls [-l] [-d] [-p] filespec
 Print a listing of the files in the directory
 .IR filespec .
 The 
@@ -315,6 +315,11 @@ flag will list files using a more verbos
 The
 .I \-d
 flag will list deleted entries in the directory.
+The 
+.I \-p
+flag will list the files in a format which is more easily parsable by
+scripts, as well as making it more clear when there are spaces or other
+non-prinitng characters at the end of filenames.
 .TP
 .I modify_inode filespec
 Modify the contents of the inode structure in the inode
diff -Nurp e2fsprogs-1.40.8/debugfs/debugfs.c e2fsprogs/debugfs/debugfs.c
--- e2fsprogs-1.40.8/debugfs/debugfs.c	2008-03-13 23:20:46.000000000 +0100
+++ e2fsprogs/debugfs/debugfs.c	2008-03-29 01:20:43.000000000 +0100
@@ -38,6 +38,8 @@ extern char *optarg;
 #include "../version.h"
 
 extern ss_request_table debug_cmds;
+ss_request_table *extra_cmds;
+const char *debug_prog_name;
 
 ext2_filsys	current_fs = NULL;
 ext2_ino_t	root, cwd;
@@ -286,7 +288,10 @@ void do_show_super_stats(int argc, char 
 	FILE 	*out;
 	struct ext2_group_desc *gdp;
 	int	c, header_only = 0;
-	int	numdirs = 0, first;
+	int	numdirs = 0, first, gdt_csum;
+
+	gdt_csum = EXT2_HAS_RO_COMPAT_FEATURE(current_fs->super,
+					      EXT4_FEATURE_RO_COMPAT_GDT_CSUM);
 
 	reset_getopt();
 	while ((c = getopt (argc, argv, "h")) != EOF) {
@@ -322,7 +327,7 @@ void do_show_super_stats(int argc, char 
 		        "inode table at %u\n"
 		        "           %d free %s, "
 		        "%d free %s, "
-		        "%d used %s\n",
+		        "%d used %s%s",
 		        i, gdp->bg_block_bitmap,
 		        gdp->bg_inode_bitmap, gdp->bg_inode_table,
 		        gdp->bg_free_blocks_count,
@@ -331,12 +336,21 @@ void do_show_super_stats(int argc, char 
 		        gdp->bg_free_inodes_count != 1 ? "inodes" : "inode",
 		        gdp->bg_used_dirs_count,
 		        gdp->bg_used_dirs_count != 1 ? "directories"
-				: "directory");
+				: "directory", gdt_csum ? ", " : "\n");
+		if (gdt_csum)
+			fprintf(out, "%d unused %s\n",
+				gdp->bg_itable_unused,
+				gdp->bg_itable_unused != 1 ? "inodes":"inode");
 		first = 1;
 		print_bg_opts(gdp, EXT2_BG_INODE_UNINIT, "Inode not init",
 			      &first, out);
 		print_bg_opts(gdp, EXT2_BG_BLOCK_UNINIT, "Block not init",
 			      &first, out);
+		if (gdt_csum) {
+			fprintf(out, "%sChecksum 0x%04x",
+				first ? "           [":", ", gdp->bg_checksum);
+			first = 0;
+		}
 		if (!first)
 			fputs("]\n", out);
 	}
@@ -509,7 +523,7 @@ static void dump_blocks(FILE *f, const c
 	lb.first_block = 0;
 	lb.f = f;
 	lb.first = 1;
-	ext2fs_block_iterate2(current_fs, inode, 0, NULL,
+	ext2fs_block_iterate2(current_fs, inode, BLOCK_FLAG_READ_ONLY, NULL,
 			     list_blocks_proc, (void *)&lb);
 	finish_range(&lb);
 	if (lb.total)
@@ -571,10 +585,6 @@ void internal_dump_inode(FILE *out, cons
 		frag = inode->osd2.hurd2.h_i_frag;
 		fsize = inode->osd2.hurd2.h_i_fsize;
 		break;
-	    case EXT2_OS_MASIX:
-		frag = inode->osd2.masix2.m_i_frag;
-		fsize = inode->osd2.masix2.m_i_fsize;
-		break;
 	    default:
 		frag = fsize = 0;
 	}
@@ -791,7 +801,8 @@ static void modify_u8(char *com, const c
 
 	sprintf(buf, format, *val);
 	printf("%30s    [%s] ", prompt, buf);
-	fgets(buf, sizeof(buf), stdin);
+	if (!fgets(buf, sizeof(buf), stdin))
+		return;
 	if (buf[strlen (buf) - 1] == '\n')
 		buf[strlen (buf) - 1] = '\0';
 	if (!buf[0])
@@ -812,7 +823,8 @@ static void modify_u16(char *com, const 
 
 	sprintf(buf, format, *val);
 	printf("%30s    [%s] ", prompt, buf);
-	fgets(buf, sizeof(buf), stdin);
+	if (!fgets(buf, sizeof(buf), stdin))
+		return;
 	if (buf[strlen (buf) - 1] == '\n')
 		buf[strlen (buf) - 1] = '\0';
 	if (!buf[0])
@@ -833,7 +845,8 @@ static void modify_u32(char *com, const 
 
 	sprintf(buf, format, *val);
 	printf("%30s    [%s] ", prompt, buf);
-	fgets(buf, sizeof(buf), stdin);
+	if (!fgets(buf, sizeof(buf), stdin))
+		return;
 	if (buf[strlen (buf) - 1] == '\n')
 		buf[strlen (buf) - 1] = '\0';
 	if (!buf[0])
@@ -901,10 +914,6 @@ void do_modify_inode(int argc, char *arg
 		frag = &inode.osd2.hurd2.h_i_frag;
 		fsize = &inode.osd2.hurd2.h_i_fsize;
 		break;
-	    case EXT2_OS_MASIX:
-		frag = &inode.osd2.masix2.m_i_frag;
-		fsize = &inode.osd2.masix2.m_i_fsize;
-		break;
 	    default:
 		frag = fsize = 0;
 	}
@@ -1013,7 +1022,7 @@ static void make_link(char *sourcename, 
 	struct ext2_inode inode;
 	int		retval;
 	ext2_ino_t	dir;
-	char		*dest, *cp, *basename;
+	char		*dest, *cp, *base_name;
 
 	/*
 	 * Get the source inode
@@ -1021,17 +1030,17 @@ static void make_link(char *sourcename, 
 	ino = string_to_inode(sourcename);
 	if (!ino)
 		return;
-	basename = strrchr(sourcename, '/');
-	if (basename)
-		basename++;
+	base_name = strrchr(sourcename, '/');
+	if (base_name)
+		base_name++;
 	else
-		basename = sourcename;
+		base_name = sourcename;
 	/*
 	 * Figure out the destination.  First see if it exists and is
 	 * a directory.  
 	 */
 	if (! (retval=ext2fs_namei(current_fs, root, cwd, destname, &dir)))
-		dest = basename;
+		dest = base_name;
 	else {
 		/*
 		 * OK, it doesn't exist.  See if it is
@@ -1113,7 +1122,7 @@ void do_undel(int argc, char *argv[])
 	if (debugfs_write_inode(ino, &inode, argv[0]))
 		return;
 
-	ext2fs_block_iterate(current_fs, ino, 0, NULL,
+	ext2fs_block_iterate(current_fs, ino, BLOCK_FLAG_READ_ONLY, NULL,
 			     mark_blocks_proc, NULL);
 
 	ext2fs_inode_alloc_stats2(current_fs, ino, +1, 0);
@@ -1126,19 +1135,19 @@ static void unlink_file_by_name(char *fi
 {
 	int		retval;
 	ext2_ino_t	dir;
-	char		*basename;
+	char		*base_name;
 	
-	basename = strrchr(filename, '/');
-	if (basename) {
-		*basename++ = '\0';
+	base_name = strrchr(filename, '/');
+	if (base_name) {
+		*base_name++ = '\0';
 		dir = string_to_inode(filename);
 		if (!dir)
 			return;
 	} else {
 		dir = cwd;
-		basename = filename;
+		base_name = filename;
 	}
-	retval = ext2fs_unlink(current_fs, dir, basename, 0, 0);
+	retval = ext2fs_unlink(current_fs, dir, base_name, 0, 0);
 	if (retval)
 		com_err("unlink_file_by_name", retval, 0);
 	return;
@@ -1511,7 +1520,7 @@ static void kill_file_by_inode(ext2_ino_
 	if (!ext2fs_inode_has_valid_blocks(&inode_buf))
 		return;
 
-	ext2fs_block_iterate(current_fs, inode, 0, NULL,
+	ext2fs_block_iterate(current_fs, inode, BLOCK_FLAG_READ_ONLY, NULL,
 			     release_blocks_proc, NULL);
 	printf("\n");
 	ext2fs_inode_alloc_stats2(current_fs, inode, -1,
@@ -1810,7 +1819,7 @@ int main(int argc, char **argv)
 {
 	int		retval;
 	int		sci_idx;
-	const char	*usage = "Usage: debugfs [-b blocksize] [-s superblock] [-f cmd_file] [-R request] [-V] [[-w] [-c] device]";
+	const char	*usage = "Usage: %s [-b blocksize] [-s superblock] [-f cmd_file] [-R request] [-V] [[-w] [-c] device]";
 	int		c;
 	int		open_flags = EXT2_FLAG_SOFTSUPP_FEATURES;
 	char		*request = 0;
@@ -1821,9 +1830,12 @@ int main(int argc, char **argv)
 	int		catastrophic = 0;
 	char		*data_filename = 0;
 	
+	if (debug_prog_name == 0)
+		debug_prog_name = "debugfs";
+
 	add_error_table(&et_ext2_error_table);
-	fprintf (stderr, "debugfs %s (%s)\n", E2FSPROGS_VERSION,
-		 E2FSPROGS_DATE);
+	fprintf (stderr, "%s %s (%s)\n", debug_prog_name,
+		 E2FSPROGS_VERSION, E2FSPROGS_DATE);
 
 	while ((c = getopt (argc, argv, "iwcR:f:b:s:Vd:")) != EOF) {
 		switch (c) {
@@ -1859,7 +1871,7 @@ int main(int argc, char **argv)
 				error_message(EXT2_ET_BASE));
 			exit(0);
 		default:
-			com_err(argv[0], 0, usage);
+			com_err(argv[0], 0, usage, debug_prog_name);
 			return 1;
 		}
 	}
@@ -1868,7 +1880,7 @@ int main(int argc, char **argv)
 				superblock, blocksize, catastrophic,
 				data_filename);
 	
-	sci_idx = ss_create_invocation("debugfs", "0.0", (char *) NULL,
+	sci_idx = ss_create_invocation(debug_prog_name, "0.0", (char *) NULL,
 				       &debug_cmds, &retval);
 	if (retval) {
 		ss_perror(sci_idx, retval, "creating invocation");
@@ -1881,6 +1893,12 @@ int main(int argc, char **argv)
 		ss_perror(sci_idx, retval, "adding standard requests");
 		exit (1);
 	}
+	if (extra_cmds)
+		ss_add_request_table (sci_idx, extra_cmds, 1, &retval);
+	if (retval) {
+		ss_perror(sci_idx, retval, "adding extra requests");
+		exit (1);
+	}
 	if (request) {
 		retval = 0;
 		retval = ss_execute_line(sci_idx, request);
diff -Nurp e2fsprogs-1.40.8/debugfs/debugfs.h e2fsprogs/debugfs/debugfs.h
--- e2fsprogs-1.40.8/debugfs/debugfs.h	2008-03-13 23:20:46.000000000 +0100
+++ e2fsprogs/debugfs/debugfs.h	2008-03-29 01:20:43.000000000 +0100
@@ -78,6 +78,7 @@ extern void do_ncheck(int argc, char **a
 /* set_fields.c */
 extern void do_set_super(int argc, char **);
 extern void do_set_inode(int argc, char **);
+extern void do_set_block_group_descriptor(int argc, char **);
 
 /* unused.c */
 extern void do_dump_unused(int argc, char **argv);
Files e2fsprogs-1.40.8/debugfs/debugfs.o and e2fsprogs/debugfs/debugfs.o differ
diff -Nurp e2fsprogs-1.40.8/debugfs/htree.c e2fsprogs/debugfs/htree.c
--- e2fsprogs-1.40.8/debugfs/htree.c	2008-03-13 23:20:46.000000000 +0100
+++ e2fsprogs/debugfs/htree.c	2008-03-29 01:20:43.000000000 +0100
@@ -347,7 +347,8 @@ void do_dirsearch(int argc, char *argv[]
 	pb.search_name = argv[2];
 	pb.len = strlen(pb.search_name);
 	
-	ext2fs_block_iterate2(current_fs, inode, 0, 0, search_dir_block, &pb);
+	ext2fs_block_iterate2(current_fs, inode, BLOCK_FLAG_READ_ONLY, 0,
+			      search_dir_block, &pb);
 
 	free(pb.buf);
 }
diff -Nurp e2fsprogs-1.40.8/debugfs/icheck.c e2fsprogs/debugfs/icheck.c
--- e2fsprogs-1.40.8/debugfs/icheck.c	2008-03-13 23:20:46.000000000 +0100
+++ e2fsprogs/debugfs/icheck.c	2008-03-29 01:20:43.000000000 +0100
@@ -127,7 +127,8 @@ void do_icheck(int argc, char **argv)
 		if (inode.i_dtime)
 			goto next;
 
-		retval = ext2fs_block_iterate2(current_fs, ino, 0, block_buf,
+		retval = ext2fs_block_iterate2(current_fs, ino,
+					       BLOCK_FLAG_READ_ONLY, block_buf,
 					       icheck_proc, &bw);
 		if (retval) {
 			com_err("icheck", retval,
diff -Nurp e2fsprogs-1.40.8/debugfs/logdump.c e2fsprogs/debugfs/logdump.c
--- e2fsprogs-1.40.8/debugfs/logdump.c	2008-03-13 23:20:46.000000000 +0100
+++ e2fsprogs/debugfs/logdump.c	2008-03-29 01:20:43.000000000 +0100
@@ -36,11 +36,11 @@ extern char *optarg;
 
 enum journal_location {JOURNAL_IS_INTERNAL, JOURNAL_IS_EXTERNAL};
 
-#define ANY_BLOCK ((unsigned int) -1)
+#define ANY_BLOCK ((blk_t) -1)
 
 int		dump_all, dump_contents, dump_descriptors;
-unsigned int	block_to_dump, group_to_dump, bitmap_to_dump;
-unsigned int	inode_block_to_dump, inode_offset_to_dump, bitmap_to_dump;
+blk_t		block_to_dump, bitmap_to_dump, inode_block_to_dump;
+unsigned int	group_to_dump, inode_offset_to_dump;
 ext2_ino_t	inode_to_dump;
 
 struct journal_source 
@@ -350,7 +350,7 @@ static void dump_journal(char *cmdname, 
 
 	jsb = (journal_superblock_t *) buf;
 	sb = (struct ext2_super_block *) (buf+1024);
-#ifdef ENABLE_SWAPFS
+#ifdef WORDS_BIGENDIAN
 	if (sb->s_magic == ext2fs_swab16(EXT2_SUPER_MAGIC)) 
 		ext2fs_swap_super(sb);
 #endif
@@ -365,8 +365,8 @@ static void dump_journal(char *cmdname, 
 		if (dump_all) {
 			fprintf(out_file, "\tuuid=%s\n", jsb_buffer);
 			fprintf(out_file, "\tblocksize=%d\n", blocksize);
-			fprintf(out_file, "\tjournal data size %ld\n",
-				(long) sb->s_blocks_count);
+			fprintf(out_file, "\tjournal data size %lu\n",
+				(unsigned long) sb->s_blocks_count);
 		}
 	}
 	
diff -Nurp e2fsprogs-1.40.8/debugfs/ls.c e2fsprogs/debugfs/ls.c
--- e2fsprogs-1.40.8/debugfs/ls.c	2008-03-13 23:20:46.000000000 +0100
+++ e2fsprogs/debugfs/ls.c	2008-03-29 01:20:43.000000000 +0100
@@ -30,6 +30,7 @@ extern char *optarg;
 
 #define LONG_OPT	0x0001
 #define DELETED_OPT	0x0002
+#define PARSE_OPT	0x0004
 
 struct list_dir_struct {
 	FILE	*f;
@@ -72,7 +73,16 @@ static int list_dir_proc(ext2_ino_t dir 
 	} else {
 		lbr = rbr = ' ';
 	}
-	if (ls->options & LONG_OPT) {
+	if (ls->options & PARSE_OPT) {
+		if (ino && debugfs_read_inode(ino, &inode, name)) return 0;
+		fprintf(ls->f,"/%u/%06o/%d/%d/%s/",ino,inode.i_mode,inode.i_uid, inode.i_gid,name);
+		if (LINUX_S_ISDIR(inode.i_mode))
+			fprintf(ls->f, "/");
+		else
+			fprintf(ls->f, "%lld/", inode.i_size | ((__u64)inode.i_size_high << 32));
+		fprintf(ls->f, "\n");
+	}
+	else if (ls->options & LONG_OPT) {
 		if (ino) {
 			if (debugfs_read_inode(ino, &inode, name))
 				return 0;
@@ -123,7 +133,7 @@ void do_list_dir(int argc, char *argv[])
 		return;
 
 	reset_getopt();
-	while ((c = getopt (argc, argv, "dl")) != EOF) {
+	while ((c = getopt (argc, argv, "dlp")) != EOF) {
 		switch (c) {
 		case 'l':
 			ls.options |= LONG_OPT;
@@ -131,6 +141,9 @@ void do_list_dir(int argc, char *argv[])
 		case 'd':
 			ls.options |= DELETED_OPT;
 			break;
+		case 'p':
+			ls.options |= PARSE_OPT;
+			break;
 		default:
 			goto print_usage;
 		}
@@ -138,7 +151,7 @@ void do_list_dir(int argc, char *argv[])
 
 	if (argc > optind+1) {
 	print_usage:
-		com_err(0, 0, "Usage: ls [-l] [-d] file");
+		com_err(0, 0, "Usage: ls [-l] [-d] [-p] file");
 		return;
 	}
 
diff -Nurp e2fsprogs-1.40.8/debugfs/lsdel.c e2fsprogs/debugfs/lsdel.c
--- e2fsprogs-1.40.8/debugfs/lsdel.c	2008-03-13 23:20:46.000000000 +0100
+++ e2fsprogs/debugfs/lsdel.c	2008-03-29 01:20:43.000000000 +0100
@@ -140,7 +140,8 @@ void do_lsdel(int argc, char **argv)
 		lsd.free_blocks = 0;
 		lsd.bad_blocks = 0;
 		
-		retval = ext2fs_block_iterate2(current_fs, ino, 0, block_buf,
+		retval = ext2fs_block_iterate2(current_fs, ino,
+					       BLOCK_FLAG_READ_ONLY, block_buf,
 					       lsdel_proc, &lsd);
 		if (retval) {
 			com_err("ls_deleted_inodes", retval,
diff -Nurp e2fsprogs-1.40.8/debugfs/set_fields.c e2fsprogs/debugfs/set_fields.c
--- e2fsprogs-1.40.8/debugfs/set_fields.c	2008-03-13 23:20:46.000000000 +0100
+++ e2fsprogs/debugfs/set_fields.c	2008-03-29 01:20:43.000000000 +0100
@@ -29,6 +29,9 @@
 #ifdef HAVE_ERRNO_H
 #include <errno.h>
 #endif
+#if HAVE_STRINGS_H
+#include <strings.h>
+#endif
 #include <fcntl.h>
 #include <utime.h>
 
diff -Nurp e2fsprogs-1.40.8/debugfs/util.c e2fsprogs/debugfs/util.c
--- e2fsprogs-1.40.8/debugfs/util.c	2008-03-13 23:20:46.000000000 +0100
+++ e2fsprogs/debugfs/util.c	2008-03-29 01:20:43.000000000 +0100
@@ -82,6 +82,8 @@ FILE *open_pager(void)
 	char buf[80];
 
 	signal(SIGPIPE, SIG_IGN);
+	if (!isatty(1))
+		return stdout;
 	if (!pager)
 		pager = getenv("PAGER");
 	if (!pager)
@@ -121,7 +123,7 @@ ext2_ino_t string_to_inode(char *str)
 
 	retval = ext2fs_namei(current_fs, root, cwd, str, &ino);
 	if (retval) {
-		com_err(str, retval, "");
+		com_err(str, retval, 0);
 		return 0;
 	}
 	return ino;
@@ -190,7 +192,7 @@ char *time_to_string(__u32 cl)
 {
 	static int	do_gmt = -1;
 	time_t		t = (time_t) cl;
-	char *		tz;
+	const char	*tz;
 
 	if (do_gmt == -1) {
 		/* The diet libc doesn't respect the TZ environemnt variable */
@@ -274,10 +276,8 @@ int strtoblk(const char *cmd, const char
 
 	blk = parse_ulong(str, cmd, "block number", &err);
 	*ret = blk;
-	if (err == 0 && blk == 0) {
-		com_err(cmd, 0, "Invalid block number 0");
-		err = 1;
-	}
+	if (err)
+		com_err(cmd, 0, "Invalid block number: %s", str);
 	return err;
 }
 
@@ -337,6 +337,11 @@ int common_block_args_process(int argc, 
 
 	if (strtoblk(argv[0], argv[1], block))
 		return 1;
+	if (*block == 0) {
+		com_err(argv[0], 0, "Invalid block number 0");
+		err = 1;
+	}
+
 	if (argc > 2) {
 		*count = parse_ulong(argv[2], argv[0], "count", &err);
 		if (err)
Files e2fsprogs-1.40.8/debugfs/util.o and e2fsprogs/debugfs/util.o differ
diff -Nurp e2fsprogs-1.40.8/doc/libext2fs.texinfo e2fsprogs/doc/libext2fs.texinfo
--- e2fsprogs-1.40.8/doc/libext2fs.texinfo	2008-03-14 01:01:41.000000000 +0100
+++ e2fsprogs/doc/libext2fs.texinfo	2008-03-29 01:20:43.000000000 +0100
@@ -7,11 +7,9 @@
 
 @ifinfo
 @dircategory Development
-@format
-START-INFO-DIR-ENTRY
+@direntry
 * libext2fs: (libext2fs.info).                  The EXT2FS library.
-END-INFO-DIR-ENTRY
-@end format
+@end direntry
 @end ifinfo
 
 @c smallbook
diff -Nurp e2fsprogs-1.40.8/e2fsck/e2fsck.8.in e2fsprogs/e2fsck/e2fsck.8.in
--- e2fsprogs-1.40.8/e2fsck/e2fsck.8.in	2008-03-13 23:20:46.000000000 +0100
+++ e2fsprogs/e2fsck/e2fsck.8.in	2008-03-29 01:20:43.000000000 +0100
@@ -8,7 +8,7 @@ e2fsck \- check a Linux ext2/ext3 file s
 .SH SYNOPSIS
 .B e2fsck
 [
-.B \-pacnyrdfkvstDFSV
+.B \-pacnyrdfkvtDFV
 ]
 [
 .B \-b
@@ -274,17 +274,6 @@ options.
 .B \-r
 This option does nothing at all; it is provided only for backwards
 compatibility.
-.TP 
-.B \-s
-This option will byte-swap the filesystem so that it is using the normalized, 
-standard byte-order (which is i386 or little endian).  If the filesystem is
-already in the standard byte-order, 
-.B e2fsck 
-will take no action.
-.TP
-.B \-S
-This option will byte-swap the filesystem, regardless of its current 
-byte-order.
 .TP
 .B \-t
 Print timing statistics for
diff -Nurp e2fsprogs-1.40.8/e2fsck/e2fsck.h e2fsprogs/e2fsck/e2fsck.h
--- e2fsprogs-1.40.8/e2fsck/e2fsck.h	2008-03-13 23:20:46.000000000 +0100
+++ e2fsprogs/e2fsck/e2fsck.h	2008-03-29 01:20:43.000000000 +0100
@@ -135,6 +135,8 @@ struct resource_track {
 	struct timeval user_start;
 	struct timeval system_start;
 	void	*brk_start;
+	unsigned long long bytes_read;
+	unsigned long long bytes_written;
 };
 #endif
 
@@ -427,8 +429,11 @@ extern void e2fsck_setup_tdb_icount(e2fs
 extern void e2fsck_use_inode_shortcuts(e2fsck_t ctx, int bool);
 extern int e2fsck_pass1_check_device_inode(ext2_filsys fs,
 					   struct ext2_inode *inode);
-extern int e2fsck_pass1_check_symlink(ext2_filsys fs,
+extern int e2fsck_pass1_check_symlink(ext2_filsys fs, ext2_ino_t ino,
 				      struct ext2_inode *inode, char *buf);
+extern void e2fsck_clear_inode(e2fsck_t ctx, ext2_ino_t ino,
+			       struct ext2_inode *inode, int restart_flag,
+			       const char *source);
 
 /* pass2.c */
 extern int e2fsck_process_bad_inode(e2fsck_t ctx, ext2_ino_t dir,
@@ -456,9 +461,6 @@ void e2fsck_rehash_directories(e2fsck_t 
 void check_super_block(e2fsck_t ctx);
 int check_backup_super_block(e2fsck_t ctx);
 
-/* swapfs.c */
-void swap_filesys(e2fsck_t ctx);
-
 /* util.c */
 extern void *e2fsck_allocate_memory(e2fsck_t ctx, unsigned int size,
 				    const char *description);
@@ -469,14 +471,21 @@ extern void e2fsck_read_bitmaps(e2fsck_t
 extern void e2fsck_write_bitmaps(e2fsck_t ctx);
 extern void preenhalt(e2fsck_t ctx);
 extern char *string_copy(e2fsck_t ctx, const char *str, int len);
+extern errcode_t e2fsck_zero_blocks(ext2_filsys fs, blk_t blk, int num,
+				    blk_t *ret_blk, int *ret_count);
 #ifdef RESOURCE_TRACK
 extern void print_resource_track(const char *desc,
-				 struct resource_track *track);
-extern void init_resource_track(struct resource_track *track);
+				 struct resource_track *track,
+				 io_channel channel);
+extern void init_resource_track(struct resource_track *track,
+				io_channel channel);
 #endif
 extern int inode_has_valid_blocks(struct ext2_inode *inode);
 extern void e2fsck_read_inode(e2fsck_t ctx, unsigned long ino,
 			      struct ext2_inode * inode, const char * proc);
+extern void e2fsck_read_inode_full(e2fsck_t ctx, unsigned long ino,
+				   struct ext2_inode *inode,
+				   const int bufsize, const char *proc);
 extern void e2fsck_write_inode(e2fsck_t ctx, unsigned long ino,
 			       struct ext2_inode * inode, const char * proc);
 extern void e2fsck_write_inode_full(e2fsck_t ctx, unsigned long ino,
diff -Nurp e2fsprogs-1.40.8/e2fsck/journal.c e2fsprogs/e2fsck/journal.c
--- e2fsprogs-1.40.8/e2fsck/journal.c	2008-03-13 23:20:46.000000000 +0100
+++ e2fsprogs/e2fsck/journal.c	2008-03-29 01:20:43.000000000 +0100
@@ -385,7 +385,7 @@ static errcode_t e2fsck_get_journal(e2fs
 		memcpy(&jsuper, start ? bh->b_data :  bh->b_data + 1024,
 		       sizeof(jsuper));
 		brelse(bh);
-#ifdef EXT2FS_ENABLE_SWAPFS
+#ifdef WORDS_BIGENDIAN
 		if (jsuper.s_magic == ext2fs_swab16(EXT2_SUPER_MAGIC)) 
 			ext2fs_swap_super(&jsuper);
 #endif
@@ -988,6 +988,7 @@ void e2fsck_move_ext3_journal(e2fsck_t c
 	ext2fs_unmark_inode_bitmap(fs->inode_map, ino);
 	ext2fs_mark_ib_dirty(fs);
 	fs->group_desc[group].bg_free_inodes_count++;
+	ext2fs_group_desc_csum_set(fs, group);
 	fs->super->s_free_inodes_count++;
 	return;
 
diff -Nurp e2fsprogs-1.40.8/e2fsck/Makefile.in e2fsprogs/e2fsck/Makefile.in
--- e2fsprogs-1.40.8/e2fsck/Makefile.in	2008-03-13 23:20:46.000000000 +0100
+++ e2fsprogs/e2fsck/Makefile.in	2008-03-29 01:20:43.000000000 +0100
@@ -62,7 +62,7 @@ COMPILE_ET=$(top_builddir)/lib/et/compil
 #MCHECK= -DMCHECK
 
 OBJS= dict.o unix.o e2fsck.o super.o pass1.o pass1b.o pass2.o pass3.o pass4.o \
-	pass5.o journal.o swapfs.o badblocks.o util.o dirinfo.o dx_dirinfo.o \
+	pass5.o journal.o badblocks.o util.o dirinfo.o dx_dirinfo.o \
 	ehandler.o problem.o message.o recovery.o region.o revoke.o \
 	ea_refcount.o rehash.o profile.o prof_err.o $(MTRACE_OBJ)
 
@@ -71,7 +71,7 @@ PROFILED_OBJS= profiled/dict.o profiled/
 	profiled/pass2.o profiled/pass3.o profiled/pass4.o profiled/pass5.o \
 	profiled/journal.o profiled/badblocks.o profiled/util.o \
 	profiled/dirinfo.o profiled/dx_dirinfo.o profiled/ehandler.o \
-	profiled/message.o profiled/problem.o profiled/swapfs.o \
+	profiled/message.o profiled/problem.o \
 	profiled/recovery.o profiled/region.o profiled/revoke.o \
 	profiled/ea_refcount.o profiled/rehash.o profiled/profile.o \
 	profiled/prof_err.o
@@ -96,7 +96,6 @@ SRCS= $(srcdir)/e2fsck.c \
 	$(srcdir)/ehandler.c \
 	$(srcdir)/problem.c \
 	$(srcdir)/message.c \
-	$(srcdir)/swapfs.c \
 	$(srcdir)/ea_refcount.c \
 	$(srcdir)/rehash.c \
 	$(srcdir)/region.c \
@@ -378,13 +377,6 @@ message.o: $(srcdir)/message.c $(srcdir)
  $(top_builddir)/lib/ext2fs/ext2_err.h $(top_srcdir)/lib/ext2fs/bitops.h \
  $(top_srcdir)/lib/blkid/blkid.h $(top_builddir)/lib/blkid/blkid_types.h \
  $(srcdir)/profile.h prof_err.h $(srcdir)/problem.h
-swapfs.o: $(srcdir)/swapfs.c $(top_srcdir)/lib/et/com_err.h \
- $(srcdir)/e2fsck.h $(top_srcdir)/lib/ext2fs/ext2_fs.h \
- $(top_builddir)/lib/ext2fs/ext2_types.h $(top_srcdir)/lib/ext2fs/ext2fs.h \
- $(top_srcdir)/lib/ext2fs/ext2_fs.h $(top_srcdir)/lib/ext2fs/ext2_io.h \
- $(top_builddir)/lib/ext2fs/ext2_err.h $(top_srcdir)/lib/ext2fs/bitops.h \
- $(top_srcdir)/lib/blkid/blkid.h $(top_builddir)/lib/blkid/blkid_types.h \
- $(srcdir)/profile.h prof_err.h
 ea_refcount.o: $(srcdir)/ea_refcount.c $(srcdir)/e2fsck.h \
  $(top_srcdir)/lib/ext2fs/ext2_fs.h $(top_builddir)/lib/ext2fs/ext2_types.h \
  $(top_srcdir)/lib/ext2fs/ext2fs.h $(top_srcdir)/lib/ext2fs/ext2_fs.h \
diff -Nurp e2fsprogs-1.40.8/e2fsck/Makefile.pq e2fsprogs/e2fsck/Makefile.pq
--- e2fsprogs-1.40.8/e2fsck/Makefile.pq	1970-01-01 01:00:00.000000000 +0100
+++ e2fsprogs/e2fsck/Makefile.pq	2008-03-29 01:20:43.000000000 +0100
@@ -0,0 +1,9 @@
+TOPSRC=..
+LIBNAME=E2FSCK.LIB
+OBJFILE=E2FSCK.LST
+
+OBJS= e2fsck.obj super.obj pass1.obj pass2.obj pass3.obj \
+	pass4.obj pass5.obj dirinfo.obj
+
+!include $(TOPSRC)\powerquest\MCONFIG
+
diff -Nurp e2fsprogs-1.40.8/e2fsck/message.c e2fsprogs/e2fsck/message.c
--- e2fsprogs-1.40.8/e2fsck/message.c	2008-03-13 23:20:46.000000000 +0100
+++ e2fsprogs/e2fsck/message.c	2008-03-29 01:20:43.000000000 +0100
@@ -80,6 +80,7 @@
  * 	@S	superblock
  * 	@u	unattached
  * 	@v	device
+ *	@x	extent
  * 	@z	zero-length
  */
 
@@ -134,6 +135,7 @@ static const char *abbrevs[] = {
 	N_("Ssuper@b"),
 	N_("uunattached"),
 	N_("vdevice"),
+	N_("xextent"),
 	N_("zzero-length"),
 	"@@",
 	0
@@ -388,7 +390,11 @@ static _INLINE_ void expand_percent_expr
 		fputc('%', stdout);
 		break;
 	case 'b':
-		printf("%u", ctx->blk);
+#ifdef EXT2_NO_64_TYPE
+		printf("%u", (unsigned long) ctx->blk);
+#else
+		printf("%llu", (unsigned long long) ctx->blk);
+#endif
 		break;
 	case 'B':
 #ifdef EXT2_NO_64_TYPE
@@ -398,7 +404,11 @@ static _INLINE_ void expand_percent_expr
 #endif
 		break;
 	case 'c':
-		printf("%u", ctx->blk2);
+#ifdef EXT2_NO_64_TYPE
+		printf("%u", (unsigned long) ctx->blk2);
+#else
+		printf("%llu", (unsigned long long) ctx->blk2);
+#endif
 		break;
 	case 'd':
 		printf("%u", ctx->dir);
diff -Nurp e2fsprogs-1.40.8/e2fsck/pass1b.c e2fsprogs/e2fsck/pass1b.c
--- e2fsprogs-1.40.8/e2fsck/pass1b.c	2008-03-13 23:20:46.000000000 +0100
+++ e2fsprogs/e2fsck/pass1b.c	2008-03-29 01:20:43.000000000 +0100
@@ -294,7 +294,8 @@ static void pass1b(e2fsck_t ctx, char *b
 		if (ext2fs_inode_has_valid_blocks(&inode) ||
 		    (ino == EXT2_BAD_INO))
 			pctx.errcode = ext2fs_block_iterate2(fs, ino,
-				     0, block_buf, process_pass1b_block, &pb);
+					     BLOCK_FLAG_READ_ONLY, block_buf,
+					     process_pass1b_block, &pb);
 		if (inode.i_file_acl)
 			process_pass1b_block(fs, &inode.i_file_acl,
 					     BLOCK_COUNT_EXTATTR, 0, 0, &pb);
@@ -590,20 +591,17 @@ static void delete_file(e2fsck_t ctx, ex
 
 	e2fsck_read_inode(ctx, ino, &inode, "delete_file");
 	if (ext2fs_inode_has_valid_blocks(&inode))
-		pctx.errcode = ext2fs_block_iterate2(fs, ino, 0, block_buf,
-						     delete_file_block, &pb);
+		pctx.errcode = ext2fs_block_iterate2(fs, ino, BLOCK_FLAG_READ_ONLY, 
+						     block_buf, delete_file_block, &pb);
 	if (pctx.errcode)
 		fix_problem(ctx, PR_1B_BLOCK_ITERATE, &pctx);
-	ext2fs_unmark_inode_bitmap(ctx->inode_used_map, ino);
-	ext2fs_unmark_inode_bitmap(ctx->inode_dir_map, ino);
 	if (ctx->inode_bad_map)
 		ext2fs_unmark_inode_bitmap(ctx->inode_bad_map, ino);
 	ext2fs_inode_alloc_stats2(fs, ino, -1, LINUX_S_ISDIR(inode.i_mode));
 
 	/* Inode may have changed by block_iterate, so reread it */
 	e2fsck_read_inode(ctx, ino, &inode, "delete_file");
-	inode.i_links_count = 0;
-	inode.i_dtime = ctx->now;
+	e2fsck_clear_inode(ctx, ino, &inode, 0, "delete_file");
 	if (inode.i_file_acl &&
 	    (fs->super->s_feature_compat & EXT2_FEATURE_COMPAT_EXT_ATTR)) {
 		count = 1;
@@ -629,7 +627,6 @@ static void delete_file(e2fsck_t ctx, ex
 			delete_file_block(fs, &inode.i_file_acl,
 					  BLOCK_COUNT_EXTATTR, 0, 0, &pb);
 	}
-	e2fsck_write_inode(ctx, ino, &inode, "delete_file");
 }
 
 struct clone_struct {
diff -Nurp e2fsprogs-1.40.8/e2fsck/pass1.c e2fsprogs/e2fsck/pass1.c
--- e2fsprogs-1.40.8/e2fsck/pass1.c	2008-03-13 23:20:46.000000000 +0100
+++ e2fsprogs/e2fsck/pass1.c	2008-03-29 01:20:43.000000000 +0100
@@ -163,17 +163,42 @@ int e2fsck_pass1_check_device_inode(ext2
  * Check to make sure a symlink inode is real.  Returns 1 if the symlink
  * checks out, 0 if not.
  */
-int e2fsck_pass1_check_symlink(ext2_filsys fs, struct ext2_inode *inode,
-			       char *buf)
+int e2fsck_pass1_check_symlink(ext2_filsys fs, ext2_ino_t ino,
+			       struct ext2_inode *inode, char *buf)
 {
 	unsigned int len;
 	int i;
 	blk_t	blocks;
+	ext2_extent_handle_t	handle;
+	struct ext2_extent_info	info;
+	struct ext2fs_extent	extent;
 
 	if ((inode->i_size_high || inode->i_size == 0) ||
 	    (inode->i_flags & EXT2_INDEX_FL))
 		return 0;
 
+	if (inode->i_flags & EXT4_EXTENTS_FL) {
+		if (inode->i_size > fs->blocksize)
+			return 0;
+		if (ext2fs_extent_open(fs, ino, &handle))
+			return 0;
+		i = 0;
+		if (ext2fs_extent_get_info(handle, &info) ||
+		    (info.num_entries != 1) ||
+		    (info.max_depth != 0))
+			goto exit_extent;
+		if (ext2fs_extent_get(handle, EXT2_EXTENT_ROOT, &extent) ||
+		    (extent.e_lblk != 0) ||
+		    (extent.e_len != 1) ||
+		    (extent.e_pblk < fs->super->s_first_data_block) ||
+		    (extent.e_pblk >= fs->super->s_blocks_count))
+			goto exit_extent;
+		i = 1;
+	exit_extent:
+		ext2fs_extent_free(handle);
+		return i;
+	}
+
 	blocks = ext2fs_inode_data_blocks(fs, inode);
 	if (blocks) {
 		if ((inode->i_size >= fs->blocksize) ||
@@ -264,6 +289,7 @@ static void check_ea_in_inode(e2fsck_t c
 	remain = storage_size - sizeof(__u32); 
 
 	while (!EXT2_EXT_IS_LAST_ENTRY(entry)) {
+		__u32 hash;
 
 		/* header eats this space */
 		remain -= sizeof(struct ext2_ext_attr_entry);
@@ -291,9 +317,12 @@ static void check_ea_in_inode(e2fsck_t c
 			problem = PR_1_ATTR_VALUE_BLOCK;
 			goto fix;
 		}
-		
-		/* e_hash must be 0 in inode's ea */
-		if (entry->e_hash != 0) {
+
+		hash = ext2fs_ext_attr_hash_entry(entry,
+						  start + entry->e_value_offs);
+
+		/* e_hash may be 0 in older inode's ea */
+		if (entry->e_hash != 0 && entry->e_hash != hash) {
 			pctx->num = entry->e_hash;
 			problem = PR_1_ATTR_HASH;
 			goto fix;
@@ -308,15 +337,12 @@ fix:
 	 * it seems like a corruption. it's very unlikely we could repair
 	 * EA(s) in automatic fashion -bzzz
 	 */
-#if 0
-	problem = PR_1_ATTR_HASH;
-#endif
 	if (problem == 0 || !fix_problem(ctx, problem, pctx))
 		return;
 
-	/* simple remove all possible EA(s) */
+	/* simply remove all possible EA(s) */
 	*((__u32 *)start) = 0UL;
-	e2fsck_write_inode_full(ctx, pctx->ino, (struct ext2_inode *) inode,
+	e2fsck_write_inode_full(ctx, pctx->ino, pctx->inode,
 				EXT2_INODE_SIZE(sb), "pass1");
 }
 
@@ -480,12 +506,12 @@ void e2fsck_pass1(e2fsck_t ctx)
 	struct		scan_callback_struct scan_struct;
 	struct ext2_super_block *sb = ctx->fs->super;
 	const char	*old_op;
-	int		imagic_fs;
+	int		imagic_fs, extent_fs;
 	int		busted_fs_time = 0;
 	int		inode_size;
 	
 #ifdef RESOURCE_TRACK
-	init_resource_track(&rtrack);
+	init_resource_track(&rtrack, ctx->fs->io);
 #endif
 	clear_problem_context(&pctx);
 
@@ -514,6 +540,7 @@ void e2fsck_pass1(e2fsck_t ctx)
 #undef EXT2_BPP
 
 	imagic_fs = (sb->s_feature_compat & EXT2_FEATURE_COMPAT_IMAGIC_INODES);
+	extent_fs = (sb->s_feature_incompat & EXT3_FEATURE_INCOMPAT_EXTENTS);
 
 	/*
 	 * Allocate bitmaps structures
@@ -653,6 +680,47 @@ void e2fsck_pass1(e2fsck_t ctx)
 				return;
 			}
 		}
+		
+		if ((inode->i_flags & EXT4_EXTENTS_FL) && !extent_fs && 
+		    (inode->i_links_count || (ino == EXT2_BAD_INO) ||
+		     (ino == EXT2_ROOT_INO) || (ino == EXT2_JOURNAL_INO))) {
+			if ((ext2fs_extent_header_verify(inode->i_block, 
+						 sizeof(inode->i_block)) == 0) &&
+			    fix_problem(ctx, PR_1_EXTENT_FEATURE, &pctx)) {
+				sb->s_feature_incompat |= EXT3_FEATURE_INCOMPAT_EXTENTS;
+				ext2fs_mark_super_dirty(fs);
+				extent_fs = 1;
+			} else if (fix_problem(ctx, PR_1_EXTENTS_SET, &pctx)) {
+			clear_inode:
+				e2fsck_clear_inode(ctx, ino, inode, 0, "pass1");
+				if (ino == EXT2_BAD_INO)
+					ext2fs_mark_inode_bitmap(ctx->inode_used_map, 
+								 ino);
+				continue;
+			}
+		}
+
+		if (extent_fs && !(inode->i_flags & EXT4_EXTENTS_FL) &&
+		    (inode->i_links_count || (ino == EXT2_BAD_INO) ||
+		     (ino == EXT2_ROOT_INO) || (ino == EXT2_JOURNAL_INO)) &&
+		    (LINUX_S_ISREG(inode->i_mode) ||
+		     LINUX_S_ISDIR(inode->i_mode)) &&
+		    (ext2fs_extent_header_verify(inode->i_block, 
+						 sizeof(inode->i_block)) == 0)) {
+			if (fix_problem(ctx, PR_1_UNSET_EXTENT_FL, &pctx)) {
+				inode->i_flags |= EXT4_EXTENTS_FL;
+				e2fsck_write_inode(ctx, ino, inode, "pass1");
+			}
+		}
+
+		if (extent_fs && (inode->i_flags & EXT4_EXTENTS_FL) &&
+		    LINUX_S_ISLNK(inode->i_mode) &&
+		    !ext2fs_inode_has_valid_blocks(inode) &&
+		    fix_problem(ctx, PR_1_FAST_SYMLINK_EXTENT_FL, &pctx)) {
+			inode->i_flags &= ~EXT4_EXTENTS_FL;
+			e2fsck_write_inode(ctx, ino, inode, "pass1");
+		}
+
 		if (ino == EXT2_BAD_INO) {
 			struct process_block_struct pb;
 			
@@ -695,15 +763,8 @@ void e2fsck_pass1(e2fsck_t ctx)
 			 * regnerated in pass #3.
 			 */
 			if (!LINUX_S_ISDIR(inode->i_mode)) {
-				if (fix_problem(ctx, PR_1_ROOT_NO_DIR, &pctx)) {
-					inode->i_dtime = ctx->now;
-					inode->i_links_count = 0;
-					ext2fs_icount_store(ctx->inode_link_info,
-							    ino, 0);
-					e2fsck_write_inode(ctx, ino, inode,
-							   "pass1");
-				}
-
+				if (fix_problem(ctx, PR_1_ROOT_NO_DIR, &pctx))
+					goto clear_inode;
 			}
 			/*
 			 * If dtime is set, offer to clear it.  mke2fs
@@ -834,10 +895,6 @@ void e2fsck_pass1(e2fsck_t ctx)
 			frag = inode->osd2.hurd2.h_i_frag;
 			fsize = inode->osd2.hurd2.h_i_fsize;
 			break;
-		    case EXT2_OS_MASIX:
-			frag = inode->osd2.masix2.m_i_frag;
-			fsize = inode->osd2.masix2.m_i_fsize;
-			break;
 		    default:
 			frag = fsize = 0;
 		}
@@ -886,7 +943,8 @@ void e2fsck_pass1(e2fsck_t ctx)
 			check_size(ctx, &pctx);
 			ctx->fs_blockdev_count++;
 		} else if (LINUX_S_ISLNK (inode->i_mode) &&
-			   e2fsck_pass1_check_symlink(fs, inode, block_buf)) {
+			   e2fsck_pass1_check_symlink(fs, ino, inode, 
+						      block_buf)) {
 			check_immutable(ctx, &pctx);
 			ctx->fs_symlinks_count++;
 			if (ext2fs_inode_data_blocks(fs, inode) == 0) {
@@ -913,10 +971,11 @@ void e2fsck_pass1(e2fsck_t ctx)
 			ctx->fs_dind_count++;
 		if (inode->i_block[EXT2_TIND_BLOCK])
 			ctx->fs_tind_count++;
-		if (inode->i_block[EXT2_IND_BLOCK] ||
-		    inode->i_block[EXT2_DIND_BLOCK] ||
-		    inode->i_block[EXT2_TIND_BLOCK] ||
-		    inode->i_file_acl) {
+		if (!(inode->i_flags & EXT4_EXTENTS_FL) &&
+		    (inode->i_block[EXT2_IND_BLOCK] ||
+		     inode->i_block[EXT2_DIND_BLOCK] ||
+		     inode->i_block[EXT2_TIND_BLOCK] ||
+		     inode->i_file_acl)) {
 			inodes_to_process[process_inode_count].ino = ino;
 			inodes_to_process[process_inode_count].inode = *inode;
 			process_inode_count++;
@@ -1013,7 +1072,7 @@ endit:
 #ifdef RESOURCE_TRACK
 	if (ctx->options & E2F_OPT_TIME2) {
 		e2fsck_clear_progbar(ctx);
-		print_resource_track(_("Pass 1"), &rtrack);
+		print_resource_track(_("Pass 1"), &rtrack, ctx->fs->io);
 	}
 #endif
 }
@@ -1364,10 +1423,13 @@ static int check_ext_attr(e2fsck_t ctx, 
 	entry = (struct ext2_ext_attr_entry *)(header+1);
 	end = block_buf + fs->blocksize;
 	while ((char *)entry < end && *(__u32 *)entry) {
+		__u32 hash;
+
 		if (region_allocate(region, (char *)entry - (char *)header,
 			           EXT2_EXT_ATTR_LEN(entry->e_name_len))) {
 			if (fix_problem(ctx, PR_1_EA_ALLOC_COLLISION, pctx))
 				goto clear_extattr;
+			break;
 		}
 		if ((ctx->ext_attr_ver == 1 &&
 		     (entry->e_name_len == 0 || entry->e_name_index != 0)) ||
@@ -1375,6 +1437,7 @@ static int check_ext_attr(e2fsck_t ctx, 
 		     entry->e_name_index == 0)) {
 			if (fix_problem(ctx, PR_1_EA_BAD_NAME, pctx))
 				goto clear_extattr;
+			break;
 		}
 		if (entry->e_value_block != 0) {
 			if (fix_problem(ctx, PR_1_EA_BAD_VALUE, pctx))
@@ -1391,6 +1454,17 @@ static int check_ext_attr(e2fsck_t ctx, 
 			if (fix_problem(ctx, PR_1_EA_ALLOC_COLLISION, pctx))
 				goto clear_extattr;
 		}
+
+		hash = ext2fs_ext_attr_hash_entry(entry, block_buf +
+							 entry->e_value_offs);
+
+		if (entry->e_hash != hash) {
+			pctx->num = entry->e_hash;
+			if (fix_problem(ctx, PR_1_ATTR_HASH, pctx))
+				goto clear_extattr;
+			entry->e_hash = hash;
+		}
+
 		entry = EXT2_EXT_ATTR_NEXT(entry);
 	}
 	if (region_allocate(region, (char *)entry - (char *)header, 4)) {
@@ -1416,8 +1490,7 @@ clear_extattr:
 
 /* Returns 1 if bad htree, 0 if OK */
 static int handle_htree(e2fsck_t ctx, struct problem_context *pctx,
-			ext2_ino_t ino EXT2FS_ATTR((unused)),
-			struct ext2_inode *inode,
+			ext2_ino_t ino, struct ext2_inode *inode,
 			char *block_buf)
 {
 	struct ext2_dx_root_info	*root;
@@ -1431,12 +1504,17 @@ static int handle_htree(e2fsck_t ctx, st
 	     fix_problem(ctx, PR_1_HTREE_SET, pctx)))
 		return 1;
 
-	blk = inode->i_block[0];
-	if (((blk == 0) ||
-	     (blk < fs->super->s_first_data_block) ||
-	     (blk >= fs->super->s_blocks_count)) &&
-	    fix_problem(ctx, PR_1_HTREE_BADROOT, pctx))
-		return 1;
+	pctx->errcode = ext2fs_bmap(fs, ino, inode, 0, 0, 0, &blk);
+
+	if ((pctx->errcode) ||
+	    (blk == 0) ||
+	    (blk < fs->super->s_first_data_block) ||
+	    (blk >= fs->super->s_blocks_count)) {
+		if (fix_problem(ctx, PR_1_HTREE_BADROOT, pctx))
+			return 1;
+		else
+			return 0;
+	}
 
 	retval = io_channel_read_blk(fs->io, blk, 1, block_buf);
 	if (retval && fix_problem(ctx, PR_1_HTREE_BADROOT, pctx))
@@ -1468,6 +1546,147 @@ static int handle_htree(e2fsck_t ctx, st
 	return 0;
 }
 
+void e2fsck_clear_inode(e2fsck_t ctx, ext2_ino_t ino,
+			struct ext2_inode *inode, int restart_flag,
+			const char *source)
+{
+	inode->i_flags = 0;
+	inode->i_links_count = 0;
+	ext2fs_icount_store(ctx->inode_link_info, ino, 0);
+	inode->i_dtime = ctx->now;
+
+	ext2fs_unmark_inode_bitmap(ctx->inode_dir_map, ino);
+	ext2fs_unmark_inode_bitmap(ctx->inode_used_map, ino);
+	if (ctx->inode_reg_map)
+		ext2fs_unmark_inode_bitmap(ctx->inode_reg_map, ino);
+	if (ctx->inode_bad_map)
+		ext2fs_unmark_inode_bitmap(ctx->inode_bad_map, ino);
+
+	/*
+	 * If the inode was partially accounted for before processing
+	 * was aborted, we need to restart the pass 1 scan.
+	 */
+	ctx->flags |= restart_flag;
+
+	e2fsck_write_inode(ctx, ino, inode, source);
+}
+
+static void scan_extent_node(e2fsck_t ctx, struct problem_context *pctx,
+			     struct process_block_struct *pb, 
+			     ext2_extent_handle_t ehandle)
+{
+	struct ext2fs_extent	extent;
+	blk_t			blk;
+	e2_blkcnt_t		blockcnt;
+	int			i;
+	int			is_dir, is_leaf;
+	errcode_t		problem;
+
+
+	pctx->errcode = ext2fs_extent_get(ehandle, EXT2_EXTENT_FIRST_SIB,
+					  &extent);
+	while (!pctx->errcode) {
+		is_leaf = extent.e_flags & EXT2_EXTENT_FLAGS_LEAF;
+		is_dir = LINUX_S_ISDIR(pctx->inode->i_mode);
+
+		problem = 0;
+		if (extent.e_pblk < ctx->fs->super->s_first_data_block ||
+		    extent.e_pblk >= ctx->fs->super->s_blocks_count)
+			problem = PR_1_EXTENT_BAD_START_BLK;
+		else if ((extent.e_pblk + extent.e_len) >
+			 ctx->fs->super->s_blocks_count)
+			problem = PR_1_EXTENT_ENDS_BEYOND;
+
+		if (problem) {
+			pctx->blk = extent.e_pblk;
+			pctx->blk2 = extent.e_lblk;
+			pctx->num = extent.e_len;
+			if (fix_problem(ctx, problem, pctx)) {
+				pctx->errcode =
+					ext2fs_extent_delete(ehandle, 0);
+				if (pctx->errcode) {
+					fix_problem(ctx,
+						    PR_1_EXTENT_DELETE_FAIL,
+						    pctx);
+					/* Should never get here */
+					ctx->flags |= E2F_FLAG_ABORT;
+					return;
+				}
+			}
+			goto next;
+		}
+
+		if (!is_leaf) {
+			mark_block_used(ctx, extent.e_pblk);
+			pb->num_blocks++;
+			pctx->errcode = ext2fs_extent_get(ehandle,
+						  EXT2_EXTENT_DOWN, &extent);
+			if (pctx->errcode) {
+				printf("Error1: %s on inode %lld\n",
+					error_message(pctx->errcode), pctx->ino);
+				abort();
+			}
+			scan_extent_node(ctx, pctx, pb, ehandle);
+			pctx->errcode = ext2fs_extent_get(ehandle,
+						  EXT2_EXTENT_UP, &extent);
+			if (pctx->errcode) {
+				printf("Error1: %s on inode %lld\n",
+					error_message(pctx->errcode), pctx->ino);
+				abort();
+			}
+			goto next;
+		}
+
+		for (blk = extent.e_pblk, blockcnt = extent.e_lblk, i = 0;
+		     i < extent.e_len;
+		     blk++, blockcnt++, i++) {
+			mark_block_used(ctx, blk);
+
+			if (is_dir) {
+				pctx->errcode = ext2fs_add_dir_block(ctx->fs->dblist, pctx->ino, blk, blockcnt);
+				if (pctx->errcode) {
+					pctx->blk = blk;
+					pctx->num = blockcnt;
+					fix_problem(ctx, PR_1_ADD_DBLOCK, pctx);
+					/* Should never get here */
+					ctx->flags |= E2F_FLAG_ABORT;
+					return;
+				}
+			}
+		}
+		pb->num_blocks += extent.e_len;
+		pb->last_block = extent.e_lblk + extent.e_len - 1;
+	next:
+		pctx->errcode = ext2fs_extent_get(ehandle,
+						  EXT2_EXTENT_NEXT_SIB,
+						  &extent);
+	}
+	if (pctx->errcode == EXT2_ET_EXTENT_NO_NEXT)
+		pctx->errcode = 0;
+}
+
+static void check_blocks_extents(e2fsck_t ctx, struct problem_context *pctx,
+				 struct process_block_struct *pb, 
+				 char *block_buf)
+{
+	struct ext2_inode	*inode = pctx->inode;
+	ext2_extent_handle_t	ehandle;
+	ext2_filsys		fs = ctx->fs;
+	ext2_ino_t		ino = pctx->ino;
+
+	pctx->errcode = ext2fs_extent_open(fs, ino, &ehandle);
+	if (pctx->errcode &&
+	    fix_problem(ctx, PR_1_READ_EXTENT, pctx)) {
+		e2fsck_clear_inode(ctx, ino, inode, 0, "check_blocks_extents");
+		pctx->errcode = 0;
+		return;
+	}
+
+	scan_extent_node(ctx, pctx, pb, ehandle);
+
+	ext2fs_extent_free(ehandle);
+}
+
 /*
  * This subroutine is called on each inode to account for all of the
  * blocks used by that inode.
@@ -1512,13 +1731,22 @@ static void check_blocks(e2fsck_t ctx, s
 		}
 	}
 
-	if (inode->i_file_acl && check_ext_attr(ctx, pctx, block_buf))
+	if (inode->i_file_acl && check_ext_attr(ctx, pctx, block_buf)) {
+		if (ctx->flags & E2F_FLAG_SIGNAL_MASK)
+			goto out;
 		pb.num_blocks++;
+	}
 
-	if (ext2fs_inode_has_valid_blocks(inode))
-		pctx->errcode = ext2fs_block_iterate2(fs, ino,
-				       pb.is_dir ? BLOCK_FLAG_HOLE : 0,
-				       block_buf, process_block, &pb);
+	if (ext2fs_inode_has_valid_blocks(inode)) {
+		if ((ctx->fs->super->s_feature_incompat &
+		     EXT3_FEATURE_INCOMPAT_EXTENTS) &&
+		    (inode->i_flags & EXT4_EXTENTS_FL))
+			check_blocks_extents(ctx, pctx, &pb, block_buf);
+		else
+			pctx->errcode = ext2fs_block_iterate2(fs, ino,
+						pb.is_dir ? BLOCK_FLAG_HOLE : 0,
+						block_buf, process_block, &pb);
+	}
 	end_problem_latch(ctx, PR_LATCH_BLOCK);
 	end_problem_latch(ctx, PR_LATCH_TOOBIG);
 	if (ctx->flags & E2F_FLAG_SIGNAL_MASK)
@@ -1530,20 +1758,9 @@ static void check_blocks(e2fsck_t ctx, s
 		ctx->fs_fragmented++;
 
 	if (pb.clear) {
-		inode->i_links_count = 0;
-		ext2fs_icount_store(ctx->inode_link_info, ino, 0);
-		inode->i_dtime = ctx->now;
-		dirty_inode++;
-		ext2fs_unmark_inode_bitmap(ctx->inode_dir_map, ino);
-		ext2fs_unmark_inode_bitmap(ctx->inode_reg_map, ino);
-		ext2fs_unmark_inode_bitmap(ctx->inode_used_map, ino);
-		/*
-		 * The inode was probably partially accounted for
-		 * before processing was aborted, so we need to
-		 * restart the pass 1 scan.
-		 */
-		ctx->flags |= E2F_FLAG_RESTART;
-		goto out;
+		e2fsck_clear_inode(ctx, ino, inode, E2F_FLAG_RESTART,
+				   "check_blocks");
+		return;
 	}
 	
 	if (pb.is_dir) {
@@ -1583,15 +1800,9 @@ static void check_blocks(e2fsck_t ctx, s
 		
 	if (!pb.num_blocks && pb.is_dir) {
 		if (fix_problem(ctx, PR_1_ZERO_LENGTH_DIR, pctx)) {
-			inode->i_links_count = 0;
-			ext2fs_icount_store(ctx->inode_link_info, ino, 0);
-			inode->i_dtime = ctx->now;
-			dirty_inode++;
-			ext2fs_unmark_inode_bitmap(ctx->inode_dir_map, ino);
-			ext2fs_unmark_inode_bitmap(ctx->inode_reg_map, ino);
-			ext2fs_unmark_inode_bitmap(ctx->inode_used_map, ino);
+			e2fsck_clear_inode(ctx, ino, inode, 0, "check_blocks");
 			ctx->fs_directory_count--;
-			goto out;
+			return;
 		}
 	}
 
diff -Nurp e2fsprogs-1.40.8/e2fsck/pass2.c e2fsprogs/e2fsck/pass2.c
--- e2fsprogs-1.40.8/e2fsck/pass2.c	2008-03-13 23:20:46.000000000 +0100
+++ e2fsprogs/e2fsck/pass2.c	2008-03-29 01:20:43.000000000 +0100
@@ -102,7 +102,7 @@ void e2fsck_pass2(e2fsck_t ctx)
 	int			bad_dir;
 
 #ifdef RESOURCE_TRACK
-	init_resource_track(&rtrack);
+	init_resource_track(&rtrack, ctx->fs->io);
 #endif
 
 	clear_problem_context(&cd.pctx);
@@ -151,7 +151,7 @@ void e2fsck_pass2(e2fsck_t ctx)
 	
 	cd.pctx.errcode = ext2fs_dblist_iterate(fs->dblist, check_dir_block,
 						&cd);
-	if (ctx->flags & E2F_FLAG_SIGNAL_MASK)
+	if (ctx->flags & E2F_FLAG_SIGNAL_MASK || ctx->flags & E2F_FLAG_RESTART)
 		return;
 	if (cd.pctx.errcode) {
 		fix_problem(ctx, PR_2_DBLIST_ITERATE, &cd.pctx);
@@ -280,7 +280,7 @@ void e2fsck_pass2(e2fsck_t ctx)
 #ifdef RESOURCE_TRACK
 	if (ctx->options & E2F_OPT_TIME2) {
 		e2fsck_clear_progbar(ctx);
-		print_resource_track(_("Pass 2"), &rtrack);
+		print_resource_track(_("Pass 2"), &rtrack, fs->io);
 	}
 #endif
 }
@@ -727,7 +727,7 @@ static int check_dir_block(ext2_filsys f
 	buf = cd->buf;
 	ctx = cd->ctx;
 
-	if (ctx->flags & E2F_FLAG_SIGNAL_MASK)
+	if (ctx->flags & E2F_FLAG_SIGNAL_MASK || ctx->flags & E2F_FLAG_RESTART)
 		return DIRENT_ABORT;
 	
 	if (ctx->progress && (ctx->progress)(ctx, 2, cd->count++, cd->max))
@@ -831,6 +831,9 @@ out_htree:
 	dict_init(&de_dict, DICTCOUNT_T_MAX, dict_de_cmp);
 	prev = 0;
 	do {
+		int group;
+		ext2_ino_t first_unused_inode;
+
 		problem = 0;
 		dirent = (struct ext2_dir_entry *) (buf + offset);
 		cd->pctx.dirent = dirent;
@@ -880,12 +883,6 @@ out_htree:
 		     (dirent->inode < EXT2_FIRST_INODE(fs->super))) ||
 		    (dirent->inode > fs->super->s_inodes_count)) {
 			problem = PR_2_BAD_INO;
-		} else if (!(ext2fs_test_inode_bitmap(ctx->inode_used_map,
-					       dirent->inode))) {
-			/*
-			 * If the inode is unused, offer to clear it.
-			 */
-			problem = PR_2_UNUSED_INODE;
 		} else if (ctx->inode_bb_map &&
 			   (ext2fs_test_inode_bitmap(ctx->inode_bb_map,
 						     dirent->inode))) {
@@ -962,6 +959,67 @@ out_htree:
 				return DIRENT_ABORT;
 		}
 
+		group = ext2fs_group_of_ino(fs, dirent->inode);
+		first_unused_inode = group * fs->super->s_inodes_per_group +
+					1 + fs->super->s_inodes_per_group -
+					fs->group_desc[group].bg_itable_unused;
+		cd->pctx.group = group;
+
+		/*
+		 * Check if the inode was missed out because _INODE_UNINIT
+		 * flag was set or bg_itable_unused was incorrect.
+		 * If that is the case restart e2fsck.
+		 * XXX Optimisations TODO:
+		 * 1. only restart e2fsck once
+		 * 2. only exposed inodes are checked again.
+		 */
+		if (fs->group_desc[group].bg_flags & EXT2_BG_INODE_UNINIT) {
+			if (fix_problem(ctx, PR_2_INOREF_BG_INO_UNINIT,
+					&cd->pctx)){
+				fs->group_desc[group].bg_flags &=
+					~EXT2_BG_INODE_UNINIT;
+				ctx->flags |= E2F_FLAG_RESTART |
+					E2F_FLAG_SIGNAL_MASK;
+			} else {
+				ext2fs_unmark_valid(fs);
+				if (problem == PR_2_BAD_INO)
+					goto next;
+			}
+		} else if (dirent->inode >= first_unused_inode) {
+			if (fix_problem(ctx, PR_2_INOREF_IN_UNUSED, &cd->pctx)){
+				fs->group_desc[group].bg_itable_unused = 0;
+				fs->group_desc[group].bg_flags &=
+					~EXT2_BG_INODE_UNINIT;
+				ext2fs_mark_super_dirty(fs);
+				ctx->flags |= E2F_FLAG_RESTART;
+				goto restart_fsck;
+			} else {
+				ext2fs_unmark_valid(fs);
+				if (problem == PR_2_BAD_INO)
+					goto next;
+			}
+		}
+
+		if (!(ext2fs_test_inode_bitmap(ctx->inode_used_map,
+					       dirent->inode))) {
+			/*
+			 * If the inode is unused, offer to clear it.
+			 */
+			problem = PR_2_UNUSED_INODE;
+		}
+
+		if (problem) {
+			if (fix_problem(ctx, problem, &cd->pctx)) {
+				dirent->inode = 0;
+				dir_modified++;
+				goto next;
+			} else {
+				ext2fs_unmark_valid(fs);
+				if (problem == PR_2_BAD_INO)
+					goto next;
+			}
+		}
+
 		if (check_name(ctx, dirent, ino, &cd->pctx))
 			dir_modified++;
 
@@ -1071,8 +1129,9 @@ out_htree:
 	dict_free_nodes(&de_dict);
 	return 0;
 abort_free_dict:
-	dict_free_nodes(&de_dict);
 	ctx->flags |= E2F_FLAG_ABORT;
+restart_fsck:
+	dict_free_nodes(&de_dict);
 	return DIRENT_ABORT;
 }
 
@@ -1109,11 +1168,8 @@ static void deallocate_inode(e2fsck_t ct
 	struct problem_context	pctx;
 	__u32			count;
 	
-	ext2fs_icount_store(ctx->inode_link_info, ino, 0);
 	e2fsck_read_inode(ctx, ino, &inode, "deallocate_inode");
-	inode.i_links_count = 0;
-	inode.i_dtime = ctx->now;
-	e2fsck_write_inode(ctx, ino, &inode, "deallocate_inode");
+	e2fsck_clear_inode(ctx, ino, &inode, 0, "deallocate_inode");
 	clear_problem_context(&pctx);
 	pctx.ino = ino;
 
@@ -1121,10 +1177,6 @@ static void deallocate_inode(e2fsck_t ct
 	 * Fix up the bitmaps...
 	 */
 	e2fsck_read_bitmaps(ctx);
-	ext2fs_unmark_inode_bitmap(ctx->inode_used_map, ino);
-	ext2fs_unmark_inode_bitmap(ctx->inode_dir_map, ino);
-	if (ctx->inode_bad_map)
-		ext2fs_unmark_inode_bitmap(ctx->inode_bad_map, ino);
 	ext2fs_inode_alloc_stats2(fs, ino, -1, LINUX_S_ISDIR(inode.i_mode));
 
 	if (inode.i_file_acl &&
@@ -1225,7 +1277,7 @@ extern int e2fsck_process_bad_inode(e2fs
 		 && !e2fsck_pass1_check_device_inode(fs, &inode))
 		problem = PR_2_BAD_SOCKET;
 	else if (LINUX_S_ISLNK(inode.i_mode)
-		 && !e2fsck_pass1_check_symlink(fs, &inode, buf)) {
+		 && !e2fsck_pass1_check_symlink(fs, ino, &inode, buf)) {
 		problem = PR_2_INVALID_SYMLINK;
 	}
 
@@ -1253,10 +1305,6 @@ extern int e2fsck_process_bad_inode(e2fs
 		frag = &inode.osd2.hurd2.h_i_frag;
 		fsize = &inode.osd2.hurd2.h_i_fsize;
 		break;
-	    case EXT2_OS_MASIX:
-		frag = &inode.osd2.masix2.m_i_frag;
-		fsize = &inode.osd2.masix2.m_i_fsize;
-		break;
 	    default:
 		frag = fsize = 0;
 	}
diff -Nurp e2fsprogs-1.40.8/e2fsck/pass3.c e2fsprogs/e2fsck/pass3.c
--- e2fsprogs-1.40.8/e2fsck/pass3.c	2008-03-13 23:20:46.000000000 +0100
+++ e2fsprogs/e2fsck/pass3.c	2008-03-29 01:20:43.000000000 +0100
@@ -61,7 +61,7 @@ void e2fsck_pass3(e2fsck_t ctx)
 	unsigned long maxdirs, count;
 
 #ifdef RESOURCE_TRACK
-	init_resource_track(&rtrack);
+	init_resource_track(&rtrack, ctx->fs->io);
 #endif
 
 	clear_problem_context(&pctx);
@@ -87,7 +87,8 @@ void e2fsck_pass3(e2fsck_t ctx)
 #ifdef RESOURCE_TRACK
 	if (ctx->options & E2F_OPT_TIME) {
 		e2fsck_clear_progbar(ctx);
-		print_resource_track(_("Peak memory"), &ctx->global_rtrack);
+		print_resource_track(_("Peak memory"), &ctx->global_rtrack,
+				     NULL);
 	}
 #endif
 
@@ -142,7 +143,7 @@ abort_exit:
 #ifdef RESOURCE_TRACK
 	if (ctx->options & E2F_OPT_TIME2) {
 		e2fsck_clear_progbar(ctx);
-		print_resource_track(_("Pass 3"), &rtrack);
+		print_resource_track(_("Pass 3"), &rtrack, ctx->fs->io);
 	}
 #endif
 }
diff -Nurp e2fsprogs-1.40.8/e2fsck/pass4.c e2fsprogs/e2fsck/pass4.c
--- e2fsprogs-1.40.8/e2fsck/pass4.c	2008-03-13 23:20:46.000000000 +0100
+++ e2fsprogs/e2fsck/pass4.c	2008-03-29 01:20:43.000000000 +0100
@@ -15,6 +15,7 @@
 
 #include "e2fsck.h"
 #include "problem.h"
+#include <ext2fs/ext2_ext_attr.h>
 
 /*
  * This routine is called when an inode is not connected to the
@@ -23,39 +24,45 @@
  * This subroutine returns 1 then the caller shouldn't bother with the
  * rest of the pass 4 tests.
  */
-static int disconnect_inode(e2fsck_t ctx, ext2_ino_t i)
+static int disconnect_inode(e2fsck_t ctx, ext2_ino_t i,
+			    struct ext2_inode *inode)
 {
 	ext2_filsys fs = ctx->fs;
-	struct ext2_inode	inode;
 	struct problem_context	pctx;
+	__u32 eamagic = 0;
+	int extra_size = 0;
 
-	e2fsck_read_inode(ctx, i, &inode, "pass4: disconnect_inode");
+	if (EXT2_INODE_SIZE(fs->super) > EXT2_GOOD_OLD_INODE_SIZE) {
+		e2fsck_read_inode_full(ctx, i, inode,EXT2_INODE_SIZE(fs->super),
+				       "pass4: disconnect_inode");
+		extra_size = ((struct ext2_inode_large *)inode)->i_extra_isize;
+	} else {
+		e2fsck_read_inode(ctx, i, inode, "pass4: disconnect_inode");
+	}
 	clear_problem_context(&pctx);
 	pctx.ino = i;
-	pctx.inode = &inode;
+	pctx.inode = inode;
 	
+	if (EXT2_INODE_SIZE(fs->super) -EXT2_GOOD_OLD_INODE_SIZE -extra_size >0)
+		eamagic = *(__u32 *)(((char *)inode) +EXT2_GOOD_OLD_INODE_SIZE +
+				     extra_size);
 	/*
 	 * Offer to delete any zero-length files that does not have
 	 * blocks.  If there is an EA block, it might have useful
 	 * information, so we won't prompt to delete it, but let it be
 	 * reconnected to lost+found.
 	 */
-	if (!inode.i_blocks && (LINUX_S_ISREG(inode.i_mode) ||
-				LINUX_S_ISDIR(inode.i_mode))) {
+	if (!inode->i_blocks && eamagic != EXT2_EXT_ATTR_MAGIC &&
+	    (LINUX_S_ISREG(inode->i_mode) || LINUX_S_ISDIR(inode->i_mode))) {
 		if (fix_problem(ctx, PR_4_ZERO_LEN_INODE, &pctx)) {
-			ext2fs_icount_store(ctx->inode_link_info, i, 0);
-			inode.i_links_count = 0;
-			inode.i_dtime = ctx->now;
-			e2fsck_write_inode(ctx, i, &inode,
+			e2fsck_clear_inode(ctx, i, inode, 0, 
 					   "disconnect_inode");
 			/*
 			 * Fix up the bitmaps...
 			 */
 			e2fsck_read_bitmaps(ctx);
-			ext2fs_unmark_inode_bitmap(ctx->inode_used_map, i);
-			ext2fs_unmark_inode_bitmap(ctx->inode_dir_map, i);
 			ext2fs_inode_alloc_stats2(fs, i, -1,
-						  LINUX_S_ISDIR(inode.i_mode));
+						  LINUX_S_ISDIR(inode->i_mode));
 			return 0;
 		}
 	}
@@ -83,7 +90,7 @@ void e2fsck_pass4(e2fsck_t ctx)
 {
 	ext2_filsys fs = ctx->fs;
 	ext2_ino_t	i;
-	struct ext2_inode	inode;
+	struct ext2_inode	*inode;
 #ifdef RESOURCE_TRACK
 	struct resource_track	rtrack;
 #endif
@@ -93,7 +100,7 @@ void e2fsck_pass4(e2fsck_t ctx)
 	int	group, maxgroup;
 	
 #ifdef RESOURCE_TRACK
-	init_resource_track(&rtrack);
+	init_resource_track(&rtrack, ctx->fs->io);
 #endif
 
 #ifdef MTRACE
@@ -111,6 +118,9 @@ void e2fsck_pass4(e2fsck_t ctx)
 		if ((ctx->progress)(ctx, 4, 0, maxgroup))
 			return;
 
+	inode = e2fsck_allocate_memory(ctx, EXT2_INODE_SIZE(fs->super),
+				       "scratch inode");
+
 	/* Protect loop from wrap-around if s_inodes_count maxed */
 	for (i=1; i <= fs->super->s_inodes_count && i > 0; i++) {
 		if (ctx->flags & E2F_FLAG_SIGNAL_MASK)
@@ -138,26 +148,34 @@ void e2fsck_pass4(e2fsck_t ctx)
 				     fs->blocksize, "bad_inode buffer");
 			if (e2fsck_process_bad_inode(ctx, 0, i, buf))
 				continue;
-			if (disconnect_inode(ctx, i))
+			if (disconnect_inode(ctx, i, inode))
 				continue;
 			ext2fs_icount_fetch(ctx->inode_link_info, i,
 					    &link_count);
 			ext2fs_icount_fetch(ctx->inode_count, i,
 					    &link_counted);
 		}
+		if (ext2fs_test_inode_bitmap(ctx->inode_dir_map, i) &&
+		    (link_counted > EXT2_LINK_MAX))
+			link_counted = 1;
 		if (link_counted != link_count) {
-			e2fsck_read_inode(ctx, i, &inode, "pass4");
+			e2fsck_read_inode(ctx, i, inode, "pass4");
 			pctx.ino = i;
-			pctx.inode = &inode;
-			if (link_count != inode.i_links_count) {
+			pctx.inode = inode;
+			if (link_count != inode->i_links_count) {
 				pctx.num = link_count;
 				fix_problem(ctx,
 					    PR_4_INCONSISTENT_COUNT, &pctx);
 			}
 			pctx.num = link_counted;
-			if (fix_problem(ctx, PR_4_BAD_REF_COUNT, &pctx)) {
-				inode.i_links_count = link_counted;
-				e2fsck_write_inode(ctx, i, &inode, "pass4");
+			/* i_link_count was previously exceeded, but no longer
+			 * is, fix this but don't consider it an error */
+			if ((LINUX_S_ISDIR(inode->i_mode) && link_counted > 1 &&
+			     (inode->i_flags & EXT2_INDEX_FL) &&
+			     link_count == 1 && !(ctx->options & E2F_OPT_NO)) ||
+			     (fix_problem(ctx, PR_4_BAD_REF_COUNT, &pctx))) {
+				inode->i_links_count = link_counted;
+				e2fsck_write_inode(ctx, i, inode, "pass4");
 			}
 		}
 	}
@@ -170,10 +188,12 @@ void e2fsck_pass4(e2fsck_t ctx)
 errout:
 	if (buf)
 		ext2fs_free_mem(&buf);
+
+	ext2fs_free_mem(&inode);
 #ifdef RESOURCE_TRACK
 	if (ctx->options & E2F_OPT_TIME2) {
 		e2fsck_clear_progbar(ctx);
-		print_resource_track(_("Pass 4"), &rtrack);
+		print_resource_track(_("Pass 4"), &rtrack, ctx->fs->io);
 	}
 #endif
 }
diff -Nurp e2fsprogs-1.40.8/e2fsck/pass5.c e2fsprogs/e2fsck/pass5.c
--- e2fsprogs-1.40.8/e2fsck/pass5.c	2008-03-13 23:20:46.000000000 +0100
+++ e2fsprogs/e2fsck/pass5.c	2008-03-29 01:20:43.000000000 +0100
@@ -30,7 +30,7 @@ void e2fsck_pass5(e2fsck_t ctx)
 #endif
 
 #ifdef RESOURCE_TRACK
-	init_resource_track(&rtrack);
+	init_resource_track(&rtrack, ctx->fs->io);
 #endif
 	
 	clear_problem_context(&pctx);
@@ -67,7 +67,7 @@ void e2fsck_pass5(e2fsck_t ctx)
 #ifdef RESOURCE_TRACK
 	if (ctx->options & E2F_OPT_TIME2) {
 		e2fsck_clear_progbar(ctx);
-		print_resource_track(_("Pass 5"), &rtrack);
+		print_resource_track(_("Pass 5"), &rtrack, ctx->fs->io);
 	}
 #endif
 }
@@ -114,14 +114,14 @@ static void check_block_bitmaps(e2fsck_t
 	blk_t	i, super;
 	int	*free_array;
 	int	group = 0;
-	unsigned int	blocks = 0;
-	unsigned int	free_blocks = 0;
+	blk_t	blocks = 0;
+	blk_t	free_blocks = 0;
 	int	group_free = 0;
 	int	actual, bitmap;
 	struct problem_context	pctx;
 	int	problem, save_problem, fixit, had_problem;
 	errcode_t	retval;
-	int		lazy_bg = 0;
+	int		lazy_flag, csum_flag;
 	int		skip_group = 0;
 
 	clear_problem_context(&pctx);
@@ -158,15 +158,16 @@ static void check_block_bitmaps(e2fsck_t
 		goto errout;
 	}
 
-	if (EXT2_HAS_COMPAT_FEATURE(fs->super, EXT2_FEATURE_COMPAT_LAZY_BG))
-		lazy_bg++;
-
+	lazy_flag = EXT2_HAS_COMPAT_FEATURE(fs->super,
+					    EXT2_FEATURE_COMPAT_LAZY_BG);
+	csum_flag = EXT2_HAS_RO_COMPAT_FEATURE(fs->super,
+					       EXT4_FEATURE_RO_COMPAT_GDT_CSUM);
 redo_counts:
 	had_problem = 0;
 	save_problem = 0;
 	pctx.blk = pctx.blk2 = NO_BLK;
-	if (lazy_bg && (fs->group_desc[group].bg_flags &
-			EXT2_BG_BLOCK_UNINIT))
+	if ((lazy_flag || csum_flag) &&
+	    (fs->group_desc[group].bg_flags & EXT2_BG_BLOCK_UNINIT))
 		skip_group++;
 	super = fs->super->s_first_data_block;
 	for (i = fs->super->s_first_data_block;
@@ -206,6 +207,17 @@ redo_counts:
 			 * Block used, but not marked in use in the bitmap.
 			 */
 			problem = PR_5_BLOCK_USED;
+
+			if (skip_group) {
+				struct problem_context pctx2;
+				pctx2.blk = i;
+				pctx2.group = group;
+				if (fix_problem(ctx, PR_5_BLOCK_UNINIT,&pctx2)){
+					fs->group_desc[group].bg_flags &=
+						~EXT2_BG_BLOCK_UNINIT;
+					skip_group = 0;
+				}
+			}
 		}
 		if (pctx.blk == NO_BLK) {
 			pctx.blk = pctx.blk2 = i;
@@ -224,7 +236,7 @@ redo_counts:
 		had_problem++;
 
 	do_counts:
-		if (!bitmap && !skip_group) {
+		if (!bitmap && (!skip_group || csum_flag)) {
 			group_free++;
 			free_blocks++;
 		}
@@ -241,7 +253,7 @@ redo_counts:
 				if ((ctx->progress)(ctx, 5, group,
 						    fs->group_desc_count*2))
 					goto errout;
-			if (lazy_bg &&
+			if ((lazy_flag || csum_flag) &&
 			    (i != fs->super->s_blocks_count-1) &&
 			    (fs->group_desc[group].bg_flags &
 			     EXT2_BG_BLOCK_UNINIT))
@@ -321,7 +333,7 @@ static void check_inode_bitmaps(e2fsck_t
 	errcode_t	retval;
 	struct problem_context	pctx;
 	int		problem, save_problem, fixit, had_problem;
-	int		lazy_bg = 0;
+	int		lazy_flag, csum_flag;
 	int		skip_group = 0;
 
 	clear_problem_context(&pctx);
@@ -358,16 +370,16 @@ static void check_inode_bitmaps(e2fsck_t
 		goto errout;
 	}
 
-	if (EXT2_HAS_COMPAT_FEATURE(fs->super,
-				    EXT2_FEATURE_COMPAT_LAZY_BG))
-		lazy_bg++;
-
+	lazy_flag = EXT2_HAS_COMPAT_FEATURE(fs->super,
+					    EXT2_FEATURE_COMPAT_LAZY_BG);
+	csum_flag = EXT2_HAS_RO_COMPAT_FEATURE(fs->super,
+					       EXT4_FEATURE_RO_COMPAT_GDT_CSUM);
 redo_counts:
 	had_problem = 0;
 	save_problem = 0;
 	pctx.ino = pctx.ino2 = 0;
-	if (lazy_bg && (fs->group_desc[group].bg_flags &
-			EXT2_BG_INODE_UNINIT))
+	if ((lazy_flag || csum_flag) &&
+	    (fs->group_desc[group].bg_flags & EXT2_BG_INODE_UNINIT))
 		skip_group++;
 
 	/* Protect loop from wrap-around if inodes_count is maxed */
@@ -390,6 +402,21 @@ redo_counts:
 			 * Inode used, but not in bitmap
 			 */
 			problem = PR_5_INODE_USED;
+
+			/* We should never hit this, because it means that
+			 * inodes were marked in use that weren't noticed
+			 * in pass1 or pass 2. It is easier to fix the problem
+			 * than to kill e2fsck and leave the user stuck. */
+			if (skip_group) {
+				struct problem_context pctx2;
+				pctx2.blk = i;
+				pctx2.group = group;
+				if (fix_problem(ctx, PR_5_INODE_UNINIT,&pctx2)){
+					fs->group_desc[group].bg_flags &=
+						~EXT2_BG_INODE_UNINIT;
+					skip_group = 0;
+				}
+			}
 		}
 		if (pctx.ino == 0) {
 			pctx.ino = pctx.ino2 = i;
@@ -411,7 +438,7 @@ do_counts:
 		if (bitmap) {
 			if (ext2fs_test_inode_bitmap(ctx->inode_dir_map, i))
 				dirs_count++;
-		} else if (!skip_group) {
+		} else if (!skip_group || csum_flag) {
 			group_free++;
 			free_inodes++;
 		}
@@ -430,7 +457,7 @@ do_counts:
 					    group + fs->group_desc_count,
 					    fs->group_desc_count*2))
 					goto errout;
-			if (lazy_bg &&
+			if ((lazy_flag || csum_flag) &&
 			    (i != fs->super->s_inodes_count) &&
 			    (fs->group_desc[group].bg_flags &
 			     EXT2_BG_INODE_UNINIT))
@@ -563,7 +590,7 @@ static void check_block_end(e2fsck_t ctx
 
 	clear_problem_context(&pctx);
 
-	end = fs->block_map->start +
+	end = ext2fs_get_block_bitmap_start(fs->block_map) +
 		(EXT2_BLOCKS_PER_GROUP(fs->super) * fs->group_desc_count) - 1;
 	pctx.errcode = ext2fs_fudge_block_bitmap_end(fs->block_map, end,
 						     &save_blocks_count);
diff -Nurp e2fsprogs-1.40.8/e2fsck/problem.c e2fsprogs/e2fsck/problem.c
--- e2fsprogs-1.40.8/e2fsck/problem.c	2008-03-13 23:20:46.000000000 +0100
+++ e2fsprogs/e2fsck/problem.c	2008-03-29 01:20:43.000000000 +0100
@@ -351,8 +351,28 @@ static struct e2fsck_problem problem_tab
 	  N_("Adding dirhash hint to @f.\n\n"),
 	  PROMPT_NONE, 0 },
 
+	/* group descriptor N checksum is invalid. */
+	{ PR_0_GDT_CSUM,
+	  N_("@g descriptor %g checksum is invalid.  "),
+	     PROMPT_FIX, PR_PREEN_OK },
+
+	/* group descriptor N marked uninitialized without feature set. */
+	{ PR_0_GDT_UNINIT,
+	  N_("@g descriptor %g marked uninitialized without feature set.\n"),
+	     PROMPT_FIX, PR_PREEN_OK },
+
+	/* group N block bitmap uninitialized but inode bitmap in use. */
+	{ PR_0_BB_UNINIT_IB_INIT,
+	  N_("@g %g @b @B uninitialized but @i @B in use.\n"),
+	     PROMPT_FIX, PR_PREEN_OK },
+
+	/* Group descriptor N has invalid unused inodes count. */
+	{ PR_0_GDT_ITABLE_UNUSED,
+	  N_("@g descriptor %g has invalid unused inodes count %b.  "),
+	     PROMPT_FIX, PR_PREEN_OK },
+
 	/* Pass 1 errors */
-	
+
 	/* Pass 1: Checking inodes, blocks, and sizes */
 	{ PR_1_PASS_HEADER,
 	  N_("Pass 1: Checking @is, @bs, and sizes\n"),
@@ -776,7 +796,7 @@ static struct e2fsck_problem problem_tab
 
 	/* invalid ea entry->e_hash */	
 	{ PR_1_ATTR_HASH,
-	  N_("@a in @i %i has a hash (%N) which is @n (must be 0)\n"),
+	  N_("@a in @i %i has a hash (%N) which is @n\n"),
 	  PROMPT_CLEAR, PR_PREEN_OK },
 
 	/* inode appears to be a directory */
@@ -784,6 +804,46 @@ static struct e2fsck_problem problem_tab
 	  N_("@i %i is a %It but it looks like it is really a directory.\n"),
 	  PROMPT_FIX, 0 },
 
+	/* Error while reading extent tree */
+	{ PR_1_READ_EXTENT,
+	  N_("Error while reading over @x tree in @i %i: %m\n"),
+	  PROMPT_CLEAR_INODE, 0 },
+
+	/* Error deleting a bogus extent */
+	{ PR_1_EXTENT_DELETE_FAIL,
+	  N_("Error while deleting extent: %m\n"),
+	  PROMPT_ABORT, 0 },
+
+	/* Bad starting block in extent */
+	{ PR_1_EXTENT_BAD_START_BLK,
+	  N_("@i %i has an @n extent\n\t(logical @b %c, @n physical @b %b, len %N)\n"),
+	  PROMPT_CLEAR, 0 },
+
+	/* Extent ends beyond filesystem */
+	{ PR_1_EXTENT_ENDS_BEYOND,
+	  N_("@i %i has an @n extent\n\t(logical @b %c, physical @b %b, @n len %N)\n"),
+	  PROMPT_CLEAR, 0 },
+
+	/* EXTENTS_FL flag set on a non-extents filesystem */
+	{ PR_1_EXTENTS_SET,
+	  N_("@i %i has EXTENTS_FL flag set on @f without extents support.\n"),
+	  PROMPT_CLEAR, 0 },
+
+	/* inode has extents, superblock missing INCOMPAT_EXTENTS feature */
+	{ PR_1_EXTENT_FEATURE,
+	  N_("@i %i is in extent format, but @S is missing EXTENTS feature\n"),
+	  PROMPT_FIX, 0 },
+
+	/* inode missing EXTENTS_FL, but is an extent inode */
+	{ PR_1_UNSET_EXTENT_FL,
+	  N_("@i %i missing EXTENT_FL, but is in extents format\n"),
+	  PROMPT_FIX, PR_PREEN_OK },
+
+	/* Fast symlink has EXTENTS_FL set */
+	{ PR_1_FAST_SYMLINK_EXTENT_FL,
+	  N_("Fast symlink %i has EXTENT_FL set.  "),
+	  PROMPT_CLEAR, 0 },
+
 	/* Pass 1b errors */
 
 	/* Pass 1B: Rescan for duplicate/bad blocks */
@@ -1192,6 +1252,16 @@ static struct e2fsck_problem problem_tab
 	{ PR_2_UNEXPECTED_HTREE_BLOCK,
 	  N_("Unexpected @b in @h %d (%q).\n"), PROMPT_CLEAR_HTREE, 0 },
 		  
+	/* Inode found in group where _INODE_UNINIT is set */
+	{ PR_2_INOREF_BG_INO_UNINIT,
+	  N_("@i %i found in @g %g where _INODE_UNINIT is set.  "),
+	  PROMPT_FIX, PR_PREEN_OK },
+
+	/* Inode found in group unused inodes area */
+	{ PR_2_INOREF_IN_UNUSED,
+	  N_("@i %i found in @g %g unused inodes area.  "),
+	  PROMPT_FIX, PR_PREEN_OK },
+
 	/* Pass 3 errors */
 
 	/* Pass 3: Checking directory connectivity */
@@ -1503,6 +1573,16 @@ static struct e2fsck_problem problem_tab
 	  N_("Recreate journal to make the filesystem ext3 again?\n"),
 	  PROMPT_FIX, PR_PREEN_OK | PR_NO_OK },
 
+	/* Group N block(s) in use but group is marked BLOCK_UNINIT */
+	{ PR_5_BLOCK_UNINIT,
+	  N_("@g %g @b(s) in use but @g is marked BLOCK_UNINIT\n"),
+	  PROMPT_FIX, PR_PREEN_OK },
+
+	/* Group N inode(s) in use but group is marked INODE_UNINIT */
+	{ PR_5_INODE_UNINIT,
+	  N_("@g %g @i(s) in use but @g is marked INODE_UNINIT\n"),
+	  PROMPT_FIX, PR_PREEN_OK },
+
 	{ 0 }
 };
 
diff -Nurp e2fsprogs-1.40.8/e2fsck/problem.h e2fsprogs/e2fsck/problem.h
--- e2fsprogs-1.40.8/e2fsck/problem.h	2008-03-13 23:20:46.000000000 +0100
+++ e2fsprogs/e2fsck/problem.h	2008-03-29 01:20:43.000000000 +0100
@@ -16,7 +16,7 @@ struct problem_context {
 	ext2_ino_t ino, ino2, dir;
 	struct ext2_inode *inode;
 	struct ext2_dir_entry *dirent;
-	blk_t	blk, blk2;
+	blk64_t	blk, blk2;
 	e2_blkcnt_t	blkcount;
 	int		group;
 	__u64	num;
@@ -196,6 +196,18 @@ struct problem_context {
 /* Superblock hint for external journal incorrect */
 #define PR_0_DIRHASH_HINT			0x000034
 
+/* Group descriptor N checksum is invalid */
+#define PR_0_GDT_CSUM				0x000035
+
+/* Group descriptor N marked uninitialized without feature set. */
+#define PR_0_GDT_UNINIT				0x000036
+
+/* Block bitmap is not initialised and Inode bitmap is */
+#define PR_0_BB_UNINIT_IB_INIT			0x000037
+
+/* Group descriptor N has invalid unused inodes count. */
+#define PR_0_GDT_ITABLE_UNUSED			0x000038
+
 /*
  * Pass 1 errors
  */
@@ -455,6 +467,30 @@ struct problem_context {
 /* inode appears to be a directory */
 #define PR_1_TREAT_AS_DIRECTORY		0x010055
 
+/* Error while reading extent tree */
+#define PR_1_READ_EXTENT		0x010056
+
+/* Error deleting a bogus extent */
+#define PR_1_EXTENT_DELETE_FAIL		0x010057
+
+/* Bad starting block in extent */
+#define PR_1_EXTENT_BAD_START_BLK	0x010058
+
+/* Extent ends beyond filesystem */
+#define PR_1_EXTENT_ENDS_BEYOND		0x010059
+
+/* EXTENTS_FL flag set on a non-extents capable filesystem */
+#define PR_1_EXTENTS_SET		0x01005A
+
+/* inode has extents, superblock missing INCOMPAT_EXTENTS feature */
+#define PR_1_EXTENT_FEATURE		0x01005B
+
+/* inode missing EXTENTS_FL, but is an extent inode */
+#define PR_1_UNSET_EXTENT_FL		0x01005C
+
+/* Fast symlink has EXTENTS_FL set */
+#define PR_1_FAST_SYMLINK_EXTENT_FL	0x01005D
+
 /*
  * Pass 1b errors
  */
@@ -711,6 +747,12 @@ struct problem_context {
 /* Unexpected HTREE block */
 #define PR_2_UNEXPECTED_HTREE_BLOCK	0x020045
 
+/* Inode found in group where _INODE_UNINIT is set */
+#define PR_2_INOREF_BG_INO_UNINIT	0x020046
+
+/* Inode found in group unused inodes area */
+#define PR_2_INOREF_IN_UNUSED		0x020047
+
 /*
  * Pass 3 errors
  */
@@ -899,10 +941,16 @@ struct problem_context {
 
 /* Inode range not used, but marked in bitmap */
 #define PR_5_INODE_RANGE_UNUSED		0x050016
-	  
+
 /* Inode rangeused, but not marked used in bitmap */
 #define PR_5_INODE_RANGE_USED		0x050017
 
+/* Block in use but group is marked BLOCK_UNINIT */
+#define PR_5_BLOCK_UNINIT		0x050018
+
+/* Inode in use but group is marked INODE_UNINIT */
+#define PR_5_INODE_UNINIT		0x050019
+
 /*
  * Post-Pass 5 errors
  */
diff -Nurp e2fsprogs-1.40.8/e2fsck/rehash.c e2fsprogs/e2fsck/rehash.c
--- e2fsprogs-1.40.8/e2fsck/rehash.c	2008-03-13 23:20:46.000000000 +0100
+++ e2fsprogs/e2fsck/rehash.c	2008-03-29 01:20:43.000000000 +0100
@@ -789,7 +789,7 @@ void e2fsck_rehash_directories(e2fsck_t 
 	int			cur, max, all_dirs, dir_index, first = 1;
 
 #ifdef RESOURCE_TRACK
-	init_resource_track(&rtrack);
+	init_resource_track(&rtrack, ctx->fs->io);
 #endif
 
 	all_dirs = ctx->options & E2F_OPT_COMPRESS_DIRS;
@@ -858,7 +858,7 @@ void e2fsck_rehash_directories(e2fsck_t 
 #ifdef RESOURCE_TRACK
 	if (ctx->options & E2F_OPT_TIME2) {
 		e2fsck_clear_progbar(ctx);
-		print_resource_track("Pass 3A", &rtrack);
+		print_resource_track("Pass 3A", &rtrack, ctx->fs->io);
 	}
 #endif
 }
diff -Nurp e2fsprogs-1.40.8/e2fsck/super.c e2fsprogs/e2fsck/super.c
--- e2fsprogs-1.40.8/e2fsck/super.c	2008-03-13 23:20:46.000000000 +0100
+++ e2fsprogs/e2fsck/super.c	2008-03-29 01:20:43.000000000 +0100
@@ -467,7 +467,9 @@ void check_super_block(e2fsck_t ctx)
 	dgrp_t	i;
 	blk_t	should_be;
 	struct problem_context	pctx;
-	__u32	free_blocks = 0, free_inodes = 0;
+	blk_t	free_blocks = 0;
+	ino_t	free_inodes = 0;
+	int     lazy_flag, csum_flag;
 
 	inodes_per_block = EXT2_INODES_PER_BLOCK(fs->super);
 	ipg_max = inodes_per_block * (blocks_per_group - 4);
@@ -574,13 +576,21 @@ void check_super_block(e2fsck_t ctx)
 	/*
 	 * Verify the group descriptors....
 	 */
-	first_block =  sb->s_first_data_block;
+	first_block = sb->s_first_data_block;
+	last_block = sb->s_blocks_count-1;
 
+	lazy_flag = EXT2_HAS_COMPAT_FEATURE(fs->super,
+					    EXT2_FEATURE_COMPAT_LAZY_BG);
+	csum_flag = EXT2_HAS_RO_COMPAT_FEATURE(fs->super,
+					       EXT4_FEATURE_RO_COMPAT_GDT_CSUM);
 	for (i = 0, gd=fs->group_desc; i < fs->group_desc_count; i++, gd++) {
 		pctx.group = i;
 
-		first_block = ext2fs_group_first_block(fs, i);
-		last_block = ext2fs_group_last_block(fs, i);
+		if (!EXT2_HAS_INCOMPAT_FEATURE(fs->super,
+					       EXT4_FEATURE_INCOMPAT_FLEX_BG)) {
+			first_block = ext2fs_group_first_block(fs, i);
+			last_block = ext2fs_group_last_block(fs, i);
+		}
 
 		if ((gd->bg_block_bitmap < first_block) ||
 		    (gd->bg_block_bitmap > last_block)) {
@@ -621,6 +631,39 @@ void check_super_block(e2fsck_t ctx)
 		    (gd->bg_used_dirs_count > sb->s_inodes_per_group))
 			ext2fs_unmark_valid(fs);
 
+		if (!ext2fs_group_desc_csum_verify(fs, i)) {
+			if (fix_problem(ctx, PR_0_GDT_CSUM, &pctx)) {
+				gd->bg_flags &=	~(EXT2_BG_BLOCK_UNINIT |
+				                  EXT2_BG_INODE_UNINIT);
+				gd->bg_itable_unused = 0;
+			}
+			ext2fs_unmark_valid(fs);
+		}
+
+		if (!lazy_flag && !csum_flag &&
+		    (gd->bg_flags &(EXT2_BG_BLOCK_UNINIT|EXT2_BG_INODE_UNINIT)||
+		     gd->bg_itable_unused != 0)){
+			if (fix_problem(ctx, PR_0_GDT_UNINIT, &pctx)) {
+				gd->bg_flags &= ~(EXT2_BG_BLOCK_UNINIT |
+						  EXT2_BG_INODE_UNINIT);
+				gd->bg_itable_unused = 0;
+			}
+			ext2fs_unmark_valid(fs);
+		}
+		if (gd->bg_flags & EXT2_BG_BLOCK_UNINIT &&
+		    !(gd->bg_flags & EXT2_BG_INODE_UNINIT)) {
+			if (fix_problem(ctx, PR_0_BB_UNINIT_IB_INIT, &pctx))
+				gd->bg_flags &= ~EXT2_BG_BLOCK_UNINIT;
+			ext2fs_unmark_valid(fs);
+		}
+		if (csum_flag &&
+		    (gd->bg_itable_unused > gd->bg_free_inodes_count ||
+		     gd->bg_itable_unused > sb->s_inodes_per_group)) {
+			pctx.blk = gd->bg_itable_unused;
+			if (fix_problem(ctx, PR_0_GDT_ITABLE_UNUSED, &pctx))
+				gd->bg_itable_unused = 0;
+			ext2fs_unmark_valid(fs);
+		}
 	}
 
 	/*
@@ -797,7 +840,6 @@ int check_backup_super_block(e2fsck_t ct
 {
 	ext2_filsys	fs = ctx->fs;
 	ext2_filsys	tfs = 0;
-	io_manager	io_ptr;
 	errcode_t	retval;
 	dgrp_t		g;
 	blk_t		sb;
diff -Nurp e2fsprogs-1.40.8/e2fsck/swapfs.c e2fsprogs/e2fsck/swapfs.c
--- e2fsprogs-1.40.8/e2fsck/swapfs.c	2008-03-13 23:20:46.000000000 +0100
+++ e2fsprogs/e2fsck/swapfs.c	1970-01-01 01:00:00.000000000 +0100
@@ -1,272 +0,0 @@
-/*
- * swapfs.c --- byte-swap an ext2 filesystem
- *
- * Copyright 1996, 1997 by Theodore Ts'o
- * 
- * %Begin-Header%
- * This file may be redistributed under the terms of the GNU Public
- * License.
- * %End-Header%
- * 
- */
-
-#ifdef HAVE_ERRNO_H
-#include <errno.h>
-#endif
-#include <et/com_err.h>
-#include "e2fsck.h"
-
-#ifdef ENABLE_SWAPFS
-
-struct swap_block_struct {
-	ext2_ino_t	ino;
-	int		isdir;
-	errcode_t	errcode;
-	char		*dir_buf;
-	struct ext2_inode *inode;
-};
-
-/*
- * This is a helper function for block_iterate.  We mark all of the
- * indirect and direct blocks as changed, so that block_iterate will
- * write them out.
- */
-static int swap_block(ext2_filsys fs, blk_t *block_nr, int blockcnt,
-		      void *priv_data)
-{
-	errcode_t	retval;
-	
-	struct swap_block_struct *sb = (struct swap_block_struct *) priv_data;
-
-	if (sb->isdir && (blockcnt >= 0) && *block_nr) {
-		retval = ext2fs_read_dir_block(fs, *block_nr, sb->dir_buf);
-		if (retval) {
-			sb->errcode = retval;
-			return BLOCK_ABORT;
-		}
-		retval = ext2fs_write_dir_block(fs, *block_nr, sb->dir_buf);
-		if (retval) {
-			sb->errcode = retval;
-			return BLOCK_ABORT;
-		}
-	}
-	if (blockcnt >= 0) {
-		if (blockcnt < EXT2_NDIR_BLOCKS)
-			return 0;
-		return BLOCK_CHANGED;
-	}
-	if (blockcnt == BLOCK_COUNT_IND) {
-		if (*block_nr == sb->inode->i_block[EXT2_IND_BLOCK])
-			return 0;
-		return BLOCK_CHANGED;
-	}
-	if (blockcnt == BLOCK_COUNT_DIND) {
-		if (*block_nr == sb->inode->i_block[EXT2_DIND_BLOCK])
-			return 0;
-		return BLOCK_CHANGED;
-	}
-	if (blockcnt == BLOCK_COUNT_TIND) {
-		if (*block_nr == sb->inode->i_block[EXT2_TIND_BLOCK])
-			return 0;
-		return BLOCK_CHANGED;
-	}
-	return BLOCK_CHANGED;
-}
-
-/*
- * This function is responsible for byte-swapping all of the indirect,
- * block pointers.  It is also responsible for byte-swapping directories.
- */
-static void swap_inode_blocks(e2fsck_t ctx, ext2_ino_t ino, char *block_buf,
-			      struct ext2_inode *inode)
-{
-	errcode_t			retval;
-	struct swap_block_struct	sb;
-
-	sb.ino = ino;
-	sb.inode = inode;
-	sb.dir_buf = block_buf + ctx->fs->blocksize*3;
-	sb.errcode = 0;
-	sb.isdir = 0;
-	if (LINUX_S_ISDIR(inode->i_mode))
-		sb.isdir = 1;
-
-	retval = ext2fs_block_iterate(ctx->fs, ino, 0, block_buf,
-				      swap_block, &sb);
-	if (retval) {
-		com_err("swap_inode_blocks", retval,
-			_("while calling ext2fs_block_iterate"));
-		ctx->flags |= E2F_FLAG_ABORT;
-		return;
-	}
-	if (sb.errcode) {
-		com_err("swap_inode_blocks", sb.errcode,
-			_("while calling iterator function"));
-		ctx->flags |= E2F_FLAG_ABORT;
-		return;
-	}
-}
-
-static void swap_inodes(e2fsck_t ctx)
-{
-	ext2_filsys fs = ctx->fs;
-	dgrp_t			group;
-	unsigned int		i;
-	ext2_ino_t		ino = 1;
-	char 			*buf = NULL, *block_buf = NULL;
-	errcode_t		retval;
-	struct ext2_inode *	inode;
-
-	e2fsck_use_inode_shortcuts(ctx, 1);
-	
-	retval = ext2fs_get_array(fs->blocksize, fs->inode_blocks_per_group,
-				&buf);
-	if (retval) {
-		com_err("swap_inodes", retval,
-			_("while allocating inode buffer"));
-		ctx->flags |= E2F_FLAG_ABORT;
-		goto errout;
-	}
-	block_buf = (char *) e2fsck_allocate_memory(ctx, fs->blocksize * 4,
-						    "block interate buffer");
-	for (group = 0; group < fs->group_desc_count; group++) {
-		retval = io_channel_read_blk(fs->io,
-		      fs->group_desc[group].bg_inode_table,
-		      fs->inode_blocks_per_group, buf);
-		if (retval) {
-			com_err("swap_inodes", retval,
-				_("while reading inode table (group %d)"),
-				group);
-			ctx->flags |= E2F_FLAG_ABORT;
-			goto errout;
-		}
-		inode = (struct ext2_inode *) buf;
-		for (i=0; i < fs->super->s_inodes_per_group;
-		     i++, ino++, inode++) {
-			ctx->stashed_ino = ino;
-			ctx->stashed_inode = inode;
-			
-			if (fs->flags & EXT2_FLAG_SWAP_BYTES_READ)
-				ext2fs_swap_inode(fs, inode, inode, 0);
-			
-			/*
-			 * Skip deleted files.
-			 */
-			if (inode->i_links_count == 0)
-				continue;
-			
-			if (LINUX_S_ISDIR(inode->i_mode) ||
-			    ((inode->i_block[EXT2_IND_BLOCK] ||
-			      inode->i_block[EXT2_DIND_BLOCK] ||
-			      inode->i_block[EXT2_TIND_BLOCK]) &&
-			     ext2fs_inode_has_valid_blocks(inode)))
-				swap_inode_blocks(ctx, ino, block_buf, inode);
-
-			if (ctx->flags & E2F_FLAG_SIGNAL_MASK)
-				goto errout;
-			
-			if (fs->flags & EXT2_FLAG_SWAP_BYTES_WRITE)
-				ext2fs_swap_inode(fs, inode, inode, 1);
-		}
-		retval = io_channel_write_blk(fs->io,
-		      fs->group_desc[group].bg_inode_table,
-		      fs->inode_blocks_per_group, buf);
-		if (retval) {
-			com_err("swap_inodes", retval,
-				_("while writing inode table (group %d)"),
-				group);
-			ctx->flags |= E2F_FLAG_ABORT;
-			goto errout;
-		}
-	}
-errout:
-	if (buf)
-		ext2fs_free_mem(&buf);
-	if (block_buf)
-		ext2fs_free_mem(&block_buf);
-	e2fsck_use_inode_shortcuts(ctx, 0);
-	ext2fs_flush_icache(fs);
-}
-
-#if defined(__powerpc__) && defined(EXT2FS_ENABLE_SWAPFS)
-/*
- * On the PowerPC, the big-endian variant of the ext2 filesystem
- * has its bitmaps stored as 32-bit words with bit 0 as the LSB
- * of each word.  Thus a bitmap with only bit 0 set would be, as
- * a string of bytes, 00 00 00 01 00 ...
- * To cope with this, we byte-reverse each word of a bitmap if
- * we have a big-endian filesystem, that is, if we are *not*
- * byte-swapping other word-sized numbers.
- */
-#define EXT2_BIG_ENDIAN_BITMAPS
-#endif
-
-#ifdef EXT2_BIG_ENDIAN_BITMAPS
-static void ext2fs_swap_bitmap(ext2fs_generic_bitmap bmap)
-{
-	__u32 *p = (__u32 *) bmap->bitmap;
-	int n, nbytes = (bmap->end - bmap->start + 7) / 8;
-		
-	for (n = nbytes / sizeof(__u32); n > 0; --n, ++p)
-		*p = ext2fs_swab32(*p);
-}
-#endif
-
-
-void swap_filesys(e2fsck_t ctx)
-{
-	ext2_filsys fs = ctx->fs;
-#ifdef RESOURCE_TRACK
-	struct resource_track	rtrack;
-
-	init_resource_track(&rtrack);
-#endif
-
-	if (!(ctx->options & E2F_OPT_PREEN))
-		printf(_("Pass 0: Doing byte-swap of filesystem\n"));
-	
-#ifdef MTRACE
-	mtrace_print("Byte swap");
-#endif
-
-	if (fs->super->s_mnt_count) {
-		fprintf(stderr, _("%s: the filesystem must be freshly "
-			"checked using fsck\n"
-			"and not mounted before trying to "
-			"byte-swap it.\n"), ctx->device_name);
-		ctx->flags |= E2F_FLAG_ABORT;
-		return;
-	}
-	if (fs->flags & EXT2_FLAG_SWAP_BYTES) {
-		fs->flags &= ~(EXT2_FLAG_SWAP_BYTES|
-			       EXT2_FLAG_SWAP_BYTES_WRITE);
-		fs->flags |= EXT2_FLAG_SWAP_BYTES_READ;
-	} else {
-		fs->flags &= ~EXT2_FLAG_SWAP_BYTES_READ;
-		fs->flags |= EXT2_FLAG_SWAP_BYTES_WRITE;
-	}
-	swap_inodes(ctx);
-	if (ctx->flags & E2F_FLAG_SIGNAL_MASK)
-		return;
-	if (fs->flags & EXT2_FLAG_SWAP_BYTES_WRITE)
-		fs->flags |= EXT2_FLAG_SWAP_BYTES;
-	fs->flags &= ~(EXT2_FLAG_SWAP_BYTES_READ|
-		       EXT2_FLAG_SWAP_BYTES_WRITE);
-
-#ifdef EXT2_BIG_ENDIAN_BITMAPS
-	e2fsck_read_bitmaps(ctx);
-	ext2fs_swap_bitmap(fs->inode_map);
-	ext2fs_swap_bitmap(fs->block_map);
-	fs->flags |= EXT2_FLAG_BB_DIRTY | EXT2_FLAG_IB_DIRTY;
-#endif
-	fs->flags &= ~EXT2_FLAG_MASTER_SB_ONLY;
-	ext2fs_flush(fs);
-	fs->flags |= EXT2_FLAG_MASTER_SB_ONLY;
-	
-#ifdef RESOURCE_TRACK
-	if (ctx->options & E2F_OPT_TIME2)
-		print_resource_track(_("Byte swap"), &rtrack);
-#endif
-}
-
-#endif
diff -Nurp e2fsprogs-1.40.8/e2fsck/unix.c e2fsprogs/e2fsck/unix.c
--- e2fsprogs-1.40.8/e2fsck/unix.c	2008-03-13 23:20:46.000000000 +0100
+++ e2fsprogs/e2fsck/unix.c	2008-03-29 01:20:43.000000000 +0100
@@ -52,8 +52,6 @@ extern int optind;
 #include "../version.h"
 
 /* Command line options */
-static int swapfs;
-static int normalize_swapfs;
 static int cflag;		/* check disk */
 static int show_version_only;
 static int verbose;
@@ -71,7 +69,7 @@ int journal_enable_debug = -1;
 static void usage(e2fsck_t ctx)
 {
 	fprintf(stderr,
-		_("Usage: %s [-panyrcdfvstDFSV] [-b superblock] [-B blocksize]\n"
+		_("Usage: %s [-panyrcdfvtDFV] [-b superblock] [-B blocksize]\n"
 		"\t\t[-I inode_buffer_blocks] [-P process_inode_size]\n"
 		"\t\t[-l|-L bad_blocks_file] [-C fd] [-j external_journal]\n"
 		"\t\t[-E extended-options] device\n"),
@@ -268,8 +266,7 @@ static void check_if_skip(e2fsck_t ctx)
 	if (!defer_check_on_battery)
 		batt = 0;
 
-	if ((ctx->options & E2F_OPT_FORCE) || bad_blocks_file ||
-	    cflag || swapfs)
+	if ((ctx->options & E2F_OPT_FORCE) || bad_blocks_file || cflag)
 		return;
 	
 	lastcheck = fs->super->s_lastcheck;
@@ -561,7 +558,9 @@ static void parse_extended_opts(e2fsck_t
 		       "and may take an argument which\n"
 		       "is set off by an equals ('=') sign.  "
 			"Valid extended options are:\n"
-		       "\tea_ver=<ea_version (1 or 2)>\n\n"), stderr);
+			"\tea_ver=<ea_version (1 or 2)>\n"
+			"\tuninit_groups\n"
+			"\tinit_groups\n\n"), stderr);
 		exit(1);
 	}
 }
@@ -735,20 +734,6 @@ static errcode_t PRS(int argc, char *arg
 		case 'N':
 			ctx->device_name = optarg;
 			break;
-#ifdef ENABLE_SWAPFS
-		case 's':
-			normalize_swapfs = 1;
-		case 'S':
-			swapfs = 1;
-			break;
-#else
-		case 's':
-		case 'S':
-			fprintf(stderr, _("Byte-swapping filesystems "
-					  "not compiled in this version "
-					  "of e2fsck\n"));
-			exit(1);
-#endif
 		case 'k':
 			keep_bad_blocks++;
 			break;
@@ -760,8 +745,9 @@ static errcode_t PRS(int argc, char *arg
 	if (optind != argc - 1)
 		usage(ctx);
 	if ((ctx->options & E2F_OPT_NO) && !bad_blocks_file &&
-	    !cflag && !swapfs && !(ctx->options & E2F_OPT_COMPRESS_DIRS))
+	    !cflag && !(ctx->options & E2F_OPT_COMPRESS_DIRS))
 		ctx->options |= E2F_OPT_READONLY;
+
 	ctx->io_options = strchr(argv[optind], '?');
 	if (ctx->io_options) 
 		*ctx->io_options++ = 0;
@@ -795,15 +781,6 @@ static errcode_t PRS(int argc, char *arg
 		}
 		close(fd);
 	}
-#ifdef ENABLE_SWAPFS
-	if (swapfs) {
-		if (cflag || bad_blocks_file) {
-			fprintf(stderr, _("Incompatible options not "
-					  "allowed when byte-swapping.\n"));
-			exit(FSCK_USAGE);
-		}
-	}
-#endif
 	if (cflag && bad_blocks_file) {
 		fprintf(stderr, _("The -c and the -l/-L options may "
 				  "not be both used at the same time.\n"));
@@ -869,7 +846,7 @@ sscanf_err:
 
 static const char *my_ver_string = E2FSPROGS_VERSION;
 static const char *my_ver_date = E2FSPROGS_DATE;
-					
+
 int main (int argc, char *argv[])
 {
 	errcode_t	retval = 0, orig_retval = 0;
@@ -916,7 +893,7 @@ int main (int argc, char *argv[])
 	reserve_stdio_fds();
 	
 #ifdef RESOURCE_TRACK
-	init_resource_track(&ctx->global_rtrack);
+	init_resource_track(&ctx->global_rtrack, NULL);
 #endif
 
 	if (!(ctx->options & E2F_OPT_PREEN) || show_version_only)
@@ -1234,21 +1211,6 @@ print_unsupp_features:
 		read_bad_blocks_file(ctx, 0, !keep_bad_blocks); /* Test disk */
 	if (ctx->flags & E2F_FLAG_SIGNAL_MASK)
 		fatal_error(ctx, 0);
-#ifdef ENABLE_SWAPFS
-	if (normalize_swapfs) {
-		if ((fs->flags & EXT2_FLAG_SWAP_BYTES) ==
-		    ext2fs_native_flag()) {
-			fprintf(stderr, _("%s: Filesystem byte order "
-				"already normalized.\n"), ctx->device_name);
-			fatal_error(ctx, 0);
-		}
-	}
-	if (swapfs) {
-		swap_filesys(ctx);
-		if (ctx->flags & E2F_FLAG_SIGNAL_MASK)
-			fatal_error(ctx, 0);
-	}
-#endif
 
 	/*
 	 * Mark the system as valid, 'til proven otherwise
@@ -1377,17 +1339,21 @@ no_journal:
 		}
 	}
 
+	if (sb->s_feature_ro_compat & EXT4_FEATURE_RO_COMPAT_GDT_CSUM &&
+	    !(ctx->options & E2F_OPT_READONLY))
+		ext2fs_set_gdt_csum(ctx->fs);
+
 	e2fsck_write_bitmaps(ctx);
-	
+#ifdef RESOURCE_TRACK
+	io_channel_flush(ctx->fs->io);
+	if (ctx->options & E2F_OPT_TIME)
+		print_resource_track(NULL, &ctx->global_rtrack, ctx->fs->io);
+#endif
 	ext2fs_close(fs);
 	ctx->fs = NULL;
 	free(ctx->filesystem_name);
 	free(ctx->journal_name);
 
-#ifdef RESOURCE_TRACK
-	if (ctx->options & E2F_OPT_TIME)
-		print_resource_track(NULL, &ctx->global_rtrack);
-#endif
 	e2fsck_free_context(ctx);
 	remove_error_table(&et_ext2_error_table);
 	remove_error_table(&et_prof_error_table);
diff -Nurp e2fsprogs-1.40.8/e2fsck/util.c e2fsprogs/e2fsck/util.c
--- e2fsprogs-1.40.8/e2fsck/util.c	2008-03-13 23:20:46.000000000 +0100
+++ e2fsprogs/e2fsck/util.c	2008-03-29 01:20:43.000000000 +0100
@@ -29,6 +29,10 @@
 #include <malloc.h>
 #endif
 
+#ifdef HAVE_ERRNO_H
+#include <errno.h>
+#endif
+
 #include "e2fsck.h"
 
 extern e2fsck_t e2fsck_global_ctx;   /* Try your very best not to use this! */
@@ -276,11 +280,12 @@ void preenhalt(e2fsck_t ctx)
 }
 
 #ifdef RESOURCE_TRACK
-void init_resource_track(struct resource_track *track)
+void init_resource_track(struct resource_track *track, io_channel channel)
 {
 #ifdef HAVE_GETRUSAGE
 	struct rusage r;
 #endif
+	io_stats io_start = 0;
 	
 	track->brk_start = sbrk(0);
 	gettimeofday(&track->time_start, 0);
@@ -295,6 +300,14 @@ void init_resource_track(struct resource
 	track->user_start.tv_sec = track->user_start.tv_usec = 0;
 	track->system_start.tv_sec = track->system_start.tv_usec = 0;
 #endif
+	track->bytes_read = 0;
+	track->bytes_written = 0;
+	if (channel && channel->manager && channel->manager->get_stats)
+		channel->manager->get_stats(channel, &io_start);
+	if (io_start) {
+		track->bytes_read = io_start->bytes_read;
+		track->bytes_written = io_start->bytes_written;
+	}
 }
 
 #ifdef __GNUC__
@@ -310,7 +323,8 @@ static _INLINE_ float timeval_subtract(s
 		((float) (tv1->tv_usec - tv2->tv_usec)) / 1000000);
 }
 
-void print_resource_track(const char *desc, struct resource_track *track)
+void print_resource_track(const char *desc, struct resource_track *track,
+			  io_channel channel)
 {
 #ifdef HAVE_GETRUSAGE
 	struct rusage r;
@@ -347,6 +361,26 @@ void print_resource_track(const char *de
 	printf(_("elapsed time: %6.3f\n"),
 	       timeval_subtract(&time_end, &track->time_start));
 #endif
+#define mbytes(x)	(((x) + 1048575) / 1048576)
+	if (channel && channel->manager && channel->manager->get_stats) {
+		io_stats delta = 0;
+		unsigned long long bytes_read = 0;
+		unsigned long long bytes_written = 0;
+
+		if (desc)
+			printf("%s: ", desc);
+
+		channel->manager->get_stats(channel, &delta);
+		if (delta) {
+			bytes_read = delta->bytes_read - track->bytes_read;
+			bytes_written = delta->bytes_written - 
+				track->bytes_written;
+		}
+		printf("I/O read: %lluMB, write: %lluMB, rate: %.2fMB/s\n",
+		       mbytes(bytes_read), mbytes(bytes_written),
+		       (double)mbytes(bytes_read + bytes_written) /
+		       timeval_subtract(&time_end, &track->time_start));
+	}
 }
 #endif /* RESOURCE_TRACK */
 
@@ -363,6 +397,20 @@ void e2fsck_read_inode(e2fsck_t ctx, uns
 	}
 }
 
+void e2fsck_read_inode_full(e2fsck_t ctx, unsigned long ino,
+			    struct ext2_inode *inode, int bufsize,
+			    const char *proc)
+{
+	int retval;
+
+	retval = ext2fs_read_inode_full(ctx->fs, ino, inode, bufsize);
+	if (retval) {
+		com_err("ext2fs_read_inode_full", retval,
+			_("while reading inode %ld in %s"), ino, proc);
+		fatal_error(ctx, 0);
+	}
+}
+
 extern void e2fsck_write_inode_full(e2fsck_t ctx, unsigned long ino,
 			       struct ext2_inode * inode, int bufsize,
 			       const char *proc)
@@ -451,7 +499,7 @@ blk_t get_backup_sb(e2fsck_t ctx, ext2_f
 		if (io_channel_read_blk(io, superblock,
 					-SUPERBLOCK_SIZE, buf))
 			continue;
-#ifdef EXT2FS_ENABLE_SWAPFS
+#ifdef WORDS_BIGENDIAN
 		if (sb->s_magic == ext2fs_swab16(EXT2_SUPER_MAGIC))
 			ext2fs_swap_super(sb);
 #endif
@@ -502,3 +550,60 @@ int ext2_file_type(unsigned int mode)
 	
 	return 0;
 }
+
+#define STRIDE_LENGTH 8
+/*
+ * Helper function which zeros out _num_ blocks starting at _blk_.  In
+ * case of an error, the details of the error is returned via _ret_blk_
+ * and _ret_count_ if they are non-NULL pointers.  Returns 0 on
+ * success, and an error code on an error.
+ *
+ * As a special case, if the first argument is NULL, then it will
+ * attempt to free the static zeroizing buffer.  (This is to keep
+ * programs that check for memory leaks happy.)
+ */
+errcode_t e2fsck_zero_blocks(ext2_filsys fs, blk_t blk, int num,
+			     blk_t *ret_blk, int *ret_count)
+{
+	int		j, count, next_update, next_update_incr;
+	static char	*buf;
+	errcode_t	retval;
+
+	/* If fs is null, clean up the static buffer and return */
+	if (!fs) {
+		if (buf) {
+			free(buf);
+			buf = 0;
+		}
+		return 0;
+	}
+	/* Allocate the zeroizing buffer if necessary */
+	if (!buf) {
+		buf = malloc(fs->blocksize * STRIDE_LENGTH);
+		if (!buf) {
+			com_err("malloc", ENOMEM,
+				_("while allocating zeroizing buffer"));
+			exit(1);
+		}
+		memset(buf, 0, fs->blocksize * STRIDE_LENGTH);
+	}
+	/* OK, do the write loop */
+	next_update = 0;
+	next_update_incr = num / 100;
+	if (next_update_incr < 1)
+		next_update_incr = 1;
+	for (j = 0; j < num; j += STRIDE_LENGTH, blk += STRIDE_LENGTH) {
+		count = num - j;
+		if (count > STRIDE_LENGTH)
+			count = STRIDE_LENGTH;
+		retval = io_channel_write_blk(fs->io, blk, count, buf);
+		if (retval) {
+			if (ret_count)
+				*ret_count = count;
+			if (ret_blk)
+				*ret_blk = blk;
+			return retval;
+		}
+	}
+	return 0;
+}
diff -Nurp e2fsprogs-1.40.8/e2fsprogs.spec e2fsprogs/e2fsprogs.spec
--- e2fsprogs-1.40.8/e2fsprogs.spec	2008-03-14 01:02:45.000000000 +0100
+++ e2fsprogs/e2fsprogs.spec	1970-01-01 01:00:00.000000000 +0100
@@ -1,228 +0,0 @@
-%define	_root_sbindir	/sbin
-%define	_root_libdir	/%{_lib}
-%define	_root_localedir	/usr/share/locale
-%define	_root_etcdir	/etc
-
-Summary: Utilities for managing the second extended (ext2) filesystem.
-Name: e2fsprogs
-Version: 1.40.8
-Release: 0
-License: GPLv2
-Group: System Environment/Base
-Source:  ftp://download.sourceforge.net/pub/sourceforge/e2fsprogs/e2fsprogs-%{version}.tar.gz
-Url: http://e2fsprogs.sourceforge.net/
-Prereq: /sbin/ldconfig
-BuildRoot: %{_tmppath}/%{name}-root
-
-%description
-The e2fsprogs package contains a number of utilities for creating,
-checking, modifying, and correcting any inconsistencies in second
-extended (ext2) filesystems.  E2fsprogs contains e2fsck (used to
-repair filesystem inconsistencies after an unclean shutdown), mke2fs
-(used to initialize a partition to contain an empty ext2 filesystem),
-debugfs (used to examine the internal structure of a filesystem, to
-manually repair a corrupted filesystem or to create test cases for
-e2fsck), tune2fs (used to modify filesystem parameters), resize2fs to
-grow and shrink unmounted ext2 filesystems, and most of the other core
-ext2fs filesystem utilities.
-
-You should install the e2fsprogs package if you are using any ext2
-filesystems (if you're not sure, you probably should install this
-package).  You may also need to install it (even if you don't use
-ext2) for the libuuid and libblkid libraries and fsck tool that are
-included here.
-
-%package devel
-Summary: Ext2 filesystem-specific static libraries and headers.
-Group: Development/Libraries
-Requires: e2fsprogs = %{version}
-Prereq: /sbin/install-info
-
-%description devel
-E2fsprogs-devel contains the libraries and header files needed to
-develop second extended (ext2) filesystem-specific programs.
-
-You should install e2fsprogs-devel if you want to develop ext2
-filesystem-specific programs.  If you install e2fsprogs-devel, you'll
-also want to install e2fsprogs.
-
-%package -n uuidd
-Summary: helper daemon to guarantee uniqueness of time-based UUIDs
-Group: System Environment/Daemons
-License: GPLv2
-Requires: e2fsprogs = %{version}
-Requires(pre): shadow-utils
-
-%description -n uuidd
-The uuidd package contains a userspace daemon (uuidd) which guarantees
-uniqueness of time-based UUID generation even at very high rates on
-SMP systems.
-
-%prep
-%setup
-
-%build
-%configure --enable-elf-shlibs --enable-nls
-make
-make check
-
-%install
-rm -rf $RPM_BUILD_ROOT
-export PATH=/sbin:$PATH
-make install install-libs DESTDIR="$RPM_BUILD_ROOT" \
-	root_sbindir=%{_root_sbindir} root_libdir=%{_root_libdir}
-/sbin/ldconfig -n ${RPM_BUILD_ROOT}%{_libdir}
-
-# Add a dir that uuidd needs that the Makefiles don't create
-install -d $RPM_BUILD_ROOT/var/lib/libuuid
-
-%find_lang %{name}
-
-%clean
-rm -rf $RPM_BUILD_ROOT
-
-%post -p /sbin/ldconfig
-
-%postun -p /sbin/ldconfig
-
-%post devel
-if [ -x /sbin/install-info -a -f %{_infodir}/libext2fs.info.gz ]; then
-    /sbin/install-info %{_infodir}/libext2fs.info.gz %{_infodir}/dir
-fi
-exit 0
-
-%postun devel
-if [ $1 = 0 -a -x /sbin/install-info -a -f %{_infodir}/libext2fs.info.gz ]; then
-   /sbin/install-info --delete %{_infodir}/libext2fs.info.gz %{_infodir}/dir
-fi
-exit 0
-
-%pre -n uuidd
-getent group uuidd >/dev/null || groupadd -r uuidd
-getent passwd uuidd >/dev/null || \
-useradd -r -g uuidd -d /var/lib/libuuid -s /sbin/nologin \
-    -c "UUID generator helper daemon" uuidd
-exit 0
-
-%files -f %{name}.lang
-%defattr(-,root,root)
-%doc README RELEASE-NOTES
-
-%{_root_sbindir}/badblocks
-%{_root_sbindir}/blkid
-%{_root_sbindir}/debugfs
-%{_root_sbindir}/dumpe2fs
-%{_root_sbindir}/e2fsck
-%{_root_sbindir}/e2image
-%{_root_sbindir}/e2label
-%{_root_sbindir}/findfs
-%{_root_sbindir}/fsck
-%{_root_sbindir}/fsck.ext2
-%{_root_sbindir}/fsck.ext3
-%{_root_sbindir}/logsave
-%{_root_sbindir}/mke2fs
-%{_root_etcdir}/mke2fs.conf
-%{_root_sbindir}/mkfs.ext2
-%{_root_sbindir}/mkfs.ext3
-%{_root_sbindir}/resize2fs
-%{_root_sbindir}/tune2fs
-%{_sbindir}/filefrag
-%{_sbindir}/mklost+found
-
-%{_root_libdir}/libblkid.so.*
-%{_root_libdir}/libcom_err.so.*
-%{_root_libdir}/libe2p.so.*
-%{_root_libdir}/libext2fs.so.*
-%{_root_libdir}/libss.so.*
-%{_root_libdir}/libuuid.so.*
-
-%{_libdir}/e2initrd_helper
-
-%{_bindir}/chattr
-%{_bindir}/lsattr
-%{_bindir}/uuidgen
-%{_mandir}/man1/chattr.1*
-%{_mandir}/man1/lsattr.1*
-%{_mandir}/man1/uuidgen.1*
-
-%{_mandir}/man5/e2fsck.conf.5*
-%{_mandir}/man5/mke2fs.conf.5*
-
-%{_mandir}/man8/badblocks.8*
-%{_mandir}/man8/blkid.8*
-%{_mandir}/man8/debugfs.8*
-%{_mandir}/man8/dumpe2fs.8*
-%{_mandir}/man8/e2fsck.8*
-%{_mandir}/man8/findfs.8*
-%{_mandir}/man8/fsck.ext2.8*
-%{_mandir}/man8/fsck.ext3.8*
-%{_mandir}/man8/e2image.8*
-%{_mandir}/man8/e2label.8*
-%{_mandir}/man8/fsck.8*
-%{_mandir}/man8/logsave.8*
-%{_mandir}/man8/mke2fs.8*
-%{_mandir}/man8/mkfs.ext2.8*
-%{_mandir}/man8/mkfs.ext3.8*
-%{_mandir}/man8/mklost+found.8*
-%{_mandir}/man8/resize2fs.8*
-%{_mandir}/man8/tune2fs.8*
-%{_mandir}/man8/filefrag.8*
-
-%files devel
-%defattr(-,root,root)
-%{_infodir}/libext2fs.info*
-%{_bindir}/compile_et
-%{_bindir}/mk_cmds
-
-%{_libdir}/libblkid.a
-%{_libdir}/libblkid.so
-%{_libdir}/libcom_err.a
-%{_libdir}/libcom_err.so
-%{_libdir}/libe2p.a
-%{_libdir}/libe2p.so
-%{_libdir}/libext2fs.a
-%{_libdir}/libext2fs.so
-%{_libdir}/libss.a
-%{_libdir}/libss.so
-%{_libdir}/libuuid.a
-%{_libdir}/libuuid.so
-
-%{_libdir}/pkgconfig/blkid.pc
-%{_libdir}/pkgconfig/com_err.pc
-%{_libdir}/pkgconfig/e2p.pc
-%{_libdir}/pkgconfig/ext2fs.pc
-%{_libdir}/pkgconfig/ss.pc
-%{_libdir}/pkgconfig/uuid.pc
-
-%{_datadir}/et
-%{_datadir}/ss
-%{_includedir}/blkid
-%{_includedir}/e2p
-%{_includedir}/et
-%{_includedir}/ext2fs
-%{_includedir}/ss
-%{_includedir}/uuid
-%{_mandir}/man1/compile_et.1*
-%{_mandir}/man1/mk_cmds.1*
-%{_mandir}/man3/com_err.3*
-%{_mandir}/man3/libblkid.3*
-%{_mandir}/man3/uuid.3*
-%{_mandir}/man3/uuid_clear.3*
-%{_mandir}/man3/uuid_compare.3*
-%{_mandir}/man3/uuid_copy.3*
-%{_mandir}/man3/uuid_generate.3*
-%{_mandir}/man3/uuid_generate_random.3*
-%{_mandir}/man3/uuid_generate_time.3*
-%{_mandir}/man3/uuid_is_null.3*
-%{_mandir}/man3/uuid_parse.3*
-%{_mandir}/man3/uuid_time.3*
-%{_mandir}/man3/uuid_unparse.3*
-
-%files -n uuidd
-%defattr(-,root,root)
-# if you want to run via init
-# /etc/init.d/uuidd
-%{_mandir}/man8/uuidd.8*
-%attr(6755, uuidd, uuidd) %{_sbindir}/uuidd
-%dir %attr(2775, uuidd, uuidd) /var/lib/libuuid
-
diff -Nurp e2fsprogs-1.40.8/ext2ed/doc/ext2ed-design.sgml e2fsprogs/ext2ed/doc/ext2ed-design.sgml
--- e2fsprogs-1.40.8/ext2ed/doc/ext2ed-design.sgml	2008-03-13 23:20:46.000000000 +0100
+++ e2fsprogs/ext2ed/doc/ext2ed-design.sgml	2008-03-29 01:20:43.000000000 +0100
@@ -2722,9 +2722,6 @@ struct ext2_inode {
 		struct {
 			__u32  h_i_translator;
 		} hurd1;
-		struct {
-			__u32  m_i_reserved1;
-		} masix1;
 	} osd1;				/* OS dependent 1 */
 	__u32	i_block[EXT2_N_BLOCKS];	/* Pointers to blocks */
 	__u32	i_version;		/* File version (for NFS) */
@@ -2746,12 +2743,6 @@ struct ext2_inode {
 			__u16	h_i_gid_high;
 			__u32	h_i_author;
 		} hurd2;
-		struct {
-			__u8	m_i_frag;	/* Fragment number */
-			__u8	m_i_fsize;	/* Fragment size */
-			__u16	m_pad1;
-			__u32	m_i_reserved2[2];
-		} masix2;
 	} osd2;				/* OS dependent 2 */
 };
 </ProgramListing>
diff -Nurp e2fsprogs-1.40.8/.gitignore e2fsprogs/.gitignore
--- e2fsprogs-1.40.8/.gitignore	2008-02-19 05:33:09.000000000 +0100
+++ e2fsprogs/.gitignore	1970-01-01 01:00:00.000000000 +0100
@@ -1,115 +0,0 @@
-autom4te.cache
-build
-FILES
-^core
-*~
-.pc
-patches
-Makefile
-*.o
-MCONFIG
-asm_types.h
-config.log
-config.status
-debugfs/debug_cmds.c
-debugfs/debugfs
-debugfs/debugfs.8
-doc/libext2fs.info
-e2fsck/e2fsck
-e2fsck/e2fsck.8
-e2fsck/e2fsck.conf.5
-e2fsck/e2fsck.shared
-e2fsck/e2fsck.static
-e2fsck/prof_err.c
-e2fsck/prof_err.h
-e2fsprogs.spec
-lib/blkid/blkid.pc
-lib/blkid/blkid_types.h
-lib/blkid/libblkid.3
-lib/blkid/libblkid.a
-lib/blkid/subdirs
-lib/e2p/e2p.pc
-lib/e2p/libe2p.a
-lib/e2p/subdirs
-lib/et/com_err.pc
-lib/et/compile_et
-lib/et/libcom_err.a
-lib/et/subdirs
-lib/ext2fs/ext2_err.c
-lib/ext2fs/ext2_err.et
-lib/ext2fs/ext2_err.h
-lib/ext2fs/ext2_types.h
-lib/ext2fs/ext2fs.pc
-lib/ext2fs/libext2fs.a
-lib/ext2fs/subdirs
-lib/libblkid.a
-lib/libcom_err.a
-lib/libe2p.a
-lib/libext2fs.a
-lib/libss.a
-lib/libuuid.a
-lib/ss/libss.a
-lib/ss/mk_cmds
-lib/ss/ss.pc
-lib/ss/ss_err.c
-lib/ss/ss_err.h
-lib/ss/std_rqs.c
-lib/ss/subdirs
-lib/uuid/libuuid.a
-lib/uuid/subdirs
-lib/uuid/tst_uuid
-lib/uuid/uuid.3
-lib/uuid/uuid.pc
-lib/uuid/uuid_clear.3
-lib/uuid/uuid_compare.3
-lib/uuid/uuid_copy.3
-lib/uuid/uuid_generate.3
-lib/uuid/uuid_is_null.3
-lib/uuid/uuid_parse.3
-lib/uuid/uuid_time
-lib/uuid/uuid_time.3
-lib/uuid/uuid_types.h
-lib/uuid/uuid_unparse.3
-misc/badblocks
-misc/badblocks.8
-misc/blkid
-misc/blkid.8
-misc/chattr
-misc/chattr.1
-misc/dumpe2fs
-misc/dumpe2fs.8
-misc/e2image
-misc/e2image.8
-misc/e2initrd_helper
-misc/e2label.8
-misc/filefrag
-misc/filefrag.8
-misc/findfs.8
-misc/fsck
-misc/fsck.8
-misc/logsave
-misc/logsave.8
-misc/lsattr
-misc/lsattr.1
-misc/mke2fs
-misc/mke2fs.8
-misc/mke2fs.conf.5
-misc/mklost+found
-misc/mklost+found.8
-misc/prof_err.c
-misc/prof_err.h
-misc/tune2fs
-misc/tune2fs.8
-misc/uuidgen
-misc/uuidgen.1
-po/Makefile.in
-po/POTFILES
-resize/resize2fs
-resize/resize2fs.8
-resize/test_extent
-tests/progs/test_icount
-tests/progs/test_icount_cmds.c
-util/gen-tarball
-util/subst
-util/subst.conf
-Meta
diff -Nurp e2fsprogs-1.40.8/.hgtags e2fsprogs/.hgtags
--- e2fsprogs-1.40.8/.hgtags	2007-06-30 14:58:34.000000000 +0200
+++ e2fsprogs/.hgtags	1970-01-01 01:00:00.000000000 +0100
@@ -1,76 +0,0 @@
-eed1bd163c2bbe64492dfc2c30c91273f4eb8fde E2FSPROGS-0_5B
-002ccb5ae1bf2d9ab32405594b40c92f17b3a782 E2FSPROGS-0_5C
-cf2ddbcce70598dbdd38031d8877a5e6d9b20622 E2FSPROGS-1_01
-e09e1d42565d2981df8db11f03f774ac0b1760d3 E2FSPROGS-1_02
-a5ba1d4fdb208a87143f543509ab1bada29c81aa E2FSPROGS-1_03
-8396c2d7c2d08948628b87259cb6aedd3c4e854e E2FSPROGS-1_04
-791c3ec9726cf8cd55d21196fba1737b787a8a45 E2FSPROGS-1_05
-0ae294a9a498a560baa07467c47eaa10bfaa046c E2FSPROGS-1_06
-1c5bfd8bac0814c6b7ef6a76fc6842bb22083ec7 E2FSPROGS-1_07
-288182d41028ad52fb876838bb95ff40fd302eff E2FSPROGS-1_09
-2fc3b268def26733210e4ca189de981c4e55d33e E2FSPROGS-1_10
-3c16c4f2f39ba3ec732817d5f2a0c3f587dae3d5 E2FSPROGS-1_11
-24fbb672c409f8bb3f52d5e6b70df7791036e716 PQ_SNAPSHOT_971103
-7de311bac88d3b280d3cc7e921e9ee89ab94e1f8 E2FSPROGS-1_12
-49bc583d005ce8865abf0fd3c550db3837e12784 RESIZE2FS-1_03
-b985a88877fff6cf8a9d6a1d7222391278e85cf5 E2FSPROGS-1_13
-b9ab3ad2237018ab0638a18a1bac7cd8584f9125 E2FSPROGS-1_15
-e54e2ffa66f56f11028ac8e802b9b9029d564868 E2FSPROGS-1_16
-d4b8ef7ebc7b25549abc39fa638fa3ec29be3f51 E2FSPROGS-1_17
-a92cf96f4ef106e34511fd60315a9d0d80107f66 E2FSPROGS-1_19
-1805b629c21c592f2c48b47ed71562f154fbc14a E2FSPROGS-1_20
-97ac969663130215bf42a6e9a5a8e4c2ec10e13d E2FSPROGS-1_21
-a37f5435ea9e68ab43c0ac9b27feaf34a50f2708 WIP-20010620
-cfdc7d809fc8b1962e393e9fb5f1212232b55575 E2FSPROGS-1_22
-b2ed462235c29d10c5f007ba465f0a21d3424ad5 E2FSPROGS-1_23-WIP-0720
-fc8081d26d1ac935e4e93f834a7afeebc3f3d44f E2FSPROGS-1_23-WIP-0722
-7d4bd37abc524d91911c75c91e19affbce4c8b5d E2FSPROGS-1_23-WIP-0727
-0197355d6350fc84a48eacb945e54a1ef23ec4ee E2FSPROGS-1_23-WIP-0727
-03705d00929aef695c1ce3d4f1f9c4bc8ecd012e E2FSPROGS-1_23-WIP-0727
-9c4c0f3980172838f631a5d94ce81b4a140d22af E2FSPROGS-1_23
-d7047e244df1bd3ffe42847d600118566c17df5f E2FSPROGS-1_24
-a106c02843b6aa8ddcb64855ece60e33a42ca0c3 E2FSPROGS-1_24a
-96e238040b05f76c0c79eb1f7921fdaf6a1c0231 E2FSPROGS-1.25
-fa6d2465cbe58ca0d204db0ac27e4d1eb87514e1 WIP-20011130
-a77661f0ff4afc77b1b1f1350bf1080b62f6213e E2FSPROGS-1_26-WIP-1224
-50a235ca176eb44286d9390d4755a50bd70335e4 E2FSPROGS-1_26
-24c9facc3012c76b332e847fc40e6e275e94a63b E2FSPROGS-1_26
-aacf0d2ab6158d3c3001d4ae393b28b1322ff2ee E2FSPROGS-1_26
-43372cec7b50a52f0403fa5ec0bb33a943cc0ffc E2FSPROGS-1.27-WIP-0305
-088edd484dda040294e38fa4b9753345f1d300b6 E2FSPROGS-1_27
-25faca6a70ced56c0e7ae500f684c610d9e7c9d8 E2FSPROGS-1_27
-bc393f509fad6f876a8300f3d74cc96327e81213 E2FSPROGS-1.28-WIP-0626
-b4ebc1586ad35e51a93aa7e73ba99f3dddbda29f E2FSPROGS-1.28-WIP-0817
-55d76b1b9f26a2d49a8180fd7caf1e3c403f48fb E2FSPROGS-1_28
-f560f2860e69a2c164db63d7239c8c7bf1470c0d E2FSPROGS-1_29
-ccfdc3d9f9722b242b78c1cf338aece56da1deda E2FSPROGS-1.30-WIP-0930
-503af9cbc489a5eff64d44616a6e8fb2ded887af E2FSPROGS-1_30
-aad2b766b799044d52c401a886abff9f8b856c06 E2FSPROGS-1_31
-80c78aa9c6170e1c929cf4cbb12115c3647ee8ce E2FSPROGS-1_32
-118febeaf5549f7f7452ff1589b8bbf65906943d E2FSPROGS-1_33-WIP-0306
-72a0ed9722d412fc6400cb2f10ddac7b79c7f518 E2FSPROGS-1_33-WIP-0314
-96dd92ae7152d160808dc937e4ab932737543d26 E2FSPROGS-1_33-WIP-0316
-df05b8c56d04b03909e9790d3ba0f67d672a9505 E2FSPROGS-1_33-WIP-0325
-00e2c359b3d0eeb21f24b3b2cb54bc5e1feb37e6 E2FSPROGS-1_33-WIP-0330
-8426f7cad2d1ce5553f39f7e333ac599ea5f48f4 E2FSPROGS-1_33-WIP-0414
-c245056f93eb220a875ecc1d72177eb21d31f13d E2FSPROGS-1_33
-86f66c1bdc2977bea19db3a2558837cf828e7ee6 E2FSPROGS-1_34-WIP-0521
-7b8945d1438b9c5f4225764bad9e3b07fd347877 E2FSPROGS-1_34
-98abec7dd493cbf64ca470a9e184a195c7607540 E2FSPROGS-1_35-WIP-0801
-22e8a84ebaa25c221bee1421a9866055badadc7e E2FSPROGS-1_35-WIP-0821
-06179dfc122afb97c3a89bb6c3b08f7664f0c901 E2FSPROGS-1_35-WIP-1207
-b254057535b5af57bba5c1c968e47d925793009e E2FSPROGS-1_35-WIP-0131
-80e538a1ae07e3f581aaeecd8652cec24156fd7a E2FSPROGS-1_35
-25b02e5aa1662ee16206f44b4f2ecfd8798f7739 APPLE_UUID_SNAP_1
-f1db1487ef3c2ed8013643e636a52f389515affe E2FSPROGS-1_36
-41f469aa7b40e7e610a8fdd66352a2c106c1f700 E2FSPROGS-1_37
-80496573dbce31c6cda3df95a5280a6fbae28e8e E2FSPROGS-1_38-WIP-0509
-d840a9257ffbeacb9dfd95292d9af48033da5d2b E2FSPROGS-1_38-WIP-0620
-a1d839755669d4c9b5e949fd87a359cca8f9c221 E2FSPROGS-1_38
-502cdad9110a8f5bec2ff7842a6e90a543d49840 E2FSPROGS-1.39-WIP-1210
-b3e5c52c10907a4488ded00fca596487643bddc4 E2FSPROGS-1.39-WIP-1231
-cc5d09c487b27487925fb34d8ccd50a19e801ec4 E2FSPROGS-1.39-WIP-0330
-a89eec026fc32ca7da786fbe3f76d892b6badb23 E2FSPROGS-1.39-WIP-0409
-7c019255c28099336f7bba454b9307c4bdeb94a4 E2FSPROGS-1_39
-20144d6af15c4d4efb0a74ef1ef27dcce79dc997 E2FSPROGS-1_40-WIP-1114
-097cd140ac3bd6ecacdf9a0123110fb712f58604 E2FSPROGS-1_40
diff -Nurp e2fsprogs-1.40.8/lib/blkid/blkid.pc.in e2fsprogs/lib/blkid/blkid.pc.in
--- e2fsprogs-1.40.8/lib/blkid/blkid.pc.in	2008-03-13 23:20:46.000000000 +0100
+++ e2fsprogs/lib/blkid/blkid.pc.in	2008-03-29 01:20:43.000000000 +0100
@@ -8,4 +8,5 @@ Description: Block device id library
 Version: @E2FSPROGS_VERSION@
 Requires: uuid @DEVMAPPER_REQ@
 Cflags: -I${includedir} 
-Libs: -L${libdir} -lblkid @DEVMAPPER_PC_LIBS@
+Libs: -L${libdir} -lblkid
+Libs.private: @DEVMAPPER_PC_LIBS@
diff -Nurp e2fsprogs-1.40.8/lib/blkid/getsize.c e2fsprogs/lib/blkid/getsize.c
--- e2fsprogs-1.40.8/lib/blkid/getsize.c	2008-03-13 23:20:46.000000000 +0100
+++ e2fsprogs/lib/blkid/getsize.c	2008-03-29 01:20:43.000000000 +0100
@@ -186,7 +186,7 @@ blkid_loff_t blkid_get_dev_size(int fd)
 #ifdef TEST_PROGRAM
 int main(int argc, char **argv)
 {
-	blkid_loff_t bytes;
+	long long bytes;
 	int	fd;
 
 	if (argc < 2) {
diff -Nurp e2fsprogs-1.40.8/lib/blkid/probe.c e2fsprogs/lib/blkid/probe.c
--- e2fsprogs-1.40.8/lib/blkid/probe.c	2008-03-13 23:20:46.000000000 +0100
+++ e2fsprogs/lib/blkid/probe.c	2008-03-29 01:20:43.000000000 +0100
@@ -779,6 +779,7 @@ static int probe_luks(struct blkid_probe
 		       unsigned char *buf)
 {
 	char uuid[40];
+
 	/* 168 is the offset to the 40 character uuid:
 	 * http://luks.endorphin.org/LUKS-on-disk-format.pdf */
 	strncpy(uuid, (char *) buf+168, 40);
diff -Nurp e2fsprogs-1.40.8/lib/blkid/test_probe.in e2fsprogs/lib/blkid/test_probe.in
--- e2fsprogs-1.40.8/lib/blkid/test_probe.in	2008-03-13 23:20:46.000000000 +0100
+++ e2fsprogs/lib/blkid/test_probe.in	2008-03-29 01:20:43.000000000 +0100
@@ -8,7 +8,7 @@ if test "$TESTS"x = x ; then
 	done
 fi
 
-mkdir -p tests
+mkdir -p tests/tmp
 
 for i in $TESTS
 do
@@ -19,9 +19,9 @@ do
 		echo "non-existent"
 		continue
 	fi
-	bunzip2 < $SRCDIR/tests/$i.img.bz2 > /tmp/test.img.$$
-	./tst_probe /tmp/test.img.$$ > tests/$i.out
-	/bin/rm -f /tmp/test.img.$$ tests/$i.ok tests/$i.failed
+	bunzip2 < $SRCDIR/tests/$i.img.bz2 > tests/tmp/test.img.$$
+	./tst_probe tests/tmp/test.img.$$ > tests/$i.out
+	/bin/rm -f tests/tmp/test.img.$$ tests/$i.ok tests/$i.failed
 	cmp -s tests/$i.out $SRCDIR/tests/$i.results
 	if [ $? = 0 ];  then
 		echo ok
diff -Nurp e2fsprogs-1.40.8/lib/e2p/feature.c e2fsprogs/lib/e2p/feature.c
--- e2fsprogs-1.40.8/lib/e2p/feature.c	2008-03-13 23:20:46.000000000 +0100
+++ e2fsprogs/lib/e2p/feature.c	2008-03-29 01:20:43.000000000 +0100
@@ -45,7 +45,7 @@ static struct feature feature_list[] = {
 	{	E2P_FEATURE_RO_INCOMPAT, EXT4_FEATURE_RO_COMPAT_HUGE_FILE,
 			"huge_file" },
 	{	E2P_FEATURE_RO_INCOMPAT, EXT4_FEATURE_RO_COMPAT_GDT_CSUM,
-			"gdt_checksum" },
+			"uninit_groups" },
 	{	E2P_FEATURE_RO_INCOMPAT, EXT4_FEATURE_RO_COMPAT_DIR_NLINK,
 			"dir_nlink" },
 	{	E2P_FEATURE_RO_INCOMPAT, EXT4_FEATURE_RO_COMPAT_EXTRA_ISIZE,
@@ -67,6 +67,8 @@ static struct feature feature_list[] = {
 			"extent" },
 	{	E2P_FEATURE_INCOMPAT, EXT4_FEATURE_INCOMPAT_64BIT,
 			"64bit" },
+	{       E2P_FEATURE_INCOMPAT, EXT4_FEATURE_INCOMPAT_FLEX_BG,
+                        "flex_bg"},
 	{	0, 0, 0 },
 };
 
diff -Nurp e2fsprogs-1.40.8/lib/e2p/fgetflags.c e2fsprogs/lib/e2p/fgetflags.c
--- e2fsprogs-1.40.8/lib/e2p/fgetflags.c	2008-03-13 23:20:46.000000000 +0100
+++ e2fsprogs/lib/e2p/fgetflags.c	2008-03-29 01:20:43.000000000 +0100
@@ -65,7 +65,7 @@ int fgetflags (const char * name, unsign
 #if HAVE_EXT2_IOCTLS
 	int fd, r, f, save_errno = 0;
 
-	if (!stat(name, &buf) &&
+	if (!lstat(name, &buf) &&
 	    !S_ISREG(buf.st_mode) && !S_ISDIR(buf.st_mode)) {
 		goto notsupp;
 	}
diff -Nurp e2fsprogs-1.40.8/lib/e2p/fsetflags.c e2fsprogs/lib/e2p/fsetflags.c
--- e2fsprogs-1.40.8/lib/e2p/fsetflags.c	2008-03-13 23:20:46.000000000 +0100
+++ e2fsprogs/lib/e2p/fsetflags.c	2008-03-29 01:20:43.000000000 +0100
@@ -71,7 +71,7 @@ int fsetflags (const char * name, unsign
 #if HAVE_EXT2_IOCTLS
 	int fd, r, f, save_errno = 0;
 
-	if (!stat(name, &buf) &&
+	if (!lstat(name, &buf) &&
 	    !S_ISREG(buf.st_mode) && !S_ISDIR(buf.st_mode)) {
 		goto notsupp;
 	}
diff -Nurp e2fsprogs-1.40.8/lib/e2p/iod.c e2fsprogs/lib/e2p/iod.c
--- e2fsprogs-1.40.8/lib/e2p/iod.c	2008-03-13 23:20:46.000000000 +0100
+++ e2fsprogs/lib/e2p/iod.c	2008-03-29 01:20:43.000000000 +0100
@@ -27,7 +27,7 @@ int iterate_on_dir (const char * dir_nam
 {
 	DIR * dir;
 	struct dirent *de, *dep;
-	int	max_len = -1, len;
+	int	max_len = -1, len, ret = 0;
 
 #if HAVE_PATHCONF && defined(_PC_NAME_MAX) 
 	max_len = pathconf(dir_name, _PC_NAME_MAX);
@@ -64,9 +64,10 @@ int iterate_on_dir (const char * dir_nam
 			len = max_len;
 #endif
 		memcpy(de, dep, len);
-		(*func) (dir_name, de, private);
+		if ((*func)(dir_name, de, private))
+			ret++;
 	}
 	free(de);
 	closedir(dir);
-	return 0;
+	return ret;
 }
diff -Nurp e2fsprogs-1.40.8/lib/et/com_err.texinfo e2fsprogs/lib/et/com_err.texinfo
--- e2fsprogs-1.40.8/lib/et/com_err.texinfo	2008-03-13 23:20:46.000000000 +0100
+++ e2fsprogs/lib/et/com_err.texinfo	2008-03-29 01:20:43.000000000 +0100
@@ -19,11 +19,9 @@
 
 @ifinfo
 @dircategory Development
-@format
-START-INFO-DIR-ENTRY
+@direntry
 * Com_err: (com_err).   A Common Error Description Library for UNIX.
-END-INFO-DIR-ENTRY
-@end format
+@end direntry
 @end ifinfo
 
 @iftex
diff -Nurp e2fsprogs-1.40.8/lib/ext2fs/alloc_stats.c e2fsprogs/lib/ext2fs/alloc_stats.c
--- e2fsprogs-1.40.8/lib/ext2fs/alloc_stats.c	2008-03-13 19:57:37.000000000 +0100
+++ e2fsprogs/lib/ext2fs/alloc_stats.c	2008-03-29 01:20:43.000000000 +0100
@@ -27,6 +27,25 @@ void ext2fs_inode_alloc_stats2(ext2_fils
 	fs->group_desc[group].bg_free_inodes_count -= inuse;
 	if (isdir)
 		fs->group_desc[group].bg_used_dirs_count += inuse;
+
+	/* We don't strictly need to be clearing these if inuse < 0
+	 * (i.e. freeing inodes) but it also means something is bad. */
+	fs->group_desc[group].bg_flags &= ~(EXT2_BG_INODE_UNINIT |
+					    EXT2_BG_BLOCK_UNINIT);
+	if (EXT2_HAS_RO_COMPAT_FEATURE(fs->super,
+				       EXT4_FEATURE_RO_COMPAT_GDT_CSUM)) {
+		ext2_ino_t first_unused_inode =	fs->super->s_inodes_per_group -
+			fs->group_desc[group].bg_itable_unused +
+			group * fs->super->s_inodes_per_group + 1;
+
+		if (ino >= first_unused_inode)
+			fs->group_desc[group].bg_itable_unused =
+				group * fs->super->s_inodes_per_group +
+				fs->super->s_inodes_per_group - ino;
+
+		ext2fs_group_desc_csum_set(fs, group);
+	}
+
 	fs->super->s_free_inodes_count -= inuse;
 	ext2fs_mark_super_dirty(fs);
 	ext2fs_mark_ib_dirty(fs);
@@ -46,6 +65,9 @@ void ext2fs_block_alloc_stats(ext2_filsy
 	else
 		ext2fs_unmark_block_bitmap(fs->block_map, blk);
 	fs->group_desc[group].bg_free_blocks_count -= inuse;
+	fs->group_desc[group].bg_flags &= ~EXT2_BG_BLOCK_UNINIT;
+	ext2fs_group_desc_csum_set(fs, group);
+
 	fs->super->s_free_blocks_count -= inuse;
 	ext2fs_mark_super_dirty(fs);
 	ext2fs_mark_bb_dirty(fs);
diff -Nurp e2fsprogs-1.40.8/lib/ext2fs/alloc_tables.c e2fsprogs/lib/ext2fs/alloc_tables.c
--- e2fsprogs-1.40.8/lib/ext2fs/alloc_tables.c	2008-03-13 19:57:37.000000000 +0100
+++ e2fsprogs/lib/ext2fs/alloc_tables.c	2008-03-29 01:20:43.000000000 +0100
@@ -95,13 +95,11 @@ errcode_t ext2fs_allocate_group_table(ex
 			ext2fs_mark_block_bitmap(bmap, blk);
 		fs->group_desc[group].bg_inode_table = new_blk;
 	}
+	ext2fs_group_desc_csum_set(fs, group);
 
-	
 	return 0;
 }
 
-	
-
 errcode_t ext2fs_allocate_tables(ext2_filsys fs)
 {
 	errcode_t	retval;
diff -Nurp e2fsprogs-1.40.8/lib/ext2fs/bitmaps.c e2fsprogs/lib/ext2fs/bitmaps.c
--- e2fsprogs-1.40.8/lib/ext2fs/bitmaps.c	2008-03-13 23:20:46.000000000 +0100
+++ e2fsprogs/lib/ext2fs/bitmaps.c	2008-03-29 01:20:43.000000000 +0100
@@ -27,96 +27,31 @@
 #include "ext2_fs.h"
 #include "ext2fs.h"
 
-static errcode_t make_bitmap(__u32 start, __u32 end, __u32 real_end,
-			     const char *descr, char *init_map,
-			     ext2fs_generic_bitmap *ret)
-{
-	ext2fs_generic_bitmap	bitmap;
-	errcode_t		retval;
-	size_t			size;
-
-	retval = ext2fs_get_mem(sizeof(struct ext2fs_struct_generic_bitmap), 
-				&bitmap);
-	if (retval)
-		return retval;
-
-	bitmap->magic = EXT2_ET_MAGIC_GENERIC_BITMAP;
-	bitmap->fs = NULL;
-	bitmap->start = start;
-	bitmap->end = end;
-	bitmap->real_end = real_end;
-	bitmap->base_error_code = EXT2_ET_BAD_GENERIC_MARK;
-	if (descr) {
-		retval = ext2fs_get_mem(strlen(descr)+1, &bitmap->description);
-		if (retval) {
-			ext2fs_free_mem(&bitmap);
-			return retval;
-		}
-		strcpy(bitmap->description, descr);
-	} else
-		bitmap->description = 0;
-
-	size = (size_t) (((bitmap->real_end - bitmap->start) / 8) + 1);
-	retval = ext2fs_get_mem(size, &bitmap->bitmap);
-	if (retval) {
-		ext2fs_free_mem(&bitmap->description);
-		ext2fs_free_mem(&bitmap);
-		return retval;
-	}
-
-	if (init_map)
-		memcpy(bitmap->bitmap, init_map, size);
-	else
-		memset(bitmap->bitmap, 0, size);
-	*ret = bitmap;
-	return 0;
-}
-
-errcode_t ext2fs_allocate_generic_bitmap(__u32 start,
-					 __u32 end,
-					 __u32 real_end,
-					 const char *descr,
-					 ext2fs_generic_bitmap *ret)
+void ext2fs_free_inode_bitmap(ext2fs_inode_bitmap bitmap)
 {
-	return make_bitmap(start, end, real_end, descr, 0, ret);
+	ext2fs_free_generic_bitmap(bitmap);
+}
+
+void ext2fs_free_block_bitmap(ext2fs_block_bitmap bitmap)
+{
+	ext2fs_free_generic_bitmap(bitmap);
 }
 
 errcode_t ext2fs_copy_bitmap(ext2fs_generic_bitmap src,
 			     ext2fs_generic_bitmap *dest)
 {
-	errcode_t		retval;
-	ext2fs_generic_bitmap	new_map;
-
-	retval = make_bitmap(src->start, src->end, src->real_end,
-			     src->description, src->bitmap, &new_map);
-	if (retval)
-		return retval;
-	new_map->magic = src->magic;
-	new_map->fs = src->fs;
-	new_map->base_error_code = src->base_error_code;
-	*dest = new_map;
-	return 0;
+	return (ext2fs_copy_generic_bitmap(src, dest));
 }
 
 void ext2fs_set_bitmap_padding(ext2fs_generic_bitmap map)
 {
-	__u32	i, j;
-
-	/* Protect loop from wrap-around if map->real_end is maxed */
-	for (i=map->end+1, j = i - map->start; 
-	     i <= map->real_end && i > map->end; 
-	     i++, j++)
-		ext2fs_set_bit(j, map->bitmap);
-
-	return;
+	ext2fs_set_generic_bitmap_padding(map);
 }	
 
 errcode_t ext2fs_allocate_inode_bitmap(ext2_filsys fs,
 				       const char *descr,
 				       ext2fs_inode_bitmap *ret)
 {
-	ext2fs_inode_bitmap bitmap;
-	errcode_t	retval;
 	__u32		start, end, real_end;
 
 	EXT2_CHECK_MAGIC(fs, EXT2_ET_MAGIC_EXT2FS_FILSYS);
@@ -127,25 +62,15 @@ errcode_t ext2fs_allocate_inode_bitmap(e
 	end = fs->super->s_inodes_count;
 	real_end = (EXT2_INODES_PER_GROUP(fs->super) * fs->group_desc_count);
 
-	retval = ext2fs_allocate_generic_bitmap(start, end, real_end,
-						descr, &bitmap);
-	if (retval)
-		return retval;
-	
-	bitmap->magic = EXT2_ET_MAGIC_INODE_BITMAP;
-	bitmap->fs = fs;
-	bitmap->base_error_code = EXT2_ET_BAD_INODE_MARK;
-	
-	*ret = bitmap;
-	return 0;
+	return (ext2fs_make_generic_bitmap(EXT2_ET_MAGIC_INODE_BITMAP, fs,
+					   start, end, real_end,
+					   descr, 0, ret));
 }
 
 errcode_t ext2fs_allocate_block_bitmap(ext2_filsys fs,
 				       const char *descr,
 				       ext2fs_block_bitmap *ret)
 {
-	ext2fs_block_bitmap bitmap;
-	errcode_t	retval;
 	__u32		start, end, real_end;
 
 	EXT2_CHECK_MAGIC(fs, EXT2_ET_MAGIC_EXT2FS_FILSYS);
@@ -157,59 +82,102 @@ errcode_t ext2fs_allocate_block_bitmap(e
 	real_end = (EXT2_BLOCKS_PER_GROUP(fs->super)  
 		    * fs->group_desc_count)-1 + start;
 	
-	retval = ext2fs_allocate_generic_bitmap(start, end, real_end,
-						descr, &bitmap);
-	if (retval)
-		return retval;
-
-	bitmap->magic = EXT2_ET_MAGIC_BLOCK_BITMAP;
-	bitmap->fs = fs;
-	bitmap->base_error_code = EXT2_ET_BAD_BLOCK_MARK;
-	
-	*ret = bitmap;
-	return 0;
+	return (ext2fs_make_generic_bitmap(EXT2_ET_MAGIC_BLOCK_BITMAP, fs,
+					   start, end, real_end,
+					   descr, 0, ret));
 }
 
 errcode_t ext2fs_fudge_inode_bitmap_end(ext2fs_inode_bitmap bitmap,
 					ext2_ino_t end, ext2_ino_t *oend)
 {
-	EXT2_CHECK_MAGIC(bitmap, EXT2_ET_MAGIC_INODE_BITMAP);
-	
-	if (end > bitmap->real_end)
-		return EXT2_ET_FUDGE_INODE_BITMAP_END;
-	if (oend)
-		*oend = bitmap->end;
-	bitmap->end = end;
-	return 0;
+
+	return (ext2fs_fudge_generic_bitmap_end(bitmap,
+						EXT2_ET_MAGIC_INODE_BITMAP,
+						EXT2_ET_FUDGE_INODE_BITMAP_END,
+						end, oend));
 }
 
 errcode_t ext2fs_fudge_block_bitmap_end(ext2fs_block_bitmap bitmap,
 					blk_t end, blk_t *oend)
 {
-	EXT2_CHECK_MAGIC(bitmap, EXT2_ET_MAGIC_BLOCK_BITMAP);
-	
-	if (end > bitmap->real_end)
-		return EXT2_ET_FUDGE_BLOCK_BITMAP_END;
-	if (oend)
-		*oend = bitmap->end;
-	bitmap->end = end;
-	return 0;
+	return (ext2fs_fudge_generic_bitmap_end(bitmap,
+						EXT2_ET_MAGIC_BLOCK_BITMAP,
+						EXT2_ET_FUDGE_BLOCK_BITMAP_END,
+						end, oend));
 }
 
 void ext2fs_clear_inode_bitmap(ext2fs_inode_bitmap bitmap)
 {
-	if (!bitmap || (bitmap->magic != EXT2_ET_MAGIC_INODE_BITMAP))
-		return;
-
-	memset(bitmap->bitmap, 0,
-	       (size_t) (((bitmap->real_end - bitmap->start) / 8) + 1));
+	ext2fs_clear_generic_bitmap(bitmap);
 }
 
 void ext2fs_clear_block_bitmap(ext2fs_block_bitmap bitmap)
 {
-	if (!bitmap || (bitmap->magic != EXT2_ET_MAGIC_BLOCK_BITMAP))
-		return;
+	ext2fs_clear_generic_bitmap(bitmap);
+}
+
+errcode_t ext2fs_resize_inode_bitmap(__u32 new_end, __u32 new_real_end,
+				     ext2fs_inode_bitmap bmap)
+{
+	return (ext2fs_resize_generic_bitmap(EXT2_ET_MAGIC_INODE_BITMAP,
+					     new_end, new_real_end, bmap));
+}
+
+errcode_t ext2fs_resize_block_bitmap(__u32 new_end, __u32 new_real_end,
+				     ext2fs_block_bitmap bmap)
+{
+	return (ext2fs_resize_generic_bitmap(EXT2_ET_MAGIC_BLOCK_BITMAP,
+					     new_end, new_real_end, bmap));
+}
+
+errcode_t ext2fs_compare_block_bitmap(ext2fs_block_bitmap bm1,
+				      ext2fs_block_bitmap bm2)
+{
+	return (ext2fs_compare_generic_bitmap(EXT2_ET_MAGIC_BLOCK_BITMAP,
+					      EXT2_ET_NEQ_BLOCK_BITMAP,
+					      bm1, bm2));
+}
+
+errcode_t ext2fs_compare_inode_bitmap(ext2fs_inode_bitmap bm1,
+				      ext2fs_inode_bitmap bm2)
+{
+	return (ext2fs_compare_generic_bitmap(EXT2_ET_MAGIC_INODE_BITMAP,
+					      EXT2_ET_NEQ_INODE_BITMAP,
+					      bm1, bm2));
+}
+
+errcode_t ext2fs_set_inode_bitmap_range(ext2fs_inode_bitmap bmap,
+					ext2_ino_t start, unsigned int num,
+					void *in)
+{
+	return (ext2fs_set_generic_bitmap_range(bmap,
+						EXT2_ET_MAGIC_INODE_BITMAP,
+						start, num, in));
+}
+
+errcode_t ext2fs_get_inode_bitmap_range(ext2fs_inode_bitmap bmap,
+					ext2_ino_t start, unsigned int num,
+					void *out)
+{
+	return (ext2fs_get_generic_bitmap_range(bmap,
+						EXT2_ET_MAGIC_INODE_BITMAP,
+						start, num, out));
+}
 
-	memset(bitmap->bitmap, 0,
-	       (size_t) (((bitmap->real_end - bitmap->start) / 8) + 1));
+errcode_t ext2fs_set_block_bitmap_range(ext2fs_block_bitmap bmap,
+					blk_t start, unsigned int num,
+					void *in)
+{
+	return (ext2fs_set_generic_bitmap_range(bmap, 
+						EXT2_ET_MAGIC_BLOCK_BITMAP,
+						start, num, in));
+}
+
+errcode_t ext2fs_get_block_bitmap_range(ext2fs_block_bitmap bmap,
+					blk_t start, unsigned int num,
+					void *out)
+{
+	return (ext2fs_get_generic_bitmap_range(bmap,
+						EXT2_ET_MAGIC_BLOCK_BITMAP,
+						start, num, out));
 }
diff -Nurp e2fsprogs-1.40.8/lib/ext2fs/bitops.c e2fsprogs/lib/ext2fs/bitops.c
--- e2fsprogs-1.40.8/lib/ext2fs/bitops.c	2008-03-13 23:20:46.000000000 +0100
+++ e2fsprogs/lib/ext2fs/bitops.c	2008-03-29 01:20:43.000000000 +0100
@@ -76,16 +76,3 @@ void ext2fs_warn_bitmap(errcode_t errcod
 		com_err(0, errcode, "#%lu", arg);
 #endif
 }
-
-void ext2fs_warn_bitmap2(ext2fs_generic_bitmap bitmap,
-			    int code, unsigned long arg)
-{
-#ifndef OMIT_COM_ERR
-	if (bitmap->description)
-		com_err(0, bitmap->base_error_code+code,
-			"#%lu for %s", arg, bitmap->description);
-	else
-		com_err(0, bitmap->base_error_code + code, "#%lu", arg);
-#endif
-}
-
diff -Nurp e2fsprogs-1.40.8/lib/ext2fs/bitops.h e2fsprogs/lib/ext2fs/bitops.h
--- e2fsprogs-1.40.8/lib/ext2fs/bitops.h	2008-03-13 23:20:46.000000000 +0100
+++ e2fsprogs/lib/ext2fs/bitops.h	2008-03-29 01:20:43.000000000 +0100
@@ -104,11 +104,18 @@ extern int ext2fs_fast_test_block_bitmap
 					       blk_t block, int num);
 extern void ext2fs_set_bitmap_padding(ext2fs_generic_bitmap map);
 
-/* These two routines moved to gen_bitmap.c */
+/* These routines moved to gen_bitmap.c */
 extern int ext2fs_mark_generic_bitmap(ext2fs_generic_bitmap bitmap,
 					 __u32 bitno);
 extern int ext2fs_unmark_generic_bitmap(ext2fs_generic_bitmap bitmap,
 					   blk_t bitno);
+extern int ext2fs_test_generic_bitmap(ext2fs_generic_bitmap bitmap,
+				      blk_t bitno);
+extern int ext2fs_test_block_bitmap_range(ext2fs_block_bitmap bitmap,
+					  blk_t block, int num);
+extern __u32 ext2fs_get_generic_bitmap_start(ext2fs_generic_bitmap bitmap);
+extern __u32 ext2fs_get_generic_bitmap_end(ext2fs_generic_bitmap bitmap);
+
 /*
  * The inline routines themselves...
  * 
@@ -267,36 +274,6 @@ _INLINE_ int ext2fs_find_next_bit_set (v
 }
 #endif
 
-#ifdef EXT2FS_ENABLE_SWAPFS
-_INLINE_ __u32 ext2fs_swab32(__u32 val)
-{
-#ifdef EXT2FS_REQUIRE_486
-	__asm__("bswap %0" : "=r" (val) : "0" (val));
-#else
-	__asm__("xchgb %b0,%h0\n\t"	/* swap lower bytes	*/
-		"rorl $16,%0\n\t"	/* swap words		*/
-		"xchgb %b0,%h0"		/* swap higher bytes	*/
-		:"=q" (val)
-		: "0" (val));
-#endif
-	return val;
-}
-
-_INLINE_ __u16 ext2fs_swab16(__u16 val)
-{
-	__asm__("xchgb %b0,%h0"		/* swap bytes		*/ \
-		: "=q" (val) \
-		:  "0" (val)); \
-		return val;
-}
-
-_INLINE_ __u64 ext2fs_swab64(__u64 val)
-{
-	return (ext2fs_swab32(val >> 32) |
-		(((__u64)ext2fs_swab32(val & 0xFFFFFFFFUL)) << 32));
-}
-#endif
-
 #undef EXT2FS_ADDR
 
 #endif	/* i386 */
@@ -339,7 +316,7 @@ _INLINE_ int ext2fs_test_bit(unsigned in
 #endif /* __mc68000__ */
 
 
-#if !defined(_EXT2_HAVE_ASM_SWAB_) && defined(EXT2FS_ENABLE_SWAPFS)
+#if !defined(_EXT2_HAVE_ASM_SWAB_) && defined(WORDS_BIGENDIAN)
 
 _INLINE_ __u16 ext2fs_swab16(__u16 val)
 {
@@ -401,24 +378,10 @@ _INLINE_ int ext2fs_find_next_bit_set (v
 }
 #endif	
 
-_INLINE_ int ext2fs_test_generic_bitmap(ext2fs_generic_bitmap bitmap,
-					blk_t bitno);
-
-_INLINE_ int ext2fs_test_generic_bitmap(ext2fs_generic_bitmap bitmap,
-					blk_t bitno)
-{
-	if ((bitno < bitmap->start) || (bitno > bitmap->end)) {
-		ext2fs_warn_bitmap2(bitmap, EXT2FS_TEST_ERROR, bitno);
-		return 0;
-	}
-	return ext2fs_test_bit(bitno - bitmap->start, bitmap->bitmap);
-}
-
 _INLINE_ int ext2fs_mark_block_bitmap(ext2fs_block_bitmap bitmap,
 				       blk_t block)
 {
-	return ext2fs_mark_generic_bitmap((ext2fs_generic_bitmap)
-				       bitmap,
+	return ext2fs_mark_generic_bitmap((ext2fs_generic_bitmap) bitmap,
 					  block);
 }
 
@@ -460,197 +423,77 @@ _INLINE_ int ext2fs_test_inode_bitmap(ex
 _INLINE_ void ext2fs_fast_mark_block_bitmap(ext2fs_block_bitmap bitmap,
 					    blk_t block)
 {
-#ifdef EXT2FS_DEBUG_FAST_OPS
-	if ((block < bitmap->start) || (block > bitmap->end)) {
-		ext2fs_warn_bitmap(EXT2_ET_BAD_BLOCK_MARK, block,
-				   bitmap->description);
-		return;
-	}
-#endif	
-	ext2fs_fast_set_bit(block - bitmap->start, bitmap->bitmap);
+	ext2fs_mark_generic_bitmap((ext2fs_generic_bitmap) bitmap, block);
 }
 
 _INLINE_ void ext2fs_fast_unmark_block_bitmap(ext2fs_block_bitmap bitmap,
 					      blk_t block)
 {
-#ifdef EXT2FS_DEBUG_FAST_OPS
-	if ((block < bitmap->start) || (block > bitmap->end)) {
-		ext2fs_warn_bitmap(EXT2_ET_BAD_BLOCK_UNMARK,
-				   block, bitmap->description);
-		return;
-	}
-#endif
-	ext2fs_fast_clear_bit(block - bitmap->start, bitmap->bitmap);
+	ext2fs_unmark_generic_bitmap((ext2fs_generic_bitmap) bitmap, block);
 }
 
 _INLINE_ int ext2fs_fast_test_block_bitmap(ext2fs_block_bitmap bitmap,
 					    blk_t block)
 {
-#ifdef EXT2FS_DEBUG_FAST_OPS
-	if ((block < bitmap->start) || (block > bitmap->end)) {
-		ext2fs_warn_bitmap(EXT2_ET_BAD_BLOCK_TEST,
-				   block, bitmap->description);
-		return 0;
-	}
-#endif
-	return ext2fs_test_bit(block - bitmap->start, bitmap->bitmap);
+	return ext2fs_test_generic_bitmap((ext2fs_generic_bitmap) bitmap, 
+					  block);
 }
 
 _INLINE_ void ext2fs_fast_mark_inode_bitmap(ext2fs_inode_bitmap bitmap,
 					    ext2_ino_t inode)
 {
-#ifdef EXT2FS_DEBUG_FAST_OPS
-	if ((inode < bitmap->start) || (inode > bitmap->end)) {
-		ext2fs_warn_bitmap(EXT2_ET_BAD_INODE_MARK,
-				   inode, bitmap->description);
-		return;
-	}
-#endif
-	ext2fs_fast_set_bit(inode - bitmap->start, bitmap->bitmap);
+	ext2fs_mark_generic_bitmap((ext2fs_generic_bitmap) bitmap, inode);
 }
 
 _INLINE_ void ext2fs_fast_unmark_inode_bitmap(ext2fs_inode_bitmap bitmap,
 					      ext2_ino_t inode)
 {
-#ifdef EXT2FS_DEBUG_FAST_OPS
-	if ((inode < bitmap->start) || (inode > bitmap->end)) {
-		ext2fs_warn_bitmap(EXT2_ET_BAD_INODE_UNMARK,
-				   inode, bitmap->description);
-		return;
-	}
-#endif
-	ext2fs_fast_clear_bit(inode - bitmap->start, bitmap->bitmap);
+	ext2fs_unmark_generic_bitmap((ext2fs_generic_bitmap) bitmap, inode);
 }
 
 _INLINE_ int ext2fs_fast_test_inode_bitmap(ext2fs_inode_bitmap bitmap,
 					   ext2_ino_t inode)
 {
-#ifdef EXT2FS_DEBUG_FAST_OPS
-	if ((inode < bitmap->start) || (inode > bitmap->end)) {
-		ext2fs_warn_bitmap(EXT2_ET_BAD_INODE_TEST,
-				   inode, bitmap->description);
-		return 0;
-	}
-#endif
-	return ext2fs_test_bit(inode - bitmap->start, bitmap->bitmap);
+	return ext2fs_test_generic_bitmap((ext2fs_generic_bitmap) bitmap, 
+					  inode);
 }
 
 _INLINE_ blk_t ext2fs_get_block_bitmap_start(ext2fs_block_bitmap bitmap)
 {
-	return bitmap->start;
+	return ext2fs_get_generic_bitmap_start((ext2fs_generic_bitmap) bitmap);
 }
 
 _INLINE_ ext2_ino_t ext2fs_get_inode_bitmap_start(ext2fs_inode_bitmap bitmap)
 {
-	return bitmap->start;
+	return ext2fs_get_generic_bitmap_start((ext2fs_generic_bitmap) bitmap);
 }
 
 _INLINE_ blk_t ext2fs_get_block_bitmap_end(ext2fs_block_bitmap bitmap)
 {
-	return bitmap->end;
+	return ext2fs_get_generic_bitmap_end((ext2fs_generic_bitmap) bitmap);
 }
 
 _INLINE_ ext2_ino_t ext2fs_get_inode_bitmap_end(ext2fs_inode_bitmap bitmap)
 {
-	return bitmap->end;
-}
-
-_INLINE_ int ext2fs_test_block_bitmap_range(ext2fs_block_bitmap bitmap,
-					    blk_t block, int num)
-{
-	int	i;
-
-	if ((block < bitmap->start) || (block+num-1 > bitmap->end)) {
-		ext2fs_warn_bitmap(EXT2_ET_BAD_BLOCK_TEST,
-				   block, bitmap->description);
-		return 0;
-	}
-	for (i=0; i < num; i++) {
-		if (ext2fs_fast_test_block_bitmap(bitmap, block+i))
-			return 0;
-	}
-	return 1;
+	return ext2fs_get_generic_bitmap_end((ext2fs_generic_bitmap) bitmap);
 }
 
 _INLINE_ int ext2fs_fast_test_block_bitmap_range(ext2fs_block_bitmap bitmap,
 						 blk_t block, int num)
 {
-	int	i;
-
-#ifdef EXT2FS_DEBUG_FAST_OPS
-	if ((block < bitmap->start) || (block+num-1 > bitmap->end)) {
-		ext2fs_warn_bitmap(EXT2_ET_BAD_BLOCK_TEST,
-				   block, bitmap->description);
-		return 0;
-	}
-#endif
-	for (i=0; i < num; i++) {
-		if (ext2fs_fast_test_block_bitmap(bitmap, block+i))
-			return 0;
-	}
-	return 1;
-}
-
-_INLINE_ void ext2fs_mark_block_bitmap_range(ext2fs_block_bitmap bitmap,
-					     blk_t block, int num)
-{
-	int	i;
-	
-	if ((block < bitmap->start) || (block+num-1 > bitmap->end)) {
-		ext2fs_warn_bitmap(EXT2_ET_BAD_BLOCK_MARK, block,
-				   bitmap->description);
-		return;
-	}
-	for (i=0; i < num; i++)
-		ext2fs_fast_set_bit(block + i - bitmap->start, bitmap->bitmap);
+	return ext2fs_test_block_bitmap_range(bitmap, block, num);
 }
 
 _INLINE_ void ext2fs_fast_mark_block_bitmap_range(ext2fs_block_bitmap bitmap,
 						  blk_t block, int num)
 {
-	int	i;
-	
-#ifdef EXT2FS_DEBUG_FAST_OPS
-	if ((block < bitmap->start) || (block+num-1 > bitmap->end)) {
-		ext2fs_warn_bitmap(EXT2_ET_BAD_BLOCK_MARK, block,
-				   bitmap->description);
-		return;
-	}
-#endif	
-	for (i=0; i < num; i++)
-		ext2fs_fast_set_bit(block + i - bitmap->start, bitmap->bitmap);
-}
-
-_INLINE_ void ext2fs_unmark_block_bitmap_range(ext2fs_block_bitmap bitmap,
-					       blk_t block, int num)
-{
-	int	i;
-	
-	if ((block < bitmap->start) || (block+num-1 > bitmap->end)) {
-		ext2fs_warn_bitmap(EXT2_ET_BAD_BLOCK_UNMARK, block,
-				   bitmap->description);
-		return;
-	}
-	for (i=0; i < num; i++)
-		ext2fs_fast_clear_bit(block + i - bitmap->start, 
-				      bitmap->bitmap);
+	ext2fs_mark_block_bitmap_range(bitmap, block, num);
 }
 
 _INLINE_ void ext2fs_fast_unmark_block_bitmap_range(ext2fs_block_bitmap bitmap,
 						    blk_t block, int num)
 {
-	int	i;
-	
-#ifdef EXT2FS_DEBUG_FAST_OPS
-	if ((block < bitmap->start) || (block+num-1 > bitmap->end)) {
-		ext2fs_warn_bitmap(EXT2_ET_BAD_BLOCK_UNMARK, block,
-				   bitmap->description);
-		return;
-	}
-#endif	
-	for (i=0; i < num; i++)
-		ext2fs_fast_clear_bit(block + i - bitmap->start, 
-				      bitmap->bitmap);
+	ext2fs_unmark_block_bitmap_range(bitmap, block, num);
 }
 #undef _INLINE_
 #endif
diff -Nurp e2fsprogs-1.40.8/lib/ext2fs/block.c e2fsprogs/lib/ext2fs/block.c
--- e2fsprogs-1.40.8/lib/ext2fs/block.c	2008-03-13 23:20:46.000000000 +0100
+++ e2fsprogs/lib/ext2fs/block.c	2008-03-29 01:20:43.000000000 +0100
@@ -36,6 +36,26 @@ struct block_context {
 	void	*priv_data;
 };
 
+#define check_for_ro_violation_return(ctx, ret)				\
+	do {								\
+		if (((ctx)->flags & BLOCK_FLAG_READ_ONLY) &&		\
+		    ((ret) & BLOCK_CHANGED)) {				\
+			(ctx)->errcode = EXT2_ET_RO_BLOCK_ITERATE;	\
+			ret |= BLOCK_ABORT | BLOCK_ERROR;		\
+			return ret;					\
+		}							\
+	} while (0)
+
+#define check_for_ro_violation_goto(ctx, ret, label)			\
+	do {								\
+		if (((ctx)->flags & BLOCK_FLAG_READ_ONLY) &&		\
+		    ((ret) & BLOCK_CHANGED)) {				\
+			(ctx)->errcode = EXT2_ET_RO_BLOCK_ITERATE;	\
+			ret |= BLOCK_ABORT | BLOCK_ERROR;		\
+			goto label;					\
+		}							\
+	} while (0)
+
 static int block_iterate_ind(blk_t *ind_block, blk_t ref_block,
 			     int ref_offset, struct block_context *ctx)
 {
@@ -49,6 +69,7 @@ static int block_iterate_ind(blk_t *ind_
 		ret = (*ctx->func)(ctx->fs, ind_block,
 				   BLOCK_COUNT_IND, ref_block,
 				   ref_offset, ctx->priv_data);
+	check_for_ro_violation_return(ctx, ret);
 	if (!*ind_block || (ret & BLOCK_ABORT)) {
 		ctx->bcount += limit;
 		return ret;
@@ -95,6 +116,7 @@ static int block_iterate_ind(blk_t *ind_
 			offset += sizeof(blk_t);
 		}
 	}
+	check_for_ro_violation_return(ctx, changed);
 	if (changed & BLOCK_CHANGED) {
 		ctx->errcode = ext2fs_write_ind_block(ctx->fs, *ind_block,
 						      ctx->ind_buf);
@@ -107,6 +129,7 @@ static int block_iterate_ind(blk_t *ind_
 		ret |= (*ctx->func)(ctx->fs, ind_block,
 				    BLOCK_COUNT_IND, ref_block,
 				    ref_offset, ctx->priv_data);
+	check_for_ro_violation_return(ctx, ret);
 	return ret;
 }
 	
@@ -123,6 +146,7 @@ static int block_iterate_dind(blk_t *din
 		ret = (*ctx->func)(ctx->fs, dind_block,
 				   BLOCK_COUNT_DIND, ref_block,
 				   ref_offset, ctx->priv_data);
+	check_for_ro_violation_return(ctx, ret);
 	if (!*dind_block || (ret & BLOCK_ABORT)) {
 		ctx->bcount += limit*limit;
 		return ret;
@@ -171,6 +195,7 @@ static int block_iterate_dind(blk_t *din
 			offset += sizeof(blk_t);
 		}
 	}
+	check_for_ro_violation_return(ctx, changed);
 	if (changed & BLOCK_CHANGED) {
 		ctx->errcode = ext2fs_write_ind_block(ctx->fs, *dind_block,
 						      ctx->dind_buf);
@@ -183,6 +208,7 @@ static int block_iterate_dind(blk_t *din
 		ret |= (*ctx->func)(ctx->fs, dind_block,
 				    BLOCK_COUNT_DIND, ref_block,
 				    ref_offset, ctx->priv_data);
+	check_for_ro_violation_return(ctx, ret);
 	return ret;
 }
 	
@@ -199,6 +225,7 @@ static int block_iterate_tind(blk_t *tin
 		ret = (*ctx->func)(ctx->fs, tind_block,
 				   BLOCK_COUNT_TIND, ref_block,
 				   ref_offset, ctx->priv_data);
+	check_for_ro_violation_return(ctx, ret);
 	if (!*tind_block || (ret & BLOCK_ABORT)) {
 		ctx->bcount += limit*limit*limit;
 		return ret;
@@ -247,6 +274,7 @@ static int block_iterate_tind(blk_t *tin
 			offset += sizeof(blk_t);
 		}
 	}
+	check_for_ro_violation_return(ctx, changed);
 	if (changed & BLOCK_CHANGED) {
 		ctx->errcode = ext2fs_write_ind_block(ctx->fs, *tind_block,
 						      ctx->tind_buf);
@@ -259,7 +287,7 @@ static int block_iterate_tind(blk_t *tin
 		ret |= (*ctx->func)(ctx->fs, tind_block,
 				    BLOCK_COUNT_TIND, ref_block,
 				    ref_offset, ctx->priv_data);
-	
+	check_for_ro_violation_return(ctx, ret);
 	return ret;
 }
 	
@@ -276,9 +304,7 @@ errcode_t ext2fs_block_iterate2(ext2_fil
 				void *priv_data)
 {
 	int	i;
-	int	got_inode = 0;
 	int	ret = 0;
-	blk_t	blocks[EXT2_N_BLOCKS];	/* directory data blocks */
 	struct ext2_inode inode;
 	errcode_t	retval;
 	struct block_context ctx;
@@ -286,23 +312,19 @@ errcode_t ext2fs_block_iterate2(ext2_fil
 
 	EXT2_CHECK_MAGIC(fs, EXT2_ET_MAGIC_EXT2FS_FILSYS);
 
+	ctx.errcode = ext2fs_read_inode(fs, ino, &inode);
+	if (ctx.errcode)
+		return ctx.errcode;
+
 	/*
 	 * Check to see if we need to limit large files
 	 */
 	if (flags & BLOCK_FLAG_NO_LARGE) {
-		ctx.errcode = ext2fs_read_inode(fs, ino, &inode);
-		if (ctx.errcode)
-			return ctx.errcode;
-		got_inode = 1;
 		if (!LINUX_S_ISDIR(inode.i_mode) &&
 		    (inode.i_size_high != 0))
 			return EXT2_ET_FILE_TOO_BIG;
 	}
 
-	retval = ext2fs_get_blocks(fs, ino, blocks);
-	if (retval)
-		return retval;
-
 	limit = fs->blocksize >> 2;
 
 	ctx.fs = fs;
@@ -325,10 +347,6 @@ errcode_t ext2fs_block_iterate2(ext2_fil
 	 */
 	if ((fs->super->s_creator_os == EXT2_OS_HURD) &&
 	    !(flags & BLOCK_FLAG_DATA_ONLY)) {
-		ctx.errcode = ext2fs_read_inode(fs, ino, &inode);
-		if (ctx.errcode)
-			goto abort_exit;
-		got_inode = 1;
 		if (inode.osd1.hurd1.h_i_translator) {
 			ret |= (*ctx.func)(fs,
 					   &inode.osd1.hurd1.h_i_translator,
@@ -336,36 +354,98 @@ errcode_t ext2fs_block_iterate2(ext2_fil
 					   0, 0, priv_data);
 			if (ret & BLOCK_ABORT)
 				goto abort_exit;
+			check_for_ro_violation_goto(&ctx, ret, abort_exit);
 		}
 	}
 	
+	if (inode.i_flags & EXT4_EXTENTS_FL) {
+		ext2_extent_handle_t	handle;
+		struct ext2fs_extent	extent;
+		e2_blkcnt_t		blockcnt;
+		blk_t			blk;
+		int			op = EXT2_EXTENT_ROOT;
+		unsigned int		j;
+
+		if (!(flags & BLOCK_FLAG_READ_ONLY))
+			return EXT2_ET_EXTENT_NOT_SUPPORTED;
+
+		ctx.errcode = ext2fs_extent_open(fs, ino, &handle);
+		if (ctx.errcode)
+			goto abort_exit;
+
+		while (1) {
+			ctx.errcode = ext2fs_extent_get(handle, op, &extent);
+			if (ctx.errcode) {
+				if (ctx.errcode == EXT2_ET_EXTENT_NO_NEXT)
+					ctx.errcode = 0;
+				break;
+			}
+
+			op = EXT2_EXTENT_NEXT;
+			blk = extent.e_pblk;
+			if (!(extent.e_flags & EXT2_EXTENT_FLAGS_LEAF) &&
+			    !(ctx.flags & BLOCK_FLAG_DATA_ONLY) &&
+			    ((!(extent.e_flags &
+				EXT2_EXTENT_FLAGS_SECOND_VISIT) &&
+			      !(ctx.flags & BLOCK_FLAG_DEPTH_TRAVERSE)) ||
+			     ((extent.e_flags &
+			       EXT2_EXTENT_FLAGS_SECOND_VISIT) &&
+			      (ctx.flags & BLOCK_FLAG_DEPTH_TRAVERSE)))) {
+				ret |= (*ctx.func)(fs, &blk,
+						   -1, 0, 0, priv_data);
+				check_for_ro_violation_goto(&ctx, ret,
+							    extent_errout);
+				continue;
+			}
+			for (blockcnt = extent.e_lblk, j = 0;
+			     j < extent.e_len;
+			     blk++, blockcnt++, j++) {
+				ret |= (*ctx.func)(fs, &blk,
+						   blockcnt,
+						   0, 0, priv_data);
+				check_for_ro_violation_goto(&ctx, ret,
+							    extent_errout);
+				if (ret & BLOCK_ABORT) {
+					ext2fs_extent_free(handle);
+					goto abort_exit;
+				}
+			}
+		}
+
+	extent_errout:
+		ext2fs_extent_free(handle);
+		ret |= BLOCK_ERROR | BLOCK_ABORT;
+		goto abort_exit;
+	}
+
 	/*
 	 * Iterate over normal data blocks
 	 */
 	for (i = 0; i < EXT2_NDIR_BLOCKS ; i++, ctx.bcount++) {
-		if (blocks[i] || (flags & BLOCK_FLAG_APPEND)) {
-			ret |= (*ctx.func)(fs, &blocks[i],
+		if (inode.i_block[i] || (flags & BLOCK_FLAG_APPEND)) {
+			ret |= (*ctx.func)(fs, &inode.i_block[i],
 					    ctx.bcount, 0, i, priv_data);
 			if (ret & BLOCK_ABORT)
 				goto abort_exit;
 		}
 	}
-	if (*(blocks + EXT2_IND_BLOCK) || (flags & BLOCK_FLAG_APPEND)) {
-		ret |= block_iterate_ind(blocks + EXT2_IND_BLOCK,
+	check_for_ro_violation_goto(&ctx, ret, abort_exit);
+	if (inode.i_block[EXT2_IND_BLOCK] || (flags & BLOCK_FLAG_APPEND)) {
+		ret |= block_iterate_ind(&inode.i_block[EXT2_IND_BLOCK],
 					 0, EXT2_IND_BLOCK, &ctx);
 		if (ret & BLOCK_ABORT)
 			goto abort_exit;
 	} else
 		ctx.bcount += limit;
-	if (*(blocks + EXT2_DIND_BLOCK) || (flags & BLOCK_FLAG_APPEND)) {
-		ret |= block_iterate_dind(blocks + EXT2_DIND_BLOCK,
+	if (inode.i_block[EXT2_DIND_BLOCK] || (flags & BLOCK_FLAG_APPEND)) {
+		ret |= block_iterate_dind(&inode.i_block[EXT2_DIND_BLOCK],
 					  0, EXT2_DIND_BLOCK, &ctx);
 		if (ret & BLOCK_ABORT)
 			goto abort_exit;
 	} else
 		ctx.bcount += limit * limit;
-	if (*(blocks + EXT2_TIND_BLOCK) || (flags & BLOCK_FLAG_APPEND)) {
-		ret |= block_iterate_tind(blocks + EXT2_TIND_BLOCK,
+	if (inode.i_block[EXT2_TIND_BLOCK] || (flags & BLOCK_FLAG_APPEND)) {
+		ret |= block_iterate_tind(&inode.i_block[EXT2_TIND_BLOCK],
 					  0, EXT2_TIND_BLOCK, &ctx);
 		if (ret & BLOCK_ABORT)
 			goto abort_exit;
@@ -373,13 +453,6 @@ errcode_t ext2fs_block_iterate2(ext2_fil
 
 abort_exit:
 	if (ret & BLOCK_CHANGED) {
-		if (!got_inode) {
-			retval = ext2fs_read_inode(fs, ino, &inode);
-			if (retval)
-				return retval;
-		}
-		for (i=0; i < EXT2_N_BLOCKS; i++)
-			inode.i_block[i] = blocks[i];
 		retval = ext2fs_write_inode(fs, ino, &inode);
 		if (retval)
 			return retval;
diff -Nurp e2fsprogs-1.40.8/lib/ext2fs/bmap.c e2fsprogs/lib/ext2fs/bmap.c
--- e2fsprogs-1.40.8/lib/ext2fs/bmap.c	2008-03-13 23:20:46.000000000 +0100
+++ e2fsprogs/lib/ext2fs/bmap.c	2008-03-29 01:20:43.000000000 +0100
@@ -14,6 +14,7 @@
 #if HAVE_UNISTD_H
 #include <unistd.h>
 #endif
+#include <errno.h>
 
 #include "ext2_fs.h"
 #include "ext2fs.h"
@@ -51,10 +52,8 @@ static _BMAP_INLINE_ errcode_t block_ind
 
 	if (flags & BMAP_SET) {
 		b = *ret_blk;
-#ifdef EXT2FS_ENABLE_SWAPFS
-		if ((fs->flags & EXT2_FLAG_SWAP_BYTES) ||
-		    (fs->flags & EXT2_FLAG_SWAP_BYTES_WRITE))
-			b = ext2fs_swab32(b);
+#ifdef WORDS_BIGENDIAN
+		b = ext2fs_swab32(b);
 #endif
 		((blk_t *) block_buf)[nr] = b;
 		return io_channel_write_blk(fs->io, ind, 1, block_buf);
@@ -62,10 +61,8 @@ static _BMAP_INLINE_ errcode_t block_ind
 
 	b = ((blk_t *) block_buf)[nr];
 
-#ifdef EXT2FS_ENABLE_SWAPFS
-	if ((fs->flags & EXT2_FLAG_SWAP_BYTES) ||
-	    (fs->flags & EXT2_FLAG_SWAP_BYTES_READ))
-		b = ext2fs_swab32(b);
+#ifdef WORDS_BIGENDIAN
+	b = ext2fs_swab32(b);
 #endif
 
 	if (!b && (flags & BMAP_ALLOC)) {
@@ -75,13 +72,11 @@ static _BMAP_INLINE_ errcode_t block_ind
 		if (retval)
 			return retval;
 
-#ifdef EXT2FS_ENABLE_SWAPFS
-		if ((fs->flags & EXT2_FLAG_SWAP_BYTES) ||
-		    (fs->flags & EXT2_FLAG_SWAP_BYTES_WRITE))
-			((blk_t *) block_buf)[nr] = ext2fs_swab32(b);
-		else
+#ifdef WORDS_BIGENDIAN
+		((blk_t *) block_buf)[nr] = ext2fs_swab32(b);
+#else
+		((blk_t *) block_buf)[nr] = b;
 #endif
-			((blk_t *) block_buf)[nr] = b;
 
 		retval = io_channel_write_blk(fs->io, ind, 1, block_buf);
 		if (retval)
@@ -134,13 +129,14 @@ static _BMAP_INLINE_ errcode_t block_tin
 	return retval;
 }
 
-errcode_t ext2fs_bmap(ext2_filsys fs, ext2_ino_t ino, struct ext2_inode *inode,
-		      char *block_buf, int bmap_flags, blk_t block,
-		      blk_t *phys_blk)
+errcode_t ext2fs_bmap2(ext2_filsys fs, ext2_ino_t ino, struct ext2_inode *inode,
+		       char *block_buf, int bmap_flags, blk64_t block,
+		       int *ret_flags, blk64_t *phys_blk)
 {
 	struct ext2_inode inode_buf;
+	ext2_extent_handle_t handle = 0;
 	blk_t addr_per_block;
-	blk_t	b;
+	blk_t	b, blk32;
 	char	*buf = 0;
 	errcode_t	retval = 0;
 	int		blocks_alloc = 0, inode_dirty = 0;
@@ -148,6 +144,9 @@ errcode_t ext2fs_bmap(ext2_filsys fs, ex
 	if (!(bmap_flags & BMAP_SET))
 		*phys_blk = 0;
 
+	if (ret_flags)
+		*ret_flags = 0;
+
 	/* Read inode structure if necessary */
 	if (!inode) {
 		retval = ext2fs_read_inode(fs, ino, &inode_buf);
@@ -157,6 +156,37 @@ errcode_t ext2fs_bmap(ext2_filsys fs, ex
 	}
 	addr_per_block = (blk_t) fs->blocksize >> 2;
 
+	if (inode->i_flags & EXT4_EXTENTS_FL) {
+		struct ext2fs_extent	extent;
+		unsigned int		offset;
+
+		if (bmap_flags & BMAP_SET) {
+			retval = EXT2_ET_EXTENT_NOT_SUPPORTED;
+			goto done;
+		}
+		retval = ext2fs_extent_open(fs, ino, &handle);
+		if (retval)
+			goto done;
+		retval = ext2fs_extent_goto(handle, block);
+		if (retval) {
+			/* If the extent is not found, return phys_blk = 0 */
+			if (retval == EXT2_ET_EXTENT_NOT_FOUND)
+				retval = 0;
+			goto done;
+		}
+		retval = ext2fs_extent_get(handle, EXT2_EXTENT_CURRENT, &extent);
+		if (retval)
+			goto done;
+		offset = block - extent.e_lblk;
+		if (block >= extent.e_lblk && (offset <= extent.e_len)) {
+			*phys_blk = extent.e_pblk + offset;
+			if (ret_flags && extent.e_flags & EXT2_EXTENT_FLAGS_UNINIT)
+				*ret_flags |= BMAP_RET_UNINIT;
+		}
+		retval = 0;
+		goto done;
+	}
+
 	if (!block_buf) {
 		retval = ext2fs_get_array(2, fs->blocksize, &buf);
 		if (retval)
@@ -167,10 +197,8 @@ errcode_t ext2fs_bmap(ext2_filsys fs, ex
 	if (block < EXT2_NDIR_BLOCKS) {
 		if (bmap_flags & BMAP_SET) {
 			b = *phys_blk;
-#ifdef EXT2FS_ENABLE_SWAPFS
-			if ((fs->flags & EXT2_FLAG_SWAP_BYTES) ||
-			    (fs->flags & EXT2_FLAG_SWAP_BYTES_READ))
-				b = ext2fs_swab32(b);
+#ifdef WORDS_BIGENDIAN
+			b = ext2fs_swab32(b);
 #endif
 			inode_bmap(inode, block) = b;
 			inode_dirty++;
@@ -193,6 +221,7 @@ errcode_t ext2fs_bmap(ext2_filsys fs, ex
 	
 	/* Indirect block */
 	block -= EXT2_NDIR_BLOCKS;
+	blk32 = *phys_blk;
 	if (block < addr_per_block) {
 		b = inode_bmap(inode, EXT2_IND_BLOCK);
 		if (!b) {
@@ -210,7 +239,9 @@ errcode_t ext2fs_bmap(ext2_filsys fs, ex
 			blocks_alloc++;
 		}
 		retval = block_ind_bmap(fs, bmap_flags, b, block_buf, 
-					&blocks_alloc, block, phys_blk);
+					&blocks_alloc, block, &blk32);
+		if (retval == 0)
+			*phys_blk = blk32;
 		goto done;
 	}
 	
@@ -233,7 +264,9 @@ errcode_t ext2fs_bmap(ext2_filsys fs, ex
 			blocks_alloc++;
 		}
 		retval = block_dind_bmap(fs, bmap_flags, b, block_buf, 
-					 &blocks_alloc, block, phys_blk);
+					 &blocks_alloc, block, &blk32);
+		if (retval == 0)
+			*phys_blk = blk32;
 		goto done;
 	}
 
@@ -255,10 +288,14 @@ errcode_t ext2fs_bmap(ext2_filsys fs, ex
 		blocks_alloc++;
 	}
 	retval = block_tind_bmap(fs, bmap_flags, b, block_buf, 
-				 &blocks_alloc, block, phys_blk);
+				 &blocks_alloc, block, &blk32);
+	if (retval == 0)
+		*phys_blk = blk32;
 done:
 	if (buf)
 		ext2fs_free_mem(&buf);
+	if (handle)
+		ext2fs_extent_free(handle);
 	if ((retval == 0) && (blocks_alloc || inode_dirty)) {
 		inode->i_blocks += (blocks_alloc * fs->blocksize) / 512;
 		retval = ext2fs_write_inode(fs, ino, inode);
@@ -266,5 +303,19 @@ done:
 	return retval;
 }
 
+errcode_t ext2fs_bmap(ext2_filsys fs, ext2_ino_t ino, struct ext2_inode *inode,
+		      char *block_buf, int bmap_flags, blk_t block,
+		      blk_t *phys_blk)
+{
+	errcode_t ret;
+	blk64_t	ret_blk;
 
-
+	ret = ext2fs_bmap2(fs, ino, inode, block_buf, bmap_flags, block,
+			    0, &ret_blk);
+	if (ret)
+		return ret;
+	if (ret_blk >= ((long long) 1 << 32))
+		return EOVERFLOW;
+	*phys_blk = ret_blk;
+	return 0;
+}
diff -Nurp e2fsprogs-1.40.8/lib/ext2fs/check_desc.c e2fsprogs/lib/ext2fs/check_desc.c
--- e2fsprogs-1.40.8/lib/ext2fs/check_desc.c	2008-03-13 23:20:46.000000000 +0100
+++ e2fsprogs/lib/ext2fs/check_desc.c	2008-03-29 01:20:43.000000000 +0100
@@ -33,13 +33,16 @@ errcode_t ext2fs_check_desc(ext2_filsys 
 {
 	dgrp_t i;
 	blk_t first_block = fs->super->s_first_data_block;
-	blk_t last_block;
+	blk_t last_block = fs->super->s_blocks_count-1;
 
 	EXT2_CHECK_MAGIC(fs, EXT2_ET_MAGIC_EXT2FS_FILSYS);
 
 	for (i = 0; i < fs->group_desc_count; i++) {
-		first_block = ext2fs_group_first_block(fs, i);
-		last_block = ext2fs_group_last_block(fs, i);
+		if (!EXT2_HAS_INCOMPAT_FEATURE(fs->super,
+					       EXT4_FEATURE_INCOMPAT_FLEX_BG)) {
+			first_block = ext2fs_group_first_block(fs, i);
+			last_block = ext2fs_group_last_block(fs, i);
+		}
 
 		/*
 		 * Check to make sure block bitmap for group is
diff -Nurp e2fsprogs-1.40.8/lib/ext2fs/closefs.c e2fsprogs/lib/ext2fs/closefs.c
--- e2fsprogs-1.40.8/lib/ext2fs/closefs.c	2008-03-13 23:20:46.000000000 +0100
+++ e2fsprogs/lib/ext2fs/closefs.c	2008-03-29 01:20:43.000000000 +0100
@@ -54,11 +54,10 @@ int ext2fs_super_and_bgd_loc(ext2_filsys
 {
 	blk_t	group_block, super_blk = 0, old_desc_blk = 0, new_desc_blk = 0;
 	unsigned int meta_bg, meta_bg_size;
-	int	numblocks, has_super;
-	int	old_desc_blocks;
+	blk_t	numblocks, old_desc_blocks;
+	int	has_super;
 
-	group_block = fs->super->s_first_data_block +
-		(group * fs->super->s_blocks_per_group);
+	group_block = ext2fs_group_first_block(fs, group);
 
 	if (fs->super->s_feature_incompat & EXT2_FEATURE_INCOMPAT_META_BG)
 		old_desc_blocks = fs->super->s_first_meta_bg;
@@ -81,7 +80,7 @@ int ext2fs_super_and_bgd_loc(ext2_filsys
 		super_blk = group_block;
 		numblocks--;
 	}
-	meta_bg_size = (fs->blocksize / sizeof (struct ext2_group_desc));
+	meta_bg_size = EXT2_DESC_PER_BLOCK(fs->super);
 	meta_bg = group / meta_bg_size;
 
 	if (!(fs->super->s_feature_incompat & EXT2_FEATURE_INCOMPAT_META_BG) ||
@@ -191,12 +190,11 @@ static errcode_t write_backup_super(ext2
 	
 	if (sgrp > ((1 << 16) - 1))
 		sgrp = (1 << 16) - 1;
-#ifdef EXT2FS_ENABLE_SWAPFS
-	if (fs->flags & EXT2_FLAG_SWAP_BYTES)
-		super_shadow->s_block_group_nr = ext2fs_swab16(sgrp);
-	else
+#ifdef WORDS_BIGENDIAN
+	super_shadow->s_block_group_nr = ext2fs_swab16(sgrp);
+#else
+	fs->super->s_block_group_nr = sgrp;
 #endif
-		fs->super->s_block_group_nr = sgrp;
 
 	return io_channel_write_blk(fs->io, group_block, -SUPERBLOCK_SIZE, 
 				    super_shadow);
@@ -205,13 +203,16 @@ static errcode_t write_backup_super(ext2
 
 errcode_t ext2fs_flush(ext2_filsys fs)
 {
-	dgrp_t		i,j;
+	dgrp_t		i;
 	errcode_t	retval;
 	unsigned long	fs_state;
 	__u32		feature_incompat;
 	struct ext2_super_block *super_shadow = 0;
 	struct ext2_group_desc *group_shadow = 0;
+#ifdef WORDS_BIGENDIAN
 	struct ext2_group_desc *s, *t;
+	dgrp_t		j;
+#endif
 	char	*group_ptr;
 	int	old_desc_blocks;
 	
@@ -222,28 +223,23 @@ errcode_t ext2fs_flush(ext2_filsys fs)
 
 	fs->super->s_wtime = fs->now ? fs->now : time(NULL);
 	fs->super->s_block_group_nr = 0;
-#ifdef EXT2FS_ENABLE_SWAPFS
-	if (fs->flags & EXT2_FLAG_SWAP_BYTES) {
-		retval = EXT2_ET_NO_MEMORY;
-		retval = ext2fs_get_mem(SUPERBLOCK_SIZE, &super_shadow);
-		if (retval)
-			goto errout;
-		retval = ext2fs_get_array(fs->blocksize, fs->desc_blocks,
-					&group_shadow);
-		if (retval)
-			goto errout;
-		memset(group_shadow, 0, (size_t) fs->blocksize *
-		       fs->desc_blocks);
-
-		/* swap the group descriptors */
-		for (j=0, s=fs->group_desc, t=group_shadow;
-		     j < fs->group_desc_count; j++, t++, s++) {
-			*t = *s;
-			ext2fs_swap_group_desc(t);
-		}
-	} else {
-		super_shadow = fs->super;
-		group_shadow = fs->group_desc;
+#ifdef WORDS_BIGENDIAN
+	retval = EXT2_ET_NO_MEMORY;
+	retval = ext2fs_get_mem(SUPERBLOCK_SIZE, &super_shadow);
+	if (retval)
+		goto errout;
+	retval = ext2fs_get_array(fs->desc_blocks, fs->blocksize, 
+				  &group_shadow);
+	if (retval)
+		goto errout;
+	memset(group_shadow, 0, (size_t) fs->blocksize *
+	       fs->desc_blocks);
+	
+	/* swap the group descriptors */
+	for (j=0, s=fs->group_desc, t=group_shadow;
+	     j < fs->group_desc_count; j++, t++, s++) {
+		*t = *s;
+		ext2fs_swap_group_desc(t);
 	}
 #else
 	super_shadow = fs->super;
@@ -257,11 +253,9 @@ errcode_t ext2fs_flush(ext2_filsys fs)
 	 */
 	fs->super->s_state &= ~EXT2_VALID_FS;
 	fs->super->s_feature_incompat &= ~EXT3_FEATURE_INCOMPAT_RECOVER;
-#ifdef EXT2FS_ENABLE_SWAPFS
-	if (fs->flags & EXT2_FLAG_SWAP_BYTES) {
-		*super_shadow = *fs->super;
-		ext2fs_swap_super(super_shadow);
-	}
+#ifdef WORDS_BIGENDIAN
+	*super_shadow = *fs->super;
+	ext2fs_swap_super(super_shadow);
 #endif
 
 	/*
@@ -336,11 +330,9 @@ write_primary_superblock_only:
 	fs->super->s_block_group_nr = 0;
 	fs->super->s_state = fs_state;
 	fs->super->s_feature_incompat = feature_incompat;
-#ifdef EXT2FS_ENABLE_SWAPFS
-	if (fs->flags & EXT2_FLAG_SWAP_BYTES) {
-		*super_shadow = *fs->super;
-		ext2fs_swap_super(super_shadow);
-	}
+#ifdef WORDS_BIGENDIAN
+	*super_shadow = *fs->super;
+	ext2fs_swap_super(super_shadow);
 #endif
 
 	retval = io_channel_flush(fs->io);
@@ -353,12 +345,12 @@ write_primary_superblock_only:
 	retval = io_channel_flush(fs->io);
 errout:
 	fs->super->s_state = fs_state;
-	if (fs->flags & EXT2_FLAG_SWAP_BYTES) {
-		if (super_shadow)
-			ext2fs_free_mem(&super_shadow);
-		if (group_shadow)
-			ext2fs_free_mem(&group_shadow);
-	}
+#ifdef WORDS_BIGENDIAN
+	if (super_shadow)
+		ext2fs_free_mem(&super_shadow);
+	if (group_shadow)
+		ext2fs_free_mem(&group_shadow);
+#endif
 	return retval;
 }
 
diff -Nurp e2fsprogs-1.40.8/lib/ext2fs/cmp_bitmaps.c e2fsprogs/lib/ext2fs/cmp_bitmaps.c
--- e2fsprogs-1.40.8/lib/ext2fs/cmp_bitmaps.c	2008-03-13 23:20:46.000000000 +0100
+++ e2fsprogs/lib/ext2fs/cmp_bitmaps.c	1970-01-01 01:00:00.000000000 +0100
@@ -1,72 +0,0 @@
-/*
- * cmp_bitmaps.c --- routines to compare inode and block bitmaps.
- *
- * Copyright (C) 1995 Theodore Ts'o.
- *
- * %Begin-Header%
- * This file may be redistributed under the terms of the GNU Public
- * License.
- * %End-Header%
- */
-
-#include <stdio.h>
-#include <string.h>
-#if HAVE_UNISTD_H
-#include <unistd.h>
-#endif
-#include <fcntl.h>
-#include <time.h>
-#if HAVE_SYS_STAT_H
-#include <sys/stat.h>
-#endif
-#if HAVE_SYS_TYPES_H
-#include <sys/types.h>
-#endif
-
-#include "ext2_fs.h"
-#include "ext2fs.h"
-
-errcode_t ext2fs_compare_block_bitmap(ext2fs_block_bitmap bm1,
-				      ext2fs_block_bitmap bm2)
-{
-	blk_t	i;
-	
-	EXT2_CHECK_MAGIC(bm1, EXT2_ET_MAGIC_BLOCK_BITMAP);
-	EXT2_CHECK_MAGIC(bm2, EXT2_ET_MAGIC_BLOCK_BITMAP);
-
-	if ((bm1->start != bm2->start) ||
-	    (bm1->end != bm2->end) ||
-	    (memcmp(bm1->bitmap, bm2->bitmap,
-		    (size_t) (bm1->end - bm1->start)/8)))
-		return EXT2_ET_NEQ_BLOCK_BITMAP;
-
-	for (i = bm1->end - ((bm1->end - bm1->start) % 8); i <= bm1->end; i++)
-		if (ext2fs_fast_test_block_bitmap(bm1, i) !=
-		    ext2fs_fast_test_block_bitmap(bm2, i))
-			return EXT2_ET_NEQ_BLOCK_BITMAP;
-
-	return 0;
-}
-
-errcode_t ext2fs_compare_inode_bitmap(ext2fs_inode_bitmap bm1,
-				      ext2fs_inode_bitmap bm2)
-{
-	ext2_ino_t	i;
-	
-	EXT2_CHECK_MAGIC(bm1, EXT2_ET_MAGIC_INODE_BITMAP);
-	EXT2_CHECK_MAGIC(bm2, EXT2_ET_MAGIC_INODE_BITMAP);
-
-	if ((bm1->start != bm2->start) ||
-	    (bm1->end != bm2->end) ||
-	    (memcmp(bm1->bitmap, bm2->bitmap,
-		    (size_t) (bm1->end - bm1->start)/8)))
-		return EXT2_ET_NEQ_INODE_BITMAP;
-
-	for (i = bm1->end - ((bm1->end - bm1->start) % 8); i <= bm1->end; i++)
-		if (ext2fs_fast_test_inode_bitmap(bm1, i) !=
-		    ext2fs_fast_test_inode_bitmap(bm2, i))
-			return EXT2_ET_NEQ_INODE_BITMAP;
-
-	return 0;
-}
-
diff -Nurp e2fsprogs-1.40.8/lib/ext2fs/crc16.c e2fsprogs/lib/ext2fs/crc16.c
--- e2fsprogs-1.40.8/lib/ext2fs/crc16.c	1970-01-01 01:00:00.000000000 +0100
+++ e2fsprogs/lib/ext2fs/crc16.c	2008-03-29 01:20:43.000000000 +0100
@@ -0,0 +1,61 @@
+/*
+ *      crc16.c
+ *
+ * This source code is licensed under the GNU General Public License,
+ * Version 2. See the file COPYING for more details.
+ */
+
+#include "crc16.h"
+
+/** CRC table for the CRC-16. The poly is 0x8005 (x16 + x15 + x2 + 1) */
+__u16 const crc16_table[256] = {
+	0x0000, 0xC0C1, 0xC181, 0x0140, 0xC301, 0x03C0, 0x0280, 0xC241,
+	0xC601, 0x06C0, 0x0780, 0xC741, 0x0500, 0xC5C1, 0xC481, 0x0440,
+	0xCC01, 0x0CC0, 0x0D80, 0xCD41, 0x0F00, 0xCFC1, 0xCE81, 0x0E40,
+	0x0A00, 0xCAC1, 0xCB81, 0x0B40, 0xC901, 0x09C0, 0x0880, 0xC841,
+	0xD801, 0x18C0, 0x1980, 0xD941, 0x1B00, 0xDBC1, 0xDA81, 0x1A40,
+	0x1E00, 0xDEC1, 0xDF81, 0x1F40, 0xDD01, 0x1DC0, 0x1C80, 0xDC41,
+	0x1400, 0xD4C1, 0xD581, 0x1540, 0xD701, 0x17C0, 0x1680, 0xD641,
+	0xD201, 0x12C0, 0x1380, 0xD341, 0x1100, 0xD1C1, 0xD081, 0x1040,
+	0xF001, 0x30C0, 0x3180, 0xF141, 0x3300, 0xF3C1, 0xF281, 0x3240,
+	0x3600, 0xF6C1, 0xF781, 0x3740, 0xF501, 0x35C0, 0x3480, 0xF441,
+	0x3C00, 0xFCC1, 0xFD81, 0x3D40, 0xFF01, 0x3FC0, 0x3E80, 0xFE41,
+	0xFA01, 0x3AC0, 0x3B80, 0xFB41, 0x3900, 0xF9C1, 0xF881, 0x3840,
+	0x2800, 0xE8C1, 0xE981, 0x2940, 0xEB01, 0x2BC0, 0x2A80, 0xEA41,
+	0xEE01, 0x2EC0, 0x2F80, 0xEF41, 0x2D00, 0xEDC1, 0xEC81, 0x2C40,
+	0xE401, 0x24C0, 0x2580, 0xE541, 0x2700, 0xE7C1, 0xE681, 0x2640,
+	0x2200, 0xE2C1, 0xE381, 0x2340, 0xE101, 0x21C0, 0x2080, 0xE041,
+	0xA001, 0x60C0, 0x6180, 0xA141, 0x6300, 0xA3C1, 0xA281, 0x6240,
+	0x6600, 0xA6C1, 0xA781, 0x6740, 0xA501, 0x65C0, 0x6480, 0xA441,
+	0x6C00, 0xACC1, 0xAD81, 0x6D40, 0xAF01, 0x6FC0, 0x6E80, 0xAE41,
+	0xAA01, 0x6AC0, 0x6B80, 0xAB41, 0x6900, 0xA9C1, 0xA881, 0x6840,
+	0x7800, 0xB8C1, 0xB981, 0x7940, 0xBB01, 0x7BC0, 0x7A80, 0xBA41,
+	0xBE01, 0x7EC0, 0x7F80, 0xBF41, 0x7D00, 0xBDC1, 0xBC81, 0x7C40,
+	0xB401, 0x74C0, 0x7580, 0xB541, 0x7700, 0xB7C1, 0xB681, 0x7640,
+	0x7200, 0xB2C1, 0xB381, 0x7340, 0xB101, 0x71C0, 0x7080, 0xB041,
+	0x5000, 0x90C1, 0x9181, 0x5140, 0x9301, 0x53C0, 0x5280, 0x9241,
+	0x9601, 0x56C0, 0x5780, 0x9741, 0x5500, 0x95C1, 0x9481, 0x5440,
+	0x9C01, 0x5CC0, 0x5D80, 0x9D41, 0x5F00, 0x9FC1, 0x9E81, 0x5E40,
+	0x5A00, 0x9AC1, 0x9B81, 0x5B40, 0x9901, 0x59C0, 0x5880, 0x9841,
+	0x8801, 0x48C0, 0x4980, 0x8941, 0x4B00, 0x8BC1, 0x8A81, 0x4A40,
+	0x4E00, 0x8EC1, 0x8F81, 0x4F40, 0x8D01, 0x4DC0, 0x4C80, 0x8C41,
+	0x4400, 0x84C1, 0x8581, 0x4540, 0x8701, 0x47C0, 0x4680, 0x8641,
+	0x8201, 0x42C0, 0x4380, 0x8341, 0x4100, 0x81C1, 0x8081, 0x4040
+};
+
+/**
+ * Compute the CRC-16 for the data buffer
+ *
+ * @param crc     previous CRC value
+ * @param buffer  data pointer
+ * @param len     number of bytes in the buffer
+ * @return        the updated CRC value
+ */
+crc16_t crc16(crc16_t crc, const void *buffer, unsigned int len)
+{
+	const unsigned char *cp = buffer;
+
+	while (len--)
+		crc = crc16_byte(crc, *cp++);
+	return crc;
+}
diff -Nurp e2fsprogs-1.40.8/lib/ext2fs/crc16.h e2fsprogs/lib/ext2fs/crc16.h
--- e2fsprogs-1.40.8/lib/ext2fs/crc16.h	1970-01-01 01:00:00.000000000 +0100
+++ e2fsprogs/lib/ext2fs/crc16.h	2008-03-29 01:20:43.000000000 +0100
@@ -0,0 +1,45 @@
+/*
+ *	crc16.h - CRC-16 routine
+ *
+ * Implements the standard CRC-16:
+ *   Width 16
+ *   Poly  0x8005 (x16 + x15 + x2 + 1)
+ *   Init  0
+ *
+ * Copyright (c) 2005 Ben Gardner <bgardner@wabtec.com>
+ *
+ * This source code is licensed under the GNU General Public License,
+ * Version 2. See the file COPYING for more details.
+ */
+
+#ifndef __CRC16_H
+#define __CRC16_H
+
+#include <ext2fs/ext2_types.h>
+
+extern __u16 const crc16_table[256];
+
+#ifdef WORDS_BIGENDIAN
+/* for an unknown reason, PPC treats __u16 as signed and keeps doing sign
+ * extension on the value.  Instead, use only the low 16 bits of an
+ * unsigned int for holding the CRC value to avoid this.
+ */
+typedef unsigned crc16_t;
+
+static inline crc16_t crc16_byte(crc16_t crc, const unsigned char data)
+{
+	return (((crc >> 8) & 0xffU) ^ crc16_table[(crc ^ data) & 0xffU]) &
+		0x0000ffffU;
+}
+#else
+typedef __u16 crc16_t;
+
+static inline crc16_t crc16_byte(crc16_t crc, const unsigned char data)
+{
+	return (crc >> 8) ^ crc16_table[(crc ^ data) & 0xff];
+}
+#endif
+
+extern crc16_t crc16(crc16_t crc, const void *buffer, unsigned int len);
+
+#endif /* __CRC16_H */
diff -Nurp e2fsprogs-1.40.8/lib/ext2fs/csum.c e2fsprogs/lib/ext2fs/csum.c
--- e2fsprogs-1.40.8/lib/ext2fs/csum.c	1970-01-01 01:00:00.000000000 +0100
+++ e2fsprogs/lib/ext2fs/csum.c	2008-03-29 01:20:43.000000000 +0100
@@ -0,0 +1,162 @@
+/*
+ * csum.c --- checksumming of ext3 structures
+ *
+ * Copyright (C) 2006 Cluster File Systems, Inc.
+ *
+ * %Begin-Header%
+ * This file may be redistributed under the terms of the GNU Public
+ * License.
+ * %End-Header%
+ */
+
+#include "ext2_fs.h"
+#include "ext2fs.h"
+#include "crc16.h"
+#include <assert.h>
+
+#ifndef offsetof
+#define offsetof(TYPE, MEMBER) ((size_t) &((TYPE *)0)->MEMBER)
+#endif
+
+#ifdef DEBUG
+#define STATIC
+#else
+#define STATIC static
+#endif
+
+STATIC __u16 ext2fs_group_desc_csum(ext2_filsys fs, dgrp_t group)
+{
+	__u16 crc = 0;
+	struct ext2_group_desc *desc;
+
+	desc = &fs->group_desc[group];
+
+	if (fs->super->s_feature_ro_compat & EXT4_FEATURE_RO_COMPAT_GDT_CSUM) {
+		int offset = offsetof(struct ext2_group_desc, bg_checksum);
+
+#ifdef WORDS_BIGENDIAN
+		struct ext2_group_desc swabdesc = *desc;
+
+		/* Have to swab back to little-endian to do the checksum */
+		ext2fs_swap_group_desc(&swabdesc);
+		desc = &swabdesc;
+
+		group = ext2fs_swab32(group);
+#endif
+		crc = crc16(~0, fs->super->s_uuid, sizeof(fs->super->s_uuid));
+		crc = crc16(crc, &group, sizeof(group));
+		crc = crc16(crc, desc, offset);
+		offset += sizeof(desc->bg_checksum); /* skip checksum */
+		assert(offset == sizeof(*desc));
+		/* for checksum of struct ext4_group_desc do the rest...*/
+		if (offset < fs->super->s_desc_size) {
+			crc = crc16(crc, (char *)desc + offset,
+				    fs->super->s_desc_size - offset);
+		}
+	}
+
+	return crc;
+}
+
+int ext2fs_group_desc_csum_verify(ext2_filsys fs, dgrp_t group)
+{
+	if (fs->group_desc[group].bg_checksum != 
+	    ext2fs_group_desc_csum(fs, group))
+		return 0;
+
+	return 1;
+}
+
+void ext2fs_group_desc_csum_set(ext2_filsys fs, dgrp_t group)
+{
+	fs->group_desc[group].bg_checksum = ext2fs_group_desc_csum(fs, group);
+}
+
+static __u32 find_last_inode_ingrp(ext2fs_inode_bitmap bitmap,
+				   __u32 inodes_per_grp, dgrp_t grp_no)
+{
+	ext2_ino_t i, start_ino, end_ino;
+
+	start_ino = grp_no * inodes_per_grp + 1;
+	end_ino = start_ino + inodes_per_grp - 1;
+
+	for (i = end_ino; i >= start_ino; i--) {
+		if (ext2fs_fast_test_inode_bitmap(bitmap, i))
+			return i - start_ino + 1;
+	}
+	return inodes_per_grp;
+}
+
+/* update the bitmap flags, set the itable high watermark, and calculate
+ * checksums for the group descriptors */
+void ext2fs_set_gdt_csum(ext2_filsys fs)
+{
+	struct ext2_super_block *sb = fs->super;
+	struct ext2_group_desc *bg = fs->group_desc;
+	int blks, csum_flag, dirty = 0;
+	dgrp_t i;
+
+	csum_flag = EXT2_HAS_RO_COMPAT_FEATURE(fs->super,
+					       EXT4_FEATURE_RO_COMPAT_GDT_CSUM);
+	if (!EXT2_HAS_COMPAT_FEATURE(fs->super,
+				     EXT2_FEATURE_COMPAT_LAZY_BG) && !csum_flag)
+		return;
+
+	for (i = 0; i < fs->group_desc_count; i++, bg++) {
+		int old_csum = bg->bg_checksum;
+
+		/* Even if it wasn't zeroed, by the time this function is
+		 * called by e2fsck we have already scanned and corrected
+		 * the whole inode table so we may as well not overwrite it.
+		 * This is just a hint to the kernel that it could do lazy
+		 * zeroing of the inode table if mke2fs didn't do it, to help
+		 * out if we need to do a full itable scan sometime later. */
+		if (!(bg->bg_flags & (EXT2_BG_INODE_UNINIT |
+				      EXT2_BG_INODE_ZEROED))) {
+			fs->group_desc[i].bg_flags |= EXT2_BG_INODE_ZEROED;
+			dirty = 1;
+		}
+
+		if (bg->bg_free_inodes_count == sb->s_inodes_per_group &&
+		    i > 0 && (i < fs->group_desc_count - 1 || csum_flag)) {
+			if (!(bg->bg_flags & EXT2_BG_INODE_UNINIT)) {
+				bg->bg_flags |= EXT2_BG_INODE_UNINIT;
+				dirty = 1;
+			}
+			if (csum_flag) {
+				int old_unused = bg->bg_itable_unused;
+				bg->bg_itable_unused = sb->s_inodes_per_group;
+				if (old_unused != bg->bg_itable_unused)
+					dirty = 1;
+			}
+		} else if (csum_flag) {
+			int old_unused = bg->bg_itable_unused;
+			bg->bg_flags &= ~EXT2_BG_INODE_UNINIT;
+			bg->bg_itable_unused = sb->s_inodes_per_group -
+				find_last_inode_ingrp(fs->inode_map,
+						      sb->s_inodes_per_group,i);
+			if (old_unused != bg->bg_itable_unused)
+				dirty = 1;
+		}
+
+		/* skip first and last groups, or groups with GDT backups
+		 * because the resize inode has blocks allocated in them. */
+		if (i == 0 || (i == fs->group_desc_count - 1 && !csum_flag) ||
+		    (ext2fs_bg_has_super(fs, i) && sb->s_reserved_gdt_blocks))
+			goto checksum;
+
+		blks = ext2fs_super_and_bgd_loc(fs, i, 0, 0, 0, 0);
+		if (bg->bg_free_blocks_count == blks &&
+		    bg->bg_flags & EXT2_BG_INODE_UNINIT &&
+		    !(bg->bg_flags & EXT2_BG_BLOCK_UNINIT)) {
+			bg->bg_flags |= EXT2_BG_BLOCK_UNINIT;
+			dirty = 1;
+		}
+checksum:
+		ext2fs_group_desc_csum_set(fs, i);
+		if (old_csum != bg->bg_checksum)
+			dirty = 1;
+	}
+	if (dirty)
+		ext2fs_mark_super_dirty(fs);
+}
diff -Nurp e2fsprogs-1.40.8/lib/ext2fs/dblist.c e2fsprogs/lib/ext2fs/dblist.c
--- e2fsprogs-1.40.8/lib/ext2fs/dblist.c	2008-03-13 18:48:05.000000000 +0100
+++ e2fsprogs/lib/ext2fs/dblist.c	2008-03-29 01:20:43.000000000 +0100
@@ -263,8 +263,6 @@ int ext2fs_dblist_count(ext2_dblist dbli
 errcode_t ext2fs_dblist_get_last(ext2_dblist dblist, 
 				 struct ext2_db_entry **entry)
 {
-	errcode_t		retval;
-
 	EXT2_CHECK_MAGIC(dblist, EXT2_ET_MAGIC_DBLIST);
 
 	if (dblist->count == 0)
diff -Nurp e2fsprogs-1.40.8/lib/ext2fs/dirblock.c e2fsprogs/lib/ext2fs/dirblock.c
--- e2fsprogs-1.40.8/lib/ext2fs/dirblock.c	2008-03-13 23:20:46.000000000 +0100
+++ e2fsprogs/lib/ext2fs/dirblock.c	2008-03-29 01:20:43.000000000 +0100
@@ -25,26 +25,21 @@ errcode_t ext2fs_read_dir_block2(ext2_fi
 	errcode_t	retval;
 	char		*p, *end;
 	struct ext2_dir_entry *dirent;
-	unsigned int	name_len, rec_len, do_swap;
+	unsigned int	name_len, rec_len;
 	
 
  	retval = io_channel_read_blk(fs->io, block, 1, buf);
 	if (retval)
 		return retval;
-#ifdef EXT2FS_ENABLE_SWAPFS
-	do_swap = (fs->flags & (EXT2_FLAG_SWAP_BYTES|
-				EXT2_FLAG_SWAP_BYTES_READ)) != 0;
-#endif
+
 	p = (char *) buf;
 	end = (char *) buf + fs->blocksize;
 	while (p < end-8) {
 		dirent = (struct ext2_dir_entry *) p;
-#ifdef EXT2FS_ENABLE_SWAPFS
-		if (do_swap) {
-			dirent->inode = ext2fs_swab32(dirent->inode);
-			dirent->rec_len = ext2fs_swab16(dirent->rec_len);
-			dirent->name_len = ext2fs_swab16(dirent->name_len);
-		}
+#ifdef WORDS_BIGENDIAN
+		dirent->inode = ext2fs_swab32(dirent->inode);
+		dirent->rec_len = ext2fs_swab16(dirent->rec_len);
+		dirent->name_len = ext2fs_swab16(dirent->name_len);
 #endif
 		name_len = dirent->name_len;
 #ifdef WORDS_BIGENDIAN
@@ -73,22 +68,12 @@ errcode_t ext2fs_read_dir_block(ext2_fil
 errcode_t ext2fs_write_dir_block2(ext2_filsys fs, blk_t block,
 				  void *inbuf, int flags EXT2FS_ATTR((unused)))
 {
-#ifdef EXT2FS_ENABLE_SWAPFS
-	int		do_swap = 0;
+#ifdef WORDS_BIGENDIAN
 	errcode_t	retval;
 	char		*p, *end;
 	char		*buf = 0;
 	struct ext2_dir_entry *dirent;
 
-	if ((fs->flags & EXT2_FLAG_SWAP_BYTES) ||
-	    (fs->flags & EXT2_FLAG_SWAP_BYTES_WRITE))
-		do_swap = 1;
-
-#ifndef WORDS_BIGENDIAN
-	if (!do_swap)
-		return io_channel_write_blk(fs->io, block, 1, (char *) inbuf);
-#endif
-
 	retval = ext2fs_get_mem(fs->blocksize, &buf);
 	if (retval)
 		return retval;
@@ -103,15 +88,12 @@ errcode_t ext2fs_write_dir_block2(ext2_f
 			return (EXT2_ET_DIR_CORRUPTED);
 		}
 		p += dirent->rec_len;
-		if (do_swap) {
-			dirent->inode = ext2fs_swab32(dirent->inode);
-			dirent->rec_len = ext2fs_swab16(dirent->rec_len);
-			dirent->name_len = ext2fs_swab16(dirent->name_len);
-		}
-#ifdef WORDS_BIGENDIAN 
+		dirent->inode = ext2fs_swab32(dirent->inode);
+		dirent->rec_len = ext2fs_swab16(dirent->rec_len);
+		dirent->name_len = ext2fs_swab16(dirent->name_len);
+
 		if (flags & EXT2_DIRBLOCK_V2_STRUCT)
 			dirent->name_len = ext2fs_swab16(dirent->name_len);
-#endif
 	}
  	retval = io_channel_write_blk(fs->io, block, 1, buf);
 	ext2fs_free_mem(&buf);
diff -Nurp e2fsprogs-1.40.8/lib/ext2fs/dir_iterate.c e2fsprogs/lib/ext2fs/dir_iterate.c
--- e2fsprogs-1.40.8/lib/ext2fs/dir_iterate.c	2008-03-13 23:20:46.000000000 +0100
+++ e2fsprogs/lib/ext2fs/dir_iterate.c	2008-03-29 01:20:43.000000000 +0100
@@ -78,7 +78,7 @@ errcode_t ext2fs_dir_iterate2(ext2_filsy
 	ctx.func = func;
 	ctx.priv_data = priv_data;
 	ctx.errcode = 0;
-	retval = ext2fs_block_iterate2(fs, dir, 0, 0,
+	retval = ext2fs_block_iterate2(fs, dir, BLOCK_FLAG_READ_ONLY, 0,
 				       ext2fs_process_dir_block, &ctx);
 	if (!block_buf)
 		ext2fs_free_mem(&ctx.buf);
diff -Nurp e2fsprogs-1.40.8/lib/ext2fs/ext2_err.et.in e2fsprogs/lib/ext2fs/ext2_err.et.in
--- e2fsprogs-1.40.8/lib/ext2fs/ext2_err.et.in	2008-03-13 23:20:46.000000000 +0100
+++ e2fsprogs/lib/ext2fs/ext2_err.et.in	2008-03-29 01:20:43.000000000 +0100
@@ -62,8 +62,8 @@ ec	EXT2_ET_MAGIC_E2IMAGE,
 ec	EXT2_ET_MAGIC_INODE_IO_CHANNEL,
 	"Wrong magic number for inode io_channel structure"
 
-ec	EXT2_ET_MAGIC_RESERVED_9,
-	"Wrong magic number --- RESERVED_9"
+ec	EXT2_ET_MAGIC_EXTENT_HANDLE,
+	"Wrong magic number for ext4 extent handle"
 
 ec	EXT2_ET_BAD_MAGIC,
 	"Bad magic number in super-block"
@@ -329,5 +329,82 @@ ec	EXT2_ET_TDB_ERR_RDONLY,
 ec	EXT2_ET_DBLIST_EMPTY,
 	"Ext2fs directory block list is empty"
 
-	end
+ec	EXT2_ET_RO_BLOCK_ITERATE,
+	"Attempt to modify a block mapping via a read-only block iterator"
+
+ec	EXT2_ET_MAGIC_EXTENT_PATH,
+	"Wrong magic number for ext4 extent saved path"
+
+ec	EXT2_ET_MAGIC_RESERVED_10,
+	"Wrong magic number --- RESERVED_10"
+
+ec	EXT2_ET_MAGIC_RESERVED_11,
+	"Wrong magic number --- RESERVED_11"
+
+ec	EXT2_ET_MAGIC_RESERVED_12,
+	"Wrong magic number --- RESERVED_12"
+
+ec	EXT2_ET_MAGIC_RESERVED_13,
+	"Wrong magic number --- RESERVED_13"
+
+ec	EXT2_ET_MAGIC_RESERVED_14,
+	"Wrong magic number --- RESERVED_14"
+
+ec	EXT2_ET_MAGIC_RESERVED_15,
+	"Wrong magic number --- RESERVED_15"
+
+ec	EXT2_ET_MAGIC_RESERVED_16,
+	"Wrong magic number --- RESERVED_16"
+
+ec	EXT2_ET_MAGIC_RESERVED_17,
+	"Wrong magic number --- RESERVED_17"
+
+ec	EXT2_ET_MAGIC_RESERVED_18,
+	"Wrong magic number --- RESERVED_18"
+
+ec	EXT2_ET_MAGIC_RESERVED_19,
+	"Wrong magic number --- RESERVED_19"
+
+ec	EXT2_ET_EXTENT_HEADER_BAD,
+	"Corrupt extent header"
+
+ec	EXT2_ET_EXTENT_INDEX_BAD,
+	"Corrupt extent index"
 
+ec	EXT2_ET_EXTENT_LEAF_BAD,
+	"Corrupt extent"
+
+ec	EXT2_ET_EXTENT_NO_SPACE,
+	"No free space in extent map"
+
+ec	EXT2_ET_INODE_NOT_EXTENT,
+	"Inode does not use extents"
+
+ec	EXT2_ET_EXTENT_NO_NEXT,
+	"No 'next' extent"
+
+ec	EXT2_ET_EXTENT_NO_PREV,
+	"No 'previous' extent"
+
+ec	EXT2_ET_EXTENT_NO_UP,
+	"No 'up' extent"
+
+ec	EXT2_ET_EXTENT_NO_DOWN,
+	"No 'down' extent"
+
+ec	EXT2_ET_NO_CURRENT_NODE,
+	"No current node"
+
+ec	EXT2_ET_OP_NOT_SUPPORTED,
+	"Ext2fs operation not supported"
+
+ec	EXT2_ET_CANT_INSERT_EXTENT,
+	"No room to insert extent in node"
+
+ec	EXT2_ET_EXTENT_NOT_FOUND,
+	"Extent not found"
+
+ec	EXT2_ET_EXTENT_NOT_SUPPORTED,
+	"Operation not supported for inodes containing extents"
+
+	end
diff -Nurp e2fsprogs-1.40.8/lib/ext2fs/ext2_fs.h e2fsprogs/lib/ext2fs/ext2_fs.h
--- e2fsprogs-1.40.8/lib/ext2fs/ext2_fs.h	2008-03-13 23:20:46.000000000 +0100
+++ e2fsprogs/lib/ext2fs/ext2_fs.h	2008-03-29 01:20:43.000000000 +0100
@@ -173,6 +173,7 @@ struct ext4_group_desc
 
 #define EXT2_BG_INODE_UNINIT	0x0001 /* Inode table/bitmap not initialized */
 #define EXT2_BG_BLOCK_UNINIT	0x0002 /* Block bitmap not initialized */
+#define EXT2_BG_INODE_ZEROED	0x0004 /* On-disk itable initialized to zero */
 
 /*
  * Data structures used by the directory indexing feature
@@ -217,6 +218,13 @@ struct ext2_dx_countlimit {
 /*
  * Macro-instructions used to manage group descriptors
  */
+#define EXT2_MIN_DESC_SIZE             32
+#define EXT2_MIN_DESC_SIZE_64BIT       64
+#define EXT2_MAX_DESC_SIZE             EXT2_MIN_BLOCK_SIZE
+#define EXT2_DESC_SIZE(s)                                                \
+       ((EXT2_SB(s)->s_feature_incompat & EXT4_FEATURE_INCOMPAT_64BIT) ? \
+	(s)->s_desc_size : EXT2_MIN_DESC_SIZE)
+
 #define EXT2_BLOCKS_PER_GROUP(s)	(EXT2_SB(s)->s_blocks_per_group)
 #define EXT2_INODES_PER_GROUP(s)	(EXT2_SB(s)->s_inodes_per_group)
 #define EXT2_INODES_PER_BLOCK(s)	(EXT2_BLOCK_SIZE(s)/EXT2_INODE_SIZE(s))
@@ -227,7 +235,7 @@ struct ext2_dx_countlimit {
 #define EXT2_DESC_PER_BLOCK(s)		(EXT2_SB(s)->s_desc_per_block)
 #define EXT2_DESC_PER_BLOCK_BITS(s)	(EXT2_SB(s)->s_desc_per_block_bits)
 #else
-#define EXT2_DESC_PER_BLOCK(s)		(EXT2_BLOCK_SIZE(s) / sizeof (struct ext2_group_desc))
+#define EXT2_DESC_PER_BLOCK(s)		(EXT2_BLOCK_SIZE(s) / EXT2_DESC_SIZE(s))
 #endif
 
 /*
@@ -319,9 +327,6 @@ struct ext2_inode {
 		struct {
 			__u32  h_i_translator;
 		} hurd1;
-		struct {
-			__u32  m_i_reserved1;
-		} masix1;
 	} osd1;				/* OS dependent 1 */
 	__u32	i_block[EXT2_N_BLOCKS];/* Pointers to blocks */
 	__u32	i_generation;	/* File version (for NFS) */
@@ -344,12 +349,6 @@ struct ext2_inode {
 			__u16	h_i_gid_high;
 			__u32	h_i_author;
 		} hurd2;
-		struct {
-			__u8	m_i_frag;	/* Fragment number */
-			__u8	m_i_fsize;	/* Fragment size */
-			__u16	m_pad1;
-			__u32	m_i_reserved2[2];
-		} masix2;
 	} osd2;				/* OS dependent 2 */
 };
 
@@ -375,9 +374,6 @@ struct ext2_inode_large {
 		struct {
 			__u32  h_i_translator;
 		} hurd1;
-		struct {
-			__u32  m_i_reserved1;
-		} masix1;
 	} osd1;				/* OS dependent 1 */
 	__u32	i_block[EXT2_N_BLOCKS];/* Pointers to blocks */
 	__u32	i_generation;	/* File version (for NFS) */
@@ -400,12 +396,6 @@ struct ext2_inode_large {
 			__u16	h_i_gid_high;
 			__u32	h_i_author;
 		} hurd2;
-		struct {
-			__u8	m_i_frag;	/* Fragment number */
-			__u8	m_i_fsize;	/* Fragment size */
-			__u16	m_pad1;
-			__u32	m_i_reserved2[2];
-		} masix2;
 	} osd2;				/* OS dependent 2 */
 	__u16	i_extra_isize;
 	__u16	i_pad1;
@@ -437,37 +427,20 @@ struct ext2_inode_large {
 #define i_gid_high	osd2.hurd2.h_i_gid_high
 #define i_author	osd2.hurd2.h_i_author
 
-#else
-#if defined(__masix__)
-
-#define i_reserved1	osd1.masix1.m_i_reserved1
-#define i_frag		osd2.masix2.m_i_frag
-#define i_fsize		osd2.masix2.m_i_fsize
-#define i_reserved2	osd2.masix2.m_i_reserved2
-
-#endif  /* __masix__ */
 #endif  /* __GNU__ */
 #endif	/* defined(__KERNEL__) || defined(__linux__) */
 
-#if defined(__masix__)
-#define inode_uid(inode)	((inode).i_uid)
-#define inode_gid(inode)	((inode).i_gid)
-#define ext2fs_set_i_uid_high(inode,x) (x)
-#define ext2fs_set_i_gid_high(inode,x) (x)
-
-#else
 #define inode_uid(inode)	((inode).i_uid | (inode).osd2.linux2.l_i_uid_high << 16)
 #define inode_gid(inode)	((inode).i_gid | (inode).osd2.linux2.l_i_gid_high << 16)
 #define ext2fs_set_i_uid_high(inode,x) ((inode).osd2.linux2.l_i_uid_high = (x))
 #define ext2fs_set_i_gid_high(inode,x) ((inode).osd2.linux2.l_i_gid_high = (x))
-#endif
 
 /*
  * File system states
  */
 #define EXT2_VALID_FS			0x0001	/* Unmounted cleanly */
 #define EXT2_ERROR_FS			0x0002	/* Errors detected */
-#define EXT4_ORPHAN_FS			0x0004	/* Orphans being recovered */
+#define EXT3_ORPHAN_FS			0x0004	/* Orphans being recovered */
 
 /*
  * Misc. filesystem flags
@@ -598,7 +571,7 @@ struct ext2_super_block {
  */
 #define EXT2_OS_LINUX		0
 #define EXT2_OS_HURD		1
-#define EXT2_OS_MASIX		2
+#define EXT2_OBSO_OS_MASIX	2
 #define EXT2_OS_FREEBSD		3
 #define EXT2_OS_LITES		4
 
@@ -653,12 +626,14 @@ struct ext2_super_block {
 #define EXT3_FEATURE_INCOMPAT_EXTENTS		0x0040
 #define EXT4_FEATURE_INCOMPAT_64BIT		0x0080
 #define EXT4_FEATURE_INCOMPAT_MMP		0x0100
+#define EXT4_FEATURE_INCOMPAT_FLEX_BG		0x0200
 
 
 #define EXT2_FEATURE_COMPAT_SUPP	0
 #define EXT2_FEATURE_INCOMPAT_SUPP	(EXT2_FEATURE_INCOMPAT_FILETYPE)
 #define EXT2_FEATURE_RO_COMPAT_SUPP	(EXT2_FEATURE_RO_COMPAT_SPARSE_SUPER| \
 					 EXT2_FEATURE_RO_COMPAT_LARGE_FILE| \
+					 EXT4_FEATURE_RO_COMPAT_DIR_NLINK| \
 					 EXT2_FEATURE_RO_COMPAT_BTREE_DIR)
 
 /*
diff -Nurp e2fsprogs-1.40.8/lib/ext2fs/ext2fs.h e2fsprogs/lib/ext2fs/ext2fs.h
--- e2fsprogs-1.40.8/lib/ext2fs/ext2fs.h	2008-03-13 23:20:46.000000000 +0100
+++ e2fsprogs/lib/ext2fs/ext2fs.h	2008-03-29 01:20:43.000000000 +0100
@@ -30,15 +30,6 @@ extern "C" {
 #endif
 
 /*
- * Build in support for byte-swapping filesystems if we the feature
- * has been configured or if we're being built on a CPU architecture
- * with a non-native byte order.
- */
-#if defined(ENABLE_SWAPFS) || defined(WORDS_BIGENDIAN)
-#define EXT2FS_ENABLE_SWAPFS
-#endif
-
-/*
  * Where the master copy of the superblock is located, and how big
  * superblocks are supposed to be.  We define SUPERBLOCK_SIZE because
  * the size of the superblock structure is not necessarily trustworthy
@@ -74,6 +65,7 @@ extern "C" {
 
 typedef __u32		ext2_ino_t;
 typedef __u32		blk_t;
+typedef __u64		blk64_t;
 typedef __u32		dgrp_t;
 typedef __u32		ext2_off_t;
 typedef __s64		e2_blkcnt_t;
@@ -83,10 +75,12 @@ typedef __u32		ext2_dirhash_t;
 #include "com_err.h"
 #include "ext2_io.h"
 #include "ext2_err.h"
+#include "ext2_ext_attr.h"
 #else
 #include <et/com_err.h>
 #include <ext2fs/ext2_io.h>
 #include <ext2fs/ext2_err.h>
+#include <ext2fs/ext2_ext_attr.h>
 #endif
 
 /*
@@ -100,17 +94,6 @@ typedef __u32		ext2_dirhash_t;
 
 typedef struct struct_ext2_filsys *ext2_filsys;
 
-struct ext2fs_struct_generic_bitmap {
-	errcode_t	magic;
-	ext2_filsys 	fs;
-	__u32		start, end;
-	__u32		real_end;
-	char	*	description;
-	char	*	bitmap;
-	errcode_t	base_error_code;
-	__u32		reserved[7];
-};
-
 #define EXT2FS_MARK_ERROR 	0
 #define EXT2FS_UNMARK_ERROR 	1
 #define EXT2FS_TEST_ERROR	2
@@ -279,6 +262,9 @@ struct struct_ext2_filsys {
  * BLOCK_FLAG_DATA_ONLY indicates that the iterator function should be
  * called for data blocks only.
  *
+ * BLOCK_FLAG_READ_ONLY is a promise by the caller that it will not 
+ * modify returned block number.
+ *
  * BLOCK_FLAG_NO_LARGE is for internal use only.  It informs
  * ext2fs_block_iterate2 that large files won't be accepted.
  */
@@ -286,6 +272,7 @@ struct struct_ext2_filsys {
 #define BLOCK_FLAG_HOLE		1
 #define BLOCK_FLAG_DEPTH_TRAVERSE	2
 #define BLOCK_FLAG_DATA_ONLY	4
+#define BLOCK_FLAG_READ_ONLY	8
 
 #define BLOCK_FLAG_NO_LARGE	0x1000
 
@@ -306,6 +293,65 @@ struct struct_ext2_filsys {
 #endif
 
 /*
+ * Generic (non-filesystem layout specific) extents structure
+ */
+
+#define EXT2_EXTENT_FLAGS_LEAF		0x0001
+#define EXT2_EXTENT_FLAGS_UNINIT	0x0002
+#define EXT2_EXTENT_FLAGS_SECOND_VISIT	0x0004
+
+struct ext2fs_extent {
+	blk64_t	e_pblk;		/* first physical block */
+	blk64_t	e_lblk;		/* first logical block extent covers */
+	__u32	e_len;		/* number of blocks covered by extent */
+	__u32	e_flags;	/* extent flags */
+};
+
+typedef struct ext2_extent_handle *ext2_extent_handle_t;
+typedef struct ext2_extent_path *ext2_extent_path_t;
+
+/*
+ * Flags used by ext2fs_extent_get()
+ */
+#define EXT2_EXTENT_CURRENT	0x0000
+#define EXT2_EXTENT_MOVE_MASK	0x000F
+#define EXT2_EXTENT_ROOT	0x0001
+#define EXT2_EXTENT_LAST_LEAF	0x0002
+#define EXT2_EXTENT_FIRST_SIB	0x0003
+#define EXT2_EXTENT_LAST_SIB	0x0004
+#define EXT2_EXTENT_NEXT_SIB	0x0005
+#define EXT2_EXTENT_PREV_SIB	0x0006
+#define EXT2_EXTENT_NEXT_LEAF	0x0007
+#define EXT2_EXTENT_PREV_LEAF	0x0008
+#define EXT2_EXTENT_NEXT	0x0009
+#define EXT2_EXTENT_PREV	0x000A
+#define EXT2_EXTENT_UP		0x000B
+#define EXT2_EXTENT_DOWN	0x000C
+#define EXT2_EXTENT_DOWN_AND_LAST 0x000D
+
+/*
+ * Flags used by ext2fs_extent_insert()
+ */
+
+#define EXT2_EXTENT_INSERT_AFTER  0x0001
+
+/*
+ * Data structure returned by ext2fs_extent_get_info()
+ */
+struct ext2_extent_info {
+	int		curr_entry;
+	int		curr_level;
+	int		num_entries;
+	int		max_entries;
+	int		max_depth;
+	int		bytes_avail;
+	blk64_t		max_lblk;
+	blk64_t		max_pblk;
+	__u32		max_len;
+	__u32		max_uninit_len;
+};
+
+/*
  * Flags for directory block reading and writing functions
  */
 #define EXT2_DIRBLOCK_V2_STRUCT	0x0001
@@ -411,6 +457,11 @@ typedef struct ext2_icount *ext2_icount_
 #define BMAP_SET	0x0002
 
 /*
+ * Returned flags from ext2fs_bmap
+ */
+#define BMAP_RET_UNINIT	0x0001
+
+/*
  * Flags for imager.c functions
  */
 #define IMAGER_FLAG_INODEMAP	1
@@ -427,7 +478,7 @@ typedef struct ext2_icount *ext2_icount_
 /*
  * For ext2 compression support
  */
-#define EXT2FS_COMPRESSED_BLKADDR ((blk_t) 0xffffffff)
+#define EXT2FS_COMPRESSED_BLKADDR ((blk_t) -1)
 #define HOLE_BLKADDR(_b) ((_b) == 0 || (_b) == EXT2FS_COMPRESSED_BLKADDR)
 
 /*
@@ -453,15 +504,21 @@ typedef struct ext2_icount *ext2_icount_
 					 EXT2_FEATURE_INCOMPAT_COMPRESSION|\
 					 EXT3_FEATURE_INCOMPAT_JOURNAL_DEV|\
 					 EXT2_FEATURE_INCOMPAT_META_BG|\
-					 EXT3_FEATURE_INCOMPAT_RECOVER)
+					 EXT3_FEATURE_INCOMPAT_RECOVER|\
+					 EXT3_FEATURE_INCOMPAT_EXTENTS|\
+					 EXT4_FEATURE_INCOMPAT_FLEX_BG)
 #else
 #define EXT2_LIB_FEATURE_INCOMPAT_SUPP	(EXT2_FEATURE_INCOMPAT_FILETYPE|\
 					 EXT3_FEATURE_INCOMPAT_JOURNAL_DEV|\
 					 EXT2_FEATURE_INCOMPAT_META_BG|\
-					 EXT3_FEATURE_INCOMPAT_RECOVER)
+					 EXT3_FEATURE_INCOMPAT_RECOVER|\
+					 EXT3_FEATURE_INCOMPAT_EXTENTS|\
+					 EXT4_FEATURE_INCOMPAT_FLEX_BG)
 #endif
 #define EXT2_LIB_FEATURE_RO_COMPAT_SUPP	(EXT2_FEATURE_RO_COMPAT_SPARSE_SUPER|\
-					 EXT2_FEATURE_RO_COMPAT_LARGE_FILE)
+					 EXT2_FEATURE_RO_COMPAT_LARGE_FILE|\
+					 EXT4_FEATURE_RO_COMPAT_DIR_NLINK|\
+					 EXT4_FEATURE_RO_COMPAT_GDT_CSUM)
 
 /*
  * These features are only allowed if EXT2_FLAG_SOFTSUPP_FEATURES is passed
@@ -470,7 +527,6 @@ typedef struct ext2_icount *ext2_icount_
 #define EXT2_LIB_SOFTSUPP_INCOMPAT	(EXT3_FEATURE_INCOMPAT_EXTENTS)
 #define EXT2_LIB_SOFTSUPP_RO_COMPAT	(EXT4_FEATURE_RO_COMPAT_HUGE_FILE|\
 					 EXT4_FEATURE_RO_COMPAT_GDT_CSUM|\
-					 EXT4_FEATURE_RO_COMPAT_DIR_NLINK|\
 					 EXT4_FEATURE_RO_COMPAT_EXTRA_ISIZE)
 
 /*
@@ -552,15 +608,14 @@ extern errcode_t ext2fs_update_bb_inode(
 					ext2_badblocks_list bb_list);
 
 /* bitmaps.c */
+extern void ext2fs_free_block_bitmap(ext2fs_block_bitmap bitmap);
+extern void ext2fs_free_inode_bitmap(ext2fs_inode_bitmap bitmap);
+extern errcode_t ext2fs_copy_bitmap(ext2fs_generic_bitmap src,
+				    ext2fs_generic_bitmap *dest);
 extern errcode_t ext2fs_write_inode_bitmap(ext2_filsys fs);
 extern errcode_t ext2fs_write_block_bitmap (ext2_filsys fs);
 extern errcode_t ext2fs_read_inode_bitmap (ext2_filsys fs);
 extern errcode_t ext2fs_read_block_bitmap(ext2_filsys fs);
-extern errcode_t ext2fs_allocate_generic_bitmap(__u32 start,
-						__u32 end,
-						__u32 real_end,
-						const char *descr,
-						ext2fs_generic_bitmap *ret);
 extern errcode_t ext2fs_allocate_block_bitmap(ext2_filsys fs,
 					      const char *descr,
 					      ext2fs_block_bitmap *ret);
@@ -575,6 +630,27 @@ extern void ext2fs_clear_inode_bitmap(ex
 extern void ext2fs_clear_block_bitmap(ext2fs_block_bitmap bitmap);
 extern errcode_t ext2fs_read_bitmaps(ext2_filsys fs);
 extern errcode_t ext2fs_write_bitmaps(ext2_filsys fs);
+extern errcode_t ext2fs_resize_inode_bitmap(__u32 new_end, __u32 new_real_end,
+					    ext2fs_inode_bitmap bmap);
+extern errcode_t ext2fs_resize_block_bitmap(__u32 new_end, __u32 new_real_end,
+					    ext2fs_block_bitmap bmap);
+extern errcode_t ext2fs_compare_block_bitmap(ext2fs_block_bitmap bm1,
+					     ext2fs_block_bitmap bm2);
+extern errcode_t ext2fs_compare_inode_bitmap(ext2fs_inode_bitmap bm1,
+					     ext2fs_inode_bitmap bm2);
+extern errcode_t ext2fs_set_inode_bitmap_range(ext2fs_inode_bitmap bmap,
+					ext2_ino_t start, unsigned int num,
+					void *in);
+extern errcode_t ext2fs_get_inode_bitmap_range(ext2fs_inode_bitmap bmap,
+					ext2_ino_t start, unsigned int num,
+					void *out);
+extern errcode_t ext2fs_set_block_bitmap_range(ext2fs_block_bitmap bmap,
+					blk_t start, unsigned int num,
+					void *in);
+extern errcode_t ext2fs_get_block_bitmap_range(ext2fs_block_bitmap bmap,
+					blk_t start, unsigned int num,
+					void *out);
+
 
 /* block.c */
 extern errcode_t ext2fs_block_iterate(ext2_filsys fs,
@@ -603,7 +679,10 @@ extern errcode_t ext2fs_bmap(ext2_filsys
 			     struct ext2_inode *inode, 
 			     char *block_buf, int bmap_flags,
 			     blk_t block, blk_t *phys_blk);
-
+extern errcode_t ext2fs_bmap2(ext2_filsys fs, ext2_ino_t ino, 
+			      struct ext2_inode *inode,
+			      char *block_buf, int bmap_flags, blk64_t block,
+			      int *ret_flags, blk64_t *phys_blk);
 
 #if 0
 /* bmove.c */
@@ -628,11 +707,10 @@ extern int ext2fs_super_and_bgd_loc(ext2
 				    int *ret_meta_bg);
 extern void ext2fs_update_dynamic_rev(ext2_filsys fs);
 
-/* cmp_bitmaps.c */
-extern errcode_t ext2fs_compare_block_bitmap(ext2fs_block_bitmap bm1,
-					     ext2fs_block_bitmap bm2);
-extern errcode_t ext2fs_compare_inode_bitmap(ext2fs_inode_bitmap bm1,
-					     ext2fs_inode_bitmap bm2);
+/* csum.c */
+extern void ext2fs_group_desc_csum_set(ext2_filsys fs, dgrp_t group);
+extern int ext2fs_group_desc_csum_verify(ext2_filsys fs, dgrp_t group);
+extern void ext2fs_set_gdt_csum(ext2_filsys fs);
 
 /* dblist.c */
 
@@ -718,6 +796,8 @@ extern errcode_t ext2fs_dup_handle(ext2_
 extern errcode_t ext2fs_expand_dir(ext2_filsys fs, ext2_ino_t dir);
 
 /* ext_attr.c */
+extern __u32 ext2fs_ext_attr_hash_entry(struct ext2_ext_attr_entry *entry,
+					void *data);
 extern errcode_t ext2fs_read_ext_attr(ext2_filsys fs, blk_t block, void *buf);
 extern errcode_t ext2fs_write_ext_attr(ext2_filsys fs, blk_t block,
 				       void *buf);
@@ -725,6 +805,23 @@ extern errcode_t ext2fs_adjust_ea_refcou
 					   char *block_buf,
 					   int adjust, __u32 *newcount);
 
+/* extent.c */
+extern errcode_t ext2fs_extent_header_verify(void *ptr, int size);
+extern errcode_t ext2fs_extent_open(ext2_filsys fs, ext2_ino_t ino,
+				    ext2_extent_handle_t *handle);
+extern void ext2fs_extent_free(ext2_extent_handle_t handle);
+extern errcode_t ext2fs_extent_get(ext2_extent_handle_t handle,
+				   int flags, struct ext2fs_extent *extent);
+extern errcode_t ext2fs_extent_replace(ext2_extent_handle_t handle, int flags,
+				       struct ext2fs_extent *extent);
+extern errcode_t ext2fs_extent_insert(ext2_extent_handle_t handle, int flags,
+				      struct ext2fs_extent *extent);
+extern errcode_t ext2fs_extent_delete(ext2_extent_handle_t handle, int flags);
+extern errcode_t ext2fs_extent_get_info(ext2_extent_handle_t handle,
+					struct ext2_extent_info *info);
+extern errcode_t ext2fs_extent_goto(ext2_extent_handle_t handle,
+				    blk64_t blk);
+
 /* fileio.c */
 extern errcode_t ext2fs_file_open2(ext2_filsys fs, ext2_ino_t ino,
 				   struct ext2_inode *inode,
@@ -754,13 +851,47 @@ extern errcode_t ext2fs_sync_device(int 
 
 /* freefs.c */
 extern void ext2fs_free(ext2_filsys fs);
-extern void ext2fs_free_generic_bitmap(ext2fs_inode_bitmap bitmap);
-extern void ext2fs_free_block_bitmap(ext2fs_block_bitmap bitmap);
-extern void ext2fs_free_inode_bitmap(ext2fs_inode_bitmap bitmap);
 extern void ext2fs_free_dblist(ext2_dblist dblist);
 extern void ext2fs_badblocks_list_free(ext2_badblocks_list bb);
 extern void ext2fs_u32_list_free(ext2_u32_list bb);
 
+/* gen_bitmap.c */
+extern void ext2fs_free_generic_bitmap(ext2fs_inode_bitmap bitmap);
+extern errcode_t ext2fs_make_generic_bitmap(errcode_t magic, ext2_filsys fs, 
+					    __u32 start, __u32 end, 
+					    __u32 real_end,
+					    const char *descr, char *init_map,
+					    ext2fs_generic_bitmap *ret);
+extern errcode_t ext2fs_allocate_generic_bitmap(__u32 start,
+						__u32 end,
+						__u32 real_end,
+						const char *descr,
+						ext2fs_generic_bitmap *ret);
+extern errcode_t ext2fs_copy_generic_bitmap(ext2fs_generic_bitmap src,
+					    ext2fs_generic_bitmap *dest);
+extern void ext2fs_clear_generic_bitmap(ext2fs_generic_bitmap bitmap);
+extern errcode_t ext2fs_fudge_generic_bitmap_end(ext2fs_inode_bitmap bitmap,
+						 errcode_t magic, 
+						 errcode_t neq,
+						 ext2_ino_t end, 
+						 ext2_ino_t *oend);
+extern void ext2fs_set_generic_bitmap_padding(ext2fs_generic_bitmap map);
+extern errcode_t ext2fs_resize_generic_bitmap(errcode_t magic,
+					      __u32 new_end,
+					      __u32 new_real_end,
+					      ext2fs_generic_bitmap bmap);
+extern errcode_t ext2fs_compare_generic_bitmap(errcode_t magic, errcode_t neq,
+					       ext2fs_generic_bitmap bm1,
+					       ext2fs_generic_bitmap bm2);
+extern errcode_t ext2fs_get_generic_bitmap_range(ext2fs_generic_bitmap bmap,
+						 errcode_t magic,
+						 __u32 start, __u32 num,
+						 void *out);
+extern errcode_t ext2fs_set_generic_bitmap_range(ext2fs_generic_bitmap bmap,
+						 errcode_t magic,
+						 __u32 start, __u32 num,
+						 void *in);
+
 /* getsize.c */
 extern errcode_t ext2fs_get_device_size(const char *file, int blocksize,
 					blk_t *retblocks);
@@ -931,20 +1062,13 @@ extern errcode_t ext2fs_read_bb_FILE(ext
 /* res_gdt.c */
 extern errcode_t ext2fs_create_resize_inode(ext2_filsys fs);
 
-/* rs_bitmap.c */
-extern errcode_t ext2fs_resize_generic_bitmap(__u32 new_end,
-					      __u32 new_real_end,
-					      ext2fs_generic_bitmap bmap);
-extern errcode_t ext2fs_resize_inode_bitmap(__u32 new_end, __u32 new_real_end,
-					    ext2fs_inode_bitmap bmap);
-extern errcode_t ext2fs_resize_block_bitmap(__u32 new_end, __u32 new_real_end,
-					    ext2fs_block_bitmap bmap);
-extern errcode_t ext2fs_copy_bitmap(ext2fs_generic_bitmap src,
-				    ext2fs_generic_bitmap *dest);
-
 /* swapfs.c */
 extern void ext2fs_swap_ext_attr(char *to, char *from, int bufsize, 
 				 int has_header);
+extern void ext2fs_swap_ext_attr_header(struct ext2_ext_attr_header *to_header,
+					struct ext2_ext_attr_header *from_hdr);
+extern void ext2fs_swap_ext_attr_entry(struct ext2_ext_attr_entry *to_entry,
+				       struct ext2_ext_attr_entry *from_entry);
 extern void ext2fs_swap_super(struct ext2_super_block * super);
 extern void ext2fs_swap_group_desc(struct ext2_group_desc *gdp);
 extern void ext2fs_swap_inode_full(ext2_filsys fs, struct ext2_inode_large *t,
diff -Nurp e2fsprogs-1.40.8/lib/ext2fs/ext2_io.h e2fsprogs/lib/ext2fs/ext2_io.h
--- e2fsprogs-1.40.8/lib/ext2fs/ext2_io.h	2008-03-13 23:20:46.000000000 +0100
+++ e2fsprogs/lib/ext2fs/ext2_io.h	2008-03-29 01:20:43.000000000 +0100
@@ -26,6 +26,7 @@ ext2_loff_t ext2fs_llseek (int, ext2_lof
 
 typedef struct struct_io_manager *io_manager;
 typedef struct struct_io_channel *io_channel;
+typedef struct struct_io_stats *io_stats;
 
 #define CHANNEL_FLAGS_WRITETHROUGH	0x01
 
@@ -55,6 +56,13 @@ struct struct_io_channel {
 	void		*app_data;
 };
 
+struct struct_io_stats {
+	int			num_fields;
+	int			reserved;
+	unsigned long long	bytes_read;
+	unsigned long long	bytes_written;
+};
+
 struct struct_io_manager {
 	errcode_t magic;
 	const char *name;
@@ -70,7 +78,12 @@ struct struct_io_manager {
 				int count, const void *data);
 	errcode_t (*set_option)(io_channel channel, const char *option, 
 				const char *arg);
-	int		reserved[14];
+	errcode_t (*get_stats)(io_channel channel, io_stats *io_stats);
+	errcode_t (*read_blk64)(io_channel channel, unsigned long long block,
+					int count, void *data);
+	errcode_t (*write_blk64)(io_channel channel, unsigned long long block,
+					int count, const void *data);
+	int		reserved[16];
 };
 
 #define IO_FLAG_RW		0x0001
@@ -82,7 +95,9 @@ struct struct_io_manager {
 #define io_channel_close(c) 		((c)->manager->close((c)))
 #define io_channel_set_blksize(c,s)	((c)->manager->set_blksize((c),s))
 #define io_channel_read_blk(c,b,n,d)	((c)->manager->read_blk((c),b,n,d))
+#define io_channel_read_blk64(c,b,n,d)	((c)->manager->read_blk64((c),b,n,d))
 #define io_channel_write_blk(c,b,n,d)	((c)->manager->write_blk((c),b,n,d))
+#define io_channel_write_blk64(c,b,n,d) ((c)->manager->write_blk64((c),b,n,d))
 #define io_channel_flush(c) 		((c)->manager->flush((c)))
 #define io_channel_bumpcount(c)		((c)->refcount++)
 	
diff -Nurp e2fsprogs-1.40.8/lib/ext2fs/ext3_extents.h e2fsprogs/lib/ext2fs/ext3_extents.h
--- e2fsprogs-1.40.8/lib/ext2fs/ext3_extents.h	2008-03-13 23:20:46.000000000 +0100
+++ e2fsprogs/lib/ext2fs/ext3_extents.h	2008-03-29 01:20:43.000000000 +0100
@@ -126,6 +126,26 @@ struct ext3_ext_path {
 #define EXT_MAX_BLOCK	0xffffffff
 #define EXT_CACHE_MARK	0xffff
 
+/*
+ * EXT_INIT_MAX_LEN is the maximum number of blocks we can have in an
+ * initialized extent. This is 2^15 and not (2^16 - 1), since we use the
+ * MSB of ee_len field in the extent datastructure to signify if this
+ * particular extent is an initialized extent or an uninitialized (i.e.
+ * preallocated).
+ * EXT_UNINIT_MAX_LEN is the maximum number of blocks we can have in an
+ * uninitialized extent.
+ * If ee_len is <= 0x8000, it is an initialized extent. Otherwise, it is an
+ * uninitialized one. In other words, if MSB of ee_len is set, it is an
+ * uninitialized extent with only one special scenario when ee_len = 0x8000.
+ * In this case we can not have an uninitialized extent of zero length and
+ * thus we make it as a special case of initialized extent with 0x8000 length.
+ * This way we get better extent-to-group alignment for initialized extents.
+ * Hence, the maximum number of blocks we can have in an *initialized*
+ * extent is 2^15 (32768) and in an *uninitialized* extent is 2^15-1 (32767).
+ */
+#define EXT_INIT_MAX_LEN	(1UL << 15)
+#define EXT_UNINIT_MAX_LEN	(EXT_INIT_MAX_LEN - 1)
+
 
 #define EXT_FIRST_EXTENT(__hdr__) \
 	((struct ext3_extent *) (((char *) (__hdr__)) +		\
diff -Nurp e2fsprogs-1.40.8/lib/ext2fs/ext_attr.c e2fsprogs/lib/ext2fs/ext_attr.c
--- e2fsprogs-1.40.8/lib/ext2fs/ext_attr.c	2008-03-13 23:20:46.000000000 +0100
+++ e2fsprogs/lib/ext2fs/ext_attr.c	2008-03-29 01:20:43.000000000 +0100
@@ -23,6 +23,43 @@
 
 #include "ext2fs.h"
 
+#define NAME_HASH_SHIFT 5
+#define VALUE_HASH_SHIFT 16
+
+/*
+ * ext2_xattr_hash_entry()
+ *
+ * Compute the hash of an extended attribute.
+ */
+__u32 ext2fs_ext_attr_hash_entry(struct ext2_ext_attr_entry *entry, void *data)
+{
+	__u32 hash = 0;
+	char *name = ((char *) entry) + sizeof(struct ext2_ext_attr_entry);
+	int n;
+
+	for (n = 0; n < entry->e_name_len; n++) {
+		hash = (hash << NAME_HASH_SHIFT) ^
+		       (hash >> (8*sizeof(hash) - NAME_HASH_SHIFT)) ^
+		       *name++;
+	}
+
+	/* The hash needs to be calculated on the data in little-endian. */
+	if (entry->e_value_block == 0 && entry->e_value_size != 0) {
+		__u32 *value = (__u32 *)data;
+		for (n = (entry->e_value_size + EXT2_EXT_ATTR_ROUND) >>
+			 EXT2_EXT_ATTR_PAD_BITS; n; n--) {
+			hash = (hash << VALUE_HASH_SHIFT) ^
+			       (hash >> (8*sizeof(hash) - VALUE_HASH_SHIFT)) ^
+			       ext2fs_le32_to_cpu(*value++);
+		}
+	}
+
+	return hash;
+}
+
+#undef NAME_HASH_SHIFT
+#undef VALUE_HASH_SHIFT
+
 errcode_t ext2fs_read_ext_attr(ext2_filsys fs, blk_t block, void *buf)
 {
 	errcode_t	retval;
@@ -30,10 +67,8 @@ errcode_t ext2fs_read_ext_attr(ext2_fils
  	retval = io_channel_read_blk(fs->io, block, 1, buf);
 	if (retval)
 		return retval;
-#ifdef EXT2FS_ENABLE_SWAPFS
-	if ((fs->flags & (EXT2_FLAG_SWAP_BYTES|
-			  EXT2_FLAG_SWAP_BYTES_READ)) != 0)
-		ext2fs_swap_ext_attr(buf, buf, fs->blocksize, 1);
+#ifdef WORDS_BIGENDIAN
+	ext2fs_swap_ext_attr(buf, buf, fs->blocksize, 1);
 #endif
 	return 0;
 }
@@ -44,17 +79,15 @@ errcode_t ext2fs_write_ext_attr(ext2_fil
 	char		*write_buf;
 	char		*buf = NULL;
 
-#ifdef EXT2FS_ENABLE_SWAPFS
-	if ((fs->flags & EXT2_FLAG_SWAP_BYTES) ||
-	    (fs->flags & EXT2_FLAG_SWAP_BYTES_WRITE)) {
-		retval = ext2fs_get_mem(fs->blocksize, &buf);
-		if (retval)
-			return retval;
-		write_buf = buf;
-		ext2fs_swap_ext_attr(buf, inbuf, fs->blocksize, 1);
-	} else
+#ifdef WORDS_BIGENDIAN
+	retval = ext2fs_get_mem(fs->blocksize, &buf);
+	if (retval)
+		return retval;
+	write_buf = buf;
+	ext2fs_swap_ext_attr(buf, inbuf, fs->blocksize, 1);
+#else
+	write_buf = (char *) inbuf;
 #endif
-		write_buf = (char *) inbuf;
  	retval = io_channel_write_blk(fs->io, block, 1, write_buf);
 	if (buf)
 		ext2fs_free_mem(&buf);
diff -Nurp e2fsprogs-1.40.8/lib/ext2fs/extent.c e2fsprogs/lib/ext2fs/extent.c
--- e2fsprogs-1.40.8/lib/ext2fs/extent.c	1970-01-01 01:00:00.000000000 +0100
+++ e2fsprogs/lib/ext2fs/extent.c	2008-03-29 01:20:43.000000000 +0100
@@ -0,0 +1,1149 @@
+/*
+ * extent.c --- routines to implement extents support
+ *
+ * Copyright (C) 2007 Theodore Ts'o.
+ *
+ * %Begin-Header%
+ * This file may be redistributed under the terms of the GNU Public
+ * License.
+ * %End-Header%
+ */
+
+#include <stdio.h>
+#include <string.h>
+#if HAVE_UNISTD_H
+#include <unistd.h>
+#endif
+#if HAVE_ERRNO_H
+#include <errno.h>
+#endif
+#if HAVE_SYS_STAT_H
+#include <sys/stat.h>
+#endif
+#if HAVE_SYS_TYPES_H
+#include <sys/types.h>
+#endif
+
+#include "ext2_fs.h"
+#include "ext2fsP.h"
+#include "e2image.h"
+#include "ss/ss.h"
+
+/*
+ * Definitions to be dropped in lib/ext2fs/ext2fs.h
+ */
+
+/*
+ * Private definitions
+ */
+
+struct extent_path {
+	char		*buf;
+	int		entries;
+	int		max_entries;
+	int		left;
+	int		visit_num;
+	int		flags;
+	blk64_t		end_blk;
+	void		*curr;
+};
+
+
+struct ext2_extent_handle {
+	errcode_t		magic;
+	ext2_filsys		fs;
+	ext2_ino_t 		ino;
+	struct ext2_inode	*inode;
+	int			type;
+	int			level;
+	int			max_depth;
+	struct extent_path	*path;
+};
+
+struct ext2_extent_path {
+	errcode_t		magic;
+	int			leaf_height;
+	blk64_t			lblk;
+};
+
+/*
+ *  Useful Debugging stuff
+ */
+
+#ifdef DEBUG
+static void dbg_show_header(struct ext3_extent_header *eh)
+{
+	printf("header: magic=%x entries=%u max=%u depth=%u generation=%u\n",
+	       eh->eh_magic, eh->eh_entries, eh->eh_max, eh->eh_depth,
+	       eh->eh_generation);
+}
+
+static void dbg_show_index(struct ext3_extent_idx *ix)
+{
+	printf("index: block=%u leaf=%u leaf_hi=%u unused=%u\n",
+	       ix->ei_block, ix->ei_leaf, ix->ei_leaf_hi, ix->ei_unused);
+}
+
+static void dbg_show_extent(struct ext3_extent *ex)
+{
+	printf("extent: block=%u-%u len=%u start=%u start_hi=%u\n",
+	       ex->ee_block, ex->ee_block + ex->ee_len - 1,
+	       ex->ee_len, ex->ee_start, ex->ee_start_hi);
+}
+
+static void dbg_print_extent(char *desc, struct ext2fs_extent *extent)
+{
+	if (desc)
+		printf("%s: ", desc);
+	printf("extent: lblk %llu--%llu, len %lu, pblk %llu, flags: ",
+	       extent->e_lblk, extent->e_lblk + extent->e_len - 1,
+	       extent->e_len, extent->e_pblk);
+	if (extent->e_flags & EXT2_EXTENT_FLAGS_LEAF)
+		fputs("LEAF ", stdout);
+	if (extent->e_flags & EXT2_EXTENT_FLAGS_UNINIT)
+		fputs("UNINIT ", stdout);
+	if (extent->e_flags & EXT2_EXTENT_FLAGS_SECOND_VISIT)
+		fputs("2ND_VISIT ", stdout);
+	if (!extent->e_flags)
+		fputs("(none)", stdout);
+	fputc('\n', stdout);
+
+}
+
+#define dbg_printf(fmt, args...) printf(fmt, ## args)
+#else
+#define dbg_show_header(eh) do { } while (0)
+#define dbg_show_index(ix) do { } while (0)
+#define dbg_show_extent(ex) do { } while (0)
+#define dbg_print_extent(desc, ex) do { } while (0)
+#define dbg_printf(fmt, args...) do { } while (0)
+#endif
+
+/*
+ * Verify the extent header as being sane
+ */
+errcode_t ext2fs_extent_header_verify(void *ptr, int size)
+{
+	int eh_max, entry_size;
+	struct ext3_extent_header *eh = ptr;
+
+	dbg_show_header(eh);
+	if (ext2fs_le16_to_cpu(eh->eh_magic) != EXT3_EXT_MAGIC)
+		return EXT2_ET_EXTENT_HEADER_BAD;
+	if (ext2fs_le16_to_cpu(eh->eh_entries) > ext2fs_le16_to_cpu(eh->eh_max))
+		return EXT2_ET_EXTENT_HEADER_BAD;
+	if (eh->eh_depth == 0)
+		entry_size = sizeof(struct ext3_extent);
+	else
+		entry_size = sizeof(struct ext3_extent_idx);
+
+	eh_max = (size - sizeof(*eh)) / entry_size;
+	/* Allow two extent-sized items at the end of the block, for
+	 * ext4_extent_tail with checksum in the future. */
+	if ((ext2fs_le16_to_cpu(eh->eh_max) > eh_max) || 
+	    (ext2fs_le16_to_cpu(eh->eh_max) < (eh_max - 2)))
+		return EXT2_ET_EXTENT_HEADER_BAD;
+
+	return 0;
+}
+
+
+/*
+ * Begin functions to handle an inode's extent information
+ */
+extern void ext2fs_extent_free(ext2_extent_handle_t handle)
+{
+	int			i;
+
+	if (!handle)
+		return;
+
+	if (handle->inode)
+		ext2fs_free_mem(&handle->inode);
+	if (handle->path) {
+		for (i=1; i < handle->max_depth; i++) {
+			if (handle->path[i].buf)
+				ext2fs_free_mem(&handle->path[i].buf);
+		}
+		ext2fs_free_mem(&handle->path);
+	}
+	ext2fs_free_mem(&handle);
+}
+
+extern errcode_t ext2fs_extent_open(ext2_filsys fs, ext2_ino_t ino,
+				    ext2_extent_handle_t *ret_handle)
+{
+	struct ext2_extent_handle	*handle;
+	errcode_t			retval;
+	int				isize = EXT2_INODE_SIZE(fs->super);
+	struct ext3_extent_header	*eh;
+
+	EXT2_CHECK_MAGIC(fs, EXT2_ET_MAGIC_EXT2FS_FILSYS);
+
+	if ((ino == 0) || (ino > fs->super->s_inodes_count))
+		return EXT2_ET_BAD_INODE_NUM;
+
+	retval = ext2fs_get_mem(sizeof(struct ext2_extent_handle), &handle);
+	if (retval)
+		return retval;
+	memset(handle, 0, sizeof(struct ext2_extent_handle));
+
+	retval = ext2fs_get_mem(isize, &handle->inode);
+	if (retval)
+		goto errout;
+
+	handle->ino = ino;
+	handle->fs = fs;
+
+	retval = ext2fs_read_inode_full(fs, ino, handle->inode, isize);
+	if (retval)
+		goto errout;
+
+	if (!(handle->inode->i_flags & EXT4_EXTENTS_FL))
+		return EXT2_ET_INODE_NOT_EXTENT;
+
+	eh = (struct ext3_extent_header *) &handle->inode->i_block[0];
+
+	retval = ext2fs_extent_header_verify(eh, sizeof(handle->inode->i_block));
+	if (retval)
+		return (retval);
+
+	handle->max_depth = ext2fs_le16_to_cpu(eh->eh_depth);
+	handle->type = ext2fs_le16_to_cpu(eh->eh_magic);
+
+	retval = ext2fs_get_mem(((handle->max_depth+1) *
+				 sizeof(struct extent_path)),
+				&handle->path);
+	memset(handle->path, 0,
+	       (handle->max_depth+1) * sizeof(struct extent_path));
+	handle->path[0].buf = (char *) handle->inode->i_block;
+
+	handle->path[0].left = handle->path[0].entries =
+		ext2fs_le16_to_cpu(eh->eh_entries);
+	handle->path[0].max_entries = ext2fs_le16_to_cpu(eh->eh_max);
+	handle->path[0].curr = 0;
+	handle->path[0].end_blk =
+		((((__u64) handle->inode->i_size_high << 32) +
+		  handle->inode->i_size + (fs->blocksize - 1))
+		 >> EXT2_BLOCK_SIZE_BITS(fs->super));
+	handle->path[0].visit_num = 1;
+	handle->level = 0;
+	handle->magic = EXT2_ET_MAGIC_EXTENT_HANDLE;
+
+	*ret_handle = handle;
+	return 0;
+
+errout:
+	ext2fs_extent_free(handle);
+	return retval;
+}
+
+/*
+ * This function is responsible for (optionally) moving through the
+ * extent tree and then returning the current extent
+ */
+errcode_t ext2fs_extent_get(ext2_extent_handle_t handle,
+			    int flags, struct ext2fs_extent *extent)
+{
+	struct extent_path	*path, *newpath;
+	struct ext3_extent_header	*eh;
+	struct ext3_extent_idx		*ix = 0;
+	struct ext3_extent		*ex;
+	errcode_t			retval;
+	blk_t				blk;
+	blk64_t				end_blk;
+	int				orig_op, op;
+
+	EXT2_CHECK_MAGIC(handle, EXT2_ET_MAGIC_EXTENT_HANDLE);
+
+	if (!handle->path)
+		return EXT2_ET_NO_CURRENT_NODE;
+
+	orig_op = op = flags & EXT2_EXTENT_MOVE_MASK;
+
+retry:
+	path = handle->path + handle->level;
+	if ((orig_op == EXT2_EXTENT_NEXT) ||
+	    (orig_op == EXT2_EXTENT_NEXT_LEAF)) {
+		if (handle->level < handle->max_depth) {
+			/* interior node */
+			if (path->visit_num == 0) {
+				path->visit_num++;
+				op = EXT2_EXTENT_DOWN;
+			} else if (path->left > 0)
+				op = EXT2_EXTENT_NEXT_SIB;
+			else if (handle->level > 0)
+				op = EXT2_EXTENT_UP;
+			else
+				return EXT2_ET_EXTENT_NO_NEXT;
+		} else {
+			/* leaf node */
+			if (path->left > 0)
+				op = EXT2_EXTENT_NEXT_SIB;
+			else if (handle->level > 0)
+				op = EXT2_EXTENT_UP;
+			else
+				return EXT2_ET_EXTENT_NO_NEXT;
+		}
+		if (op != EXT2_EXTENT_NEXT_SIB) {
+			dbg_printf("<<<< OP = %s\n",
+			       (op == EXT2_EXTENT_DOWN) ? "down" :
+			       ((op == EXT2_EXTENT_UP) ? "up" : "unknown"));
+		}
+	}
+
+	if ((orig_op == EXT2_EXTENT_PREV) ||
+	    (orig_op == EXT2_EXTENT_PREV_LEAF)) {
+		if (handle->level < handle->max_depth) {
+			/* interior node */
+			if (path->visit_num > 0 ) {
+				/* path->visit_num = 0; */
+				op = EXT2_EXTENT_DOWN_AND_LAST;
+			} else if (path->left < path->entries-1)
+				op = EXT2_EXTENT_PREV_SIB;
+			else if (handle->level > 0)
+				op = EXT2_EXTENT_UP;
+			else
+				return EXT2_ET_EXTENT_NO_PREV;
+		} else {
+			/* leaf node */
+			if (path->left < path->entries-1)
+				op = EXT2_EXTENT_PREV_SIB;
+			else if (handle->level > 0)
+				op = EXT2_EXTENT_UP;
+			else
+				return EXT2_ET_EXTENT_NO_PREV;
+		}
+		if (op != EXT2_EXTENT_PREV_SIB) {
+			dbg_printf("<<<< OP = %s\n",
+			       (op == EXT2_EXTENT_DOWN_AND_LAST) ? "down/last" :
+			       ((op == EXT2_EXTENT_UP) ? "up" : "unknown"));
+		}
+	}
+
+	if (orig_op == EXT2_EXTENT_LAST_LEAF) {
+		if ((handle->level < handle->max_depth) &&
+		    (path->left == 0))
+			op = EXT2_EXTENT_DOWN;
+		else
+			op = EXT2_EXTENT_LAST_SIB;
+		dbg_printf("<<<< OP = %s\n",
+			   (op == EXT2_EXTENT_DOWN) ? "down" : "last_sib");
+	}
+
+	switch (op) {
+	case EXT2_EXTENT_CURRENT:
+		ix = path->curr;
+		break;
+	case EXT2_EXTENT_ROOT:
+		handle->level = 0;
+		path = handle->path + handle->level;
+	case EXT2_EXTENT_FIRST_SIB:
+		path->left = path->entries;
+		path->curr = 0;
+	case EXT2_EXTENT_NEXT_SIB:
+		if (path->left <= 0)
+			return EXT2_ET_EXTENT_NO_NEXT;
+		if (path->curr) {
+			ix = path->curr;
+			ix++;
+		} else {
+			eh = (struct ext3_extent_header *) path->buf;
+			ix = EXT_FIRST_INDEX(eh);
+		}
+		path->left--;
+		path->curr = ix;
+		path->visit_num = 0;
+		break;
+	case EXT2_EXTENT_PREV_SIB:
+		if (!path->curr ||
+		    path->left+1 >= path->entries)
+			return EXT2_ET_EXTENT_NO_PREV;
+		ix = path->curr;
+		ix--;
+		path->curr = ix;
+		path->left++;
+		if (handle->level < handle->max_depth)
+			path->visit_num = 1;
+		break;
+	case EXT2_EXTENT_LAST_SIB:
+		eh = (struct ext3_extent_header *) path->buf;
+		path->curr = EXT_LAST_EXTENT(eh);
+		ix = path->curr;
+		path->left = 0;
+		path->visit_num = 0;
+		break;
+	case EXT2_EXTENT_UP:
+		if (handle->level <= 0)
+			return EXT2_ET_EXTENT_NO_UP;
+		handle->level--;
+		path--;
+		ix = path->curr;
+		if ((orig_op == EXT2_EXTENT_PREV) ||
+		    (orig_op == EXT2_EXTENT_PREV_LEAF))
+			path->visit_num = 0;
+		break;
+	case EXT2_EXTENT_DOWN:
+	case EXT2_EXTENT_DOWN_AND_LAST:
+		if (!path->curr ||(handle->level >= handle->max_depth))
+			return EXT2_ET_EXTENT_NO_DOWN;
+
+		ix = path->curr;
+		newpath = path + 1;
+		if (!newpath->buf) {
+			retval = ext2fs_get_mem(handle->fs->blocksize,
+						&newpath->buf);
+			if (retval)
+				return retval;
+		}
+		blk = ext2fs_le32_to_cpu(ix->ei_leaf) +
+			((__u64) ext2fs_le16_to_cpu(ix->ei_leaf_hi) << 32);
+		if ((handle->fs->flags & EXT2_FLAG_IMAGE_FILE) &&
+		    (handle->fs->io != handle->fs->image_io))
+			memset(newpath->buf, 0, handle->fs->blocksize);
+		else {
+			retval = io_channel_read_blk(handle->fs->io,
+						     blk, 1, newpath->buf);
+			if (retval)
+				return retval;
+		}
+		handle->level++;
+
+		eh = (struct ext3_extent_header *) newpath->buf;
+
+		retval = ext2fs_extent_header_verify(eh, handle->fs->blocksize);
+		if (retval)
+			return retval;
+
+		newpath->left = newpath->entries =
+			ext2fs_le16_to_cpu(eh->eh_entries);
+		newpath->max_entries = ext2fs_le16_to_cpu(eh->eh_max);
+
+		if (path->left > 0) {
+			ix++;
+			newpath->end_blk = ext2fs_le32_to_cpu(ix->ei_block);
+		} else
+			newpath->end_blk = path->end_blk;
+
+		path = newpath;
+		if (op == EXT2_EXTENT_DOWN) {
+			ix = EXT_FIRST_INDEX((struct ext3_extent_header *) eh);
+			path->curr = ix;
+			path->left = path->entries - 1;
+			path->visit_num = 0;
+		} else {
+			ix = EXT_LAST_INDEX((struct ext3_extent_header *) eh);
+			path->curr = ix;
+			path->left = 0;
+			if (handle->level < handle->max_depth)
+				path->visit_num = 1;
+		}
+
+		dbg_printf("Down to level %d/%d, end_blk=%llu\n",
+			   handle->level, handle->max_depth,
+			   path->end_blk);
+
+		break;
+	default:
+		return EXT2_ET_OP_NOT_SUPPORTED;
+	}
+
+	if (!ix)
+		return EXT2_ET_NO_CURRENT_NODE;
+
+	extent->e_flags = 0;
+	dbg_printf("(Left %d)\n", path->left);
+
+	if (handle->level == handle->max_depth) {
+		ex = (struct ext3_extent *) ix;
+
+		extent->e_pblk = ext2fs_le32_to_cpu(ex->ee_start) +
+			((__u64) ext2fs_le16_to_cpu(ex->ee_start_hi) << 32);
+		extent->e_lblk = ext2fs_le32_to_cpu(ex->ee_block);
+		extent->e_len = ext2fs_le16_to_cpu(ex->ee_len);
+		extent->e_flags |= EXT2_EXTENT_FLAGS_LEAF;
+		if (extent->e_len > EXT_INIT_MAX_LEN) {
+			extent->e_len -= EXT_INIT_MAX_LEN;
+			extent->e_flags |= EXT2_EXTENT_FLAGS_UNINIT;
+		}
+	} else {
+		extent->e_pblk = ext2fs_le32_to_cpu(ix->ei_leaf) +
+			((__u64) ext2fs_le16_to_cpu(ix->ei_leaf_hi) << 32);
+		extent->e_lblk = ext2fs_le32_to_cpu(ix->ei_block);
+		if (path->left > 0) {
+			ix++;
+			end_blk = ext2fs_le32_to_cpu(ix->ei_block);
+		} else
+			end_blk = path->end_blk;
+
+		extent->e_len = end_blk - extent->e_lblk;
+	}
+	if (path->visit_num)
+		extent->e_flags |= EXT2_EXTENT_FLAGS_SECOND_VISIT;
+
+	if (((orig_op == EXT2_EXTENT_NEXT_LEAF) ||
+	     (orig_op == EXT2_EXTENT_PREV_LEAF)) &&
+	    (handle->level != handle->max_depth))
+		goto retry;
+
+	if ((orig_op == EXT2_EXTENT_LAST_LEAF) &&
+	    ((handle->level != handle->max_depth) ||
+	     (path->left != 0)))
+		goto retry;
+
+	return 0;
+}
+
+static errcode_t update_path(ext2_extent_handle_t handle)
+{
+	blk64_t				blk;
+	errcode_t			retval;
+	struct ext3_extent_idx		*ix;
+
+	if (handle->level == 0) {
+		retval = ext2fs_write_inode_full(handle->fs, handle->ino,
+			   handle->inode, EXT2_INODE_SIZE(handle->fs->super));
+	} else {
+		ix = handle->path[handle->level - 1].curr;
+		blk = ext2fs_le32_to_cpu(ix->ei_leaf) +
+			((__u64) ext2fs_le16_to_cpu(ix->ei_leaf_hi) << 32);
+
+		retval = io_channel_write_blk(handle->fs->io,
+				      blk, 1, handle->path[handle->level].buf);
+	}
+	return retval;
+}
+
+#if 0
+errcode_t ext2fs_extent_save_path(ext2_extent_handle_t handle,
+				  ext2_extent_path_t *ret_path)
+{
+	ext2_extent_path_t	save_path;
+	struct ext2fs_extent	extent;
+	struct ext2_extent_info	info;
+	errcode_t		retval;
+
+	retval = ext2fs_extent_get(handle, EXT2_EXTENT_CURRENT, &extent);
+	if (retval)
+		return retval;
+
+	retval = ext2fs_extent_get_info(handle, &info);
+	if (retval)
+		return retval;
+
+	retval = ext2fs_get_mem(sizeof(struct ext2_extent_path), &save_path);
+	if (retval)
+		return retval;
+	memset(save_path, 0, sizeof(struct ext2_extent_path));
+
+	save_path->magic = EXT2_ET_MAGIC_EXTENT_PATH;
+	save_path->leaf_height = info.max_depth - info.curr_level - 1;
+	save_path->lblk = extent.e_lblk;
+
+	*ret_path = save_path;
+	return 0;
+}
+
+errcode_t ext2fs_extent_free_path(ext2_extent_path_t path)
+{
+	EXT2_CHECK_MAGIC(path, EXT2_ET_MAGIC_EXTENT_PATH);
+
+	ext2fs_free_mem(&path);
+	return 0;
+}
+#endif
+
+static errcode_t extent_goto(ext2_extent_handle_t handle,
+			     int leaf_level, blk64_t blk)
+{
+	struct ext2fs_extent	extent;
+	errcode_t		retval;
+
+	retval = ext2fs_extent_get(handle, EXT2_EXTENT_ROOT, &extent);
+	if (retval)
+		return retval;
+
+	dbg_print_extent("root", &extent);
+	while (1) {
+		if (handle->level - leaf_level == handle->max_depth) {
+			if ((blk >= extent.e_lblk) &&
+			    (blk < extent.e_lblk + extent.e_len))
+				return 0;
+			if (blk < extent.e_lblk)
+				return EXT2_ET_EXTENT_NOT_FOUND;
+			retval = ext2fs_extent_get(handle,
+						   EXT2_EXTENT_NEXT_SIB,
+						   &extent);
+			if (retval == EXT2_ET_EXTENT_NO_NEXT)
+				return EXT2_ET_EXTENT_NOT_FOUND;
+			if (retval)
+				return retval;
+			continue;
+		}
+
+		retval = ext2fs_extent_get(handle, EXT2_EXTENT_NEXT_SIB,
+					   &extent);
+		if (retval == EXT2_ET_EXTENT_NO_NEXT)
+			goto go_down;
+		if (retval)
+			return retval;
+
+		dbg_print_extent("next", &extent);
+		if (blk == extent.e_lblk)
+			goto go_down;
+		if (blk > extent.e_lblk)
+			continue;
+
+		retval = ext2fs_extent_get(handle, EXT2_EXTENT_PREV_SIB,
+					   &extent);
+		if (retval)
+			return retval;
+
+		dbg_print_extent("prev", &extent);
+
+	go_down:
+		retval = ext2fs_extent_get(handle, EXT2_EXTENT_DOWN,
+					   &extent);
+		if (retval)
+			return retval;
+
+		dbg_print_extent("down", &extent);
+	}
+}
+
+errcode_t ext2fs_extent_goto(ext2_extent_handle_t handle,
+			     blk64_t blk)
+{
+	return extent_goto(handle, 0, blk);
+}
+
+errcode_t ext2fs_extent_replace(ext2_extent_handle_t handle, 
+				int flags EXT2FS_ATTR((unused)),
+				struct ext2fs_extent *extent)
+{
+	struct extent_path		*path;
+	struct ext3_extent_idx		*ix;
+	struct ext3_extent		*ex;
+
+	EXT2_CHECK_MAGIC(handle, EXT2_ET_MAGIC_EXTENT_HANDLE);
+
+	if (!(handle->fs->flags & EXT2_FLAG_RW))
+		return EXT2_ET_RO_FILSYS;
+
+	if (!handle->path)
+		return EXT2_ET_NO_CURRENT_NODE;
+
+	path = handle->path + handle->level;
+	if (!path->curr)
+		return EXT2_ET_NO_CURRENT_NODE;
+
+	if (handle->level == handle->max_depth) {
+		ex = path->curr;
+
+		ex->ee_block = ext2fs_cpu_to_le32(extent->e_lblk);
+		ex->ee_start = ext2fs_cpu_to_le32(extent->e_pblk & 0xFFFFFFFF);
+		ex->ee_start_hi = ext2fs_cpu_to_le16(extent->e_pblk >> 32);
+		ex->ee_len = ext2fs_cpu_to_le16(extent->e_len);
+	} else {
+		ix = path->curr;
+
+		ix->ei_leaf = ext2fs_cpu_to_le32(extent->e_pblk & 0xFFFFFFFF);
+		ix->ei_leaf_hi = ext2fs_cpu_to_le16(extent->e_pblk >> 32);
+		ix->ei_block = ext2fs_cpu_to_le32(extent->e_lblk);
+		ix->ei_unused = 0;
+	}
+	update_path(handle);
+	return 0;
+}
+
+errcode_t ext2fs_extent_insert(ext2_extent_handle_t handle, int flags,
+				      struct ext2fs_extent *extent)
+{
+	struct extent_path		*path;
+	struct ext3_extent_idx		*ix;
+	struct ext3_extent_header	*eh;
+	errcode_t			retval;
+
+	EXT2_CHECK_MAGIC(handle, EXT2_ET_MAGIC_EXTENT_HANDLE);
+
+	if (!(handle->fs->flags & EXT2_FLAG_RW))
+		return EXT2_ET_RO_FILSYS;
+
+	if (!handle->path)
+		return EXT2_ET_NO_CURRENT_NODE;
+
+	path = handle->path + handle->level;
+
+	if (path->entries >= path->max_entries)
+		return EXT2_ET_CANT_INSERT_EXTENT;
+
+	eh = (struct ext3_extent_header *) path->buf;
+	if (path->curr) {
+		ix = path->curr;
+		if (flags & EXT2_EXTENT_INSERT_AFTER) {
+			ix++;
+			path->left--;
+		}
+	} else
+		ix = EXT_FIRST_INDEX(eh);
+
+	path->curr = ix;
+
+	if (path->left > 0)
+		memmove(ix + 1, ix,
+			(path->left+1) * sizeof(struct ext3_extent_idx));
+	path->left++;
+	path->entries++;
+
+	eh = (struct ext3_extent_header *) path->buf;
+	eh->eh_entries = ext2fs_cpu_to_le16(path->entries);
+
+	retval = ext2fs_extent_replace(handle, 0, extent);
+	if (retval)
+		goto errout;
+
+	retval = update_path(handle);
+	if (retval)
+		goto errout;
+
+	return 0;
+
+errout:
+	ext2fs_extent_delete(handle, 0);
+	return retval;
+}
+
+errcode_t ext2fs_extent_delete(ext2_extent_handle_t handle, 
+			       int flags EXT2FS_ATTR((unused)))
+{
+	struct extent_path		*path;
+	char 				*cp;
+	struct ext3_extent_header	*eh;
+	errcode_t			retval;
+
+	EXT2_CHECK_MAGIC(handle, EXT2_ET_MAGIC_EXTENT_HANDLE);
+
+	if (!(handle->fs->flags & EXT2_FLAG_RW))
+		return EXT2_ET_RO_FILSYS;
+
+	if (!handle->path)
+		return EXT2_ET_NO_CURRENT_NODE;
+
+	path = handle->path + handle->level;
+	if (!path->curr)
+		return EXT2_ET_NO_CURRENT_NODE;
+
+	cp = path->curr;
+
+	if (path->left) {
+		memmove(cp, cp + sizeof(struct ext3_extent_idx),
+			path->left * sizeof(struct ext3_extent_idx));
+		path->left--;
+	} else {
+		struct ext3_extent_idx	*ix = path->curr;
+		ix--;
+		path->curr = ix;
+	}
+	path->entries--;
+	if (path->entries == 0)
+		path->curr = 0;
+
+	eh = (struct ext3_extent_header *) path->buf;
+	eh->eh_entries = ext2fs_cpu_to_le16(path->entries);
+
+	retval = update_path(handle);
+
+	return retval;
+}
+
+errcode_t ext2fs_extent_get_info(ext2_extent_handle_t handle,
+				 struct ext2_extent_info *info)
+{
+	struct extent_path		*path;
+
+	EXT2_CHECK_MAGIC(handle, EXT2_ET_MAGIC_EXTENT_HANDLE);
+
+	memset(info, 0, sizeof(struct ext2_extent_info));
+
+	path = handle->path + handle->level;
+	if (path) {
+		if (path->curr)
+			info->curr_entry = ((char *) path->curr - path->buf) /
+				sizeof(struct ext3_extent_idx);
+		else
+			info->curr_entry = 0;
+		info->num_entries = path->entries;
+		info->max_entries = path->max_entries;
+		info->bytes_avail = (path->max_entries - path->entries) *
+			sizeof(struct ext3_extent);
+	}
+
+	info->curr_level = handle->level;
+	info->max_depth = handle->max_depth;
+	info->max_lblk = ((__u64) 1 << 32) - 1;
+	info->max_pblk = ((__u64) 1 << 48) - 1;
+	info->max_len = (1UL << 15);
+	info->max_uninit_len = (1UL << 15) - 1;
+
+	return 0;
+}
+
+#ifdef DEBUG
+
+#include "debugfs.h"
+
+/*
+ * Hook in new commands into debugfs
+ */
+const char *debug_prog_name = "tst_extents";
+extern ss_request_table extent_cmds;
+ss_request_table *extra_cmds = &extent_cmds;
+
+ext2_ino_t	current_ino = 0;
+ext2_extent_handle_t current_handle;
+
+void do_inode(int argc, char *argv[])
+{
+	ext2_ino_t	inode;
+	int		i;
+	struct ext3_extent_header *eh;
+	errcode_t retval;
+
+	if (check_fs_open(argv[0]))
+		return;
+
+	if (argc == 1) {
+		if (current_ino)
+			printf("Current inode is %d\n", current_ino);
+		else
+			printf("No current inode\n");
+		return;
+	}
+
+	if (common_inode_args_process(argc, argv, &inode, 0)) {
+		return;
+	}
+
+	current_ino = 0;
+
+	retval = ext2fs_extent_open(current_fs, inode, &current_handle);
+	if (retval) {
+		com_err(argv[1], retval, "while opening extent handle");
+		return;
+	}
+
+	current_ino = inode;
+
+	printf("Loaded inode %d\n", current_ino);
+
+	return;
+}
+
+void generic_goto_node(char *cmd_name, int op)
+{
+	struct ext2fs_extent	extent;
+	errcode_t		retval;
+
+	if (check_fs_open(cmd_name))
+		return;
+
+	if (!current_handle) {
+		com_err(cmd_name, 0, "Extent handle not open");
+		return;
+	}
+
+	retval = ext2fs_extent_get(current_handle, op, &extent);
+	if (retval) {
+		com_err(cmd_name, retval, 0);
+		return;
+	}
+	dbg_print_extent(0, &extent);
+}
+
+void do_current_node(int argc, char *argv[])
+{
+	generic_goto_node(argv[0], EXT2_EXTENT_CURRENT);
+}
+
+void do_root_node(int argc, char *argv[])
+{
+	generic_goto_node(argv[0], EXT2_EXTENT_ROOT);
+}
+
+void do_last_leaf(int argc, char *argv[])
+{
+	generic_goto_node(argv[0], EXT2_EXTENT_LAST_LEAF);
+}
+
+void do_first_sib(int argc, char *argv[])
+{
+	generic_goto_node(argv[0], EXT2_EXTENT_FIRST_SIB);
+}
+
+void do_last_sib(int argc, char *argv[])
+{
+	generic_goto_node(argv[0], EXT2_EXTENT_LAST_SIB);
+}
+
+void do_next_sib(int argc, char *argv[])
+{
+	generic_goto_node(argv[0], EXT2_EXTENT_NEXT_SIB);
+}
+
+void do_prev_sib(int argc, char *argv[])
+{
+	generic_goto_node(argv[0], EXT2_EXTENT_PREV_SIB);
+}
+
+void do_next_leaf(int argc, char *argv[])
+{
+	generic_goto_node(argv[0], EXT2_EXTENT_NEXT_LEAF);
+}
+
+void do_prev_leaf(int argc, char *argv[])
+{
+	generic_goto_node(argv[0], EXT2_EXTENT_PREV_LEAF);
+}
+
+void do_next(int argc, char *argv[])
+{
+	generic_goto_node(argv[0], EXT2_EXTENT_NEXT);
+}
+
+void do_prev(int argc, char *argv[])
+{
+	generic_goto_node(argv[0], EXT2_EXTENT_PREV);
+}
+
+void do_up(int argc, char *argv[])
+{
+	generic_goto_node(argv[0], EXT2_EXTENT_UP);
+}
+
+void do_down(int argc, char *argv[])
+{
+	generic_goto_node(argv[0], EXT2_EXTENT_DOWN);
+}
+
+void do_delete_node(int argc, char *argv[])
+{
+	errcode_t	retval;
+	int		err;
+
+	if (check_fs_read_write(argv[0]))
+		return;
+
+	retval = ext2fs_extent_delete(current_handle, 0);
+	if (retval) {
+		com_err(argv[0], retval, 0);
+		return;
+	}
+	do_current_node(argc, argv);
+}
+
+void do_replace_node(int argc, char *argv[])
+{
+	errcode_t	retval;
+	struct ext2fs_extent extent;
+	int err;
+
+	if (check_fs_read_write(argv[0]))
+		return;
+
+	if (argc != 4) {
+		fprintf(stderr, "usage: %s <lblk> <len> <pblk>\n", argv[0]);
+		return;
+	}
+
+	extent.e_lblk = parse_ulong(argv[1], argv[0],
+				    "logical block", &err);
+	if (err)
+		return;
+
+	extent.e_len = parse_ulong(argv[2], argv[0],
+				    "logical block", &err);
+	if (err)
+		return;
+
+	extent.e_pblk = parse_ulong(argv[3], argv[0],
+				    "logical block", &err);
+	if (err)
+		return;
+
+	retval = ext2fs_extent_replace(current_handle, 0, &extent);
+	if (retval) {
+		com_err(argv[0], retval, 0);
+		return;
+	}
+	do_current_node(argc, argv);
+}
+
+void do_insert_node(int argc, char *argv[])
+{
+	errcode_t	retval;
+	struct ext2fs_extent extent;
+	char *cmd;
+	int err;
+	int flags = 0;
+
+	if (check_fs_read_write(argv[0]))
+		return;
+
+	cmd = argv[0];
+
+	if (argc > 2 && !strcmp(argv[1], "--after")) {
+		argc--;
+		argv++;
+		flags |= EXT2_EXTENT_INSERT_AFTER;
+	}
+
+	if (argc != 4) {
+		fprintf(stderr, "usage: %s <lblk> <len> <pblk>\n", cmd);
+		return;
+	}
+
+	extent.e_lblk = parse_ulong(argv[1], cmd,
+				    "logical block", &err);
+	if (err)
+		return;
+
+	extent.e_len = parse_ulong(argv[2], cmd,
+				    "length", &err);
+	if (err)
+		return;
+
+	extent.e_pblk = parse_ulong(argv[3], cmd,
+				    "pysical block", &err);
+	if (err)
+		return;
+
+	retval = ext2fs_extent_insert(current_handle, flags, &extent);
+	if (retval) {
+		com_err(cmd, retval, 0);
+		return;
+	}
+	do_current_node(argc, argv);
+}
+
+void do_print_all(int argc, char **argv)
+{
+	struct ext2fs_extent	extent;
+	errcode_t		retval;
+	errcode_t		end_err = EXT2_ET_EXTENT_NO_NEXT;
+	int			op = EXT2_EXTENT_NEXT;
+	int			first_op = EXT2_EXTENT_ROOT;
+
+
+	if (check_fs_open(argv[0]))
+		return;
+
+	if (!current_handle) {
+		com_err(argv[0], 0, "Extent handle not open");
+		return;
+	}
+
+	if (argc > 2) {
+	print_usage:
+		fprintf(stderr,
+			"Usage: %s [--leaf-only|--reverse|--reverse-leaf]\n",
+			argv[0]);
+		return;
+	}
+
+	if (argc == 2) {
+		if (!strcmp(argv[1], "--leaf-only"))
+			op = EXT2_EXTENT_NEXT_LEAF;
+		else if (!strcmp(argv[1], "--reverse")) {
+			op = EXT2_EXTENT_PREV;
+			first_op = EXT2_EXTENT_LAST_LEAF;
+			end_err = EXT2_ET_EXTENT_NO_PREV;
+		} else if (!strcmp(argv[1], "--reverse-leaf")) {
+			op = EXT2_EXTENT_PREV_LEAF;
+			first_op = EXT2_EXTENT_LAST_LEAF;
+			end_err = EXT2_ET_EXTENT_NO_PREV;
+		} else
+			  goto print_usage;
+	}
+
+	retval = ext2fs_extent_get(current_handle, first_op, &extent);
+	if (retval) {
+		com_err(argv[0], retval, 0);
+		return;
+	}
+	dbg_print_extent(0, &extent);
+
+	while (1) {
+		retval = ext2fs_extent_get(current_handle, op, &extent);
+		if (retval == end_err)
+			break;
+
+		if (retval) {
+			com_err(argv[0], retval, 0);
+			return;
+		}
+		dbg_print_extent(0, &extent);
+	}
+}
+
+void do_info(int argc, char **argv)
+{
+	struct ext2_extent_info	info;
+	errcode_t		retval;
+
+	if (check_fs_open(argv[0]))
+		return;
+
+	if (!current_handle) {
+		com_err(argv[0], 0, "Extent handle not open");
+		return;
+	}
+
+	retval = ext2fs_extent_get_info(current_handle, &info);
+	if (retval) {
+		com_err(argv[0], retval, 0);
+		return;
+	}
+
+	printf("Current handle location: %d/%d (max: %d, bytes %d), level %d/%d\n",
+	       info.curr_entry, info.num_entries, info.max_entries,
+	       info.bytes_avail, info.curr_level, info.max_depth);
+	printf("\tmax lblk: %llu, max pblk: %llu\n", info.max_lblk,
+	       info.max_pblk);
+	printf("\tmax_len: %u, max_uninit_len: %u\n", info.max_len,
+	       info.max_uninit_len);
+}
+
+void do_goto_block(int argc, char **argv)
+{
+	struct ext2fs_extent	extent;
+	errcode_t		retval;
+	int			op = EXT2_EXTENT_NEXT_LEAF;
+	blk_t			blk;
+
+	if (check_fs_open(argv[0]))
+		return;
+
+	if (!current_handle) {
+		com_err(argv[0], 0, "Extent handle not open");
+		return;
+	}
+
+	if (argc != 2) {
+		fprintf(stderr, "%s block\n", argv[0]);
+		return;
+	}
+
+	if (strtoblk(argv[0], argv[1], &blk))
+		return;
+
+	retval = ext2fs_extent_goto(current_handle, (blk64_t) blk);
+	if (retval) {
+		com_err(argv[0], retval, "while trying to go to block %lu",
+			blk);
+		return;
+	}
+
+	generic_goto_node(argv[0], EXT2_EXTENT_CURRENT);
+}
+#endif
+
diff -Nurp e2fsprogs-1.40.8/lib/ext2fs/extent_dbg.ct e2fsprogs/lib/ext2fs/extent_dbg.ct
--- e2fsprogs-1.40.8/lib/ext2fs/extent_dbg.ct	1970-01-01 01:00:00.000000000 +0100
+++ e2fsprogs/lib/ext2fs/extent_dbg.ct	2008-03-29 01:20:43.000000000 +0100
@@ -0,0 +1,68 @@
+#
+# Copyright (C) 1993 Theodore Ts'o.  This file may be redistributed
+# under the terms of the GNU Public License.
+#
+command_table extent_cmds;
+
+request do_inode, "Open an inode",
+	inode;
+
+request do_current_node, "Current extent node",
+	current_node, current;
+
+request do_root_node, "Goto root extent",
+	root_node, root;
+
+request do_last_leaf, "Goto last leaf",
+	last_leaf;
+
+request do_first_sib, "Goto first sibling",
+	first_sibling, first_sib;
+
+request do_last_sib, "Goto last sibling",
+	last_sibling, last_sib;
+
+request do_next_sib, "Goto next sibling",
+	next_sibling, next_sib, ns;
+
+request do_prev_sib, "Goto previous sibling",
+	prev_sibling, prev_sib, ps;
+
+request do_next_leaf, "Goto next leaf",
+	next_leaf, nl;
+
+request do_prev_leaf, "Goto previous leaf",
+	prev_leaf, pl;
+
+request do_next, "Goto next node",
+	next, n;
+
+request do_prev, "Goto previous node",
+	previous, prev, p;
+
+request do_up, "Up node",
+	up_node, up, u;
+
+request do_down, "Down node",
+	down_node, down, d;
+
+request do_delete_node, "Delete node",
+	delete_node, delete;
+
+request do_insert_node, "Insert node",
+	insert_node, insert;
+
+request do_replace_node, "Insert node",
+	replace_node, replace;
+
+request do_print_all, "Iterate over all nodes and print them",
+	print_all, all;
+
+request do_goto_block, "Goto extent containing specified block",
+	goto_block, goto;
+
+request do_info, "Print extent info",
+	info;
+
+end;
+
diff -Nurp e2fsprogs-1.40.8/lib/ext2fs/freefs.c e2fsprogs/lib/ext2fs/freefs.c
--- e2fsprogs-1.40.8/lib/ext2fs/freefs.c	2008-03-13 23:20:46.000000000 +0100
+++ e2fsprogs/lib/ext2fs/freefs.c	2008-03-29 01:20:43.000000000 +0100
@@ -58,41 +58,6 @@ void ext2fs_free(ext2_filsys fs)
 	ext2fs_free_mem(&fs);
 }
 
-void ext2fs_free_generic_bitmap(ext2fs_inode_bitmap bitmap)
-{
-	if (!bitmap || (bitmap->magic != EXT2_ET_MAGIC_GENERIC_BITMAP))
-		return;
-
-	bitmap->magic = 0;
-	if (bitmap->description) {
-		ext2fs_free_mem(&bitmap->description);
-		bitmap->description = 0;
-	}
-	if (bitmap->bitmap) {
-		ext2fs_free_mem(&bitmap->bitmap);
-		bitmap->bitmap = 0;
-	}
-	ext2fs_free_mem(&bitmap);
-}
-
-void ext2fs_free_inode_bitmap(ext2fs_inode_bitmap bitmap)
-{
-	if (!bitmap || (bitmap->magic != EXT2_ET_MAGIC_INODE_BITMAP))
-		return;
-
-	bitmap->magic = EXT2_ET_MAGIC_GENERIC_BITMAP;
-	ext2fs_free_generic_bitmap(bitmap);
-}
-
-void ext2fs_free_block_bitmap(ext2fs_block_bitmap bitmap)
-{
-	if (!bitmap || (bitmap->magic != EXT2_ET_MAGIC_BLOCK_BITMAP))
-		return;
-
-	bitmap->magic = EXT2_ET_MAGIC_GENERIC_BITMAP;
-	ext2fs_free_generic_bitmap(bitmap);
-}
-
 /*
  * Free the inode cache structure
  */
diff -Nurp e2fsprogs-1.40.8/lib/ext2fs/gen_bitmap.c e2fsprogs/lib/ext2fs/gen_bitmap.c
--- e2fsprogs-1.40.8/lib/ext2fs/gen_bitmap.c	2008-03-13 23:20:46.000000000 +0100
+++ e2fsprogs/lib/ext2fs/gen_bitmap.c	2008-03-29 01:20:43.000000000 +0100
@@ -1,5 +1,5 @@
 /*
- * gen_bitmap.c --- Generic bitmap routines that used to be inlined.
+ * gen_bitmap.c --- Generic (32-bit) bitmap routines
  * 
  * Copyright (C) 2001 Theodore Ts'o.
  *
@@ -27,6 +27,144 @@
 #include "ext2_fs.h"
 #include "ext2fs.h"
 
+struct ext2fs_struct_generic_bitmap {
+	errcode_t	magic;
+	ext2_filsys 	fs;
+	__u32		start, end;
+	__u32		real_end;
+	char	*	description;
+	char	*	bitmap;
+	errcode_t	base_error_code;
+	__u32		reserved[7];
+};
+
+/* 
+ * Used by previously inlined function, so we have to export this and
+ * not change the function signature
+ */
+void ext2fs_warn_bitmap2(ext2fs_generic_bitmap bitmap,
+			    int code, unsigned long arg)
+{
+#ifndef OMIT_COM_ERR
+	if (bitmap->description)
+		com_err(0, bitmap->base_error_code+code,
+			"#%lu for %s", arg, bitmap->description);
+	else
+		com_err(0, bitmap->base_error_code + code, "#%lu", arg);
+#endif
+}
+
+static errcode_t check_magic(ext2fs_generic_bitmap bitmap)
+{
+	if (!bitmap || !((bitmap->magic == EXT2_ET_MAGIC_GENERIC_BITMAP) ||
+			 (bitmap->magic == EXT2_ET_MAGIC_INODE_BITMAP) ||
+			 (bitmap->magic == EXT2_ET_MAGIC_BLOCK_BITMAP)))
+		return EXT2_ET_MAGIC_GENERIC_BITMAP;
+	return 0;
+}
+
+errcode_t ext2fs_make_generic_bitmap(errcode_t magic, ext2_filsys fs, 
+				     __u32 start, __u32 end, __u32 real_end,
+				     const char *descr, char *init_map,
+				     ext2fs_generic_bitmap *ret)
+{
+	ext2fs_generic_bitmap	bitmap;
+	errcode_t		retval;
+	size_t			size;
+
+	retval = ext2fs_get_mem(sizeof(struct ext2fs_struct_generic_bitmap), 
+				&bitmap);
+	if (retval)
+		return retval;
+
+	bitmap->magic = magic;
+	bitmap->fs = fs;
+	bitmap->start = start;
+	bitmap->end = end;
+	bitmap->real_end = real_end;
+	switch (magic) {
+	case EXT2_ET_MAGIC_INODE_BITMAP:
+		bitmap->base_error_code = EXT2_ET_BAD_INODE_MARK;
+		break;
+	case EXT2_ET_MAGIC_BLOCK_BITMAP:
+		bitmap->base_error_code = EXT2_ET_BAD_BLOCK_MARK;
+		break;
+	default:
+		bitmap->base_error_code = EXT2_ET_BAD_GENERIC_MARK;
+	}
+	if (descr) {
+		retval = ext2fs_get_mem(strlen(descr)+1, &bitmap->description);
+		if (retval) {
+			ext2fs_free_mem(&bitmap);
+			return retval;
+		}
+		strcpy(bitmap->description, descr);
+	} else
+		bitmap->description = 0;
+
+	size = (size_t) (((bitmap->real_end - bitmap->start) / 8) + 1);
+	retval = ext2fs_get_mem(size, &bitmap->bitmap);
+	if (retval) {
+		ext2fs_free_mem(&bitmap->description);
+		ext2fs_free_mem(&bitmap);
+		return retval;
+	}
+
+	if (init_map)
+		memcpy(bitmap->bitmap, init_map, size);
+	else
+		memset(bitmap->bitmap, 0, size);
+	*ret = bitmap;
+	return 0;
+}
+
+errcode_t ext2fs_allocate_generic_bitmap(__u32 start,
+					 __u32 end,
+					 __u32 real_end,
+					 const char *descr,
+					 ext2fs_generic_bitmap *ret)
+{
+	return ext2fs_make_generic_bitmap(EXT2_ET_MAGIC_GENERIC_BITMAP, 0, 
+					  start, end, real_end, descr, 0, ret);
+}
+
+errcode_t ext2fs_copy_generic_bitmap(ext2fs_generic_bitmap src,
+				     ext2fs_generic_bitmap *dest)
+{
+	return (ext2fs_make_generic_bitmap(src->magic, src->fs,
+					   src->start, src->end, 
+					   src->real_end,
+					   src->description, src->bitmap,
+					   dest));
+}
+
+void ext2fs_free_generic_bitmap(ext2fs_inode_bitmap bitmap)
+{
+	if (check_magic(bitmap))
+		return;
+
+	bitmap->magic = 0;
+	if (bitmap->description) {
+		ext2fs_free_mem(&bitmap->description);
+		bitmap->description = 0;
+	}
+	if (bitmap->bitmap) {
+		ext2fs_free_mem(&bitmap->bitmap);
+		bitmap->bitmap = 0;
+	}
+	ext2fs_free_mem(&bitmap);
+}
+
+int ext2fs_test_generic_bitmap(ext2fs_generic_bitmap bitmap,
+					blk_t bitno)
+{
+	if ((bitno < bitmap->start) || (bitno > bitmap->end)) {
+		ext2fs_warn_bitmap2(bitmap, EXT2FS_TEST_ERROR, bitno);
+		return 0;
+	}
+	return ext2fs_test_bit(bitno - bitmap->start, bitmap->bitmap);
+}
+
 int ext2fs_mark_generic_bitmap(ext2fs_generic_bitmap bitmap,
 					 __u32 bitno)
 {
@@ -46,3 +184,191 @@ int ext2fs_unmark_generic_bitmap(ext2fs_
 	}
 	return ext2fs_clear_bit(bitno - bitmap->start, bitmap->bitmap);
 }
+
+__u32 ext2fs_get_generic_bitmap_start(ext2fs_generic_bitmap bitmap)
+{
+	return bitmap->start;
+}
+
+__u32 ext2fs_get_generic_bitmap_end(ext2fs_generic_bitmap bitmap)
+{
+	return bitmap->end;
+}
+
+void ext2fs_clear_generic_bitmap(ext2fs_generic_bitmap bitmap)
+{
+	if (check_magic(bitmap))
+		return;
+
+	memset(bitmap->bitmap, 0,
+	       (size_t) (((bitmap->real_end - bitmap->start) / 8) + 1));
+}
+
+errcode_t ext2fs_fudge_generic_bitmap_end(ext2fs_inode_bitmap bitmap,
+					  errcode_t magic, errcode_t neq,
+					  ext2_ino_t end, ext2_ino_t *oend)
+{
+	EXT2_CHECK_MAGIC(bitmap, magic);
+	
+	if (end > bitmap->real_end)
+		return neq;
+	if (oend)
+		*oend = bitmap->end;
+	bitmap->end = end;
+	return 0;
+}
+
+errcode_t ext2fs_resize_generic_bitmap(errcode_t magic,
+				       __u32 new_end, __u32 new_real_end,
+				       ext2fs_generic_bitmap bmap)
+{
+	errcode_t	retval;
+	size_t		size, new_size;
+	__u32		bitno;
+
+	if (!bmap || (bmap->magic != magic))
+		return magic;
+
+	/*
+	 * If we're expanding the bitmap, make sure all of the new
+	 * parts of the bitmap are zero.
+	 */
+	if (new_end > bmap->end) {
+		bitno = bmap->real_end;
+		if (bitno > new_end)
+			bitno = new_end;
+		for (; bitno > bmap->end; bitno--)
+			ext2fs_clear_bit(bitno - bmap->start, bmap->bitmap);
+	}
+	if (new_real_end == bmap->real_end) {
+		bmap->end = new_end;
+		return 0;
+	}
+	
+	size = ((bmap->real_end - bmap->start) / 8) + 1;
+	new_size = ((new_real_end - bmap->start) / 8) + 1;
+
+	if (size != new_size) {
+		retval = ext2fs_resize_mem(size, new_size, &bmap->bitmap);
+		if (retval)
+			return retval;
+	}
+	if (new_size > size)
+		memset(bmap->bitmap + size, 0, new_size - size);
+
+	bmap->end = new_end;
+	bmap->real_end = new_real_end;
+	return 0;
+}
+
+errcode_t ext2fs_compare_generic_bitmap(errcode_t magic, errcode_t neq,
+					ext2fs_generic_bitmap bm1,
+					ext2fs_generic_bitmap bm2)
+{
+	blk_t	i;
+	
+	if (!bm1 || bm1->magic != magic)
+		return magic;
+	if (!bm2 || bm2->magic != magic)
+		return magic;
+
+	if ((bm1->start != bm2->start) ||
+	    (bm1->end != bm2->end) ||
+	    (memcmp(bm1->bitmap, bm2->bitmap,
+		    (size_t) (bm1->end - bm1->start)/8)))
+		return neq;
+
+	for (i = bm1->end - ((bm1->end - bm1->start) % 8); i <= bm1->end; i++)
+		if (ext2fs_fast_test_block_bitmap(bm1, i) !=
+		    ext2fs_fast_test_block_bitmap(bm2, i))
+			return neq;
+
+	return 0;
+}
+
+void ext2fs_set_generic_bitmap_padding(ext2fs_generic_bitmap map)
+{
+	__u32	i, j;
+
+	/* Protect loop from wrap-around if map->real_end is maxed */
+	for (i=map->end+1, j = i - map->start; 
+	     i <= map->real_end && i > map->end; 
+	     i++, j++)
+		ext2fs_set_bit(j, map->bitmap);
+}
+
+errcode_t ext2fs_get_generic_bitmap_range(ext2fs_generic_bitmap bmap,
+					  errcode_t magic,
+					  __u32 start, __u32 num,
+					  void *out)
+{
+	if (!bmap || (bmap->magic != magic))
+		return magic;
+
+	if ((start < bmap->start) || (start+num-1 > bmap->real_end))
+		return EXT2_ET_INVALID_ARGUMENT;
+
+	memcpy(out, bmap->bitmap + (start >> 3), (num+7) >> 3);
+	return 0;
+}
+
+errcode_t ext2fs_set_generic_bitmap_range(ext2fs_generic_bitmap bmap,
+					  errcode_t magic,
+					  __u32 start, __u32 num,
+					  void *in)
+{
+	if (!bmap || (bmap->magic != magic))
+		return magic;
+
+	if ((start < bmap->start) || (start+num-1 > bmap->real_end))
+		return EXT2_ET_INVALID_ARGUMENT;
+
+	memcpy(bmap->bitmap + (start >> 3), in, (num+7) >> 3);
+	return 0;
+}
+
+int ext2fs_test_block_bitmap_range(ext2fs_block_bitmap bitmap,
+				   blk_t block, int num)
+{
+	int	i;
+
+	if ((block < bitmap->start) || (block+num-1 > bitmap->real_end)) {
+		ext2fs_warn_bitmap(EXT2_ET_BAD_BLOCK_TEST,
+				   block, bitmap->description);
+		return 0;
+	}
+	for (i=0; i < num; i++) {
+		if (ext2fs_fast_test_block_bitmap(bitmap, block+i))
+			return 0;
+	}
+	return 1;
+}
+
+void ext2fs_mark_block_bitmap_range(ext2fs_block_bitmap bitmap,
+				    blk_t block, int num)
+{
+	int	i;
+	
+	if ((block < bitmap->start) || (block+num-1 > bitmap->end)) {
+		ext2fs_warn_bitmap(EXT2_ET_BAD_BLOCK_MARK, block,
+				   bitmap->description);
+		return;
+	}
+	for (i=0; i < num; i++)
+		ext2fs_fast_set_bit(block + i - bitmap->start, bitmap->bitmap);
+}
+
+void ext2fs_unmark_block_bitmap_range(ext2fs_block_bitmap bitmap,
+					       blk_t block, int num)
+{
+	int	i;
+	
+	if ((block < bitmap->start) || (block+num-1 > bitmap->end)) {
+		ext2fs_warn_bitmap(EXT2_ET_BAD_BLOCK_UNMARK, block,
+				   bitmap->description);
+		return;
+	}
+	for (i=0; i < num; i++)
+		ext2fs_fast_clear_bit(block + i - bitmap->start, 
+				      bitmap->bitmap);
+}
diff -Nurp e2fsprogs-1.40.8/lib/ext2fs/icount.c e2fsprogs/lib/ext2fs/icount.c
--- e2fsprogs-1.40.8/lib/ext2fs/icount.c	2008-03-13 19:57:37.000000000 +0100
+++ e2fsprogs/lib/ext2fs/icount.c	2008-03-29 01:20:43.000000000 +0100
@@ -43,7 +43,7 @@
 
 struct ext2_icount_el {
 	ext2_ino_t	ino;
-	__u16	count;
+	__u32		count;
 };
 
 struct ext2_icount {
@@ -60,6 +60,15 @@ struct ext2_icount {
 	TDB_CONTEXT		*tdb;
 };
 
+/*
+ * We now use a 32-bit counter field because it doesn't cost us
+ * anything extra for the in-memory data structure, due to alignment
+ * padding.  But there's no point changing the interface if most of
+ * the time we only care if the number is bigger than 65,000 or not.
+ * So use the following translation function to return a 16-bit count.
+ */
+#define icount_16_xlate(x) (((x) > 65500) ? 65500 : (x))
+
 void ext2fs_free_icount(ext2_icount_t icount)
 {
 	if (!icount)
@@ -398,7 +407,7 @@ static struct ext2_icount_el *get_icount
 }
 
 static errcode_t set_inode_count(ext2_icount_t icount, ext2_ino_t ino,
-				 __u16 count)
+				 __u32 count)
 {
 	struct ext2_icount_el 	*el;
 	TDB_DATA key, data;
@@ -407,7 +416,7 @@ static errcode_t set_inode_count(ext2_ic
 		key.dptr = (unsigned char *) &ino;
 		key.dsize = sizeof(ext2_ino_t);
 		data.dptr = (unsigned char *) &count;
-		data.dsize = sizeof(__u16);
+		data.dsize = sizeof(__u32);
 		if (count) {
 			if (tdb_store(icount->tdb, key, data, TDB_REPLACE))
 				return tdb_error(icount->tdb) +
@@ -429,7 +438,7 @@ static errcode_t set_inode_count(ext2_ic
 }
 
 static errcode_t get_inode_count(ext2_icount_t icount, ext2_ino_t ino,
-				 __u16 *count)
+				 __u32 *count)
 {
 	struct ext2_icount_el 	*el;
 	TDB_DATA key, data;
@@ -444,7 +453,7 @@ static errcode_t get_inode_count(ext2_ic
 			return tdb_error(icount->tdb) + EXT2_ET_TDB_SUCCESS;
 		}
 
-		*count = *((__u16 *) data.dptr);
+		*count = *((__u32 *) data.dptr);
 		free(data.dptr);
 		return 0;
 	}
@@ -483,6 +492,7 @@ errcode_t ext2fs_icount_validate(ext2_ic
 
 errcode_t ext2fs_icount_fetch(ext2_icount_t icount, ext2_ino_t ino, __u16 *ret)
 {
+	__u32	val;
 	EXT2_CHECK_MAGIC(icount, EXT2_ET_MAGIC_ICOUNT);
 
 	if (!ino || (ino > icount->num_inodes))
@@ -497,14 +507,15 @@ errcode_t ext2fs_icount_fetch(ext2_icoun
 		*ret = 0;
 		return 0;
 	}
-	get_inode_count(icount, ino, ret);
+	get_inode_count(icount, ino, &val);
+	*ret = icount_16_xlate(val);
 	return 0;
 }
 
 errcode_t ext2fs_icount_increment(ext2_icount_t icount, ext2_ino_t ino,
 				  __u16 *ret)
 {
-	__u16			curr_value;
+	__u32			curr_value;
 
 	EXT2_CHECK_MAGIC(icount, EXT2_ET_MAGIC_ICOUNT);
 
@@ -554,14 +565,14 @@ errcode_t ext2fs_icount_increment(ext2_i
 	if (icount->multiple)
 		ext2fs_mark_inode_bitmap(icount->multiple, ino);
 	if (ret)
-		*ret = curr_value;
+		*ret = icount_16_xlate(curr_value);
 	return 0;
 }
 
 errcode_t ext2fs_icount_decrement(ext2_icount_t icount, ext2_ino_t ino,
 				  __u16 *ret)
 {
-	__u16			curr_value;
+	__u32			curr_value;
 
 	if (!ino || (ino > icount->num_inodes))
 		return EXT2_ET_INVALID_ARGUMENT;
@@ -597,7 +608,7 @@ errcode_t ext2fs_icount_decrement(ext2_i
 		ext2fs_unmark_inode_bitmap(icount->multiple, ino);
 
 	if (ret)
-		*ret = curr_value;
+		*ret = icount_16_xlate(curr_value);
 	return 0;
 }
 
diff -Nurp e2fsprogs-1.40.8/lib/ext2fs/imager.c e2fsprogs/lib/ext2fs/imager.c
--- e2fsprogs-1.40.8/lib/ext2fs/imager.c	2008-03-13 23:20:46.000000000 +0100
+++ e2fsprogs/lib/ext2fs/imager.c	2008-03-29 01:20:43.000000000 +0100
@@ -277,11 +277,12 @@ errout:
  */
 errcode_t ext2fs_image_bitmap_write(ext2_filsys fs, int fd, int flags)
 {
-	char		*ptr;
-	int		c, size;
-	char		zero_buf[1024];
-	ssize_t		actual;
-	errcode_t	retval;
+	ext2fs_generic_bitmap	bmap;
+	errcode_t		err, retval;
+	ssize_t			actual;
+	__u32			itr, cnt, size;
+	int			c, total_size;
+	char			buf[1024];
 
 	if (flags & IMAGER_FLAG_INODEMAP) {
 		if (!fs->inode_map) {
@@ -289,7 +290,10 @@ errcode_t ext2fs_image_bitmap_write(ext2
 			if (retval)
 				return retval;
 		}
-		ptr = fs->inode_map->bitmap;
+		bmap = fs->inode_map;
+		err = EXT2_ET_MAGIC_INODE_BITMAP;
+		itr = 1;
+		cnt = EXT2_INODES_PER_GROUP(fs->super) * fs->group_desc_count;
 		size = (EXT2_INODES_PER_GROUP(fs->super) / 8);
 	} else {
 		if (!fs->block_map) {
@@ -297,43 +301,51 @@ errcode_t ext2fs_image_bitmap_write(ext2
 			if (retval)
 				return retval;
 		}
-		ptr = fs->block_map->bitmap;
+		bmap = fs->block_map;
+		err = EXT2_ET_MAGIC_BLOCK_BITMAP;
+		itr = fs->super->s_first_data_block;
+		cnt = EXT2_BLOCKS_PER_GROUP(fs->super) * fs->group_desc_count;
 		size = EXT2_BLOCKS_PER_GROUP(fs->super) / 8;
 	}
-	size = size * fs->group_desc_count;
+	total_size = size * fs->group_desc_count;
 
-	actual = write(fd, ptr, size);
-	if (actual == -1) {
-		retval = errno;
-		goto errout;
+	while (cnt > 0) {
+		size = sizeof(buf);
+		if (size > (cnt >> 3))
+			size = (cnt >> 3);
+
+		retval = ext2fs_get_generic_bitmap_range(bmap, 
+				 err, itr, size << 3, buf);
+		if (retval)
+			return retval;
+
+		actual = write(fd, buf, size);
+		if (actual == -1)
+			return errno;
+		if (actual != (int) size)
+			return EXT2_ET_SHORT_READ;
+		
+		itr += size << 3;
+		cnt -= size << 3;
 	}
-	if (actual != size) {
-		retval = EXT2_ET_SHORT_WRITE;
-		goto errout;
-	}
-	size = size % fs->blocksize;
-	memset(zero_buf, 0, sizeof(zero_buf));
+
+	size = total_size % fs->blocksize;
+	memset(buf, 0, sizeof(buf));
 	if (size) {
 		size = fs->blocksize - size;
 		while (size) {
 			c = size;
-			if (c > (int) sizeof(zero_buf))
-				c = sizeof(zero_buf);
-			actual = write(fd, zero_buf, c);
-			if (actual == -1) {
-				retval = errno;
-				goto errout;
-			}
-			if (actual != c) {
-				retval = EXT2_ET_SHORT_WRITE;
-				goto errout;
-			}
+			if (c > (int) sizeof(buf))
+				c = sizeof(buf);
+			actual = write(fd, buf, c);
+			if (actual == -1)
+				return errno;
+			if (actual != c)
+				return EXT2_ET_SHORT_WRITE;
 			size -= c;
 		}
 	}
-	retval = 0;
-errout:
-	return (retval);
+	return 0;
 }
 
 
@@ -342,10 +354,12 @@ errout:
  */
 errcode_t ext2fs_image_bitmap_read(ext2_filsys fs, int fd, int flags)
 {
-	char		*ptr, *buf = 0;
-	int		size;
-	ssize_t		actual;
-	errcode_t	retval;
+	ext2fs_generic_bitmap	bmap;
+	errcode_t		err, retval;
+	__u32			itr, cnt;
+	char			buf[1024];
+	unsigned int		size;
+	ssize_t			actual;
 
 	if (flags & IMAGER_FLAG_INODEMAP) {
 		if (!fs->inode_map) {
@@ -353,7 +367,10 @@ errcode_t ext2fs_image_bitmap_read(ext2_
 			if (retval)
 				return retval;
 		}
-		ptr = fs->inode_map->bitmap;
+		bmap = fs->inode_map;
+		err = EXT2_ET_MAGIC_INODE_BITMAP;
+		itr = 1;
+		cnt = EXT2_INODES_PER_GROUP(fs->super) * fs->group_desc_count;
 		size = (EXT2_INODES_PER_GROUP(fs->super) / 8);
 	} else {
 		if (!fs->block_map) {
@@ -361,29 +378,31 @@ errcode_t ext2fs_image_bitmap_read(ext2_
 			if (retval)
 				return retval;
 		}
-		ptr = fs->block_map->bitmap;
+		bmap = fs->block_map;
+		err = EXT2_ET_MAGIC_BLOCK_BITMAP;
+		itr = fs->super->s_first_data_block;
+		cnt = EXT2_BLOCKS_PER_GROUP(fs->super) * fs->group_desc_count;
 		size = EXT2_BLOCKS_PER_GROUP(fs->super) / 8;
 	}
-	size = size * fs->group_desc_count;
 
-	buf = malloc(size);
-	if (!buf)
-		return ENOMEM;
-
-	actual = read(fd, buf, size);
-	if (actual == -1) {
-		retval = errno;
-		goto errout;
-	}
-	if (actual != size) {
-		retval = EXT2_ET_SHORT_WRITE;
-		goto errout;
+	while (cnt > 0) {
+		size = sizeof(buf);
+		if (size > (cnt >> 3))
+			size = (cnt >> 3);
+
+		actual = read(fd, buf, size);
+		if (actual == -1)
+			return errno;
+		if (actual != (int) size)
+			return EXT2_ET_SHORT_READ;
+
+		retval = ext2fs_set_generic_bitmap_range(bmap, 
+				 err, itr, size << 3, buf);
+		if (retval)
+			return retval;
+
+		itr += size << 3;
+		cnt -= size << 3;
 	}
-	memcpy(ptr, buf, size);
-	
-	retval = 0;
-errout:
-	if (buf)
-		free(buf);
-	return (retval);
+	return 0;
 }
diff -Nurp e2fsprogs-1.40.8/lib/ext2fs/ind_block.c e2fsprogs/lib/ext2fs/ind_block.c
--- e2fsprogs-1.40.8/lib/ext2fs/ind_block.c	2008-03-13 23:20:46.000000000 +0100
+++ e2fsprogs/lib/ext2fs/ind_block.c	2008-03-29 01:20:43.000000000 +0100
@@ -22,9 +22,11 @@
 errcode_t ext2fs_read_ind_block(ext2_filsys fs, blk_t blk, void *buf)
 {
 	errcode_t	retval;
+#ifdef WORDS_BIGENDIAN
 	blk_t		*block_nr;
 	int		i;
 	int		limit = fs->blocksize >> 2;
+#endif
 
 	if ((fs->flags & EXT2_FLAG_IMAGE_FILE) &&
 	    (fs->io != fs->image_io))
@@ -34,31 +36,29 @@ errcode_t ext2fs_read_ind_block(ext2_fil
 		if (retval)
 			return retval;
 	}
-#ifdef EXT2FS_ENABLE_SWAPFS
-	if (fs->flags & (EXT2_FLAG_SWAP_BYTES | EXT2_FLAG_SWAP_BYTES_READ)) {
-		block_nr = (blk_t *) buf;
-		for (i = 0; i < limit; i++, block_nr++)
-			*block_nr = ext2fs_swab32(*block_nr);
-	}
+#ifdef WORDS_BIGENDIAN
+	block_nr = (blk_t *) buf;
+	for (i = 0; i < limit; i++, block_nr++)
+		*block_nr = ext2fs_swab32(*block_nr);
 #endif
 	return 0;
 }
 
 errcode_t ext2fs_write_ind_block(ext2_filsys fs, blk_t blk, void *buf)
 {
+#ifdef WORDS_BIGENDIAN
 	blk_t		*block_nr;
 	int		i;
 	int		limit = fs->blocksize >> 2;
+#endif
 
 	if (fs->flags & EXT2_FLAG_IMAGE_FILE)
 		return 0;
 
-#ifdef EXT2FS_ENABLE_SWAPFS
-	if (fs->flags & (EXT2_FLAG_SWAP_BYTES | EXT2_FLAG_SWAP_BYTES_WRITE)) {
-		block_nr = (blk_t *) buf;
-		for (i = 0; i < limit; i++, block_nr++)
-			*block_nr = ext2fs_swab32(*block_nr);
-	}
+#ifdef WORDS_BIGENDIAN
+	block_nr = (blk_t *) buf;
+	for (i = 0; i < limit; i++, block_nr++)
+		*block_nr = ext2fs_swab32(*block_nr);
 #endif
 	return io_channel_write_blk(fs->io, blk, 1, buf);
 }
diff -Nurp e2fsprogs-1.40.8/lib/ext2fs/initialize.c e2fsprogs/lib/ext2fs/initialize.c
--- e2fsprogs-1.40.8/lib/ext2fs/initialize.c	2008-03-13 23:20:46.000000000 +0100
+++ e2fsprogs/lib/ext2fs/initialize.c	2008-03-29 01:20:43.000000000 +0100
@@ -67,7 +67,7 @@ static unsigned int calc_reserved_gdt_bl
 {
 	struct ext2_super_block *sb = fs->super;
 	unsigned long bpg = sb->s_blocks_per_group;
-	unsigned int gdpb = fs->blocksize / sizeof(struct ext2_group_desc);
+	unsigned int gdpb = EXT2_DESC_PER_BLOCK(sb);
 	unsigned long max_blocks = 0xffffffff;
 	unsigned long rsv_groups;
 	unsigned int rsv_gdb;
@@ -377,6 +377,7 @@ ipg_retry:
 		fs->group_desc[i].bg_free_inodes_count =
 			fs->super->s_inodes_per_group;
 		fs->group_desc[i].bg_used_dirs_count = 0;
+		ext2fs_group_desc_csum_set(fs, i);
 	}
 	
 	c = (char) 255;
diff -Nurp e2fsprogs-1.40.8/lib/ext2fs/inode.c e2fsprogs/lib/ext2fs/inode.c
--- e2fsprogs-1.40.8/lib/ext2fs/inode.c	2008-03-13 23:20:46.000000000 +0100
+++ e2fsprogs/lib/ext2fs/inode.c	2008-03-29 01:20:43.000000000 +0100
@@ -167,6 +167,9 @@ errcode_t ext2fs_open_inode_scan(ext2_fi
 	if (EXT2_HAS_COMPAT_FEATURE(fs->super, 
 				    EXT2_FEATURE_COMPAT_LAZY_BG))
 		scan->scan_flags |= EXT2_SF_DO_LAZY;
+	if (EXT2_HAS_RO_COMPAT_FEATURE(fs->super,
+				       EXT4_FEATURE_RO_COMPAT_GDT_CSUM))
+		scan->scan_flags |= EXT2_SF_DO_LAZY;
 	*ret_scan = scan;
 	return 0;
 }
@@ -218,18 +221,30 @@ int ext2fs_inode_scan_flags(ext2_inode_s
  */
 static errcode_t get_next_blockgroup(ext2_inode_scan scan)
 {
+	ext2_filsys fs = scan->fs;
+
 	scan->current_group++;
 	scan->groups_left--;
-			
-	scan->current_block = scan->fs->
-		group_desc[scan->current_group].bg_inode_table;
+
+	scan->current_block =fs->group_desc[scan->current_group].bg_inode_table;
 
 	scan->current_inode = scan->current_group *
-		EXT2_INODES_PER_GROUP(scan->fs->super);
+		EXT2_INODES_PER_GROUP(fs->super);
 
 	scan->bytes_left = 0;
-	scan->inodes_left = EXT2_INODES_PER_GROUP(scan->fs->super);
-	scan->blocks_left = scan->fs->inode_blocks_per_group;
+	scan->inodes_left = EXT2_INODES_PER_GROUP(fs->super);
+	scan->blocks_left = fs->inode_blocks_per_group;
+	if (EXT2_HAS_RO_COMPAT_FEATURE(fs->super,
+				       EXT4_FEATURE_RO_COMPAT_GDT_CSUM)) {
+		scan->inodes_left -=
+			fs->group_desc[scan->current_group].bg_itable_unused;
+		scan->blocks_left =
+			(EXT2_INODES_PER_GROUP(fs->super) -
+			 fs->group_desc[scan->current_group].bg_itable_unused +
+			 fs->blocksize / scan->inode_size - 1) *
+			scan->inode_size / fs->blocksize;
+	}
+
 	return 0;
 }
 
@@ -417,6 +432,8 @@ errcode_t ext2fs_get_next_inode_full(ext
 	    (scan->fs->group_desc[scan->current_group].bg_flags &
 	     EXT2_BG_INODE_UNINIT))
 		goto force_new_group;
+	if (scan->inodes_left == 0)
+		goto force_new_group;
 	if (scan->current_block == 0) {
 		if (scan->scan_flags & EXT2_SF_SKIP_MISSING_ITABLE) {
 			goto force_new_group;
@@ -453,32 +470,28 @@ errcode_t ext2fs_get_next_inode_full(ext
 		scan->ptr += scan->inode_size - extra_bytes;
 		scan->bytes_left -= scan->inode_size - extra_bytes;
 
-#ifdef EXT2FS_ENABLE_SWAPFS
+#ifdef WORDS_BIGENDIAN
 		memset(inode, 0, bufsize);
-		if ((scan->fs->flags & EXT2_FLAG_SWAP_BYTES) ||
-		    (scan->fs->flags & EXT2_FLAG_SWAP_BYTES_READ))
-			ext2fs_swap_inode_full(scan->fs, 
-				(struct ext2_inode_large *) inode,
-				(struct ext2_inode_large *) scan->temp_buffer, 
-				0, bufsize);
-		else
+		ext2fs_swap_inode_full(scan->fs, 
+			       (struct ext2_inode_large *) inode,
+			       (struct ext2_inode_large *) scan->temp_buffer, 
+			       0, bufsize);
+#else
+		*inode = *((struct ext2_inode *) scan->temp_buffer);
 #endif
-			*inode = *((struct ext2_inode *) scan->temp_buffer);
 		if (scan->scan_flags & EXT2_SF_BAD_EXTRA_BYTES)
 			retval = EXT2_ET_BAD_BLOCK_IN_INODE_TABLE;
 		scan->scan_flags &= ~EXT2_SF_BAD_EXTRA_BYTES;
 	} else {
-#ifdef EXT2FS_ENABLE_SWAPFS
+#ifdef WORDS_BIGENDIAN
 		memset(inode, 0, bufsize);
-		if ((scan->fs->flags & EXT2_FLAG_SWAP_BYTES) ||
-		    (scan->fs->flags & EXT2_FLAG_SWAP_BYTES_READ))
-			ext2fs_swap_inode_full(scan->fs, 
+		ext2fs_swap_inode_full(scan->fs, 
 				(struct ext2_inode_large *) inode,
 				(struct ext2_inode_large *) scan->ptr,
 				0, bufsize);
-		else
+#else
+		memcpy(inode, scan->ptr, bufsize);
 #endif
-			memcpy(inode, scan->ptr, bufsize);
 		scan->ptr += scan->inode_size;
 		scan->bytes_left -= scan->inode_size;
 		if (scan->scan_flags & EXT2_SF_BAD_INODE_BLK)
@@ -583,12 +596,10 @@ errcode_t ext2fs_read_inode_full(ext2_fi
 		block_nr++;
 	}
 
-#ifdef EXT2FS_ENABLE_SWAPFS
-	if ((fs->flags & EXT2_FLAG_SWAP_BYTES) ||
-	    (fs->flags & EXT2_FLAG_SWAP_BYTES_READ))
-		ext2fs_swap_inode_full(fs, (struct ext2_inode_large *) inode, 
-				       (struct ext2_inode_large *) inode, 
-				       0, bufsize);
+#ifdef WORDS_BIGENDIAN
+	ext2fs_swap_inode_full(fs, (struct ext2_inode_large *) inode, 
+			       (struct ext2_inode_large *) inode, 
+			       0, bufsize);
 #endif
 
 	/* Update the inode cache */
@@ -657,16 +668,14 @@ errcode_t ext2fs_write_inode_full(ext2_f
 		w_inode = &temp_inode;
 	memset(w_inode, 0, length);
 
-#ifdef EXT2FS_ENABLE_SWAPFS
-	if ((fs->flags & EXT2_FLAG_SWAP_BYTES) ||
-	    (fs->flags & EXT2_FLAG_SWAP_BYTES_WRITE))
-		ext2fs_swap_inode_full(fs, w_inode, 
-				       (struct ext2_inode_large *) inode, 
-				       1, bufsize);
-	else
+#ifdef WORDS_BIGENDIAN
+	ext2fs_swap_inode_full(fs, w_inode, 
+			       (struct ext2_inode_large *) inode, 
+			       1, bufsize);
+#else
+	memcpy(w_inode, inode, bufsize);
 #endif
-		memcpy(w_inode, inode, bufsize);
-	
+
 	group = (ino - 1) / EXT2_INODES_PER_GROUP(fs->super);
 	offset = ((ino - 1) % EXT2_INODES_PER_GROUP(fs->super)) *
 		EXT2_INODE_SIZE(fs->super);
diff -Nurp e2fsprogs-1.40.8/lib/ext2fs/inode_io.c e2fsprogs/lib/ext2fs/inode_io.c
--- e2fsprogs-1.40.8/lib/ext2fs/inode_io.c	2008-03-13 19:57:37.000000000 +0100
+++ e2fsprogs/lib/ext2fs/inode_io.c	2008-03-29 01:20:43.000000000 +0100
@@ -56,7 +56,11 @@ static errcode_t inode_write_blk(io_chan
 static errcode_t inode_flush(io_channel channel);
 static errcode_t inode_write_byte(io_channel channel, unsigned long offset,
 				int size, const void *data);
-
+static errcode_t inode_read_blk64(io_channel channel, 
+				unsigned long long block, int count, void *data);
+static errcode_t inode_write_blk64(io_channel channel, 
+				unsigned long long block, int count, const void *data);
+				
 static struct struct_io_manager struct_inode_manager = {
 	EXT2_ET_MAGIC_IO_MANAGER,
 	"Inode I/O Manager",
@@ -66,7 +70,11 @@ static struct struct_io_manager struct_i
 	inode_read_blk,
 	inode_write_blk,
 	inode_flush,
-	inode_write_byte
+	inode_write_byte,
+	NULL,
+	NULL,
+	inode_read_blk64,
+	inode_write_blk64
 };
 
 io_manager inode_io_manager = &struct_inode_manager;
@@ -197,8 +205,8 @@ static errcode_t inode_set_blksize(io_ch
 }
 
 
-static errcode_t inode_read_blk(io_channel channel, unsigned long block,
-			       int count, void *buf)
+static errcode_t inode_read_blk64(io_channel channel,
+				unsigned long long block, int count, void *buf)
 {
 	struct inode_private_data *data;
 	errcode_t	retval;
@@ -217,8 +225,14 @@ static errcode_t inode_read_blk(io_chann
 	return ext2fs_file_read(data->file, buf, count, 0);
 }
 
-static errcode_t inode_write_blk(io_channel channel, unsigned long block,
-				int count, const void *buf)
+static errcode_t inode_read_blk(io_channel channel, unsigned long block,
+			       int count, void *buf)
+{
+	return inode_read_blk64(channel, block, count, buf);
+}
+
+static errcode_t inode_write_blk64(io_channel channel,
+				unsigned long long block, int count, const void *buf)
 {
 	struct inode_private_data *data;
 	errcode_t	retval;
@@ -237,6 +251,12 @@ static errcode_t inode_write_blk(io_chan
 	return ext2fs_file_write(data->file, buf, count, 0);
 }
 
+static errcode_t inode_write_blk(io_channel channel, unsigned long block, 
+				int count, const void *buf)
+{
+	return inode_write_blk64(channel, block, count, buf);
+}
+
 static errcode_t inode_write_byte(io_channel channel, unsigned long offset,
 				 int size, const void *buf)
 {
diff -Nurp e2fsprogs-1.40.8/lib/ext2fs/ismounted.c e2fsprogs/lib/ext2fs/ismounted.c
--- e2fsprogs-1.40.8/lib/ext2fs/ismounted.c	2008-03-13 23:20:46.000000000 +0100
+++ e2fsprogs/lib/ext2fs/ismounted.c	2008-03-29 01:20:43.000000000 +0100
@@ -251,10 +251,8 @@ static int is_swap_device(const char *fi
 	if (!(f = fopen("/proc/swaps", "r")))
 		return 0;
 	/* Skip the first line */
-	fgets(buf, sizeof(buf), f);
-	while (!feof(f)) {
-		if (!fgets(buf, sizeof(buf), f))
-			break;
+	if (fgets(buf, sizeof(buf), f))
+	while (fgets(buf, sizeof(buf), f)) {
 		if ((cp = strchr(buf, ' ')) != NULL)
 			*cp = 0;
 		if ((cp = strchr(buf, '\t')) != NULL)
diff -Nurp e2fsprogs-1.40.8/lib/ext2fs/Makefile.in e2fsprogs/lib/ext2fs/Makefile.in
--- e2fsprogs-1.40.8/lib/ext2fs/Makefile.in	2008-03-13 23:20:46.000000000 +0100
+++ e2fsprogs/lib/ext2fs/Makefile.in	2008-03-29 01:20:43.000000000 +0100
@@ -7,10 +7,12 @@ INSTALL = @INSTALL@
 
 @MCONFIG@
 
-@DEBUGFS_CMT@DEBUGFS_LIB_OBJS = bb_compat.o cmp_bitmaps.o fileio.o \
+@DEBUGFS_CMT@DEBUGFS_LIB_OBJS = bb_compat.o fileio.o \
 @DEBUGFS_CMT@	inode_io.o namei.o write_bb_file.o 
 
-@RESIZER_CMT@RESIZE_LIB_OBJS = rs_bitmap.o dupfs.o test_io.o 
+MK_CMDS=	_SS_DIR_OVERRIDE=../ss ../ss/mk_cmds
+
+@RESIZER_CMT@RESIZE_LIB_OBJS = dupfs.o test_io.o 
 
 @IMAGER_CMT@E2IMAGE_LIB_OBJS = imager.o
 
@@ -28,6 +30,8 @@ OBJS= $(DEBUGFS_LIB_OBJS) $(RESIZE_LIB_O
 	bmap.o \
 	check_desc.o \
 	closefs.o \
+	crc16.o \
+	csum.o \
 	dblist.o \
 	dblist_dir.o \
 	dirblock.o \
@@ -35,6 +39,7 @@ OBJS= $(DEBUGFS_LIB_OBJS) $(RESIZE_LIB_O
 	dir_iterate.o \
 	expanddir.o \
 	ext_attr.o \
+	extent.o \
 	finddev.o \
 	flushb.o \
 	freefs.o \
@@ -82,7 +87,8 @@ SRCS= ext2_err.c \
 	$(srcdir)/bmap.c \
 	$(srcdir)/check_desc.c \
 	$(srcdir)/closefs.c \
-	$(srcdir)/cmp_bitmaps.c \
+	$(srcdir)/crc16.c \
+	$(srcdir)/csum.c \
 	$(srcdir)/dblist.c \
 	$(srcdir)/dblist_dir.c \
 	$(srcdir)/dirblock.c \
@@ -91,6 +97,7 @@ SRCS= ext2_err.c \
 	$(srcdir)/dupfs.c \
 	$(srcdir)/expanddir.c \
 	$(srcdir)/ext_attr.c \
+	$(srcdir)/extent.c \
 	$(srcdir)/fileio.c \
 	$(srcdir)/finddev.c \
 	$(srcdir)/flushb.c \
@@ -120,21 +127,21 @@ SRCS= ext2_err.c \
 	$(srcdir)/read_bb.c \
 	$(srcdir)/read_bb_file.c \
 	$(srcdir)/res_gdt.c \
-	$(srcdir)/rs_bitmap.c \
 	$(srcdir)/rw_bitmaps.c \
 	$(srcdir)/swapfs.c \
 	$(srcdir)/tdb.c \
 	$(srcdir)/test_io.c \
-	$(srcdir)/unix_io.c \
-	$(srcdir)/unlink.c \
-	$(srcdir)/valid_blk.c \
-	$(srcdir)/version.c \
-	$(srcdir)/write_bb_file.c \
 	$(srcdir)/tst_badblocks.c \
 	$(srcdir)/tst_bitops.c \
 	$(srcdir)/tst_byteswap.c \
+	$(srcdir)/tst_csum.c \
 	$(srcdir)/tst_getsize.c \
-	$(srcdir)/tst_iscan.c
+	$(srcdir)/tst_iscan.c \
+	$(srcdir)/unix_io.c \
+	$(srcdir)/unlink.c \
+	$(srcdir)/valid_blk.c \
+	$(srcdir)/version.c \
+	$(srcdir)/write_bb_file.c
 
 HFILES= bitops.h ext2fs.h ext2_io.h ext2_fs.h ext2_ext_attr.h ext3_extents.h \
 	tdb.h
@@ -187,12 +194,14 @@ ext2fs.pc: $(srcdir)/ext2fs.pc.in $(top_
 	@echo "	CONFIG.STATUS $@"
 	@cd $(top_builddir); CONFIG_FILES=lib/ext2fs/ext2fs.pc ./config.status
 
-tst_badblocks: tst_badblocks.o freefs.o \
-		read_bb_file.o write_bb_file.o badblocks.o 
-	@echo "	LD $@"
-	@$(CC) -o tst_badblocks tst_badblocks.o freefs.o \
-		read_bb_file.o write_bb_file.o badblocks.o \
-		inline.o bitops.o gen_bitmap.o $(LIBCOM_ERR)
+tst_badblocks: tst_badblocks.o freefs.o bitmaps.o rw_bitmaps.o \
+		read_bb_file.o write_bb_file.o badblocks.o csum.o crc16.o \
+		closefs.o io_manager.o
+	@echo "	LD $@"
+	@$(CC) -o tst_badblocks tst_badblocks.o freefs.o read_bb_file.o \
+		write_bb_file.o badblocks.o rw_bitmaps.o inline.o bitops.o \
+		gen_bitmap.o bitmaps.o csum.o crc16.o closefs.o io_manager.o \
+		$(LIBCOM_ERR)
 
 tst_icount: icount.c initialize.o  $(STATIC_LIBEXT2FS)
 	@echo "	LD $@"
@@ -241,19 +250,85 @@ ext2_tdbtool: tdbtool.o
 	@echo "	LD $@"
 	@$(CC) -o ext2_tdbtool tdbtool.o tdb.o
 
+extent_dbg.c: $(srcdir)/extent_dbg.ct
+	@echo "	MK_CMDS $<"
+	@$(MK_CMDS) $(srcdir)/extent_dbg.ct
+
+debug_cmds.c debug_cmds.h: $(top_srcdir)/debugfs/debug_cmds.ct
+	@echo "	MK_CMDS $<@"
+	@$(MK_CMDS) $(top_srcdir)/debugfs/debug_cmds.ct
+
+DEBUG_OBJS= debug_cmds.o debugfs.o util.o ncheck.o icheck.o ls.o \
+	lsdel.o dump.o set_fields.o logdump.o htree.o unused.o
+
+debugfs.o: $(top_srcdir)/debugfs/debugfs.c
+	@echo "	CC $<"
+	@$(CC) $(ALL_CFLAGS) -c $< -o $@
+
+util.o: $(top_srcdir)/debugfs/util.c
+	@echo "	CC $<"
+	@$(CC) $(ALL_CFLAGS) -c $< -o $@
+
+ncheck.o: $(top_srcdir)/debugfs/ncheck.c
+	@echo "	CC $<"
+	@$(CC) $(ALL_CFLAGS) -c $< -o $@
+
+icheck.o: $(top_srcdir)/debugfs/icheck.c
+	@echo "	CC $<"
+	@$(CC) $(ALL_CFLAGS) -c $< -o $@
+
+ls.o: $(top_srcdir)/debugfs/ls.c
+	@echo "	CC $<"
+	@$(CC) $(ALL_CFLAGS) -c $< -o $@
+
+lsdel.o: $(top_srcdir)/debugfs/lsdel.c
+	@echo "	CC $<"
+	@$(CC) $(ALL_CFLAGS) -c $< -o $@
+
+dump.o: $(top_srcdir)/debugfs/dump.c
+	@echo "	CC $<"
+	@$(CC) $(ALL_CFLAGS) -c $< -o $@
+
+set_fields.o: $(top_srcdir)/debugfs/set_fields.c
+	@echo "	CC $<"
+	@$(CC) $(ALL_CFLAGS) -c $< -o $@
+
+logdump.o: $(top_srcdir)/debugfs/logdump.c
+	@echo "	CC $<"
+	@$(CC) $(ALL_CFLAGS) -c $< -o $@
+
+htree.o: $(top_srcdir)/debugfs/htree.c
+	@echo "	CC $<"
+	@$(CC) $(ALL_CFLAGS) -c $< -o $@
+
+unused.o: $(top_srcdir)/debugfs/unused.c
+	@echo "	CC $<"
+	@$(CC) $(ALL_CFLAGS) -c $< -o $@
+
+tst_extents: $(srcdir)/extent.c extent_dbg.c $(DEBUG_OBJS) $(LIBSS) $(LIBE2P) $(DEPLIBUUID) $(DEPLIBBLKID)
+	@echo "	LD $@"
+	@$(CC) -o tst_extents $(srcdir)/extent.c extent_dbg.c \
+		$(ALL_CFLAGS) -DDEBUG $(DEBUG_OBJS) $(LIBSS) $(LIBE2P) \
+		$(LIBUUID) $(STATIC_LIBEXT2FS) $(LIBBLKID) $(LIBCOM_ERR) \
+		-I $(top_srcdir)/debugfs
+
+tst_csum: tst_csum.c csum.c $(STATIC_LIBEXT2FS)
+	@echo "	LD $@"
+	@$(CC) -o tst_csum $(srcdir)/csum.c $(srcdir)/tst_csum.c -DDEBUG \
+		$(ALL_CFLAGS) $(STATIC_LIBEXT2FS) $(LIBCOM_ERR)
+
 mkjournal: mkjournal.c $(STATIC_LIBEXT2FS)
 	@echo "	LD $@"
 	@$(CC) -o mkjournal $(srcdir)/mkjournal.c -DDEBUG $(STATIC_LIBEXT2FS) $(LIBCOM_ERR) $(ALL_CFLAGS)
 
-check:: tst_bitops tst_badblocks tst_iscan @SWAPFS_CMT@ tst_byteswap \
-	tst_types tst_icount tst_super_size
+check:: tst_bitops tst_badblocks tst_iscan tst_types tst_icount tst_super_size tst_types tst_csum
 	LD_LIBRARY_PATH=$(LIB) DYLD_LIBRARY_PATH=$(LIB) ./tst_bitops
 	LD_LIBRARY_PATH=$(LIB) DYLD_LIBRARY_PATH=$(LIB) ./tst_badblocks
 	LD_LIBRARY_PATH=$(LIB) DYLD_LIBRARY_PATH=$(LIB) ./tst_iscan
-@SWAPFS_CMT@	LD_LIBRARY_PATH=$(LIB) DYLD_LIBRARY_PATH=$(LIB) ./tst_byteswap
 	LD_LIBRARY_PATH=$(LIB) DYLD_LIBRARY_PATH=$(LIB) ./tst_types
 	LD_LIBRARY_PATH=$(LIB) DYLD_LIBRARY_PATH=$(LIB) ./tst_icount
 	LD_LIBRARY_PATH=$(LIB) DYLD_LIBRARY_PATH=$(LIB) ./tst_super_size
+	LD_LIBRARY_PATH=$(LIB) DYLD_LIBRARY_PATH=$(LIB) ./tst_csum
 
 installdirs::
 	@echo "	MKINSTALLDIRS $(libdir) $(includedir)/ext2fs"
@@ -285,8 +360,8 @@ clean::
 	$(RM) -f \#* *.s *.o *.a *~ *.bak core profiled/* checker/* \
 		tst_badblocks tst_iscan ext2_err.et ext2_err.c ext2_err.h \
 		tst_byteswap tst_ismounted tst_getsize tst_sectgetsize \
-		tst_bitops tst_types tst_icount tst_super_size \
-		ext2_tdbtool mkjournal \
+		tst_bitops tst_types tst_icount tst_super_size tst_csum \
+		ext2_tdbtool mkjournal debug_cmds.c \
 		../libext2fs.a ../libext2fs_p.a ../libext2fs_chk.a
 
 mostlyclean:: clean
@@ -361,10 +436,10 @@ closefs.o: $(srcdir)/closefs.c $(srcdir)
  $(srcdir)/ext2fs.h $(srcdir)/ext2_fs.h $(srcdir)/ext3_extents.h \
  $(top_srcdir)/lib/et/com_err.h $(srcdir)/ext2_io.h \
  $(top_builddir)/lib/ext2fs/ext2_err.h $(srcdir)/bitops.h
-cmp_bitmaps.o: $(srcdir)/cmp_bitmaps.c $(srcdir)/ext2_fs.h \
- $(top_builddir)/lib/ext2fs/ext2_types.h $(srcdir)/ext2fs.h \
- $(srcdir)/ext2_fs.h $(srcdir)/ext3_extents.h $(top_srcdir)/lib/et/com_err.h \
- $(srcdir)/ext2_io.h $(top_builddir)/lib/ext2fs/ext2_err.h $(srcdir)/bitops.h
+crc16.o: $(srcdir)/crc16.c $(srcdir)/ext2_fs.h $(srcdir)/crc16.h \
+ $(top_builddir)/lib/ext2fs/ext2_types.h $(srcdir)/ext2fs.h $(srcdir)/ext2_fs.h
+csum.o: $(srcdir)/csum.c $(srcdir)/ext2_fs.h \
+ $(top_builddir)/lib/ext2fs/ext2_types.h $(srcdir)/ext2fs.h $(srcdir)/ext2_fs.h
 dblist.o: $(srcdir)/dblist.c $(srcdir)/ext2_fs.h \
  $(top_builddir)/lib/ext2fs/ext2_types.h $(srcdir)/ext2fsP.h \
  $(srcdir)/ext2fs.h $(srcdir)/ext2_fs.h $(srcdir)/ext3_extents.h \
@@ -523,10 +598,6 @@ res_gdt.o: $(srcdir)/res_gdt.c $(srcdir)
  $(top_builddir)/lib/ext2fs/ext2_types.h $(srcdir)/ext2fs.h \
  $(srcdir)/ext2_fs.h $(srcdir)/ext3_extents.h $(top_srcdir)/lib/et/com_err.h \
  $(srcdir)/ext2_io.h $(top_builddir)/lib/ext2fs/ext2_err.h $(srcdir)/bitops.h
-rs_bitmap.o: $(srcdir)/rs_bitmap.c $(srcdir)/ext2_fs.h \
- $(top_builddir)/lib/ext2fs/ext2_types.h $(srcdir)/ext2fs.h \
- $(srcdir)/ext2_fs.h $(srcdir)/ext3_extents.h $(top_srcdir)/lib/et/com_err.h \
- $(srcdir)/ext2_io.h $(top_builddir)/lib/ext2fs/ext2_err.h $(srcdir)/bitops.h
 rw_bitmaps.o: $(srcdir)/rw_bitmaps.c $(srcdir)/ext2_fs.h \
  $(top_builddir)/lib/ext2fs/ext2_types.h $(srcdir)/ext2fs.h \
  $(srcdir)/ext2_fs.h $(srcdir)/ext3_extents.h $(top_srcdir)/lib/et/com_err.h \
@@ -583,3 +654,5 @@ tst_iscan.o: $(srcdir)/tst_iscan.c $(src
  $(top_builddir)/lib/ext2fs/ext2_types.h $(srcdir)/ext2fs.h \
  $(srcdir)/ext2_fs.h $(srcdir)/ext3_extents.h $(top_srcdir)/lib/et/com_err.h \
  $(srcdir)/ext2_io.h $(top_builddir)/lib/ext2fs/ext2_err.h $(srcdir)/bitops.h
+tst_csum.o: $(srcdir)/tst_csum.c $(srcdir)/ext2_fs.h \
+ $(top_builddir)/lib/ext2fs/ext2_types.h $(srcdir)/ext2fs.h
diff -Nurp e2fsprogs-1.40.8/lib/ext2fs/Makefile.pq e2fsprogs/lib/ext2fs/Makefile.pq
--- e2fsprogs-1.40.8/lib/ext2fs/Makefile.pq	1970-01-01 01:00:00.000000000 +0100
+++ e2fsprogs/lib/ext2fs/Makefile.pq	2008-03-29 01:20:43.000000000 +0100
@@ -0,0 +1,49 @@
+TOPSRC=..\..
+LIBNAME=EXT2.LIB
+OBJFILE=EXT2.LST
+
+OBJS= 	alloc.obj \
+	alloc_tables.obj \
+	badblocks.obj \
+	bb_compat.obj \
+	bb_inode.obj \
+	bitmaps.obj \
+	bitops.obj \
+	block.obj \
+	bmap.obj \
+	bmove.obj \
+	check_desc.obj \
+	closefs.obj \
+	cmp_bitmaps.obj \
+	dblist.obj \
+	dblist_dir.obj \
+	dirblock.obj \
+	dir_iterate.obj \
+	dupfs.obj \
+	expanddir.obj \
+	fileio.obj \
+	freefs.obj \
+	get_pathname.obj \
+	icount.obj \
+	initialize.obj \
+	inline.obj \
+	inode.obj \
+	ismounted.obj \
+	link.obj \
+	lookup.obj \
+	mkdir.obj \
+	namei.obj \
+	native.obj \
+	newdir.obj \
+	openfs.obj \
+	read_bb.obj \
+	read_bb_file.obj \
+	rs_bitmap.obj \
+	rw_bitmaps.obj \
+	swapfs.obj \
+	unlink.obj \
+	valid_blk.obj \
+	version.obj
+
+!include $(TOPSRC)\powerquest\MCONFIG
+
diff -Nurp e2fsprogs-1.40.8/lib/ext2fs/openfs.c e2fsprogs/lib/ext2fs/openfs.c
--- e2fsprogs-1.40.8/lib/ext2fs/openfs.c	2008-03-13 23:20:46.000000000 +0100
+++ e2fsprogs/lib/ext2fs/openfs.c	2008-03-29 01:20:43.000000000 +0100
@@ -39,11 +39,10 @@ blk_t ext2fs_descriptor_block_loc(ext2_f
 	    (i < fs->super->s_first_meta_bg))
 		return (group_block + i + 1);
 
-	bg = (fs->blocksize / sizeof (struct ext2_group_desc)) * i;
+	bg = EXT2_DESC_PER_BLOCK(fs->super) * i;
 	if (ext2fs_bg_has_super(fs, bg))
 		has_super = 1;
-	ret_blk = (fs->super->s_first_data_block + has_super + 
-		   (bg * fs->super->s_blocks_per_group));
+	ret_blk = ext2fs_group_first_block(fs, bg) + has_super;
 	/*
 	 * If group_block is not the normal value, we're trying to use
 	 * the backup group descriptors and superblock --- so use the
@@ -87,10 +86,13 @@ errcode_t ext2fs_open2(const char *name,
 	errcode_t	retval;
 	unsigned long	i;
 	__u32		features;
-	int		j, groups_per_block, blocks_per_group, io_flags;
+	int		groups_per_block, blocks_per_group, io_flags;
 	blk_t		group_block, blk;
 	char		*dest, *cp;
+#ifdef WORDS_BIGENDIAN
 	struct ext2_group_desc *gdp;
+	int		j;
+#endif
 	
 	EXT2_CHECK_MAGIC(manager, EXT2_ET_MAGIC_IO_MANAGER);
 
@@ -178,12 +180,13 @@ errcode_t ext2fs_open2(const char *name,
 	if (fs->orig_super)
 		memcpy(fs->orig_super, fs->super, SUPERBLOCK_SIZE);
 
-#ifdef EXT2FS_ENABLE_SWAPFS
-	if ((fs->super->s_magic == ext2fs_swab16(EXT2_SUPER_MAGIC)) ||
-	    (fs->flags & EXT2_FLAG_SWAP_BYTES)) {
-		fs->flags |= EXT2_FLAG_SWAP_BYTES;
-
-		ext2fs_swap_super(fs->super);
+#ifdef WORDS_BIGENDIAN
+	fs->flags |= EXT2_FLAG_SWAP_BYTES;
+	ext2fs_swap_super(fs->super);
+#else
+	if (fs->flags & EXT2_FLAG_SWAP_BYTES) {
+		retval = EXT2_ET_UNIMPLEMENTED;
+		goto cleanup;
 	}
 #endif
 	
@@ -287,24 +290,38 @@ errcode_t ext2fs_open2(const char *name,
 	if (!group_block)
 		group_block = fs->super->s_first_data_block;
 	dest = (char *) fs->group_desc;
-	groups_per_block = fs->blocksize / sizeof(struct ext2_group_desc);
+	groups_per_block = EXT2_DESC_PER_BLOCK(fs->super);
 	for (i=0 ; i < fs->desc_blocks; i++) {
 		blk = ext2fs_descriptor_block_loc(fs, group_block, i);
 		retval = io_channel_read_blk(fs->io, blk, 1, dest);
 		if (retval)
 			goto cleanup;
-#ifdef EXT2FS_ENABLE_SWAPFS
-		if (fs->flags & EXT2_FLAG_SWAP_BYTES) {
-			gdp = (struct ext2_group_desc *) dest;
-			for (j=0; j < groups_per_block; j++)
-				ext2fs_swap_group_desc(gdp++);
-		}
+#ifdef WORDS_BIGENDIAN
+		gdp = (struct ext2_group_desc *) dest;
+		for (j=0; j < groups_per_block; j++)
+			ext2fs_swap_group_desc(gdp++);
 #endif
 		dest += fs->blocksize;
 	}
 
 	fs->stride = fs->super->s_raid_stride;
 
+	/*
+	 * If recovery is from backup superblock, Clear _UNININT flags &
+	 * reset bg_itable_unused to zero
+	 */
+	if (superblock > 1 && EXT2_HAS_RO_COMPAT_FEATURE(fs->super,
+					EXT4_FEATURE_RO_COMPAT_GDT_CSUM)) {
+		struct ext2_group_desc *gd;
+		for (i = 0, gd = fs->group_desc; i < fs->group_desc_count;
+		     i++, gd++) {
+			gd->bg_flags &= ~EXT2_BG_BLOCK_UNINIT;
+			gd->bg_flags &= ~EXT2_BG_INODE_UNINIT;
+			gd->bg_itable_unused = 0;
+		}
+		ext2fs_mark_super_dirty(fs);
+	}
+
 	fs->flags &= ~EXT2_FLAG_NOFREE_ON_ERROR;
 	*ret_fs = fs;
 	return 0;
diff -Nurp e2fsprogs-1.40.8/lib/ext2fs/read_bb.c e2fsprogs/lib/ext2fs/read_bb.c
--- e2fsprogs-1.40.8/lib/ext2fs/read_bb.c	2008-03-13 23:20:46.000000000 +0100
+++ e2fsprogs/lib/ext2fs/read_bb.c	2008-03-29 01:20:43.000000000 +0100
@@ -86,8 +86,8 @@ errcode_t ext2fs_read_bb_inode(ext2_fils
 
 	rb.bb_list = *bb_list;
 	rb.err = 0;
-	retval = ext2fs_block_iterate2(fs, EXT2_BAD_INO, 0, 0,
-				      mark_bad_block, &rb);
+	retval = ext2fs_block_iterate2(fs, EXT2_BAD_INO, BLOCK_FLAG_READ_ONLY,
+				       0, mark_bad_block, &rb);
 	if (retval)
 		return retval;
 
diff -Nurp e2fsprogs-1.40.8/lib/ext2fs/rs_bitmap.c e2fsprogs/lib/ext2fs/rs_bitmap.c
--- e2fsprogs-1.40.8/lib/ext2fs/rs_bitmap.c	2008-03-13 23:20:46.000000000 +0100
+++ e2fsprogs/lib/ext2fs/rs_bitmap.c	1970-01-01 01:00:00.000000000 +0100
@@ -1,106 +0,0 @@
-/*
- * rs_bitmap.c --- routine for changing the size of a bitmap
- *
- * Copyright (C) 1996, 1997 Theodore Ts'o.
- *
- * %Begin-Header%
- * This file may be redistributed under the terms of the GNU Public
- * License.
- * %End-Header%
- */
-
-#include <stdio.h>
-#include <string.h>
-#if HAVE_UNISTD_H
-#include <unistd.h>
-#endif
-#include <fcntl.h>
-#include <time.h>
-#ifdef HAVE_SYS_STAT_H
-#include <sys/stat.h>
-#endif
-#ifdef HAVE_SYS_TYPES_H
-#include <sys/types.h>
-#endif
-
-#include "ext2_fs.h"
-#include "ext2fs.h"
-
-errcode_t ext2fs_resize_generic_bitmap(__u32 new_end, __u32 new_real_end,
-				       ext2fs_generic_bitmap bmap)
-{
-	errcode_t	retval;
-	size_t		size, new_size;
-	__u32		bitno;
-
-	if (!bmap)
-		return EXT2_ET_INVALID_ARGUMENT;
-
-	EXT2_CHECK_MAGIC(bmap, EXT2_ET_MAGIC_GENERIC_BITMAP);
-
-	/*
-	 * If we're expanding the bitmap, make sure all of the new
-	 * parts of the bitmap are zero.
-	 */
-	if (new_end > bmap->end) {
-		bitno = bmap->real_end;
-		if (bitno > new_end)
-			bitno = new_end;
-		for (; bitno > bmap->end; bitno--)
-			ext2fs_clear_bit(bitno - bmap->start, bmap->bitmap);
-	}
-	if (new_real_end == bmap->real_end) {
-		bmap->end = new_end;
-		return 0;
-	}
-	
-	size = ((bmap->real_end - bmap->start) / 8) + 1;
-	new_size = ((new_real_end - bmap->start) / 8) + 1;
-
-	if (size != new_size) {
-		retval = ext2fs_resize_mem(size, new_size, &bmap->bitmap);
-		if (retval)
-			return retval;
-	}
-	if (new_size > size)
-		memset(bmap->bitmap + size, 0, new_size - size);
-
-	bmap->end = new_end;
-	bmap->real_end = new_real_end;
-	return 0;
-}
-
-errcode_t ext2fs_resize_inode_bitmap(__u32 new_end, __u32 new_real_end,
-				     ext2fs_inode_bitmap bmap)
-{
-	errcode_t	retval;
-	
-	if (!bmap)
-		return EXT2_ET_INVALID_ARGUMENT;
-
-	EXT2_CHECK_MAGIC(bmap, EXT2_ET_MAGIC_INODE_BITMAP);
-
-	bmap->magic = EXT2_ET_MAGIC_GENERIC_BITMAP;
-	retval = ext2fs_resize_generic_bitmap(new_end, new_real_end,
-					      bmap);
-	bmap->magic = EXT2_ET_MAGIC_INODE_BITMAP;
-	return retval;
-}
-
-errcode_t ext2fs_resize_block_bitmap(__u32 new_end, __u32 new_real_end,
-				     ext2fs_block_bitmap bmap)
-{
-	errcode_t	retval;
-	
-	if (!bmap)
-		return EXT2_ET_INVALID_ARGUMENT;
-
-	EXT2_CHECK_MAGIC(bmap, EXT2_ET_MAGIC_BLOCK_BITMAP);
-
-	bmap->magic = EXT2_ET_MAGIC_GENERIC_BITMAP;
-	retval = ext2fs_resize_generic_bitmap(new_end, new_real_end,
-					      bmap);
-	bmap->magic = EXT2_ET_MAGIC_BLOCK_BITMAP;
-	return retval;
-}
-
diff -Nurp e2fsprogs-1.40.8/lib/ext2fs/rw_bitmaps.c e2fsprogs/lib/ext2fs/rw_bitmaps.c
--- e2fsprogs-1.40.8/lib/ext2fs/rw_bitmaps.c	2008-03-13 23:20:46.000000000 +0100
+++ e2fsprogs/lib/ext2fs/rw_bitmaps.c	2008-03-29 01:20:43.000000000 +0100
@@ -27,30 +27,6 @@
 #include "ext2fs.h"
 #include "e2image.h"
 
-#if defined(__powerpc__) && defined(EXT2FS_ENABLE_SWAPFS)
-/*
- * On the PowerPC, the big-endian variant of the ext2 filesystem
- * has its bitmaps stored as 32-bit words with bit 0 as the LSB
- * of each word.  Thus a bitmap with only bit 0 set would be, as
- * a string of bytes, 00 00 00 01 00 ...
- * To cope with this, we byte-reverse each word of a bitmap if
- * we have a big-endian filesystem, that is, if we are *not*
- * byte-swapping other word-sized numbers.
- */
-#define EXT2_BIG_ENDIAN_BITMAPS
-#endif
-
-#ifdef EXT2_BIG_ENDIAN_BITMAPS
-static void ext2fs_swap_bitmap(ext2_filsys fs, char *bitmap, int nbytes)
-{
-	__u32 *p = (__u32 *) bitmap;
-	int n;
-		
-	for (n = nbytes / sizeof(__u32); n > 0; --n, ++p)
-		*p = ext2fs_swab32(*p);
-}
-#endif
-
 static errcode_t write_bitmaps(ext2_filsys fs, int do_inode, int do_block)
 {
 	dgrp_t 		i;
@@ -58,10 +34,11 @@ static errcode_t write_bitmaps(ext2_fils
 	int		block_nbytes, inode_nbytes;
 	unsigned int	nbits;
 	errcode_t	retval;
-	char 		*block_bitmap, *inode_bitmap;
 	char 		*block_buf, *inode_buf;
 	int		lazy_flag = 0;
 	blk_t		blk;
+	blk_t		blk_itr = fs->super->s_first_data_block;
+	ext2_ino_t	ino_itr = 1;
 
 	EXT2_CHECK_MAGIC(fs, EXT2_ET_MAGIC_EXT2FS_FILSYS);
 
@@ -71,9 +48,7 @@ static errcode_t write_bitmaps(ext2_fils
 				    EXT2_FEATURE_COMPAT_LAZY_BG))
 		lazy_flag = 1;
 	inode_nbytes = block_nbytes = 0;
-	block_bitmap = inode_bitmap = 0;
 	if (do_block) {
-		block_bitmap = fs->block_map->bitmap;
 		block_nbytes = EXT2_BLOCKS_PER_GROUP(fs->super) / 8;
 		retval = ext2fs_get_mem(fs->blocksize, &block_buf);
 		if (retval)
@@ -81,7 +56,6 @@ static errcode_t write_bitmaps(ext2_fils
 		memset(block_buf, 0xff, fs->blocksize);
 	}
 	if (do_inode) {
-		inode_bitmap = fs->inode_map->bitmap;
 		inode_nbytes = (size_t) 
 			((EXT2_INODES_PER_GROUP(fs->super)+7) / 8);
 		retval = ext2fs_get_mem(fs->blocksize, &inode_buf);
@@ -91,14 +65,18 @@ static errcode_t write_bitmaps(ext2_fils
 	}
 
 	for (i = 0; i < fs->group_desc_count; i++) {
-		if (!block_bitmap || !do_block)
+		if (!do_block)
 			goto skip_block_bitmap;
 
 		if (lazy_flag && fs->group_desc[i].bg_flags &
 		    EXT2_BG_BLOCK_UNINIT) 
 			goto skip_this_block_bitmap;
  
-		memcpy(block_buf, block_bitmap, block_nbytes);
+		retval = ext2fs_get_block_bitmap_range(fs->block_map, 
+				blk_itr, block_nbytes << 3, block_buf);
+		if (retval)
+			return retval;
+
 		if (i == fs->group_desc_count - 1) {
 			/* Force bitmap padding for the last group */
 			nbits = ((fs->super->s_blocks_count
@@ -110,44 +88,36 @@ static errcode_t write_bitmaps(ext2_fils
 		}
 		blk = fs->group_desc[i].bg_block_bitmap;
 		if (blk) {
-#ifdef EXT2_BIG_ENDIAN_BITMAPS
-			if (!((fs->flags & EXT2_FLAG_SWAP_BYTES) ||
-			      (fs->flags & EXT2_FLAG_SWAP_BYTES_WRITE)))
-				ext2fs_swap_bitmap(fs, block_buf, 
-						   block_nbytes);
-#endif
 			retval = io_channel_write_blk(fs->io, blk, 1,
 						      block_buf);
 			if (retval)
 				return EXT2_ET_BLOCK_BITMAP_WRITE;
 		}
 	skip_this_block_bitmap:
-		block_bitmap += block_nbytes;
+		blk_itr += block_nbytes << 3;
 	skip_block_bitmap:
 
-		if (!inode_bitmap || !do_inode)
+		if (!do_inode)
 			continue;
 
 		if (lazy_flag && fs->group_desc[i].bg_flags &
 		    EXT2_BG_INODE_UNINIT) 
 			goto skip_this_inode_bitmap;
  
-		memcpy(inode_buf, inode_bitmap, inode_nbytes);
+		retval = ext2fs_get_inode_bitmap_range(fs->inode_map, 
+				ino_itr, inode_nbytes << 3, inode_buf);
+		if (retval)
+			return retval;
+
 		blk = fs->group_desc[i].bg_inode_bitmap;
 		if (blk) {
-#ifdef EXT2_BIG_ENDIAN_BITMAPS
-			if (!((fs->flags & EXT2_FLAG_SWAP_BYTES) ||
-			      (fs->flags & EXT2_FLAG_SWAP_BYTES_WRITE)))
-				ext2fs_swap_bitmap(fs, inode_buf, 
-						   inode_nbytes);
-#endif
 			retval = io_channel_write_blk(fs->io, blk, 1,
 						      inode_buf);
 			if (retval)
 				return EXT2_ET_INODE_BITMAP_WRITE;
 		}
 	skip_this_inode_bitmap:
-		inode_bitmap += inode_nbytes;
+		ino_itr += inode_nbytes << 3;
 
 	}
 	if (do_block) {
@@ -167,17 +137,25 @@ static errcode_t read_bitmaps(ext2_filsy
 	char *block_bitmap = 0, *inode_bitmap = 0;
 	char *buf;
 	errcode_t retval;
-	int block_nbytes = (int) EXT2_BLOCKS_PER_GROUP(fs->super) / 8;
-	int inode_nbytes = (int) EXT2_INODES_PER_GROUP(fs->super) / 8;
+	unsigned int block_nbytes = EXT2_BLOCKS_PER_GROUP(fs->super) / 8;
+	unsigned inode_nbytes = EXT2_INODES_PER_GROUP(fs->super) / 8;
 	int lazy_flag = 0;
+	int do_image = fs->flags & EXT2_FLAG_IMAGE_FILE;
+	unsigned int	cnt;
 	blk_t	blk;
+	blk_t	blk_itr = fs->super->s_first_data_block;
+	blk_t   blk_cnt;
+	ext2_ino_t ino_itr = 1;
+	ext2_ino_t ino_cnt;
 
 	EXT2_CHECK_MAGIC(fs, EXT2_ET_MAGIC_EXT2FS_FILSYS);
 
 	fs->write_bitmaps = ext2fs_write_bitmaps;
 
-	if (EXT2_HAS_COMPAT_FEATURE(fs->super, 
-				    EXT2_FEATURE_COMPAT_LAZY_BG))
+	if (EXT2_HAS_COMPAT_FEATURE(fs->super,
+				    EXT2_FEATURE_COMPAT_LAZY_BG) ||
+	    EXT2_HAS_RO_COMPAT_FEATURE(fs->super,
+				       EXT4_FEATURE_RO_COMPAT_GDT_CSUM))
 		lazy_flag = 1;
 
 	retval = ext2fs_get_mem(strlen(fs->device_name) + 80, &buf);
@@ -190,8 +168,12 @@ static errcode_t read_bitmaps(ext2_filsy
 		retval = ext2fs_allocate_block_bitmap(fs, buf, &fs->block_map);
 		if (retval)
 			goto cleanup;
-		block_bitmap = fs->block_map->bitmap;
-	}
+		retval = ext2fs_get_mem(do_image ? fs->blocksize : 
+					block_nbytes, &block_bitmap);
+		if (retval)
+			goto cleanup;
+	} else
+		block_nbytes = 0;
 	if (do_inode) {
 		if (fs->inode_map)
 			ext2fs_free_inode_bitmap(fs->inode_map);
@@ -199,37 +181,62 @@ static errcode_t read_bitmaps(ext2_filsy
 		retval = ext2fs_allocate_inode_bitmap(fs, buf, &fs->inode_map);
 		if (retval)
 			goto cleanup;
-		inode_bitmap = fs->inode_map->bitmap;
-	}
+		retval = ext2fs_get_mem(do_image ? fs->blocksize : 
+					inode_nbytes, &inode_bitmap);
+		if (retval)
+			goto cleanup;
+	} else
+		inode_nbytes = 0;
 	ext2fs_free_mem(&buf);
 
 	if (fs->flags & EXT2_FLAG_IMAGE_FILE) {
-		if (inode_bitmap) {
-			blk = (fs->image_header->offset_inodemap /
-			       fs->blocksize);
-			retval = io_channel_read_blk(fs->image_io, blk,
-			     -(inode_nbytes * fs->group_desc_count),
-			     inode_bitmap);
+		blk = (fs->image_header->offset_inodemap / fs->blocksize);
+		ino_cnt = fs->super->s_inodes_count;
+		while (inode_nbytes > 0) {
+			retval = io_channel_read_blk(fs->image_io, blk++,
+						     1, inode_bitmap);
 			if (retval)
 				goto cleanup;
+			cnt = fs->blocksize << 3;
+			if (cnt > ino_cnt)
+				cnt = ino_cnt;
+			retval = ext2fs_set_inode_bitmap_range(fs->inode_map, 
+					       ino_itr, cnt, inode_bitmap);
+			if (retval)
+				goto cleanup;
+			ino_itr += fs->blocksize << 3;
+			ino_cnt -= fs->blocksize << 3;
+			inode_nbytes -= fs->blocksize;
 		}
-		if (block_bitmap) {
-			blk = (fs->image_header->offset_blockmap /
-			       fs->blocksize);
-			retval = io_channel_read_blk(fs->image_io, blk, 
-			     -(block_nbytes * fs->group_desc_count),
-			     block_bitmap);
+		blk = (fs->image_header->offset_blockmap /
+		       fs->blocksize);
+		blk_cnt = EXT2_BLOCKS_PER_GROUP(fs->super) * 
+			fs->group_desc_count;
+		while (block_nbytes > 0) {
+			retval = io_channel_read_blk(fs->image_io, blk++,
+						     1, block_bitmap);
 			if (retval)
 				goto cleanup;
+			cnt = fs->blocksize << 3;
+			if (cnt > blk_cnt)
+				cnt = blk_cnt;
+			retval = ext2fs_set_block_bitmap_range(fs->block_map, 
+				       blk_itr, cnt, block_bitmap);
+			if (retval)
+				goto cleanup;
+			blk_itr += fs->blocksize << 3;
+			blk_cnt -= fs->blocksize << 3;
+			block_nbytes -= fs->blocksize;
 		}
-		return 0;
+		goto success_cleanup;
 	}
 
 	for (i = 0; i < fs->group_desc_count; i++) {
 		if (block_bitmap) {
 			blk = fs->group_desc[i].bg_block_bitmap;
 			if (lazy_flag && fs->group_desc[i].bg_flags &
-			    EXT2_BG_BLOCK_UNINIT)
+			    EXT2_BG_BLOCK_UNINIT &&
+			    ext2fs_group_desc_csum_verify(fs, i))
 				blk = 0;
 			if (blk) {
 				retval = io_channel_read_blk(fs->io, blk,
@@ -238,19 +245,20 @@ static errcode_t read_bitmaps(ext2_filsy
 					retval = EXT2_ET_BLOCK_BITMAP_READ;
 					goto cleanup;
 				}
-#ifdef EXT2_BIG_ENDIAN_BITMAPS
-				if (!((fs->flags & EXT2_FLAG_SWAP_BYTES) ||
-				      (fs->flags & EXT2_FLAG_SWAP_BYTES_READ)))
-					ext2fs_swap_bitmap(fs, block_bitmap, block_nbytes);
-#endif
 			} else
 				memset(block_bitmap, 0xff, block_nbytes);
-			block_bitmap += block_nbytes;
+			cnt = block_nbytes << 3;
+			retval = ext2fs_set_block_bitmap_range(fs->block_map, 
+					       blk_itr, cnt, block_bitmap);
+			if (retval)
+				goto cleanup;
+			blk_itr += block_nbytes << 3;
 		}
 		if (inode_bitmap) {
 			blk = fs->group_desc[i].bg_inode_bitmap;
 			if (lazy_flag && fs->group_desc[i].bg_flags &
-			    EXT2_BG_INODE_UNINIT)
+			    EXT2_BG_INODE_UNINIT &&
+			    ext2fs_group_desc_csum_verify(fs, i))
 				blk = 0;
 			if (blk) {
 				retval = io_channel_read_blk(fs->io, blk,
@@ -259,16 +267,21 @@ static errcode_t read_bitmaps(ext2_filsy
 					retval = EXT2_ET_INODE_BITMAP_READ;
 					goto cleanup;
 				}
-#ifdef EXT2_BIG_ENDIAN_BITMAPS
-				if (!((fs->flags & EXT2_FLAG_SWAP_BYTES) ||
-				      (fs->flags & EXT2_FLAG_SWAP_BYTES_READ)))
-					ext2fs_swap_bitmap(fs, inode_bitmap, inode_nbytes);
-#endif
 			} else
 				memset(inode_bitmap, 0xff, inode_nbytes);
-			inode_bitmap += inode_nbytes;
+			cnt = inode_nbytes << 3;
+			retval = ext2fs_set_inode_bitmap_range(fs->inode_map, 
+					       ino_itr, cnt, inode_bitmap);
+			if (retval)
+				goto cleanup;
+			ino_itr += inode_nbytes << 3;
 		}
 	}
+success_cleanup:
+	if (inode_bitmap)
+		ext2fs_free_mem(&inode_bitmap);
+	if (block_bitmap)
+		ext2fs_free_mem(&block_bitmap);
 	return 0;
 	
 cleanup:
@@ -280,6 +293,10 @@ cleanup:
 		ext2fs_free_mem(&fs->inode_map);
 		fs->inode_map = 0;
 	}
+	if (inode_bitmap)
+		ext2fs_free_mem(&inode_bitmap);
+	if (block_bitmap)
+		ext2fs_free_mem(&block_bitmap);
 	if (buf)
 		ext2fs_free_mem(&buf);
 	return retval;
diff -Nurp e2fsprogs-1.40.8/lib/ext2fs/swapfs.c e2fsprogs/lib/ext2fs/swapfs.c
--- e2fsprogs-1.40.8/lib/ext2fs/swapfs.c	2008-03-13 23:20:46.000000000 +0100
+++ e2fsprogs/lib/ext2fs/swapfs.c	2008-03-29 01:20:43.000000000 +0100
@@ -20,7 +20,7 @@
 #include "ext2fs.h"
 #include <ext2fs/ext2_ext_attr.h>
 
-#ifdef EXT2FS_ENABLE_SWAPFS
+#ifdef WORDS_BIGENDIAN
 void ext2fs_swap_super(struct ext2_super_block * sb)
 {
   	int i;
@@ -90,6 +90,29 @@ void ext2fs_swap_group_desc(struct ext2_
 	gdp->bg_checksum = ext2fs_swab16(gdp->bg_checksum);
 }
 
+void ext2fs_swap_ext_attr_header(struct ext2_ext_attr_header *to_header,
+				 struct ext2_ext_attr_header *from_header)
+{
+	int n;
+
+	to_header->h_magic    = ext2fs_swab32(from_header->h_magic);
+	to_header->h_blocks   = ext2fs_swab32(from_header->h_blocks);
+	to_header->h_refcount = ext2fs_swab32(from_header->h_refcount);
+	to_header->h_hash     = ext2fs_swab32(from_header->h_hash);
+	for (n = 0; n < 4; n++)
+		to_header->h_reserved[n] =
+			ext2fs_swab32(from_header->h_reserved[n]);
+}
+
+void ext2fs_swap_ext_attr_entry(struct ext2_ext_attr_entry *to_entry,
+				struct ext2_ext_attr_entry *from_entry)
+{
+	to_entry->e_value_offs  = ext2fs_swab16(from_entry->e_value_offs);
+	to_entry->e_value_block = ext2fs_swab32(from_entry->e_value_block);
+	to_entry->e_value_size  = ext2fs_swab32(from_entry->e_value_size);
+	to_entry->e_hash	= ext2fs_swab32(from_entry->e_hash);
+}
+
 void ext2fs_swap_ext_attr(char *to, char *from, int bufsize, int has_header)
 {
 	struct ext2_ext_attr_header *from_header =
@@ -98,32 +121,22 @@ void ext2fs_swap_ext_attr(char *to, char
 		(struct ext2_ext_attr_header *)to;
 	struct ext2_ext_attr_entry *from_entry, *to_entry;
 	char *from_end = (char *)from_header + bufsize;
-	int n;
 
 	if (to_header != from_header)
 		memcpy(to_header, from_header, bufsize);
 
-	from_entry = (struct ext2_ext_attr_entry *)from_header;
-	to_entry   = (struct ext2_ext_attr_entry *)to_header;
-
 	if (has_header) {
-		to_header->h_magic    = ext2fs_swab32(from_header->h_magic);
-		to_header->h_blocks   = ext2fs_swab32(from_header->h_blocks);
-		to_header->h_refcount = ext2fs_swab32(from_header->h_refcount);
-		for (n=0; n<4; n++)
-			to_header->h_reserved[n] =
-				ext2fs_swab32(from_header->h_reserved[n]);
+		ext2fs_swap_ext_attr_header(to_header, from_header);
+
 		from_entry = (struct ext2_ext_attr_entry *)(from_header+1);
 		to_entry   = (struct ext2_ext_attr_entry *)(to_header+1);
+	} else {
+		from_entry = (struct ext2_ext_attr_entry *)from_header;
+		to_entry   = (struct ext2_ext_attr_entry *)to_header;
 	}
 
 	while ((char *)from_entry < from_end && *(__u32 *)from_entry) {
-		to_entry->e_value_offs  =	
-			ext2fs_swab16(from_entry->e_value_offs);
-		to_entry->e_value_block =	
-			ext2fs_swab32(from_entry->e_value_block);
-		to_entry->e_value_size  =	
-			ext2fs_swab32(from_entry->e_value_size);
+		ext2fs_swap_ext_attr_entry(to_entry, from_entry);
 		from_entry = EXT2_EXT_ATTR_NEXT(from_entry);
 		to_entry   = EXT2_EXT_ATTR_NEXT(to_entry);
 	}
@@ -133,7 +146,7 @@ void ext2fs_swap_inode_full(ext2_filsys 
 			    struct ext2_inode_large *f, int hostorder,
 			    int bufsize)
 {
-	unsigned i, has_data_blocks, extra_isize;
+	unsigned i, has_data_blocks, extra_isize, attr_magic;
 	int islnk = 0;
 	__u32 *eaf, *eat;
 
@@ -158,7 +171,11 @@ void ext2fs_swap_inode_full(ext2_filsys 
 	if (!hostorder)
 		has_data_blocks = ext2fs_inode_data_blocks(fs, 
 					   (struct ext2_inode *) t);
+	if (hostorder && (f->i_flags & EXT4_EXTENTS_FL))
+		has_data_blocks = 0;
 	t->i_flags = ext2fs_swab32(f->i_flags);
+	if (hostorder && (t->i_flags & EXT4_EXTENTS_FL))
+		has_data_blocks = 0;
 	t->i_dir_acl = ext2fs_swab32(f->i_dir_acl);
 	if (!islnk || has_data_blocks ) {
 		for (i = 0; i < EXT2_N_BLOCKS; i++)
@@ -198,16 +215,7 @@ void ext2fs_swap_inode_full(ext2_filsys 
 		t->osd2.hurd2.h_i_author =
 		  ext2fs_swab32 (f->osd2.hurd2.h_i_author);
 		break;
-	case EXT2_OS_MASIX:
-		t->osd1.masix1.m_i_reserved1 =
-			ext2fs_swab32(f->osd1.masix1.m_i_reserved1);
-		t->osd2.masix2.m_i_frag = f->osd2.masix2.m_i_frag;
-		t->osd2.masix2.m_i_fsize = f->osd2.masix2.m_i_fsize;
-		t->osd2.masix2.m_pad1 = ext2fs_swab16(f->osd2.masix2.m_pad1);
-		t->osd2.masix2.m_i_reserved2[0] =
-			ext2fs_swab32(f->osd2.masix2.m_i_reserved2[0]);
-		t->osd2.masix2.m_i_reserved2[1] =
-			ext2fs_swab32(f->osd2.masix2.m_i_reserved2[1]);
+	default:
 		break;
 	}
 
@@ -232,7 +240,11 @@ void ext2fs_swap_inode_full(ext2_filsys 
 	eaf = (__u32 *) (((char *) f) + sizeof(struct ext2_inode) +
 					extra_isize);
 
-	if (ext2fs_swab32(*eaf) != EXT2_EXT_ATTR_MAGIC)
+	attr_magic = *eaf;
+	if (!hostorder)
+		attr_magic = ext2fs_swab32(attr_magic);
+
+	if (attr_magic != EXT2_EXT_ATTR_MAGIC)
 		return; /* it seems no magic here */
 
 	eat = (__u32 *) (((char *) t) + sizeof(struct ext2_inode) +
diff -Nurp e2fsprogs-1.40.8/lib/ext2fs/tdb/Makefile e2fsprogs/lib/ext2fs/tdb/Makefile
--- e2fsprogs-1.40.8/lib/ext2fs/tdb/Makefile	2008-02-17 12:35:12.000000000 +0100
+++ e2fsprogs/lib/ext2fs/tdb/Makefile	1970-01-01 01:00:00.000000000 +0100
@@ -1,15 +0,0 @@
-all: tdbtool
-
-tdb.c tdb.h tdbtool.c: 
-	./build-tdb
-
-tdbtool.o: tdbtool.c
-	gcc -c tdbtool.c
-
-tdbtool: tdb.o tdbtool.o
-	gcc -o tdbtool tdb.o tdbtool.o
-
-clean:
-	rm -f tdb.c tdb.h tdb.o tdbtool tdbtool.c tdbtool.o .svninfo
-	rm -rf .pc
-
diff -Nurp e2fsprogs-1.40.8/lib/ext2fs/test_io.c e2fsprogs/lib/ext2fs/test_io.c
--- e2fsprogs-1.40.8/lib/ext2fs/test_io.c	2008-03-13 23:20:46.000000000 +0100
+++ e2fsprogs/lib/ext2fs/test_io.c	2008-03-29 01:20:43.000000000 +0100
@@ -66,6 +66,8 @@ static errcode_t test_write_byte(io_chan
 				 int count, const void *buf);
 static errcode_t test_set_option(io_channel channel, const char *option, 
 				 const char *arg);
+static errcode_t test_get_stats(io_channel channel, io_stats *stats);
+
 
 static struct struct_io_manager struct_test_manager = {
 	EXT2_ET_MAGIC_IO_MANAGER,
@@ -77,7 +79,8 @@ static struct struct_io_manager struct_t
 	test_write_blk,
 	test_flush,
 	test_write_byte,
-	test_set_option
+	test_set_option,
+	test_get_stats,
 };
 
 io_manager test_io_manager = &struct_test_manager;
@@ -409,3 +412,18 @@ static errcode_t test_set_option(io_chan
 	}
 	return retval;
 }
+
+static errcode_t test_get_stats(io_channel channel, io_stats *stats)
+{
+	struct test_private_data *data;
+	errcode_t	retval = 0;
+
+	EXT2_CHECK_MAGIC(channel, EXT2_ET_MAGIC_IO_CHANNEL);
+	data = (struct test_private_data *) channel->private_data;
+	EXT2_CHECK_MAGIC(data, EXT2_ET_MAGIC_TEST_IO_CHANNEL);
+
+	if (data->real && data->real->manager->get_stats) {
+		retval = (data->real->manager->get_stats)(data->real, stats);
+	}
+	return retval;
+}
diff -Nurp e2fsprogs-1.40.8/lib/ext2fs/tst_csum.c e2fsprogs/lib/ext2fs/tst_csum.c
--- e2fsprogs-1.40.8/lib/ext2fs/tst_csum.c	1970-01-01 01:00:00.000000000 +0100
+++ e2fsprogs/lib/ext2fs/tst_csum.c	2008-03-29 01:20:43.000000000 +0100
@@ -0,0 +1,130 @@
+/*
+ * This testing program verifies checksumming operations
+ *
+ * Copyright (C) 2006, 2007 by Andreas Dilger <adilger@clusterfs.com>
+ *
+ * %Begin-Header%
+ * This file may be redistributed under the terms of the GNU Public
+ * License.
+ * %End-Header%
+ */
+
+#include "ext2fs/ext2_fs.h"
+#include "ext2fs/ext2fs.h"
+
+#ifndef offsetof
+#define offsetof(TYPE, MEMBER) ((size_t) &((TYPE *)0)->MEMBER)
+#endif
+
+void print_csum(const char *msg, ext2_filsys fs, dgrp_t group)
+{
+	__u16 crc1, crc2, crc3;
+	dgrp_t swabgroup;
+	struct ext2_group_desc *desc = &fs->group_desc[group];
+	struct ext2_super_block *sb = fs->super;
+
+#ifdef WORDS_BIGENDIAN
+	struct ext2_group_desc swabdesc = fs->group_desc[group];
+
+	/* Have to swab back to little-endian to do the checksum */
+	ext2fs_swap_group_desc(&swabdesc);
+	desc = &swabdesc;
+
+	swabgroup = ext2fs_swab32(group);
+#else
+	swabgroup = group;
+#endif
+
+	crc1 = crc16(~0, sb->s_uuid, sizeof(fs->super->s_uuid));
+	crc2 = crc16(crc1, &swabgroup, sizeof(swabgroup));
+	crc3 = crc16(crc2, desc, offsetof(struct ext2_group_desc, bg_checksum));
+	printf("%s: UUID %016Lx%016Lx(%04x), grp %u(%04x): %04x=%04x\n",
+	       msg, *(long long *)&sb->s_uuid, *(long long *)&sb->s_uuid[8],
+	       crc1, group, crc2, crc3, ext2fs_group_desc_csum(fs, group));
+}
+
+unsigned char sb_uuid[16] = { 0x4f, 0x25, 0xe8, 0xcf, 0xe7, 0x97, 0x48, 0x23,
+			      0xbe, 0xfa, 0xa7, 0x88, 0x4b, 0xae, 0xec, 0xdb };
+
+main(int argc, char **argv)
+{
+	struct ext2_super_block param;
+	errcode_t		retval;
+	ext2_filsys		fs;
+	int			i;
+	__u16 csum1, csum2, csum_known = 0xd3a4;
+
+	memset(&param, 0, sizeof(param));
+	param.s_blocks_count = 32768;
+
+	retval = ext2fs_initialize("test fs", 0, &param,
+				   test_io_manager, &fs);
+	if (retval) {
+		com_err("setup", retval,
+			"While initializing filesystem");
+		exit(1);
+	}
+	memcpy(fs->super->s_uuid, sb_uuid, 16);
+	fs->super->s_feature_ro_compat = EXT4_FEATURE_RO_COMPAT_GDT_CSUM;
+
+	for (i=0; i < fs->group_desc_count; i++) {
+		fs->group_desc[i].bg_block_bitmap = 124;
+		fs->group_desc[i].bg_inode_bitmap = 125;
+		fs->group_desc[i].bg_inode_table = 126;
+		fs->group_desc[i].bg_free_blocks_count = 31119;
+		fs->group_desc[i].bg_free_inodes_count = 15701;
+		fs->group_desc[i].bg_used_dirs_count = 2;
+		fs->group_desc[i].bg_flags = 0;
+	};
+
+	csum1 = ext2fs_group_desc_csum(fs, 0);
+	print_csum("csum0000", fs, 0);
+
+#ifdef WORDS_BIGENDIAN
+	csum_known = ext2fs_swab16(known);
+#endif
+	if (csum1 != csum_known) {
+		printf("checksum for group 0 should be %04x\n", csum_known);
+		exit(1);
+	}
+	csum2 = ext2fs_group_desc_csum(fs, 1);
+	print_csum("csum0001", fs, 1);
+	if (csum1 == csum2) {
+		printf("checksums for different groups shouldn't match\n");
+		exit(1);
+	}
+	csum2 = ext2fs_group_desc_csum(fs, 2);
+	print_csum("csumffff", fs, 2);
+	if (csum1 == csum2) {
+		printf("checksums for different groups shouldn't match\n");
+		exit(1);
+	}
+	fs->group_desc[0].bg_checksum = csum1;
+	csum2 = ext2fs_group_desc_csum(fs, 0);
+	print_csum("csum_set", fs, 0);
+	if (csum1 != csum2) {
+		printf("checksums should not depend on checksum field\n");
+		exit(1);
+	}
+	if (!ext2fs_group_desc_csum_verify(fs, 0)) {
+		printf("checksums should verify against gd_checksum\n");
+		exit(1);
+	}
+	memset(fs->super->s_uuid, 0x30, sizeof(fs->super->s_uuid));
+	print_csum("new_uuid", fs, 0);
+	if (ext2fs_group_desc_csum_verify(fs, 0) != 0) {
+		printf("checksums for different filesystems shouldn't match\n");
+		exit(1);
+	}
+	csum1 = fs->group_desc[0].bg_checksum = ext2fs_group_desc_csum(fs, 0);
+	print_csum("csum_new", fs, 0);
+	fs->group_desc[0].bg_free_blocks_count = 1;
+	csum2 = ext2fs_group_desc_csum(fs, 0);
+	print_csum("csum_blk", fs, 0);
+	if (csum1 == csum2) {
+		printf("checksums for different data shouldn't match\n");
+		exit(1);
+	}
+
+	return 0;
+}
diff -Nurp e2fsprogs-1.40.8/lib/ext2fs/unix_io.c e2fsprogs/lib/ext2fs/unix_io.c
--- e2fsprogs-1.40.8/lib/ext2fs/unix_io.c	2008-03-13 23:20:46.000000000 +0100
+++ e2fsprogs/lib/ext2fs/unix_io.c	2008-03-29 01:20:43.000000000 +0100
@@ -70,6 +70,7 @@ struct unix_private_data {
 	int	access_time;
 	ext2_loff_t offset;
 	struct unix_cache cache[CACHE_SIZE];
+	struct struct_io_stats io_stats;
 };
 
 static errcode_t unix_open(const char *name, int flags, io_channel *channel);
@@ -84,9 +85,14 @@ static errcode_t unix_write_byte(io_chan
 				int size, const void *data);
 static errcode_t unix_set_option(io_channel channel, const char *option, 
 				 const char *arg);
-
+static errcode_t unix_get_stats(io_channel channel, io_stats *stats)
+;
 static void reuse_cache(io_channel channel, struct unix_private_data *data,
-		 struct unix_cache *cache, unsigned long block);
+		 struct unix_cache *cache, unsigned long long block);
+static errcode_t unix_read_blk64(io_channel channel, unsigned long long block,
+			       int count, void *data);
+static errcode_t unix_write_blk64(io_channel channel, unsigned long long block,
+				int count, const void *data);
 
 /* __FreeBSD_kernel__ is defined by GNU/kFreeBSD - the FreeBSD kernel
  * does not know buffered block devices - everything is raw. */
@@ -110,18 +116,37 @@ static struct struct_io_manager struct_u
 #else
 	unix_write_byte,
 #endif
-	unix_set_option
+	unix_set_option,
+	unix_get_stats,
+	unix_read_blk64,
+	unix_write_blk64,
 };
 
 io_manager unix_io_manager = &struct_unix_manager;
 
+static errcode_t unix_get_stats(io_channel channel, io_stats *stats)
+{
+	errcode_t 	retval = 0;
+
+	struct unix_private_data *data;
+
+	EXT2_CHECK_MAGIC(channel, EXT2_ET_MAGIC_IO_CHANNEL);
+	data = (struct unix_private_data *) channel->private_data;
+	EXT2_CHECK_MAGIC(data, EXT2_ET_MAGIC_UNIX_IO_CHANNEL);
+
+	if (stats)
+		*stats = &data->io_stats;
+
+	return retval;
+}
+
 /*
  * Here are the raw I/O functions
  */
 #ifndef NEED_BOUNCE_BUFFER
 static errcode_t raw_read_blk(io_channel channel,
 			      struct unix_private_data *data,
-			      unsigned long block,
+			      unsigned long long block,
 			      int count, void *buf)
 {
 	errcode_t	retval;
@@ -130,6 +155,7 @@ static errcode_t raw_read_blk(io_channel
 	int		actual = 0;
 
 	size = (count < 0) ? -count : count * channel->block_size;
+	data->io_stats.bytes_read += size;
 	location = ((ext2_loff_t) block * channel->block_size) + data->offset;
 	if (ext2fs_llseek(data->dev, location, SEEK_SET) != location) {
 		retval = errno ? errno : EXT2_ET_LLSEEK_FAILED;
@@ -168,6 +194,7 @@ static errcode_t raw_read_blk(io_channel
 	char		sector[BLOCKALIGN];
 
 	size = (count < 0) ? -count : count * channel->block_size;
+	data->io_stats.bytes_read += size;
 	location = ((ext2_loff_t) block * channel->block_size) + data->offset;
 #ifdef DEBUG
 	printf("count=%d, size=%d, block=%lu, blk_size=%d, location=%llx\n",
@@ -208,7 +235,7 @@ error_out:
 
 static errcode_t raw_write_blk(io_channel channel,
 			       struct unix_private_data *data,
-			       unsigned long block,
+			       unsigned long long block,
 			       int count, const void *buf)
 {
 	ssize_t		size;
@@ -224,6 +251,7 @@ static errcode_t raw_write_blk(io_channe
 		else
 			size = count * channel->block_size;
 	}
+	data->io_stats.bytes_written += size;
 
 	location = ((ext2_loff_t) block * channel->block_size) + data->offset;
 	if (ext2fs_llseek(data->dev, location, SEEK_SET) != location) {
@@ -296,7 +324,7 @@ static void free_cache(struct unix_priva
  * entry to that should be reused.
  */
 static struct unix_cache *find_cached_block(struct unix_private_data *data,
-					    unsigned long block,
+					    unsigned long long block,
 					    struct unix_cache **eldest)
 {
 	struct unix_cache	*cache, *unused_cache, *oldest_cache;
@@ -326,7 +354,7 @@ static struct unix_cache *find_cached_bl
  * Reuse a particular cache entry for another block.
  */
 static void reuse_cache(io_channel channel, struct unix_private_data *data,
-		 struct unix_cache *cache, unsigned long block)
+		 struct unix_cache *cache, unsigned long long block)
 {
 	if (cache->dirty && cache->in_use)
 		raw_write_blk(channel, data, cache->block, 1, cache->buf);
@@ -407,6 +435,7 @@ static errcode_t unix_open(const char *n
 
 	memset(data, 0, sizeof(struct unix_private_data));
 	data->magic = EXT2_ET_MAGIC_UNIX_IO_CHANNEL;
+	data->io_stats.num_fields = 2;
 
 	if ((retval = alloc_cache(io, data)))
 		goto cleanup;
@@ -522,7 +551,7 @@ static errcode_t unix_set_blksize(io_cha
 }
 
 
-static errcode_t unix_read_blk(io_channel channel, unsigned long block,
+static errcode_t unix_read_blk64(io_channel channel, unsigned long long block,
 			       int count, void *buf)
 {
 	struct unix_private_data *data;
@@ -587,7 +616,13 @@ static errcode_t unix_read_blk(io_channe
 #endif /* NO_IO_CACHE */
 }
 
-static errcode_t unix_write_blk(io_channel channel, unsigned long block,
+static errcode_t unix_read_blk(io_channel channel, unsigned long block,
+			       int count, void *buf)
+{
+	return unix_read_blk64(channel, block, count, buf);
+}
+
+static errcode_t unix_write_blk64(io_channel channel, unsigned long long block,
 				int count, const void *buf)
 {
 	struct unix_private_data *data;
@@ -639,6 +674,12 @@ static errcode_t unix_write_blk(io_chann
 #endif /* NO_IO_CACHE */
 }
 
+static errcode_t unix_write_blk(io_channel channel, unsigned long block,
+				int count, const void *buf)
+{
+	return unix_write_blk64(channel, block, count, buf);
+}
+
 static errcode_t unix_write_byte(io_channel channel, unsigned long offset,
 				 int size, const void *buf)
 {
diff -Nurp e2fsprogs-1.40.8/lib/ss/ss.pc.in e2fsprogs/lib/ss/ss.pc.in
--- e2fsprogs-1.40.8/lib/ss/ss.pc.in	2008-03-13 23:20:46.000000000 +0100
+++ e2fsprogs/lib/ss/ss.pc.in	2008-03-29 01:20:43.000000000 +0100
@@ -8,4 +8,5 @@ Description: Subsystem command parsing l
 Version: @E2FSPROGS_VERSION@
 Requires: com_err
 Cflags: -I${includedir} 
-Libs: -L${libdir} -lss @DLOPEN_LIB@
+Libs: -L${libdir} -lss
+Libs.private: @DLOPEN_LIB@
diff -Nurp e2fsprogs-1.40.8/Makefile.in e2fsprogs/Makefile.in
--- e2fsprogs-1.40.8/Makefile.in	2008-03-13 23:20:46.000000000 +0100
+++ e2fsprogs/Makefile.in	2008-03-29 01:20:43.000000000 +0100
@@ -10,7 +10,7 @@ INSTALL = @INSTALL@
 @RESIZER_CMT@RESIZE_DIR= resize
 @DEBUGFS_CMT@DEBUGFS_DIR= debugfs
 
-LIB_SUBDIRS=lib/et lib/ss lib/e2p lib/ext2fs lib/uuid lib/blkid intl
+LIB_SUBDIRS=lib/et lib/ss lib/e2p lib/uuid lib/ext2fs lib/blkid intl
 PROG_SUBDIRS=e2fsck $(DEBUGFS_DIR) misc $(RESIZE_DIR) tests/progs po
 SUBDIRS=util $(LIB_SUBDIRS) $(PROG_SUBDIRS) tests
 
diff -Nurp e2fsprogs-1.40.8/misc/badblocks.c e2fsprogs/misc/badblocks.c
--- e2fsprogs-1.40.8/misc/badblocks.c	2008-03-13 23:20:46.000000000 +0100
+++ e2fsprogs/misc/badblocks.c	2008-03-29 01:20:43.000000000 +0100
@@ -67,13 +67,13 @@ static int s_flag = 0;			/* show progres
 static int force = 0;			/* force check of mounted device */
 static int t_flag = 0;			/* number of test patterns */
 static int t_max = 0;			/* allocated test patterns */
-static unsigned long *t_patts = NULL;	/* test patterns */
+static unsigned int *t_patts = NULL;	/* test patterns */
 static int current_O_DIRECT = 0;	/* Current status of O_DIRECT flag */
 static int exclusive_ok = 0;
 
 #define T_INC 32
 
-int sys_page_size = 4096;
+unsigned int sys_page_size = 4096;
 
 static void usage(void)
 {
@@ -90,8 +90,8 @@ static void exclusive_usage(void)
 	exit(1);
 }
 
-static unsigned long currently_testing = 0;
-static unsigned long num_blocks = 0;
+static blk_t currently_testing = 0;
+static blk_t num_blocks = 0;
 static ext2_badblocks_list bb_list = NULL;
 static FILE *out;
 static blk_t next_bad = 0;
@@ -124,14 +124,14 @@ static void *allocate_buffer(size_t size
  * This routine reports a new bad block.  If the bad block has already
  * been seen before, then it returns 0; otherwise it returns 1.
  */
-static int bb_output (unsigned long bad)
+static int bb_output (blk_t bad)
 {
 	errcode_t errcode;
 
 	if (ext2fs_badblocks_list_test(bb_list, bad))
 		return 0;
 
-	fprintf(out, "%lu\n", bad);
+	fprintf(out, "%lu\n", (unsigned long) bad);
 	fflush(out);
 
 	errcode = ext2fs_badblocks_list_add (bb_list, bad);
@@ -151,7 +151,8 @@ static int bb_output (unsigned long bad)
 
 static void print_status(void)
 {
-	fprintf(stderr, "%15ld/%15ld", currently_testing, num_blocks);
+	fprintf(stderr, "%15lu/%15lu", (unsigned long) currently_testing, 
+		(unsigned long) num_blocks);
 	fputs("\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b", stderr);
 	fflush (stderr);
 }
@@ -197,7 +198,7 @@ static void uncapture_terminate(void)
 }
 
 static void set_o_direct(int dev, unsigned char *buffer, size_t size,
-			 unsigned long current_block)
+			 blk_t current_block)
 {
 #ifdef O_DIRECT
 	int new_flag = O_DIRECT;
@@ -221,13 +222,13 @@ static void set_o_direct(int dev, unsign
 }
 
 
-static void pattern_fill(unsigned char *buffer, unsigned long pattern,
+static void pattern_fill(unsigned char *buffer, unsigned int pattern,
 			 size_t n)
 {
 	unsigned int	i, nb;
 	unsigned char	bpattern[sizeof(pattern)], *ptr;
 	
-	if (pattern == (unsigned long) ~0) {
+	if (pattern == (unsigned int) ~0) {
 		for (ptr = buffer; ptr < buffer + n; ptr++) {
 			(*ptr) = random() % (1 << (8 * sizeof(char)));
 		}
@@ -262,8 +263,8 @@ static void pattern_fill(unsigned char *
  * Perform a read of a sequence of blocks; return the number of blocks
  *    successfully sequentially read.
  */
-static long do_read (int dev, unsigned char * buffer, int try, int block_size,
-		     unsigned long current_block)
+static int do_read (int dev, unsigned char * buffer, int try, int block_size,
+		    blk_t current_block)
 {
 	long got;
 
@@ -291,8 +292,8 @@ static long do_read (int dev, unsigned c
  * Perform a write of a sequence of blocks; return the number of blocks
  *    successfully sequentially written.
  */
-static long do_write (int dev, unsigned char * buffer, int try, int block_size,
-		     unsigned long current_block)
+static int do_write(int dev, unsigned char * buffer, int try, int block_size,
+		    unsigned long current_block)
 {
 	long got;
 
@@ -327,13 +328,13 @@ static void flush_bufs(void)
 		com_err(program_name, retval, _("during ext2fs_sync_device"));
 }
 
-static unsigned int test_ro (int dev, unsigned long last_block,
-			     int block_size, unsigned long from_count,
-			     unsigned long blocks_at_once)
+static unsigned int test_ro (int dev, blk_t last_block,
+			     int block_size, blk_t from_count,
+			     unsigned int blocks_at_once)
 {
 	unsigned char * blkbuf;
 	int try;
-	long got;
+	int got;
 	unsigned int bb_count = 0;
 	errcode_t errcode;
 
@@ -358,8 +359,9 @@ static unsigned int test_ro (int dev, un
 		exit (1);
 	}
 	if (v_flag) {
-	    fprintf (stderr, _("Checking blocks %lu to %lu\n"), from_count,
-		     last_block - 1);
+		fprintf (stderr, _("Checking blocks %lu to %lu\n"), 
+			 (unsigned long) from_count, 
+			 (unsigned long) last_block - 1);
 	}
 	if (t_flag) {
 		fputs(_("Checking for bad blocks in read-only mode\n"), stderr);
@@ -404,7 +406,7 @@ static unsigned int test_ro (int dev, un
 		if (got == try) {
 			try = blocks_at_once;
 			/* recover page-aligned offset for O_DIRECT */
-			if ( blocks_at_once >= (unsigned long) (sys_page_size >> 9)
+			if ( (blocks_at_once >= sys_page_size >> 9)
 			     && (currently_testing % (sys_page_size >> 9)!= 0))
 				try -= (sys_page_size >> 9)
 					- (currently_testing 
@@ -430,13 +432,13 @@ static unsigned int test_ro (int dev, un
 	return bb_count;
 }
 
-static unsigned int test_rw (int dev, unsigned long last_block,
-			     int block_size, unsigned long from_count,
-			     unsigned long blocks_at_once)
+static unsigned int test_rw (int dev, blk_t last_block,
+			     int block_size, blk_t from_count,
+			     unsigned int blocks_at_once)
 {
 	unsigned char *buffer, *read_buffer;
-	const unsigned long patterns[] = {0xaa, 0x55, 0xff, 0x00};
-	const unsigned long *pattern;
+	const unsigned int patterns[] = {0xaa, 0x55, 0xff, 0x00};
+	const unsigned int *pattern;
 	int i, try, got, nr_pattern, pat_idx;
 	unsigned int bb_count = 0;
 
@@ -454,7 +456,8 @@ static unsigned int test_rw (int dev, un
 		fputs(_("Checking for bad blocks in read-write mode\n"), 
 		      stderr);
 		fprintf(stderr, _("From block %lu to %lu\n"),
-			 from_count, last_block);
+			(unsigned long) from_count, 
+			(unsigned long) last_block);
 	}
 	if (t_flag) {
 		pattern = t_patts;
@@ -484,7 +487,7 @@ static unsigned int test_rw (int dev, un
 			if (got == try) {
 				try = blocks_at_once;
 				/* recover page-aligned offset for O_DIRECT */
-				if ( blocks_at_once >= (unsigned long) (sys_page_size >> 9)
+				if ( (blocks_at_once >= sys_page_size >> 9)
 				     && (currently_testing % 
 					 (sys_page_size >> 9)!= 0))
 					try -= (sys_page_size >> 9)
@@ -528,7 +531,7 @@ static unsigned int test_rw (int dev, un
 			}
 			currently_testing += got;
 			/* recover page-aligned offset for O_DIRECT */
-			if ( blocks_at_once >= (unsigned long) (sys_page_size >> 9)
+			if ( (blocks_at_once >= sys_page_size >> 9)
 			     && (currently_testing % (sys_page_size >> 9)!= 0))
 				try = blocks_at_once - (sys_page_size >> 9)
 					- (currently_testing 
@@ -555,17 +558,18 @@ struct saved_blk_record {
 	int	num;
 };
 
-static unsigned int test_nd (int dev, unsigned long last_block,
-			     int block_size, unsigned long from_count,
-			     unsigned long blocks_at_once)
+static unsigned int test_nd (int dev, blk_t last_block,
+			     int block_size, blk_t from_count,
+			     unsigned int blocks_at_once)
 {
 	unsigned char *blkbuf, *save_ptr, *test_ptr, *read_ptr;
 	unsigned char *test_base, *save_base, *read_base;
 	int try, i;
-	const unsigned long patterns[] = { ~0 };
-	const unsigned long *pattern;
+	const unsigned int patterns[] = { ~0 };
+	const unsigned int *pattern;
 	int nr_pattern, pat_idx;
-	long got, used2, written, save_currently_testing;
+	int got, used2, written;
+	blk_t save_currently_testing;
 	struct saved_blk_record *test_record;
 	/* This is static to prevent being clobbered by the longjmp */
 	static int num_saved;
@@ -601,7 +605,8 @@ static unsigned int test_nd (int dev, un
 	flush_bufs();
 	if (v_flag) {
 	    fputs(_("Checking for bad blocks in non-destructive read-write mode\n"), stderr);
-	    fprintf (stderr, _("From block %lu to %lu\n"), from_count, last_block);
+	    fprintf (stderr, _("From block %lu to %lu\n"), 
+		     (unsigned long) from_count, (unsigned long) last_block);
 	}
 	if (s_flag || v_flag > 1) {
 		fputs(_("Checking for bad blocks (non-destructive read-write test)\n"), stderr);
@@ -682,7 +687,8 @@ static unsigned int test_nd (int dev, un
 			if (written != got)
 				com_err (program_name, errno,
 					 _("during test data write, block %lu"),
-					 currently_testing + written);
+					 (unsigned long) currently_testing + 
+					 written);
 
 			buf_used += got;
 			save_ptr += got * block_size;
@@ -813,27 +819,43 @@ static void check_mount(char *device_nam
 
 }
 
+/*
+ * This function will convert a string to an unsigned long, printing
+ * an error message if it fails, and returning success or failure in err.
+ */
+static unsigned int parse_uint(const char *str, const char *descr)
+{
+	char		*tmp;
+	unsigned long	ret;
+	
+	ret = strtoul(str, &tmp, 0);
+	if (*tmp || errno || (ret > UINT_MAX) ||
+	    (ret == ULONG_MAX && errno == ERANGE)) {
+		com_err (program_name, 0, _("invalid %s - %s"), descr, str);
+		exit (1);
+	}
+	return ret;
+}
 
 int main (int argc, char ** argv)
 {
 	int c;
-	char * tmp;
 	char * device_name;
 	char * host_device_name = NULL;
 	char * input_file = NULL;
 	char * output_file = NULL;
 	FILE * in = NULL;
 	int block_size = 1024;
-	unsigned long blocks_at_once = 64;
+	unsigned int blocks_at_once = 64;
 	blk_t last_block, from_count;
 	int num_passes = 0;
 	int passes_clean = 0;
 	int dev;
 	errcode_t errcode;
-	unsigned long pattern;
-	unsigned int (*test_func)(int, unsigned long,
-				  int, unsigned long,
-				  unsigned long);
+	unsigned int pattern;
+	unsigned int (*test_func)(int, blk_t,
+				  int, blk_t,
+				  unsigned int);
 	int open_flag = 0;
 	long sysval;
 
@@ -865,8 +887,8 @@ int main (int argc, char ** argv)
 	while ((c = getopt (argc, argv, "b:fi:o:svwnc:p:h:t:X")) != EOF) {
 		switch (c) {
 		case 'b':
-			block_size = strtoul (optarg, &tmp, 0);
-			if (*tmp || block_size > 4096) {
+			block_size = parse_uint(optarg, "block size");
+			if (block_size > 4096) {
 				com_err (program_name, 0,
 					 _("bad block size - %s"), optarg);
 				exit (1);
@@ -900,27 +922,18 @@ int main (int argc, char ** argv)
 			w_flag = 2;
 			break;
 		case 'c':
-			blocks_at_once = strtoul (optarg, &tmp, 0);
-			if (*tmp) {
-				com_err (program_name, 0,
-					 "bad simultaneous block count - %s", optarg);
-				exit (1);
-			}
+			blocks_at_once = parse_uint(optarg, "blocks at once");
 			break;
 		case 'p':
-			num_passes = strtoul (optarg, &tmp, 0);
-			if (*tmp) {
-				com_err (program_name, 0,
-				    "bad number of clean passes - %s", optarg);
-				exit (1);
-			}
+			num_passes = parse_uint(optarg, 
+						"number of clean passes");
 			break;
 		case 'h':
 			host_device_name = optarg;
 			break;
 		case 't':
 			if (t_flag + 1 > t_max) {
-				unsigned long *t_patts_new;
+				unsigned int *t_patts_new;
 
 				t_patts_new = realloc(t_patts, t_max + T_INC);
 				if (!t_patts_new) {
@@ -936,14 +949,8 @@ int main (int argc, char ** argv)
 			if (!strcmp(optarg, "r") || !strcmp(optarg,"random")) {
 				t_patts[t_flag++] = ~0;
 			} else {
-				pattern = strtoul(optarg, &tmp, 0);
-				if (*tmp) {
-					com_err(program_name, 0,
-					_("invalid test_pattern: %s\n"),
-						optarg);
-					exit(1);
-				}
-				if (pattern == (unsigned long) ~0)
+				pattern = parse_uint(optarg, "test pattern");
+				if (pattern == (unsigned int) ~0)
 					pattern = 0xffff;
 				t_patts[t_flag++] = pattern;
 			}
@@ -962,7 +969,7 @@ int main (int argc, char ** argv)
 			  "in read-only mode"));
 			exit(1);
 		}
-		if (t_patts && (t_patts[0] == (unsigned long) ~0)) {
+		if (t_patts && (t_patts[0] == (unsigned int) ~0)) {
 			com_err(program_name, 0,
 			_("Random test_pattern is not allowed "
 			  "in read-only mode"));
@@ -989,30 +996,18 @@ int main (int argc, char ** argv)
 		}
 	} else {
 		errno = 0;
-		last_block = strtoul (argv[optind], &tmp, 0);
+		last_block = parse_uint(argv[optind], "last block");
 		printf("last_block = %d (%s)\n", last_block, argv[optind]);
-		if (*tmp || errno || 
-		    (last_block == ULONG_MAX && errno == ERANGE)) {
-			com_err (program_name, 0, _("invalid blocks count - %s"),
-				 argv[optind]);
-			exit (1);
-		}
 		last_block++;
 		optind++;
 	}
 	if (optind <= argc-1) {
 		errno = 0;
-		from_count = strtoul (argv[optind], &tmp, 0);
+		from_count = parse_uint(argv[optind], "start block");
 		printf("from_count = %d\n", from_count);
-		if (*tmp || errno ||
-		    (from_count == ULONG_MAX && errno == ERANGE)) {
-			com_err (program_name, 0, _("invalid starting block - %s"),
-				 argv[optind]);
-			exit (1);
-		}
 	} else from_count = 0;
 	if (from_count >= last_block) {
-	    com_err (program_name, 0, _("invalid starting block (%d): must be less than %lu"),
+	    com_err (program_name, 0, _("invalid starting block (%lu): must be less than %lu"),
 		     (unsigned long) from_count, (unsigned long) last_block);
 	    exit (1);
 	}
diff -Nurp e2fsprogs-1.40.8/misc/chattr.1.in e2fsprogs/misc/chattr.1.in
--- e2fsprogs-1.40.8/misc/chattr.1.in	2008-03-13 23:20:46.000000000 +0100
+++ e2fsprogs/misc/chattr.1.in	2008-03-29 01:20:43.000000000 +0100
@@ -5,7 +5,7 @@ chattr \- change file attributes on a Li
 .SH SYNOPSIS
 .B chattr
 [
-.B \-RV
+.B \-RVf
 ]
 [
 .B \-v
@@ -34,12 +34,13 @@ synchronous updates (S), and top of dire
 .TP
 .B \-R
 Recursively change attributes of directories and their contents.
-Symbolic links encountered during recursive directory traversals are
-ignored.
 .TP
 .B \-V
 Be verbose with chattr's output and print the program version.
 .TP
+.B \-f
+Suppress most error messages.
+.TP
 .BI \-v " version"
 Set the file's version/generation number.
 .SH ATTRIBUTES
diff -Nurp e2fsprogs-1.40.8/misc/chattr.c e2fsprogs/misc/chattr.c
--- e2fsprogs-1.40.8/misc/chattr.c	2008-03-13 23:20:46.000000000 +0100
+++ e2fsprogs/misc/chattr.c	2008-03-29 01:20:43.000000000 +0100
@@ -65,6 +65,7 @@ static unsigned long version;
 
 static int recursive;
 static int verbose;
+static int silent;
 
 static unsigned long af;
 static unsigned long rf;
@@ -80,8 +81,8 @@ static unsigned long sf;
 
 static void usage(void)
 {
-	fprintf(stderr, 
-		_("Usage: %s [-RV] [-+=AacDdijsSu] [-v version] files...\n"),
+	fprintf(stderr,
+		_("Usage: %s [-RVf] [-+=AacDdijsSu] [-v version] files...\n"),
 		program_name);
 	exit(1);
 }
@@ -137,6 +138,10 @@ static int decode_arg (int * i, int argc
 				verbose = 1;
 				continue;
 			}
+			if (*p == 'f') {
+				silent = 1;
+				continue;
+			}
 			if (*p == 'v') {
 				(*i)++;
 				if (*i >= argc)
@@ -144,7 +149,7 @@ static int decode_arg (int * i, int argc
 				version = strtol (argv[*i], &tmp, 0);
 				if (*tmp) {
 					com_err (program_name, 0,
-						 _("bad version - %s\n"), 
+						 _("bad version - %s\n"),
 						 argv[*i]);
 					usage ();
 				}
@@ -180,28 +185,19 @@ static int decode_arg (int * i, int argc
 	return 1;
 }
 
-static int chattr_dir_proc (const char *, struct dirent *, void *);
+static int chattr_dir_proc(const char *, struct dirent *, void *);
 
-static void change_attributes (const char * name)
+static int change_attributes(const char * name)
 {
 	unsigned long flags;
 	STRUCT_STAT	st;
 
 	if (LSTAT (name, &st) == -1) {
-		com_err (program_name, errno, _("while trying to stat %s"), 
-			 name);
-		return;
-	}
-	if (S_ISLNK(st.st_mode) && recursive)
-		return;
-
-	/* Don't try to open device files, fifos etc.  We probably
-           ought to display an error if the file was explicitly given
-           on the command line (whether or not recursive was
-           requested).  */
-	if (!S_ISREG(st.st_mode) && !S_ISLNK(st.st_mode) &&
-	    !S_ISDIR(st.st_mode))
-		return;
+		if (!silent)
+			com_err (program_name, errno,
+				 _("while trying to stat %s"), name);
+		return -1;
+	}
 
 	if (set) {
 		if (verbose) {
@@ -212,10 +208,12 @@ static void change_attributes (const cha
 		if (fsetflags (name, sf) == -1)
 			perror (name);
 	} else {
-		if (fgetflags (name, &flags) == -1)
-			com_err (program_name, errno,
-			         _("while reading flags on %s"), name);
-		else {
+		if (fgetflags (name, &flags) == -1) {
+			if (!silent)
+				com_err (program_name, errno,
+					 _("while reading flags on %s"), name);
+			return -1;
+		} else {
 			if (rem)
 				flags &= ~rf;
 			if (add)
@@ -227,25 +225,36 @@ static void change_attributes (const cha
 			}
 			if (!S_ISDIR(st.st_mode))
 				flags &= ~EXT2_DIRSYNC_FL;
-			if (fsetflags (name, flags) == -1)
-				com_err (program_name, errno,
-				         _("while setting flags on %s"), name);
+			if (fsetflags (name, flags) == -1) {
+				if (!silent)
+					com_err(program_name, errno,
+						_("while setting flags on %s"),
+						name);
+				return -1;
+			}
 		}
 	}
 	if (set_version) {
 		if (verbose)
 			printf (_("Version of %s set as %lu\n"), name, version);
-		if (fsetversion (name, version) == -1)
-			com_err (program_name, errno,
-			         _("while setting version on %s"), name);
+		if (fsetversion (name, version) == -1) {
+			if (!silent)
+				com_err (program_name, errno,
+					 _("while setting version on %s"),
+					 name);
+			return -1;
+		}
 	}
 	if (S_ISDIR(st.st_mode) && recursive)
-		iterate_on_dir (name, chattr_dir_proc, NULL);
+		return iterate_on_dir (name, chattr_dir_proc, NULL);
+	return 0;
 }
 
 static int chattr_dir_proc (const char * dir_name, struct dirent * de,
 			    void * private EXT2FS_ATTR((unused)))
 {
+	int ret = 0;
+
 	if (strcmp (de->d_name, ".") && strcmp (de->d_name, "..")) {
 	        char *path;
 
@@ -253,19 +262,20 @@ static int chattr_dir_proc (const char *
 		if (!path) {
 			fprintf(stderr, _("Couldn't allocate path variable "
 					  "in chattr_dir_proc"));
-			exit(1);
+			return -1;
 		}
-		sprintf (path, "%s/%s", dir_name, de->d_name);
-		change_attributes (path);
+		sprintf(path, "%s/%s", dir_name, de->d_name);
+		ret = change_attributes(path);
 		free(path);
 	}
-	return 0;
+	return ret;
 }
 
 int main (int argc, char ** argv)
 {
 	int i, j;
 	int end_arg = 0;
+	int err, retval = 0;
 
 #ifdef ENABLE_NLS
 	setlocale(LC_MESSAGES, "");
@@ -303,7 +313,10 @@ int main (int argc, char ** argv)
 	if (verbose)
 		fprintf (stderr, "chattr %s (%s)\n",
 			 E2FSPROGS_VERSION, E2FSPROGS_DATE);
-	for (j = i; j < argc; j++)
-		change_attributes (argv[j]);
-	exit(0);
+	for (j = i; j < argc; j++) {
+		err = change_attributes (argv[j]);
+		if (err)
+			retval = 1;
+	}
+	exit(retval);
 }
diff -Nurp e2fsprogs-1.40.8/misc/dumpe2fs.c e2fsprogs/misc/dumpe2fs.c
--- e2fsprogs-1.40.8/misc/dumpe2fs.c	2008-03-13 23:20:46.000000000 +0100
+++ e2fsprogs/misc/dumpe2fs.c	2008-03-29 01:20:43.000000000 +0100
@@ -112,7 +112,8 @@ static void print_bg_opts(ext2_filsys fs
 {
 	int first = 1, bg_flags;
 
-	if (fs->super->s_feature_compat & EXT2_FEATURE_COMPAT_LAZY_BG)
+	if (fs->super->s_feature_compat & EXT2_FEATURE_COMPAT_LAZY_BG ||
+	    fs->super->s_feature_ro_compat & EXT4_FEATURE_RO_COMPAT_GDT_CSUM)
 		bg_flags = fs->group_desc[i].bg_flags;
 	else
 		bg_flags = 0;
@@ -134,12 +135,18 @@ static void list_desc (ext2_filsys fs)
 	blk_t	super_blk, old_desc_blk, new_desc_blk;
 	char *block_bitmap=NULL, *inode_bitmap=NULL;
 	int inode_blocks_per_group, old_desc_blocks, reserved_gdt;
+	int		block_nbytes, inode_nbytes;
 	int has_super;
+	blk_t		blk_itr = fs->super->s_first_data_block;
+	ext2_ino_t	ino_itr = 1;
+
+	block_nbytes = EXT2_BLOCKS_PER_GROUP(fs->super) / 8;
+	inode_nbytes = EXT2_INODES_PER_GROUP(fs->super) / 8;
 
 	if (fs->block_map)
-		block_bitmap = fs->block_map->bitmap;
+		block_bitmap = malloc(block_nbytes);
 	if (fs->inode_map)
-		inode_bitmap = fs->inode_map->bitmap;
+		inode_bitmap = malloc(inode_nbytes);
 
 	inode_blocks_per_group = ((fs->super->s_inodes_per_group *
 				   EXT2_INODE_SIZE(fs->super)) +
@@ -204,25 +211,33 @@ static void list_desc (ext2_filsys fs)
 		diff = fs->group_desc[i].bg_inode_table - first_block;
 		if (diff > 0)
 			printf(" (+%ld)", diff);
-		printf (_("\n  %d free blocks, %d free inodes, "
-			  "%d directories\n"),
+		printf (_("\n  %u free blocks, %u free inodes, "
+			  "%u directories%s"),
 			fs->group_desc[i].bg_free_blocks_count,
 			fs->group_desc[i].bg_free_inodes_count,
-			fs->group_desc[i].bg_used_dirs_count);
+			fs->group_desc[i].bg_used_dirs_count,
+			fs->group_desc[i].bg_itable_unused ? "" : "\n");
+		if (fs->group_desc[i].bg_itable_unused)
+			printf (_(", %u unused inodes\n"),
+				fs->group_desc[i].bg_itable_unused);
 		if (block_bitmap) {
 			fputs(_("  Free blocks: "), stdout);
+			ext2fs_get_block_bitmap_range(fs->block_map, 
+				 blk_itr, block_nbytes << 3, block_bitmap);
 			print_free (i, block_bitmap,
 				    fs->super->s_blocks_per_group,
 				    fs->super->s_first_data_block);
 			fputc('\n', stdout);
-			block_bitmap += fs->super->s_blocks_per_group / 8;
+			blk_itr += fs->super->s_blocks_per_group;
 		}
 		if (inode_bitmap) {
 			fputs(_("  Free inodes: "), stdout);
+			ext2fs_get_inode_bitmap_range(fs->inode_map, 
+				 ino_itr, inode_nbytes << 3, inode_bitmap);
 			print_free (i, inode_bitmap,
 				    fs->super->s_inodes_per_group, 1);
 			fputc('\n', stdout);
-			inode_bitmap += fs->super->s_inodes_per_group / 8;
+			ino_itr += fs->super->s_inodes_per_group;
 		}
 	}
 }
@@ -326,9 +341,9 @@ static void print_journal_information(ex
 static void parse_extended_opts(const char *opts, blk_t *superblock, 
 				int *blocksize)
 {
-	char	*buf, *token, *next, *p, *arg, *badopt = "";
+	char	*buf, *token, *next, *p, *arg, *badopt = 0;
 	int	len;
-	int	usage = 0;
+	int	do_usage = 0;
 
 	len = strlen(opts);
 	buf = malloc(len+1);
@@ -353,7 +368,7 @@ static void parse_extended_opts(const ch
 		if (strcmp(token, "superblock") == 0 ||
 		    strcmp(token, "sb") == 0) {
 			if (!arg) {
-				usage++;
+				do_usage++;
 				badopt = token;
 				continue;
 			}
@@ -362,13 +377,13 @@ static void parse_extended_opts(const ch
 				fprintf(stderr,
 					_("Invalid superblock parameter: %s\n"),
 					arg);
-				usage++;
+				do_usage++;
 				continue;
 			}
 		} else if (strcmp(token, "blocksize") == 0 ||
 			   strcmp(token, "bs") == 0) {
 			if (!arg) {
-				usage++;
+				do_usage++;
 				badopt = token;
 				continue;
 			}
@@ -377,15 +392,15 @@ static void parse_extended_opts(const ch
 				fprintf(stderr,
 					_("Invalid blocksize parameter: %s\n"),
 					arg);
-				usage++;
+				do_usage++;
 				continue;
 			}
 		} else {
-			usage++;
+			do_usage++;
 			badopt = token;
 		}
 	}
-	if (usage) {
+	if (do_usage) {
 		fprintf(stderr, _("\nBad extended option(s) specified: %s\n\n"
 			"Extended options are separated by commas, "
 			"and may take an argument which\n"
@@ -393,7 +408,7 @@ static void parse_extended_opts(const ch
 			"Valid extended options are:\n"
 			"\tsuperblock=<superblock number>\n"
 			"\tblocksize=<blocksize>\n"),
-			badopt);
+			badopt ? badopt : "");
 		free(buf);
 		exit(1);
 	}
@@ -405,13 +420,12 @@ int main (int argc, char ** argv)
 	errcode_t	retval;
 	ext2_filsys	fs;
 	int		print_badblocks = 0;
-	int		use_superblock = 0;
+	blk_t		use_superblock = 0;
 	int		use_blocksize = 0;
 	int		image_dump = 0;
 	int		force = 0;
 	int		flags;
 	int		header_only = 0;
-	int		big_endian;
 	int		c;
 
 #ifdef ENABLE_NLS
@@ -488,12 +502,6 @@ int main (int argc, char ** argv)
 	if (print_badblocks) {
 		list_bad_blocks(fs, 1);
 	} else {
-		big_endian = ((fs->flags & EXT2_FLAG_SWAP_BYTES) != 0);
-#ifdef WORDS_BIGENDIAN
-		big_endian = !big_endian;
-#endif
-		if (big_endian)
-			printf(_("Note: This is a byte-swapped filesystem\n"));
 		list_super (fs->super);
 		if (fs->super->s_feature_incompat &
 		      EXT3_FEATURE_INCOMPAT_JOURNAL_DEV) {
diff -Nurp e2fsprogs-1.40.8/misc/e2image.c e2fsprogs/misc/e2image.c
--- e2fsprogs-1.40.8/misc/e2image.c	2008-03-13 23:20:46.000000000 +0100
+++ e2fsprogs/misc/e2image.c	2008-03-29 01:20:43.000000000 +0100
@@ -347,9 +347,8 @@ static void scramble_dir_block(ext2_fils
 	for (p = buf; p < end-8; p += rec_len) {
 		dirent = (struct ext2_dir_entry_2 *) p;
 		rec_len = dirent->rec_len;
-#ifdef EXT2FS_ENABLE_SWAPFS
-		if (fs->flags & EXT2_FLAG_SWAP_BYTES) 
-			rec_len = ext2fs_swab16(rec_len);
+#ifdef WORDS_BIGENDIAN
+		rec_len = ext2fs_swab16(rec_len);
 #endif
 #if 0
 		printf("rec_len = %d, name_len = %d\n", rec_len, dirent->name_len);
@@ -360,8 +359,7 @@ static void scramble_dir_block(ext2_fils
 			       "bad rec_len (%d)\n", (unsigned long) blk, 
 			       rec_len);
 			rec_len = end - p;
-#ifdef EXT2FS_ENABLE_SWAPFS
-			if (fs->flags & EXT2_FLAG_SWAP_BYTES) 
+#ifdef WORDS_BIGENDIAN
 				dirent->rec_len = ext2fs_swab16(rec_len);
 #endif
 			continue;
@@ -516,8 +514,9 @@ static void write_raw_image_file(ext2_fi
 		    (LINUX_S_ISLNK(inode.i_mode) &&
 		     ext2fs_inode_has_valid_blocks(&inode)) ||
 		    ino == fs->super->s_journal_inum) {
-			retval = ext2fs_block_iterate2(fs, ino, 0, 
-				       block_buf, process_dir_block, &pb);
+			retval = ext2fs_block_iterate2(fs, ino,
+					BLOCK_FLAG_READ_ONLY, block_buf,
+					process_dir_block, &pb);
 			if (retval) {
 				com_err(program_name, retval,
 					"while iterating over inode %u",
@@ -525,11 +524,12 @@ static void write_raw_image_file(ext2_fi
 				exit(1);
 			}
 		} else {
-			if (inode.i_block[EXT2_IND_BLOCK] ||
+			if ((inode.i_flags & EXT4_EXTENTS_FL) ||
+			    inode.i_block[EXT2_IND_BLOCK] ||
 			    inode.i_block[EXT2_DIND_BLOCK] ||
 			    inode.i_block[EXT2_TIND_BLOCK]) {
 				retval = ext2fs_block_iterate2(fs,
-				       ino, 0, block_buf,
+				       ino, BLOCK_FLAG_READ_ONLY, block_buf,
 				       process_file_block, &pb);
 				if (retval) {
 					com_err(program_name, retval,
diff -Nurp e2fsprogs-1.40.8/misc/fsck.c e2fsprogs/misc/fsck.c
--- e2fsprogs-1.40.8/misc/fsck.c	2008-02-29 15:56:44.000000000 +0100
+++ e2fsprogs/misc/fsck.c	2008-03-29 01:20:43.000000000 +0100
@@ -800,7 +800,7 @@ static void compile_fs_type(char *fs_typ
  * This function returns true if a particular option appears in a
  * comma-delimited options list
  */
-static int opt_in_list(char *opt, char *optlist)
+static int opt_in_list(const char *opt, char *optlist)
 {
 	char	*list, *s;
 
diff -Nurp e2fsprogs-1.40.8/misc/fsck.h e2fsprogs/misc/fsck.h
--- e2fsprogs-1.40.8/misc/fsck.h	2007-06-30 14:58:34.000000000 +0200
+++ e2fsprogs/misc/fsck.h	2008-03-29 01:20:43.000000000 +0100
@@ -68,3 +68,6 @@ struct fsck_instance {
 
 extern char *base_device(const char *device);
 extern const char *identify_fs(const char *fs_name, const char *fs_types);
+
+/* ismounted.h */
+extern int is_mounted(const char *file);
diff -Nurp e2fsprogs-1.40.8/misc/ismounted.c e2fsprogs/misc/ismounted.c
--- e2fsprogs-1.40.8/misc/ismounted.c	2008-02-29 15:56:44.000000000 +0100
+++ e2fsprogs/misc/ismounted.c	2008-03-29 01:20:43.000000000 +0100
@@ -28,6 +28,9 @@
 #endif
 #include <string.h>
 #include <sys/stat.h>
+#include <ctype.h>
+
+#include "fsck.h"
 
 /*
  * ext2fs_check_if_mounted flags
@@ -80,7 +83,6 @@ static errcode_t check_mntent_file(const
 	ino_t		file_ino=0;
 	FILE 		*f;
 	char		buf[1024], *device = 0, *mnt_dir = 0, *cp;
-	int		fd;
 
 	*mount_flags = 0;
 	if ((f = fopen(mtab_file, "r")) == NULL)
diff -Nurp e2fsprogs-1.40.8/misc/Makefile.in e2fsprogs/misc/Makefile.in
--- e2fsprogs-1.40.8/misc/Makefile.in	2008-03-13 23:20:46.000000000 +0100
+++ e2fsprogs/misc/Makefile.in	2008-03-29 01:20:43.000000000 +0100
@@ -80,7 +80,7 @@ prof_err.c prof_err.h: $(srcdir)/../e2fs
 
 default_profile.c: $(srcdir)/mke2fs.conf $(srcdir)/profile-to-c.awk
 	@echo "	PROFILE_TO_C mke2fs.conf"
-	$(AWK) -f $(srcdir)/profile-to-c.awk < $(srcdir)/mke2fs.conf \
+	@$(AWK) -f $(srcdir)/profile-to-c.awk < $(srcdir)/mke2fs.conf \
 		>  default_profile.c
 profile.o:
 	@echo "	CC $<"
diff -Nurp e2fsprogs-1.40.8/misc/mke2fs.8.in e2fsprogs/misc/mke2fs.8.in
--- e2fsprogs-1.40.8/misc/mke2fs.8.in	2008-03-13 19:57:37.000000000 +0100
+++ e2fsprogs/misc/mke2fs.8.in	2008-03-29 01:20:43.000000000 +0100
@@ -427,6 +427,13 @@ Store file type information in directory
 .TP
 .B has_journal
 Create an ext3 journal (as if using the
+.TP
+.B uninit_groups
+Create a filesystem without initializing all of the groups.  This speeds
+up filesystem creation time noticably, and can also reduce
+.BR e2fsck time
+dramatically.  This feature causes the filesystem to be read-only in
+older kernels is not supported in most Linux kernels, use with caution.
 .B \-j
 option).
 @JDEV@.TP
diff -Nurp e2fsprogs-1.40.8/misc/mke2fs.c e2fsprogs/misc/mke2fs.c
--- e2fsprogs-1.40.8/misc/mke2fs.c	2008-03-13 23:20:46.000000000 +0100
+++ e2fsprogs/misc/mke2fs.c	2008-03-29 01:20:43.000000000 +0100
@@ -433,6 +433,8 @@ static void write_inode_tables(ext2_fils
 					num, blk, error_message(retval));
 				exit(1);
 			}
+			/* The kernel doesn't need to zero the itable blocks */
+			fs->group_desc[i].bg_flags |= EXT2_BG_INODE_ZEROED;
 		}
 		if (sync_kludge) {
 			if (sync_kludge == 1)
@@ -448,34 +450,49 @@ static void write_inode_tables(ext2_fils
 static void setup_lazy_bg(ext2_filsys fs)
 {
 	dgrp_t i;
-	int blks;
+	int blks, csum_flag;
 	struct ext2_super_block *sb = fs->super;
 	struct ext2_group_desc *bg = fs->group_desc;
 
-	if (EXT2_HAS_COMPAT_FEATURE(fs->super, 
-				    EXT2_FEATURE_COMPAT_LAZY_BG)) {
+	csum_flag = EXT2_HAS_RO_COMPAT_FEATURE(fs->super,
+					       EXT4_FEATURE_RO_COMPAT_GDT_CSUM);
+	if (EXT2_HAS_COMPAT_FEATURE(fs->super, EXT2_FEATURE_COMPAT_LAZY_BG) ||
+	    csum_flag) {
 		for (i = 0; i < fs->group_desc_count; i++, bg++) {
 			if ((i == 0) ||
-			    (i == fs->group_desc_count-1))
+			    (i == fs->group_desc_count - 1 && !csum_flag))
 				continue;
 			if (bg->bg_free_inodes_count ==
 			    sb->s_inodes_per_group) {
-				bg->bg_free_inodes_count = 0;
 				bg->bg_flags |= EXT2_BG_INODE_UNINIT;
-				sb->s_free_inodes_count -= 
-					sb->s_inodes_per_group;
+				if (!csum_flag) {
+					bg->bg_free_inodes_count = 0;
+					sb->s_free_inodes_count -=
+						sb->s_inodes_per_group;
+				}
 			}
+
+			/* Skip groups with GDT backups because the resize
+			 * inode has blocks allocated in them, and the last
+			 * group because it needs block bitmap padding. */
+			if ((ext2fs_bg_has_super(fs, i) &&
+			     sb->s_reserved_gdt_blocks) ||
+			    i == fs->group_desc_count - 1)
+				continue;
+
 			blks = ext2fs_super_and_bgd_loc(fs, i, 0, 0, 0, 0);
-			if (bg->bg_free_blocks_count == blks) {
-				bg->bg_free_blocks_count = 0;
+			if (bg->bg_free_blocks_count == blks &&
+			    bg->bg_flags & EXT2_BG_INODE_UNINIT) {
 				bg->bg_flags |= EXT2_BG_BLOCK_UNINIT;
-				sb->s_free_blocks_count -= blks;
+				if (!csum_flag) {
+					bg->bg_free_blocks_count = 0;
+					sb->s_free_blocks_count -= blks;
+				}
 			}
 		}
 	}
 }
 
-
 static void create_root_dir(ext2_filsys fs)
 {
 	errcode_t		retval;
@@ -513,11 +530,11 @@ static void create_root_dir(ext2_filsys 
 
 static void create_lost_and_found(ext2_filsys fs)
 {
+	unsigned int		lpf_size = 0;
 	errcode_t		retval;
 	ext2_ino_t		ino;
 	const char		*name = "lost+found";
 	int			i;
-	int			lpf_size = 0;
 
 	fs->umask = 077;
 	retval = ext2fs_mkdir(fs, EXT2_ROOT_INO, 0, name);
@@ -535,7 +552,10 @@ static void create_lost_and_found(ext2_f
 	}
 	
 	for (i=1; i < EXT2_NDIR_BLOCKS; i++) {
-		if ((lpf_size += fs->blocksize) >= 16*1024)
+		/* Ensure that lost+found is at least 2 blocks, so we always
+		 * test large empty blocks for big-block filesystems.  */
+		if ((lpf_size += fs->blocksize) >= 16*1024 &&
+		    lpf_size >= 2 * fs->blocksize)
 			break;
 		retval = ext2fs_expand_dir(fs, ino);
 		if (retval) {
@@ -694,8 +714,7 @@ static void show_stats(ext2_filsys fs)
 	if (s->s_reserved_gdt_blocks)
 		printf(_("Maximum filesystem blocks=%lu\n"),
 		       (s->s_reserved_gdt_blocks + fs->desc_blocks) *
-		       (fs->blocksize / sizeof(struct ext2_group_desc)) *
-		       s->s_blocks_per_group);
+		       EXT2_DESC_PER_BLOCK(s) * s->s_blocks_per_group);
 	if (fs->group_desc_count > 1)
 		printf(_("%u block groups\n"), fs->group_desc_count);
 	else
@@ -741,8 +760,6 @@ static int set_os(struct ext2_super_bloc
 		sb->s_creator_os = EXT2_OS_LINUX;
 	else if (strcasecmp(os, "GNU") == 0 || strcasecmp(os, "hurd") == 0)
 		sb->s_creator_os = EXT2_OS_HURD;
-	else if (strcasecmp(os, "masix") == 0)
-		sb->s_creator_os = EXT2_OS_MASIX;
 	else if (strcasecmp(os, "freebsd") == 0)
 		sb->s_creator_os = EXT2_OS_FREEBSD;
 	else if (strcasecmp(os, "lites") == 0)
@@ -757,7 +774,7 @@ static int set_os(struct ext2_super_bloc
 static void parse_extended_opts(struct ext2_super_block *param, 
 				const char *opts)
 {
-	char	*buf, *token, *next, *p, *arg, *badopt = "";
+	char	*buf, *token, *next, *p, *arg, *badopt = 0;
 	int	len;
 	int	r_usage = 0;
 
@@ -844,7 +861,7 @@ static void parse_extended_opts(struct e
 			bpg = param->s_blocks_per_group;
 			if (!bpg)
 				bpg = blocksize * 8;
-			gdpb = blocksize / sizeof(struct ext2_group_desc);
+			gdpb = EXT2_DESC_PER_BLOCK(param);
 			group_desc_count = 
 				ext2fs_div_ceil(param->s_blocks_count, bpg);
 			desc_blocks = (group_desc_count +
@@ -884,7 +901,7 @@ static void parse_extended_opts(struct e
 			"\tstripe-width=<RAID stride * data disks in blocks>\n"
 			"\tresize=<resize maximum size in blocks>\n\n"
 			"\ttest_fs\n"),
-			badopt);
+			badopt ? badopt : "");
 		free(buf);
 		exit(1);
 	}
@@ -906,11 +923,14 @@ static __u32 ok_features[3] = {
 		EXT2_FEATURE_COMPAT_EXT_ATTR,
 	/* Incompat */
 	EXT2_FEATURE_INCOMPAT_FILETYPE|
+		EXT3_FEATURE_INCOMPAT_EXTENTS|
 		EXT3_FEATURE_INCOMPAT_JOURNAL_DEV|
-		EXT2_FEATURE_INCOMPAT_META_BG,
+		EXT2_FEATURE_INCOMPAT_META_BG|
+		EXT4_FEATURE_INCOMPAT_FLEX_BG,
 	/* R/O compat */
 	EXT2_FEATURE_RO_COMPAT_LARGE_FILE|
-		EXT2_FEATURE_RO_COMPAT_SPARSE_SUPER
+		EXT2_FEATURE_RO_COMPAT_SPARSE_SUPER|
+		EXT4_FEATURE_RO_COMPAT_GDT_CSUM
 };
 
 
@@ -1475,19 +1495,6 @@ static void PRS(int argc, char *argv[])
 		}
 	}
 
-	if (!force && fs_param.s_blocks_count >= ((unsigned) 1 << 31)) {
-		com_err(program_name, 0,
-			_("Filesystem too large.  No more than 2**31-1 blocks\n"
-			  "\t (8TB using a blocksize of 4k) are currently supported."));
-             exit(1);
-	}
-
-	if ((blocksize > 4096) &&
-	    (fs_param.s_feature_compat & EXT3_FEATURE_COMPAT_HAS_JOURNAL))
-		fprintf(stderr, _("\nWarning: some 2.4 kernels do not support "
-			"blocksizes greater than 4096\n\tusing ext3.  "
-			"Use -b 4096 if this is an issue for you.\n\n"));
-
 	if (inode_size == 0) {
 		profile_get_integer(profile, "defaults", "inode_size", NULL,
 				    0, &inode_size);
@@ -1506,10 +1513,6 @@ static void PRS(int argc, char *argv[])
 				blocksize);
 			exit(1);
 		}
-		if (inode_size != EXT2_GOOD_OLD_INODE_SIZE)
-			fprintf(stderr, _("Warning: %d-byte inodes not usable "
-				"on older systems\n"),
-				inode_size);
 		fs_param.s_inode_size = inode_size;
 	}
 
@@ -1562,7 +1565,7 @@ int main (int argc, char *argv[])
 	errcode_t	retval = 0;
 	ext2_filsys	fs;
 	badblocks_list	bb_list = 0;
-	int		journal_blocks;
+	unsigned int	journal_blocks;
 	unsigned int	i;
 	int		val;
 	io_manager	io_ptr;
@@ -1773,7 +1776,7 @@ int main (int argc, char *argv[])
 			goto no_journal;
 		}
 		if (!quiet) {
-			printf(_("Creating journal (%d blocks): "),
+			printf(_("Creating journal (%u blocks): "),
 			       journal_blocks);
 			fflush(stdout);
 		}
@@ -1789,6 +1792,8 @@ int main (int argc, char *argv[])
 	}
 no_journal:
 
+	if (!super_only)
+		ext2fs_set_gdt_csum(fs);
 	if (!quiet)
 		printf(_("Writing superblocks and "
 		       "filesystem accounting information: "));
diff -Nurp e2fsprogs-1.40.8/misc/tune2fs.8.in e2fsprogs/misc/tune2fs.8.in
--- e2fsprogs-1.40.8/misc/tune2fs.8.in	2008-03-13 19:57:37.000000000 +0100
+++ e2fsprogs/misc/tune2fs.8.in	2008-03-29 01:20:43.000000000 +0100
@@ -439,10 +439,17 @@ Reserve space so the block group descrip
 future.
 .B Tune2fs 
 only supports clearing this filesystem feature.
+.TP
+.B uninit_groups
+Allow the kernel to initialize bitmaps and inode tables and keep a high
+watermark for the unused inodes in a filesystem, to reduce
+.BR e2fsck (8)
+time.
 .RE
 .IP
 After setting or clearing 
 .BR sparse_super ,
+.BR uninit_groups ,
 .BR filetype ,
 or
 .B resize_inode
diff -Nurp e2fsprogs-1.40.8/misc/tune2fs.c e2fsprogs/misc/tune2fs.c
--- e2fsprogs-1.40.8/misc/tune2fs.c	2008-03-13 23:20:46.000000000 +0100
+++ e2fsprogs/misc/tune2fs.c	2008-03-29 01:20:43.000000000 +0100
@@ -113,9 +113,12 @@ static __u32 ok_features[3] = {
 	EXT3_FEATURE_COMPAT_HAS_JOURNAL |
 		EXT2_FEATURE_COMPAT_DIR_INDEX,
 	/* Incompat */
-	EXT2_FEATURE_INCOMPAT_FILETYPE,
+	EXT2_FEATURE_INCOMPAT_FILETYPE |
+		EXT3_FEATURE_INCOMPAT_EXTENTS |
+		EXT4_FEATURE_INCOMPAT_FLEX_BG,
 	/* R/O compat */
 	EXT2_FEATURE_RO_COMPAT_LARGE_FILE |
+		EXT4_FEATURE_RO_COMPAT_GDT_CSUM |
 		EXT2_FEATURE_RO_COMPAT_SPARSE_SUPER
 };
 
@@ -125,9 +128,11 @@ static __u32 clear_ok_features[3] = {
 		EXT2_FEATURE_COMPAT_RESIZE_INODE |
 		EXT2_FEATURE_COMPAT_DIR_INDEX,
 	/* Incompat */
-	EXT2_FEATURE_INCOMPAT_FILETYPE,
+	EXT2_FEATURE_INCOMPAT_FILETYPE |
+		EXT4_FEATURE_INCOMPAT_FLEX_BG,
 	/* R/O compat */
-	EXT2_FEATURE_RO_COMPAT_LARGE_FILE
+	EXT2_FEATURE_RO_COMPAT_LARGE_FILE |
+		EXT4_FEATURE_RO_COMPAT_GDT_CSUM
 };
 
 /*
@@ -242,6 +247,7 @@ static int release_blocks_proc(ext2_fils
 	ext2fs_unmark_block_bitmap(fs->block_map,block);
 	group = ext2fs_group_of_blk(fs, block);
 	fs->group_desc[group].bg_free_blocks_count++;
+	ext2fs_group_desc_csum_set(fs, group);
 	fs->super->s_free_blocks_count++;
 	return 0;
 }
@@ -268,7 +274,8 @@ static void remove_journal_inode(ext2_fi
 				_("while reading bitmaps"));
 			exit(1);
 		}
-		retval = ext2fs_block_iterate(fs, ino, 0, NULL,
+		retval = ext2fs_block_iterate(fs, ino,
+					      BLOCK_FLAG_READ_ONLY, NULL,
 					      release_blocks_proc, NULL);
 		if (retval) {
 			com_err(program_name, retval,
@@ -311,7 +318,6 @@ static void update_mntopts(ext2_filsys f
 static void update_feature_set(ext2_filsys fs, char *features)
 {
 	struct ext2_super_block *sb= fs->super;
-	__u32	old_compat, old_incompat, old_ro_compat;
 	__u32		old_features[3];
 	int		type_err;
 	unsigned int	mask_err;
@@ -390,6 +396,15 @@ static void update_feature_set(ext2_fils
 			uuid_generate((unsigned char *) sb->s_hash_seed);
 	}
 
+	if (FEATURE_OFF(E2P_FEATURE_INCOMPAT, EXT4_FEATURE_INCOMPAT_FLEX_BG)) {
+		if (ext2fs_check_desc(fs)) {
+			fputs(_("Clearing the flex_bg flag would "
+				"cause the the filesystem to be\n"
+				"inconsistent.\n"), stderr);
+			exit(1);
+		}
+	}
+
 	if (sb->s_rev_level == EXT2_GOOD_OLD_REV &&
 	    (sb->s_feature_compat || sb->s_feature_ro_compat ||
 	     sb->s_feature_incompat))
@@ -397,6 +412,8 @@ static void update_feature_set(ext2_fils
 
 	if (FEATURE_CHANGED(E2P_FEATURE_RO_INCOMPAT,
 			    EXT2_FEATURE_RO_COMPAT_SPARSE_SUPER) ||
+	    FEATURE_CHANGED(E2P_FEATURE_RO_INCOMPAT,
+			    EXT4_FEATURE_RO_COMPAT_GDT_CSUM) ||
 	    FEATURE_CHANGED(E2P_FEATURE_INCOMPAT,
 			    EXT2_FEATURE_INCOMPAT_FILETYPE) ||
 	    FEATURE_CHANGED(E2P_FEATURE_COMPAT,
diff -Nurp e2fsprogs-1.40.8/misc/util.c e2fsprogs/misc/util.c
--- e2fsprogs-1.40.8/misc/util.c	2008-03-13 23:20:46.000000000 +0100
+++ e2fsprogs/misc/util.c	2008-03-29 01:20:43.000000000 +0100
@@ -71,8 +71,8 @@ void proceed_question(void)
 	fflush(stderr);
 	fputs(_("Proceed anyway? (y,n) "), stdout);
 	buf[0] = 0;
-	fgets(buf, sizeof(buf), stdin);
-	if (strchr(short_yes, buf[0]) == 0)
+	if (!fgets(buf, sizeof(buf), stdin) ||
+	    strchr(short_yes, buf[0]) == 0)
 		exit(1);
 }
 
@@ -249,7 +249,7 @@ void parse_journal_opts(const char *opts
  * in the filesystem.  For very small filesystems, it is not reasonable to
  * have a journal that fills more than half of the filesystem.
  */
-int figure_journal_size(int size, ext2_filsys fs)
+unsigned int figure_journal_size(int size, ext2_filsys fs)
 {
 	int j_blocks;
 
@@ -269,7 +269,7 @@ int figure_journal_size(int size, ext2_f
 				j_blocks);
 			exit(1);
 		}
-		if (j_blocks > fs->super->s_free_blocks_count / 2) {
+		if ((unsigned) j_blocks > fs->super->s_free_blocks_count / 2) {
 			fputs(_("\nJournal size too big for filesystem.\n"),
 			      stderr);
 			exit(1);
diff -Nurp e2fsprogs-1.40.8/misc/util.h e2fsprogs/misc/util.h
--- e2fsprogs-1.40.8/misc/util.h	2008-03-13 23:20:46.000000000 +0100
+++ e2fsprogs/misc/util.h	2008-03-29 01:20:43.000000000 +0100
@@ -22,5 +22,5 @@ extern void proceed_question(void);
 extern void check_plausibility(const char *device);
 extern void parse_journal_opts(const char *opts);
 extern void check_mount(const char *device, int force, const char *type);
-extern int figure_journal_size(int size, ext2_filsys fs);
+extern unsigned int figure_journal_size(int size, ext2_filsys fs);
 extern void print_check_message(ext2_filsys fs);
diff -Nurp e2fsprogs-1.40.8/misc/uuidd.c e2fsprogs/misc/uuidd.c
--- e2fsprogs-1.40.8/misc/uuidd.c	2008-02-29 15:56:44.000000000 +0100
+++ e2fsprogs/misc/uuidd.c	2008-03-29 01:20:43.000000000 +0100
@@ -52,6 +52,12 @@ static void usage(const char *progname)
 	exit(1);
 }
 
+static void die(const char *msg)
+{
+	perror(msg);
+	exit(1);
+}
+
 static void create_daemon(void)
 {
 	pid_t pid;
@@ -75,7 +81,8 @@ static void create_daemon(void)
 	chdir("/");
 	(void) setsid();
 	euid = geteuid();
-	(void) setreuid(euid, euid);
+	if (setreuid(euid, euid) < 0)
+		die("setreuid");
 }
 
 static int read_all(int fd, char *buf, size_t count)
@@ -132,7 +139,8 @@ static int call_daemon(const char *socke
 	}
 
 	srv_addr.sun_family = AF_UNIX;
-	strcpy(srv_addr.sun_path, socket_path);
+	strncpy(srv_addr.sun_path, socket_path, sizeof(srv_addr.sun_path));
+	srv_addr.sun_path[sizeof(srv_addr.sun_path)-1] = '\0';
 
 	if (connect(s, (const struct sockaddr *) &srv_addr,
 		    sizeof(struct sockaddr_un)) < 0) {
@@ -198,12 +206,12 @@ static void server_loop(const char *sock
 			int debug, int timeout, int quiet)
 {
 	struct sockaddr_un	my_addr, from_addr;
-	unsigned char		reply_buf[1024], *cp;
 	struct flock		fl;
 	socklen_t		fromlen;
 	int32_t			reply_len = 0;
 	uuid_t			uu;
 	mode_t			save_umask;
+	char			reply_buf[1024], *cp;
 	char			op, str[37];
 	int			i, s, ns, len, num;
 	int			fd_pidfile, ret;
@@ -252,7 +260,8 @@ static void server_loop(const char *sock
 	 * Create the address we will be binding to.
 	 */
 	my_addr.sun_family = AF_UNIX;
-	strcpy(my_addr.sun_path, socket_path);
+	strncpy(my_addr.sun_path, socket_path, sizeof(my_addr.sun_path));
+	my_addr.sun_path[sizeof(my_addr.sun_path)-1] = '\0';
 	(void) unlink(socket_path);
 	save_umask = umask(0);
 	if (bind(s, (const struct sockaddr *) &my_addr,
@@ -320,12 +329,12 @@ static void server_loop(const char *sock
 
 		switch(op) {
 		case UUIDD_OP_GETPID:
-			sprintf((char *) reply_buf, "%d", getpid());
-			reply_len = strlen((char *) reply_buf)+1;
+			sprintf(reply_buf, "%d", getpid());
+			reply_len = strlen(reply_buf)+1;
 			break;
 		case UUIDD_OP_GET_MAXOP:
-			sprintf((char *) reply_buf, "%d", UUIDD_MAX_OP);
-			reply_len = strlen((char *) reply_buf)+1;
+			sprintf(reply_buf, "%d", UUIDD_MAX_OP);
+			reply_len = strlen(reply_buf)+1;
 			break;
 		case UUIDD_OP_TIME_UUID:
 			num = 1;
@@ -366,12 +375,13 @@ static void server_loop(const char *sock
 				num = 1000;
 			if (num*16 > (int) (sizeof(reply_buf)-sizeof(num)))
 				num = (sizeof(reply_buf)-sizeof(num)) / 16;
-			uuid__generate_random(reply_buf+sizeof(num), &num);
+			uuid__generate_random((unsigned char *) reply_buf +
+					      sizeof(num), &num);
 			if (debug) {
 				printf(_("Generated %d UUID's:\n"), num);
 				for (i=0, cp=reply_buf+sizeof(num);
 				     i < num; i++, cp+=16) {
-					uuid_unparse(cp, str);
+					uuid_unparse((unsigned char *)cp, str);
 					printf("\t%s\n", str);
 				}
 			}
@@ -415,11 +425,11 @@ int main(int argc, char **argv)
 		switch (c) {
 		case 'd':
 			debug++;
-			drop_privs++;
+			drop_privs = 1;
 			break;
 		case 'k':
 			do_kill++;
-			drop_privs++;
+			drop_privs = 1;
 			break;
 		case 'n':
 			num = strtol(optarg, &tmp, 0);
@@ -429,18 +439,18 @@ int main(int argc, char **argv)
 			}
 		case 'p':
 			pidfile_path = optarg;
-			drop_privs++;
+			drop_privs = 1;
 			break;
 		case 'q':
 			quiet++;
 			break;
 		case 's':
 			socket_path = optarg;
-			drop_privs++;
+			drop_privs = 1;
 			break;
 		case 't':
 			do_type = UUIDD_OP_TIME_UUID;
-			drop_privs++;
+			drop_privs = 1;
 			break;
 		case 'T':
 			timeout = strtol(optarg, &tmp, 0);
@@ -451,7 +461,7 @@ int main(int argc, char **argv)
 			break;
 		case 'r':
 			do_type = UUIDD_OP_RANDOM_UUID;
-			drop_privs++;
+			drop_privs = 1;
 			break;
 		default:
 			usage(argv[0]);
@@ -460,15 +470,20 @@ int main(int argc, char **argv)
 	uid = getuid();
 	if (uid && drop_privs) {
 		gid = getgid();
-#ifdef HAVE_SETRESUID
-		setresuid(uid, uid, uid);
+#ifdef HAVE_SETRESGID
+		if (setresgid(gid, gid, gid) < 0)
+			die("setresgid");
 #else
-		setreuid(uid, uid);
+		if (setregid(gid, gid) < 0)
+			die("setregid");
 #endif
-#ifdef HAVE_SETRESGID
-		setresgid(gid, gid, gid);
+	
+#ifdef HAVE_SETRESUID
+		if (setresuid(uid, uid, uid) < 0)
+			die("setresuid");
 #else
-		setregid(gid, gid);
+		if (setreuid(uid, uid) < 0)
+			die("setreuid");
 #endif
 	}
 	if (num && do_type) {
Files e2fsprogs-1.40.8/po/de.gmo and e2fsprogs/po/de.gmo differ
diff -Nurp e2fsprogs-1.40.8/po/de.po e2fsprogs/po/de.po
--- e2fsprogs-1.40.8/po/de.po	2008-03-13 23:21:08.000000000 +0100
+++ e2fsprogs/po/de.po	2008-03-29 01:20:43.000000000 +0100
@@ -1,8 +1,9 @@
-# bertragung von e2fsprogs ins Deutsche.
-# Copyright (C) 2008 Theodore Tso (msgids)
-# Olaf Klemke <olke@users.sourceforge.net>, 2002.
-# Marc Langer <marc@marclanger.de>, 2003.
-# Philipp Thomas <pth@suse.de>, 2007, 2008.
+# Deutsche bersetzungen fr e2fsprogs
+# Copyright (C) 1996 Theodore Tso (msgids)
+# This file is distributed under the same license as the e2fsprogs package.
+# Olaf Klemke <olke@users.sourceforge.net>,2002
+# Marc Langer <marc@marclanger.de>,2003
+# Philipp Thomas <pth@suse.de>, 2007, 2008
 #
 #. The strings in e2fsck's problem.c can be very hard to translate,
 #. since the strings are expanded in two different ways.  First of all,
@@ -67,7 +68,7 @@ msgstr ""
 "Project-Id-Version: e2fsprogs-1.40.7\n"
 "Report-Msgid-Bugs-To: tytso@alum.mit.edu\n"
 "POT-Creation-Date: 2008-02-28 21:45-0500\n"
-"PO-Revision-Date: 2008-03-12 19:47+0100\n"
+"PO-Revision-Date: 2008-03-18 16:00+0100\n"
 "Last-Translator: Philipp Thomas <pth@suse.de>\n"
 "Language-Team: German <translation-team-de@lists.sourceforge.net>\n"
 "MIME-Version: 1.0\n"
@@ -82,11 +83,11 @@ msgstr "Bad block %u auerhalb des gl
 
 #: e2fsck/badblocks.c:45
 msgid "while sanity checking the bad blocks inode"
-msgstr "whrend der logischen Prfung des 'Bad Block'-Inodes"
+msgstr "whrend der logischen Prfung des Bad Block-Inodes"
 
 #: e2fsck/badblocks.c:57
 msgid "while reading the bad blocks inode"
-msgstr "whrend des Lesens des 'Bad Block'-Inodes"
+msgstr "whrend des Lesens des Bad Block-Inodes"
 
 #: e2fsck/badblocks.c:71 e2fsck/iscan.c:112 e2fsck/scantest.c:109
 #: e2fsck/unix.c:1010 e2fsck/unix.c:1093 misc/badblocks.c:1025
@@ -100,32 +101,30 @@ msgstr "beim Versuch, %s zu ffnen"
 #: e2fsck/badblocks.c:82
 #, c-format
 msgid "while trying popen '%s'"
-msgstr "beim Versuch, '%s' mittels 'popen' zu ffnen"
+msgstr "beim Versuch, %s mittels popen zu ffnen"
 
 #: e2fsck/badblocks.c:93 misc/mke2fs.c:180
 msgid "while reading in list of bad blocks from file"
-msgstr "beim Lesen der 'Bad Block'-Liste aus der Datei"
+msgstr "beim Lesen der Bad Block-Liste aus der Datei"
 
 #: e2fsck/badblocks.c:104
 msgid "while updating bad block inode"
-msgstr "beim Updaten des 'Bad Block'-Inodes"
+msgstr "beim Updaten des Bad Block-Inodes"
 
 #: e2fsck/badblocks.c:130
 #, c-format
 msgid "Warning: illegal block %u found in bad block inode.  Cleared.\n"
-msgstr ""
-"Warnung! Nicht zulssigen Block %u im 'Bad Blocks'-Inode gefunden! "
-"Bereinigt.\n"
+msgstr "Warnung: Nicht zulssiger Block %u im Bad Blocks-Inode gefunden! Bereinigt.\n"
 
 #: e2fsck/ehandler.c:53
 #, c-format
 msgid "Error reading block %lu (%s) while %s.  "
-msgstr "Lesefehler - Block %lu (%s) whrend %s  "
+msgstr "Lesefehler - Block %lu (%s) whrend %s. "
 
 #: e2fsck/ehandler.c:56
 #, c-format
 msgid "Error reading block %lu (%s).  "
-msgstr "Lesefehler - Block %lu (%s)  "
+msgstr "Lesefehler - Block %lu (%s). "
 
 #: e2fsck/ehandler.c:59 e2fsck/ehandler.c:106
 msgid "Ignore error"
@@ -138,12 +137,12 @@ msgstr "Rckschreiben erzwingen"
 #: e2fsck/ehandler.c:100
 #, c-format
 msgid "Error writing block %lu (%s) while %s.  "
-msgstr "Schreibfehler - Block %lu (%s) whrend %s  "
+msgstr "Schreibfehler - Block %lu (%s) whrend %s. "
 
 #: e2fsck/ehandler.c:103
 #, c-format
 msgid "Error writing block %lu (%s).  "
-msgstr "Schreibfehler - Block %lu (%s)  "
+msgstr "Schreibfehler - Block %lu (%s). "
 
 #: e2fsck/emptydir.c:56
 msgid "empty dirblocks"
@@ -176,7 +175,7 @@ msgstr "Konnte keinen Blockpuffer (Gr
 #: e2fsck/flushb.c:34
 #, c-format
 msgid "Usage: %s disk\n"
-msgstr "Verwendung: %s Laufwerk\n"
+msgstr "Aufruf: %s Laufwerk\n"
 
 #: e2fsck/flushb.c:63
 #, c-format
@@ -186,7 +185,7 @@ msgstr "BLKFLSBUF ioctl nicht unterstt
 #: e2fsck/iscan.c:46
 #, c-format
 msgid "Usage: %s [-F] [-I inode_buffer_blocks] device\n"
-msgstr "Verwendung: %s [-F] [-I inode_buffer_blocks] Gert\n"
+msgstr "Aufruf: %s [-F] [-I inode_buffer_blocks] Gert\n"
 
 #: e2fsck/iscan.c:83 e2fsck/unix.c:786
 #, c-format
@@ -196,7 +195,7 @@ msgstr "beim ffnen von %s fr die Puf
 #: e2fsck/iscan.c:88 e2fsck/unix.c:792 resize/main.c:274
 #, c-format
 msgid "while trying to flush %s"
-msgstr "whrend des Rckschreibeversuches auf %s."
+msgstr "whrend des Rckschreibeversuches auf %s"
 
 #: e2fsck/iscan.c:121 e2fsck/scantest.c:116 misc/e2image.c:480
 msgid "while opening inode scan"
@@ -223,7 +222,7 @@ msgstr "%s: keinen gltigen Journal-Sup
 #: e2fsck/journal.c:567
 #, c-format
 msgid "%s: journal too short\n"
-msgstr "%s: Das Journal ist zu kurz.\n"
+msgstr "%s: Das Journal ist zu kurz\n"
 
 #: e2fsck/journal.c:841
 #, c-format
@@ -290,7 +289,7 @@ msgstr "eEintrag"
 
 #: e2fsck/message.c:121
 msgid "E@e '%Dn' in %p (%i)"
-msgstr "E@e '%Dn' in %p (%i)"
+msgstr "E@e %Dn in %p (%i)"
 
 #: e2fsck/message.c:122
 msgid "ffilesystem"
@@ -362,27 +361,27 @@ msgstr "<Der NULL Inode>"
 
 #: e2fsck/message.c:149
 msgid "<The bad blocks inode>"
-msgstr "<Der 'Bad Blocks'-Inode>"
+msgstr "<Der Bad Blocks-Inode>"
 
 #: e2fsck/message.c:151
 msgid "<The ACL index inode>"
-msgstr "<Der 'ACL Index'-Inode>"
+msgstr "<Der ACL Index-Inode>"
 
 #: e2fsck/message.c:152
 msgid "<The ACL data inode>"
-msgstr "<Der 'ACL Data'-Inode>"
+msgstr "<Der ACL Data-Inode>"
 
 #: e2fsck/message.c:153
 msgid "<The boot loader inode>"
-msgstr "<Der 'Boot Loader'-Inode>"
+msgstr "<Der Boot Loader-Inode>"
 
 #: e2fsck/message.c:154
 msgid "<The undelete directory inode>"
-msgstr "<Der 'undelete directory'-Inode>"
+msgstr "<Der undelete directory-Inode>"
 
 #: e2fsck/message.c:155
 msgid "<The group descriptor inode>"
-msgstr "<Des 'group descriptor'-Inode>"
+msgstr "<Des group descriptor-Inode>"
 
 #: e2fsck/message.c:156
 msgid "<The journal inode>"
@@ -419,7 +418,7 @@ msgstr "Blockgert"
 #: e2fsck/message.c:322
 #, c-format
 msgid "named pipe"
-msgstr ""
+msgstr "named pipe"
 
 #: e2fsck/message.c:324
 #, c-format
@@ -434,7 +433,7 @@ msgstr " Socket"
 #: e2fsck/message.c:328
 #, c-format
 msgid "unknown file type with mode 0%o"
-msgstr ""
+msgstr "unbekannter Dateityp mit Modus 0%o"
 
 #: e2fsck/pass1b.c:215
 msgid "multiply claimed inode map"
@@ -465,29 +464,27 @@ msgstr "lese Verzeichnisblock"
 
 #: e2fsck/pass1.c:521
 msgid "in-use inode map"
-msgstr "'in-use inode'-Liste"
+msgstr "in-use inode-Liste"
 
 #: e2fsck/pass1.c:530
 msgid "directory inode map"
-msgstr "'directory inode'-Liste"
+msgstr "directory inode-Liste"
 
 #: e2fsck/pass1.c:538
 msgid "regular file inode map"
-msgstr "'regular file inode'-Liste"
+msgstr "regular file inode-Liste"
 
 #: e2fsck/pass1.c:545
 msgid "in-use block map"
-msgstr "'in-use block'-Liste"
+msgstr "in-use block-Liste"
 
 #: e2fsck/pass1.c:599
-#, fuzzy
 msgid "opening inode scan"
-msgstr "Inode-Scan"
+msgstr "Starte Inode-Scan"
 
 #: e2fsck/pass1.c:623
-#, fuzzy
 msgid "getting next inode from scan"
-msgstr "beim Laden des nchsten Inodes"
+msgstr "beim Lesen des nchsten Inodes"
 
 #: e2fsck/pass1.c:1016
 msgid "Pass 1"
@@ -504,11 +501,11 @@ msgstr "fehlerhafte Inode-Liste"
 
 #: e2fsck/pass1.c:1139
 msgid "inode in bad block map"
-msgstr "Inode in 'Bad Blocks'-Liste"
+msgstr "Inode in Bad Blocks-Liste"
 
 #: e2fsck/pass1.c:1159
 msgid "imagic inode map"
-msgstr "i'magic inode'-Liste"
+msgstr "imagic inode-Liste"
 
 #: e2fsck/pass1.c:1186
 msgid "multiply claimed block map"
@@ -536,7 +533,7 @@ msgstr "Durchgang 2"
 
 #: e2fsck/pass3.c:79
 msgid "inode done bitmap"
-msgstr "'inode done'-Bitmap"
+msgstr "inode done-Bitmap"
 
 #: e2fsck/pass3.c:90
 msgid "Peak memory"
@@ -548,7 +545,7 @@ msgstr "Durchgang 3"
 
 #: e2fsck/pass3.c:333
 msgid "inode loop detection bitmap"
-msgstr "'inode loop detection'-Bitmap"
+msgstr "inode loop detection-Bitmap"
 
 #: e2fsck/pass4.c:176
 msgid "Pass 4"
@@ -787,8 +784,7 @@ msgid ""
 "from the @b size.\n"
 msgstr ""
 "@S @b_size = %b, fragsize = %c.\n"
-"Diese Version von e2fsck untersttzt keine von @b-Gren verschiedene "
-"Fragmentgren.\n"
+"Diese Version von e2fsck untersttzt keine von @b-Gren verschiedene Fragmentgren.\n"
 
 #. @-expanded: superblock blocks_per_group = %b, should have been %c\n
 #: e2fsck/problem.c:144
@@ -823,7 +819,7 @@ msgstr ""
 "Hinweis: Wenn mehrere Inodes oder Bitmap-Blcke\n"
 "neu geordnet werden mssen, oder ein Teil der Inode-Tabelle\n"
 "verschoben werden muss, knnte es helfen, e2fsck erst einmal\n"
-"mit der Option '-b %S' zu starten. Das Problem knnte\n"
+"mit der Option -b %S zu starten. Das Problem knnte\n"
 "im primren Blockgruppenbezeichner liegen, und seine\n"
 "Sicherungskopie in Ordnung sein.\n"
 "\n"
@@ -881,13 +877,11 @@ msgstr "Externes @j untersttzt nicht @
 #: e2fsck/problem.c:212
 msgid ""
 "Ext3 @j @S is unknown type %N (unsupported).\n"
-"It is likely that your copy of e2fsck is old and/or doesn't support this @j "
-"format.\n"
+"It is likely that your copy of e2fsck is old and/or doesn't support this @j format.\n"
 "It is also possible the @j @S is corrupt.\n"
 msgstr ""
 "Ext3 @j @S ist eine unbekannter Type %N (nicht untersttzt).\n"
-"Es ist mglich, dass ihr e2fsck lter ist und/oder dieses @j Format nicht "
-"untersttzt.\n"
+"Es ist mglich, dass ihr e2fsck lter ist und/oder dieses @j Format nicht untersttzt.\n"
 "Es ist ebenso mglich, dass @j @S defekt ist.\n"
 
 #. @-expanded: Ext3 journal superblock is corrupt.\n
@@ -904,7 +898,7 @@ msgstr "@S hat kein has_@j Flag, aber ei
 #. @-expanded: superblock has ext3 needs_recovery flag set, but no journal.\n
 #: e2fsck/problem.c:230
 msgid "@S has ext3 needs_recovery flag set, but no @j.\n"
-msgstr "@S hat das ext3 'needs_recovery'-Flag gesetzt, aber kein @j.\n"
+msgstr "@S hat das ext3 needs_recovery-Flag gesetzt, aber kein @j.\n"
 
 #. @-expanded: ext3 recovery flag is clear, but journal has data.\n
 #: e2fsck/problem.c:235
@@ -924,8 +918,7 @@ msgstr "Starte @j trotzdem"
 #. @-expanded: Recovery flag not set in backup superblock, so running journal anyway.\n
 #: e2fsck/problem.c:250
 msgid "Recovery flag not set in backup @S, so running @j anyway.\n"
-msgstr ""
-"Recovery-Flag in Backup @S nicht gesetzt, @j wird trotzdem gestartet.\n"
+msgstr "Recovery-Kennzeichen in Backup @S nicht gesetzt, @j wird trotzdem gestartet.\n"
 
 #. @-expanded: %s orphaned inode %i (uid=%Iu, gid=%Ig, mode=%Im, size=%Is)\n
 #: e2fsck/problem.c:255
@@ -957,7 +950,7 @@ msgstr "@I @i %i in @o @i Liste.\n"
 #. @-expanded: filesystem has feature flag(s) set, but is a revision 0 filesystem.  
 #: e2fsck/problem.c:280 e2fsck/problem.c:613
 msgid "@f has feature flag(s) set, but is a revision 0 @f.  "
-msgstr ""
+msgstr "@f hat Eigenschfts-Kennzeichen gesetzt, ist aber ein Revision 0 @f. "
 
 #. @-expanded: Ext3 journal superblock has an unknown read-only feature flag set.\n
 #: e2fsck/problem.c:285
@@ -1032,8 +1025,7 @@ msgstr ""
 #. @-expanded: Resize_inode not enabled, but the resize inode is non-zero.  
 #: e2fsck/problem.c:327
 msgid "Resize_@i not enabled, but the resize @i is non-zero.  "
-msgstr ""
-"Resize_@i nicht aktiviert, aber die zu modifgizierende Inod ist nicht-Null."
+msgstr "Resize_@i nicht aktiviert, aber die zu modifgizierende Inod ist nicht-Null."
 
 #. @-expanded: Resize inode not valid.  
 #: e2fsck/problem.c:332
@@ -1063,6 +1055,8 @@ msgid ""
 "Adding dirhash hint to @f.\n"
 "\n"
 msgstr ""
+"Fge Verzeinishash-Hilfe zu @f hinzu.\n"
+"\n"
 
 #. @-expanded: Pass 1: Checking inodes, blocks, and sizes\n
 #: e2fsck/problem.c:358
@@ -1313,8 +1307,7 @@ msgstr "Fehler beim Iterieren ber @bs 
 #. @-expanded: Error storing inode count information (inode=%i, count=%N): %m\n
 #: e2fsck/problem.c:573
 msgid "Error storing @i count information (@i=%i, count=%N): %m\n"
-msgstr ""
-"Fehler beim Speichern von @i count Informationen (@i=%i, count=%N): %m\n"
+msgstr "Fehler beim Speichern von @i count Informationen (@i=%i, count=%N): %m\n"
 
 #. @-expanded: Error storing directory block information (inode=%i, block=%b, num=%N): %m\n
 #: e2fsck/problem.c:578
@@ -1538,7 +1531,7 @@ msgstr "@h %i hat eine zu groe Verzeic
 #. @-expanded: inode %i is a %It but it looks like it is really a directory.\n
 #: e2fsck/problem.c:784
 msgid "@i %i is a %It but it looks like it is really a directory.\n"
-msgstr ""
+msgstr "@i ist ein %It aber es sieht so aus, als ob es tatschlich ein Verzeichnis ist.\n"
 
 #. @-expanded: \n
 #. @-expanded: Running additional passes to resolve blocks claimed by more than one inode...\n
@@ -1555,9 +1548,9 @@ msgstr ""
 
 #. @-expanded: multiply-claimed block(s) in inode %i:
 #: e2fsck/problem.c:797
-#, fuzzy, c-format
+#, c-format
 msgid "@m @b(s) in @i %i:"
-msgstr "@I @b #%B (%b) in @i %i.  "
+msgstr "@m @b(s) in @i %i:"
 
 #: e2fsck/problem.c:812
 #, c-format
@@ -1645,7 +1638,7 @@ msgstr "Durchgang 2: Prfe @d Struktur\
 #: e2fsck/problem.c:889
 #, c-format
 msgid "@n @i number for '.' in @d @i %i.\n"
-msgstr "Falsche @i Nummer fr '.' in @d @i %i.\n"
+msgstr "Falsche @i Nummer fr . in @d @i %i.\n"
 
 #. @-expanded: entry '%Dn' in %p (%i) has invalid inode #: %Di.\n
 #: e2fsck/problem.c:894
@@ -1660,7 +1653,7 @@ msgstr "@E hat @D/unbenutzt @i %Di.  "
 #. @-expanded: entry '%Dn' in %p (%i) is a link to '.'  
 #: e2fsck/problem.c:904
 msgid "@E @L to '.'  "
-msgstr "@E @L nach '.'  "
+msgstr "@E @L nach .  "
 
 #. @-expanded: entry '%Dn' in %p (%i) points to inode (%Di) located in a bad block.\n
 #: e2fsck/problem.c:909
@@ -1686,23 +1679,23 @@ msgstr "@E hat ein unzulssiges Zeichen
 #: e2fsck/problem.c:929
 #, c-format
 msgid "Missing '.' in @d @i %i.\n"
-msgstr "Fehlende '.' in @d @i %i.\n"
+msgstr "Fehlende . in @d @i %i.\n"
 
 #. @-expanded: Missing '..' in directory inode %i.\n
 #: e2fsck/problem.c:934
 #, c-format
 msgid "Missing '..' in @d @i %i.\n"
-msgstr "Fehlende '..' in @d @i %i.\n"
+msgstr "Fehlende .. in @d @i %i.\n"
 
 #. @-expanded: First entry '%Dn' (inode=%Di) in directory inode %i (%p) should be '.'\n
 #: e2fsck/problem.c:939
 msgid "First @e '%Dn' (@i=%Di) in @d @i %i (%p) @s '.'\n"
-msgstr "Erster @e '%Dn' (inode=%Di) in @d @i %i (%p) @s '.'\n"
+msgstr "Erster @e %Dn (inode=%Di) in @d @i %i (%p) @s .\n"
 
 #. @-expanded: Second entry '%Dn' (inode=%Di) in directory inode %i should be '..'\n
 #: e2fsck/problem.c:944
 msgid "Second @e '%Dn' (@i=%Di) in @d @i %i @s '..'\n"
-msgstr "Zweiter @e '%Dn' (inode=%Di) in @d @i %i @s '..'\n"
+msgstr "Zweiter @e %Dn (inode=%Di) in @d @i %i @s ..\n"
 
 #. @-expanded: i_faddr for inode %i (%Q) is %IF, should be zero.\n
 #: e2fsck/problem.c:949
@@ -1753,13 +1746,13 @@ msgstr "@d @i %i hat einen nicht zugewie
 #: e2fsck/problem.c:994
 #, c-format
 msgid "'.' @d @e in @d @i %i is not NULL terminated\n"
-msgstr "'.' @d @e in @d @i %i ist nicht NULL-terminiert\n"
+msgstr ". @d @e in @d @i %i ist nicht NULL-terminiert\n"
 
 #. @-expanded: '..' directory entry in directory inode %i is not NULL terminated\n
 #: e2fsck/problem.c:999
 #, c-format
 msgid "'..' @d @e in @d @i %i is not NULL terminated\n"
-msgstr "'..' @d @e in @d @i %i ist nicht NULL-terminiert\n"
+msgstr ".. @d @e in @d @i %i ist nicht NULL-terminiert\n"
 
 #. @-expanded: inode %i (%Q) is an illegal character device.\n
 #: e2fsck/problem.c:1004
@@ -1774,12 +1767,12 @@ msgstr "@i %i (%Q) ist ein @I @b @v.\n"
 #. @-expanded: entry '%Dn' in %p (%i) is duplicate '.' entry.\n
 #: e2fsck/problem.c:1014
 msgid "@E is duplicate '.' @e.\n"
-msgstr "@E ist ein doppelter '.' @e.\n"
+msgstr "@E ist ein doppelter . @e.\n"
 
 #. @-expanded: entry '%Dn' in %p (%i) is duplicate '..' entry.\n
 #: e2fsck/problem.c:1019
 msgid "@E is duplicate '..' @e.\n"
-msgstr "@E ist ein doppelter '..' @e.\n"
+msgstr "@E ist ein doppelter .. @e.\n"
 
 #: e2fsck/problem.c:1024 e2fsck/problem.c:1305
 #, c-format
@@ -1828,7 +1821,7 @@ msgstr "Fehler bei der Freigabe von @i %
 #. @-expanded: directory entry for '.' is big.  
 #: e2fsck/problem.c:1064
 msgid "@d @e for '.' is big.  "
-msgstr "@d @e fr '.' ist gro.  "
+msgstr "@d @e fr . ist gro.  "
 
 #. @-expanded: inode %i (%Q) is an illegal FIFO.\n
 #: e2fsck/problem.c:1069
@@ -1873,8 +1866,7 @@ msgstr "@a @b @F ist falsch (%If).\n"
 #. @-expanded: filesystem contains large files, but lacks LARGE_FILE flag in superblock.\n
 #: e2fsck/problem.c:1109
 msgid "@f contains large files, but lacks LARGE_FILE flag in @S.\n"
-msgstr ""
-"@f enthlt groe Dateien, aber das LARGE_FILE Flag in @S ist nicht gesetzt.\n"
+msgstr "@f enthlt groe Dateien, aber das LARGE_FILE Flag in @S ist nicht gesetzt.\n"
 
 #. @-expanded: problem in HTREE directory inode %d: node (%B) not referenced\n
 #: e2fsck/problem.c:1114
@@ -1963,9 +1955,8 @@ msgstr ""
 
 #. @-expanded: i_blocks_hi for inode %i (%Q) is %N, should be zero.\n
 #: e2fsck/problem.c:1188
-#, fuzzy
 msgid "i_blocks_hi @F %N, @s zero.\n"
-msgstr "i_fsize @F %N, @s null.\n"
+msgstr "i_blocks_hi @F %N, @s zero.\n"
 
 #. @-expanded: Pass 3: Checking directory connectivity\n
 #: e2fsck/problem.c:1195
@@ -1996,7 +1987,7 @@ msgstr "/@l nicht gefunden.  "
 #. @-expanded: '..' in %Q (%i) is %P (%j), should be %q (%d).\n
 #: e2fsck/problem.c:1220
 msgid "'..' in %Q (%i) is %P (%j), @s %q (%d).\n"
-msgstr "'..' in %Q (%i) ist %P (%j), @s %q (%d).\n"
+msgstr ".. in %Q (%i) ist %P (%j), @s %q (%d).\n"
 
 #. @-expanded: Bad or non-existent /lost+found.  Cannot reconnect.\n
 #: e2fsck/problem.c:1225
@@ -2131,12 +2122,12 @@ msgstr "@I @o @i %i in @S.  "
 #: e2fsck/problem.c:1359
 #, c-format
 msgid "@u @i %i\n"
-msgstr ""
+msgstr "@u @i %i\n"
 
 #. @-expanded: inode %i ref count is %Il, should be %N.  
 #: e2fsck/problem.c:1364
 msgid "@i %i ref count is %Il, @s %N.  "
-msgstr "@i %i Prfsumme ist %Il, @s %N.  "
+msgstr "@i %i Referenzzhler ist %Il, @s %N.  "
 
 #. @-expanded: WARNING: PROGRAMMING BUG IN E2FSCK!\n
 #. @-expanded: \tOR SOME BONEHEAD (YOU) IS CHECKING A MOUNTED (LIVE) FILESYSTEM.\n
@@ -2149,8 +2140,7 @@ msgid ""
 msgstr ""
 "WARNUNG: PROGRAMMIERFEHLER IN E2FSCK!\n"
 "\tODER EIN TROTTEL (SIE) PRFT EIN EINGEHNGTES (LIVE) DATEISYSTEM.\n"
-"@i_link_info[%i] ist %N, @i.i_links_count ist %Il.  Sie sollten gleich "
-"sein!\n"
+"@i_link_info[%i] ist %N, @i.i_links_count ist %Il.  Sie sollten identisch sein!\n"
 
 #. @-expanded: Pass 5: Checking group summary information\n
 #: e2fsck/problem.c:1378
@@ -2205,12 +2195,8 @@ msgstr "Freie @bs Anzahl ist falsch (%b,
 #. @-expanded: PROGRAMMING ERROR: filesystem (#%N) bitmap endpoints (%b, %c) don't match calculated bitmap 
 #. @-expanded: endpoints (%i, %j)\n
 #: e2fsck/problem.c:1458
-msgid ""
-"PROGRAMMING ERROR: @f (#%N) @B endpoints (%b, %c) don't match calculated @B "
-"endpoints (%i, %j)\n"
-msgstr ""
-"PROGRAMMIERFEHLER: @f (#%N) @B Endpunkte (%b, %c) passen nicht zu den "
-"berechneten @B Endpunkten (%i, %j)\n"
+msgid "PROGRAMMING ERROR: @f (#%N) @B endpoints (%b, %c) don't match calculated @B endpoints (%i, %j)\n"
+msgstr "PROGRAMMIERFEHLER: @f (#%N) @B Endpunkte (%b, %c) passen nicht zu den berechneten @B Endpunkten (%i, %j)\n"
 
 #: e2fsck/problem.c:1464
 msgid "Internal error: fudging end of bitmap (%N)\n"
@@ -2231,6 +2217,8 @@ msgstr "Fehler beim hineinkopieren von @
 #: e2fsck/problem.c:1499
 msgid "Recreate journal to make the filesystem ext3 again?\n"
 msgstr ""
+"Soll das Journal wiederhergestellt werden, damit das Dateisystem\n"
+"\twieder ext3 ist?\n"
 
 #: e2fsck/problem.c:1617
 #, c-format
@@ -2265,9 +2253,9 @@ msgid "while calling ext2fs_block_iterat
 msgstr "whrend des Aufrufs von ext2fs_block_iterate fr Inode %d"
 
 #: e2fsck/super.c:210
-#, fuzzy, c-format
+#, c-format
 msgid "while calling ext2fs_adjust_ea_refcount for inode %d"
-msgstr "while calling ext2fs_adjust_ea_refocunt for inode %d"
+msgstr "whrend des Aufrufs von ext2fs_adjust_ea_refcount fr Inode %d"
 
 #: e2fsck/super.c:268
 msgid "Truncating"
@@ -2315,7 +2303,7 @@ msgstr ""
 
 #: e2fsck/swapfs.c:268
 msgid "Byte swap"
-msgstr "Byte Swap"
+msgstr "Bytes vertauschen"
 
 #: e2fsck/unix.c:74
 #, c-format
@@ -2325,7 +2313,7 @@ msgid ""
 "\t\t[-l|-L bad_blocks_file] [-C fd] [-j external_journal]\n"
 "\t\t[-E extended-options] device\n"
 msgstr ""
-"Verwendung: %s [-panyrcdfvstFSV] [-b Superblock] [-B Blockgre]\n"
+"Aufruf: %s [-panyrcdfvstFSV] [-b Superblock] [-B Blockgre]\n"
 "\t\t[-I inode_buffer_blocks] [-P process_inode_size]\n"
 "\t\t[-l|-L bad_blocks_file] [-C fd] [-j ext-journal]\n"
 "\t\t[-E erweiterte_Optionen] Gert\n"
@@ -2338,8 +2326,7 @@ msgid ""
 " -p                   Automatic repair (no questions)\n"
 " -n                   Make no changes to the filesystem\n"
 " -y                   Assume \"yes\" to all questions\n"
-" -c                   Check for bad blocks and add them to the badblock "
-"list\n"
+" -c                   Check for bad blocks and add them to the badblock list\n"
 " -f                   Force checking even if filesystem is marked clean\n"
 msgstr ""
 "\n"
@@ -2368,14 +2355,14 @@ msgstr ""
 " -L bad_blocks_file   Liste der defekten Blcke definieren\n"
 
 #: e2fsck/unix.c:121
-#, fuzzy, c-format
+#, c-format
 msgid "%s: %u/%u files (%0d.%d%% non-contiguous), %u/%u blocks\n"
-msgstr "%s: %d/%d Dateien (%0d.%d%% nicht zusammenhngend), %u/%u Blcke\n"
+msgstr "%s: %u/%u Dateien (%0d.%d%% nicht zusammenhngend), %u/%u Blcke\n"
 
 #: e2fsck/unix.c:133
-#, fuzzy, c-format
+#, c-format
 msgid "         # of inodes with ind/dind/tind blocks: %u/%u/%u\n"
-msgstr "         # von Inodes mit ind/dind/tind Blcken: %d/%d/%d\n"
+msgstr "         # von Inodes mit ind/dind/tind Blcken: %u/%u/%u\n"
 
 #: e2fsck/unix.c:176 misc/badblocks.c:789 misc/tune2fs.c:941 misc/util.c:151
 #: resize/main.c:237
@@ -2435,7 +2422,7 @@ msgstr " wurde nicht ordnungsgem aus
 
 #: e2fsck/unix.c:284
 msgid " primary superblock features different from backup"
-msgstr ""
+msgstr "Eigenschaften des primren Superblocks unterscheiden sich vom Backup"
 
 #: e2fsck/unix.c:288
 #, c-format
@@ -2452,9 +2439,9 @@ msgid ", check forced.\n"
 msgstr ", Prfung erzwungen.\n"
 
 #: e2fsck/unix.c:307
-#, fuzzy, c-format
+#, c-format
 msgid "%s: clean, %u/%u files, %u/%u blocks"
-msgstr "%s: i.O., %d/%d Dateien, %u/%u Blcke"
+msgstr "%s: sauber, %u/%u Dateien, %u/%u Blcke"
 
 #: e2fsck/unix.c:324
 msgid " (check deferred; on battery)"
@@ -2482,7 +2469,7 @@ msgstr "Invalid EA version.\n"
 #: e2fsck/unix.c:552
 #, c-format
 msgid "Unknown extended option: %s\n"
-msgstr ""
+msgstr "Unbekannte erweiterte Option: %s\n"
 
 #: e2fsck/unix.c:572
 #, c-format
@@ -2490,6 +2477,8 @@ msgid ""
 "Syntax error in e2fsck config file (%s, line #%d)\n"
 "\t%s\n"
 msgstr ""
+"Syntaxfehler in der Konfigurationsdatei von e2fsck (%s, Zeile %d)\n"
+"\t%s\n"
 
 #: e2fsck/unix.c:636
 #, c-format
@@ -2498,7 +2487,7 @@ msgstr "Fehler bei berprfung des Dat
 
 #: e2fsck/unix.c:640
 msgid "Invalid completion information file descriptor"
-msgstr "Ungltiger 'completion information'-Datei-Deskriptor"
+msgstr "Ungltiger completion information-Datei-Deskriptor"
 
 #: e2fsck/unix.c:655
 msgid "Only one of the options -p/-a, -n or -y may be specified."
@@ -2512,8 +2501,7 @@ msgstr "Die -t Option wird von dieser e2
 #: e2fsck/unix.c:747
 #, c-format
 msgid "Byte-swapping filesystems not compiled in this version of e2fsck\n"
-msgstr ""
-"Das Byte-Swapping wurde in diese Version von e2fsck nicht einkompiliert.\n"
+msgstr "Das Byte-Swapping wurde in diese Version von e2fsck nicht einkompiliert.\n"
 
 #: e2fsck/unix.c:770 misc/tune2fs.c:504 misc/tune2fs.c:769 misc/tune2fs.c:786
 #, c-format
@@ -2528,15 +2516,14 @@ msgstr "Inkompatible Optionen sind beim 
 #: e2fsck/unix.c:808
 #, c-format
 msgid "The -c and the -l/-L options may not be both used at the same time.\n"
-msgstr ""
-"Die -c und -l/-L Optionen drfen nicht gleichzeitig verwendet werden.\n"
+msgstr "Die -c und -l/-L Optionen drfen nicht gleichzeitig verwendet werden.\n"
 
 #: e2fsck/unix.c:856
 #, c-format
 msgid ""
 "E2FSCK_JBD_DEBUG \"%s\" not an integer\n"
 "\n"
-msgstr ""
+msgstr "2FSCK_JBD_DEBUG \"%s\" ist keine Ganzzahl\n"
 
 #: e2fsck/unix.c:865
 #, c-format
@@ -2545,6 +2532,9 @@ msgid ""
 "Invalid non-numeric argument to -%c (\"%s\")\n"
 "\n"
 msgstr ""
+"\n"
+"Ungltiges nicht-numerisches Argument fr -%c (\"%s\")\n"
+"\n"
 
 #: e2fsck/unix.c:905
 #, c-format
@@ -2565,13 +2555,13 @@ msgid "need terminal for interactive rep
 msgstr "Bentige ein Terminal fr interaktive Reparaturen"
 
 #: e2fsck/unix.c:983
-#, fuzzy, c-format
+#, c-format
 msgid "%s: %s trying backup blocks...\n"
-msgstr "%s versuche Backup-Blcke...\n"
+msgstr "%s: %s versuche es mit Backup-Blcken...\n"
 
 #: e2fsck/unix.c:985
 msgid "Superblock invalid,"
-msgstr ""
+msgstr "Superblock ungltig"
 
 #: e2fsck/unix.c:986
 msgid "Group descriptors look bad..."
@@ -2601,13 +2591,15 @@ msgstr "Sie bentigen %s- oder root-Rec
 #: e2fsck/unix.c:1026
 #, c-format
 msgid "Possibly non-existent or swap device?\n"
-msgstr ""
-"Mglicherweise ist die Partition nicht vorhanden oder eine Swap-Partition?\n"
+msgstr "Mglicherweise ist die Partition nicht vorhanden oder eine Swap-Partition?\n"
 
 #: e2fsck/unix.c:1028
 #, c-format
 msgid "Filesystem mounted or opened exclusively by another program?\n"
 msgstr ""
+"Ist das Dateisystem eingehngt or exklusiv von einem anderen Programm\n"
+"\n"
+"geffnet worden?\n"
 
 #: e2fsck/unix.c:1032
 #, c-format
@@ -2629,12 +2621,8 @@ msgstr "whrend der Prfung des ext3-J
 
 #: e2fsck/unix.c:1128
 #, c-format
-msgid ""
-"Warning: skipping journal recovery because doing a read-only filesystem "
-"check.\n"
-msgstr ""
-"Warnung: berspringe Journal-Wiederherstellung, da das Dateisystem im Nur-"
-"Lesen-Modus ist.\n"
+msgid "Warning: skipping journal recovery because doing a read-only filesystem check.\n"
+msgstr "Warnung: berspringe Journal-Wiederherstellung, da das Dateisystem im Nur-Lesen-Modus ist.\n"
 
 #: e2fsck/unix.c:1141
 #, c-format
@@ -2647,9 +2635,9 @@ msgid "while recovering ext3 journal of 
 msgstr "bei der Wiederherstellung des ext3-Journals von %s"
 
 #: e2fsck/unix.c:1171
-#, fuzzy, c-format
+#, c-format
 msgid "%s has unsupported feature(s):"
-msgstr "@h %i hat eine nicht untersttzte hash-Version (%N)\n"
+msgstr "%s besitzt nicht untersttzte Eigenschaft(en):"
 
 #: e2fsck/unix.c:1187
 msgid "Warning: compression support is experimental.\n"
@@ -2680,7 +2668,7 @@ msgstr "Das verheit nichts gutes, aber
 
 #: e2fsck/unix.c:1289
 msgid "Couldn't determine journal size"
-msgstr ""
+msgstr "Konnte die Gre des Dateisystems nicht ermitteln"
 
 #: e2fsck/unix.c:1292 misc/mke2fs.c:1776
 #, c-format
@@ -2696,9 +2684,9 @@ msgstr ""
 "\tbeim Erstellen des Journals"
 
 #: e2fsck/unix.c:1302
-#, fuzzy, c-format
+#, c-format
 msgid " Done.\n"
-msgstr "erledigt\n"
+msgstr " Erledigt.\n"
 
 #: e2fsck/unix.c:1303
 #, c-format
@@ -2706,6 +2694,8 @@ msgid ""
 "\n"
 "*** journal has been re-created - filesystem is now ext3 again ***\n"
 msgstr ""
+"\n"
+"*** Journal wurde wiederhergestellt - Dateisystem ist nun wieder ext3 ***\n"
 
 #: e2fsck/unix.c:1310
 #, c-format
@@ -2884,21 +2874,18 @@ msgid "while writing inode %ld in %s"
 msgstr "beim Schreiben von Inode %ld in %s"
 
 #: misc/badblocks.c:61
-#, fuzzy
 msgid "done                                \n"
-msgstr "erledigt                           \n"
+msgstr "erledigt                            \n"
 
 #: misc/badblocks.c:80
 #, c-format
 msgid ""
 "Usage: %s [-b block_size] [-i input_file] [-o output_file] [-svwnf]\n"
-" [-c blocks_at_once] [-p num_passes] [-t test_pattern [-t test_pattern "
-"[...]]]\n"
+" [-c blocks_at_once] [-p num_passes] [-t test_pattern [-t test_pattern [...]]]\n"
 " device [last_block [start_block]]\n"
 msgstr ""
-"Verwendung: %s [-b Blockgre] [-i Eingabedatei] [-o Ausgabedatei] [-svwnf]\n"
-" [-c Blcke_auf_einmal] [-p Durchgnge ] [-t Testpattern [-t Testpattern "
-"[...]]]\n"
+"Aufruf: %s [-b Blockgre] [-i Eingabedatei] [-o Ausgabedatei] [-svwnf]\n"
+" [-c Blcke_auf_einmal] [-p Anzahl_Durchgnge ] [-t Testmuster [-t Testmuster [...]]]\n"
 " Gert [letzter_Block [Startblock]]\n"
 
 #: misc/badblocks.c:88
@@ -2907,6 +2894,8 @@ msgid ""
 "%s: The -n and -w options are mutually exclusive.\n"
 "\n"
 msgstr ""
+"%s: Die Optionen -n und -w schliessen sich gegenseitig aus.\n"
+"\n"
 
 #: misc/badblocks.c:235
 msgid "Testing with random pattern: "
@@ -2931,7 +2920,7 @@ msgstr "whrend ext2fs_sync_device"
 
 #: misc/badblocks.c:343 misc/badblocks.c:581
 msgid "while beginning bad block list iteration"
-msgstr "beim Beginn des 'Bad Block'-Listendurchlaufs"
+msgstr "beim Beginn des Bad Block-Listendurchlaufs"
 
 #: misc/badblocks.c:357 misc/badblocks.c:447 misc/badblocks.c:591
 msgid "while allocating buffers"
@@ -2965,13 +2954,11 @@ msgstr "Lesen und Vergleichen:"
 
 #: misc/badblocks.c:603
 msgid "Checking for bad blocks in non-destructive read-write mode\n"
-msgstr ""
-"Suche nach defekten Blcken im zerstrungsfreien Lesen+Schreiben-Modus\n"
+msgstr "Suche nach defekten Blcken im zerstrungsfreien Lesen+Schreiben-Modus\n"
 
 #: misc/badblocks.c:607
 msgid "Checking for bad blocks (non-destructive read-write test)\n"
-msgstr ""
-"Suche nach defekten Blcken (zerstrungsfreier Lesen+Schreiben-Modus)\n"
+msgstr "Suche nach defekten Blcken (zerstrungsfreier Lesen+Schreiben-Modus)\n"
 
 #: misc/badblocks.c:614
 msgid ""
@@ -2993,8 +2980,7 @@ msgstr "%s ist eingehngt; "
 
 #: misc/badblocks.c:796
 msgid "badblocks forced anyway.  Hope /etc/mtab is incorrect.\n"
-msgstr ""
-"Badblocks wird trotzdem erzwungen. Hoffentlich ist /etc/mtab nicht korrekt.\n"
+msgstr "Badblocks wird trotzdem erzwungen. Hoffentlich ist /etc/mtab nicht korrekt.\n"
 
 #: misc/badblocks.c:801
 msgid "it's not safe to run badblocks!\n"
@@ -3003,12 +2989,11 @@ msgstr "es ist zu unsicher, Badblocks zu
 #: misc/badblocks.c:806 misc/util.c:167
 #, c-format
 msgid "%s is apparently in use by the system; "
-msgstr ""
+msgstr "%s wird offensichtlich vom System genutzt; "
 
 #: misc/badblocks.c:809
 msgid "badblocks forced anyway.\n"
-msgstr ""
-"Badblocks wird trotzdem erzwungen. Hoffentlich ist /etc/mtab nicht korrekt.\n"
+msgstr "Badblocks wird trotzdem erzwungen. Hoffentlich ist /etc/mtab nicht korrekt.\n"
 
 #: misc/badblocks.c:871
 #, c-format
@@ -3018,27 +3003,26 @@ msgstr "bad block Gre - %s"
 #: misc/badblocks.c:928
 #, c-format
 msgid "can't allocate memory for test_pattern - %s"
-msgstr "Kann keinen Speicher fr Testpattern reservieren - %s"
+msgstr "Kann keinen Speicher fr Testmuster reservieren - %s"
 
 #: misc/badblocks.c:942
 #, c-format
 msgid "invalid test_pattern: %s\n"
-msgstr "Ungltiges Testpattern: %s\n"
+msgstr "Ungltiges Testmuster: %s\n"
 
 #: misc/badblocks.c:961
 msgid "Maximum of one test_pattern may be specified in read-only mode"
-msgstr "Es darf im Nur-Lesen-Modus nur ein Testpattern angegeben werden"
+msgstr "Es darf im Nur-Lesen-Modus nur ein Testmuster angegeben werden"
 
 #: misc/badblocks.c:967
 msgid "Random test_pattern is not allowed in read-only mode"
-msgstr "Zuflliges Testpattern ist im Nur-Lesen-Modus nicht erlaubt"
+msgstr "Zuflliges Testmuster ist im Nur-Lesen-Modus nicht erlaubt"
 
 #: misc/badblocks.c:981
 msgid ""
 "Couldn't determine device size; you must specify\n"
 "the size manually\n"
-msgstr ""
-"Gre des Gertes nicht feststellbar. Sie mssen sie manuell angeben.\n"
+msgstr "Gre des Gertes ist nicht feststellbar. Sie mssen sie manuell angeben.\n"
 
 #: misc/badblocks.c:987
 msgid "while trying to determine device size"
@@ -3055,9 +3039,9 @@ msgid "invalid starting block - %s"
 msgstr "Defekter Startblock - %s"
 
 #: misc/badblocks.c:1015
-#, fuzzy, c-format
+#, c-format
 msgid "invalid starting block (%d): must be less than %lu"
-msgstr "Defekter Startblock - %s"
+msgstr "Ungltiger Startblock (%d): er muss kleiner als %lu sein"
 
 #: misc/badblocks.c:1070
 msgid "while creating in-memory bad blocks list"
@@ -3075,7 +3059,7 @@ msgstr "Durchgang beendet, %u defekte Bl
 #: misc/chattr.c:84
 #, c-format
 msgid "Usage: %s [-RV] [-+=AacDdijsSu] [-v version] files...\n"
-msgstr "Verwendung: %s [-RV] [-+=AacDdijsSu] [-v Version] Dateien...\n"
+msgstr "Aufruf: %s [-RV] [-+=AacDdijsSu] [-v Version] Dateien...\n"
 
 #: misc/chattr.c:147
 #, c-format
@@ -3123,12 +3107,12 @@ msgstr "= ist inkompatibel mit - und +\n
 
 #: misc/chattr.c:300
 msgid "Must use '-v', =, - or +\n"
-msgstr "Benutze '-v', =, - oder +\n"
+msgstr "Benutze -v, =, - oder +\n"
 
 #: misc/dumpe2fs.c:53
 #, c-format
 msgid "Usage: %s [-bfhixV] [-ob superblock] [-oB blocksize] device\n"
-msgstr "Verwendung: %s [-bfhixV] [-ob Superblock] [-oB Blockgre] Gert\n"
+msgstr "Aufruf: %s [-bfhixV] [-ob Superblock] [-oB Blockgre] Gert\n"
 
 #: misc/dumpe2fs.c:162
 #, c-format
@@ -3202,12 +3186,12 @@ msgstr "  Freie Inodes: "
 
 #: misc/dumpe2fs.c:246
 msgid "while printing bad block list"
-msgstr "beim Ausgeben der 'Bad Block'-Liste"
+msgstr "beim Ausgeben der Bad Block-Liste"
 
 #: misc/dumpe2fs.c:252
-#, fuzzy, c-format
+#, c-format
 msgid "Bad blocks: %u"
-msgstr "Bad Blocks: %d"
+msgstr "Bad Blocks: %u"
 
 #: misc/dumpe2fs.c:274 misc/tune2fs.c:261
 msgid "while reading journal inode"
@@ -3215,7 +3199,7 @@ msgstr "beim Lesen des Journal-Inodes"
 
 #: misc/dumpe2fs.c:277
 msgid "Journal size:             "
-msgstr ""
+msgstr "Journalgrsse:            "
 
 #: misc/dumpe2fs.c:296 misc/tune2fs.c:183
 msgid "while reading journal superblock"
@@ -3226,7 +3210,7 @@ msgid "Couldn't find journal superblock 
 msgstr "Konnte die magische Nummer des Journal-Superblocks nicht finden"
 
 #: misc/dumpe2fs.c:308
-#, fuzzy, c-format
+#, c-format
 msgid ""
 "\n"
 "Journal block size:       %u\n"
@@ -3242,31 +3226,30 @@ msgstr ""
 "Journal Startblock:       %u\n"
 "Journal Sequenz:          0x%08x\n"
 "Journal Start:            %u\n"
-"Journal Nutzeranzahl:     %lu\n"
+"Journal Anzahl Nutzer:    %u\n"
 
 #: misc/dumpe2fs.c:321
 #, c-format
 msgid "Journal users:            %s\n"
-msgstr ""
+msgstr "Jounalnutzer:            %s\n"
 
 #: misc/dumpe2fs.c:337 misc/mke2fs.c:768 misc/tune2fs.c:810
 #, c-format
 msgid "Couldn't allocate memory to parse options!\n"
-msgstr ""
-"Speicher zum Parsen der RAID-Optionen konnte nicht reserviert werden!\n"
+msgstr "Speicher zum Parsen der Optionen konnte nicht reserviert werden!\n"
 
 #: misc/dumpe2fs.c:363
-#, fuzzy, c-format
+#, c-format
 msgid "Invalid superblock parameter: %s\n"
-msgstr "Ungltiger \"stride\"-Parameter: %s\n"
+msgstr "Ungltiger Superblock-Parameter: %s\n"
 
 #: misc/dumpe2fs.c:378
-#, fuzzy, c-format
+#, c-format
 msgid "Invalid blocksize parameter: %s\n"
-msgstr "Ungltiger \"resize\"-Parameter: %s\n"
+msgstr "Ungltiger Blockgrssen-Parameter: %s\n"
 
 #: misc/dumpe2fs.c:389
-#, fuzzy, c-format
+#, c-format
 msgid ""
 "\n"
 "Bad extended option(s) specified: %s\n"
@@ -3279,14 +3262,14 @@ msgid ""
 "\tblocksize=<blocksize>\n"
 msgstr ""
 "\n"
-"falsche Raid-Optionen angegeben.\n"
+"Falsche erweiterte Optionen angegeben: %s\n"
 "\n"
-"Raid-Optionen werden mit Kommatas getrennt angegeben, sie knnen ein "
-"Argument\n"
-"\terhalten welches mit Gleichheitszeichen ('=') zugewiesen wird.\n"
+"Erweiterte Optionen werden durch Kommatas getrennt. Manche erwarten ein\n"
+"\tArgument, welches mit Gleichheitszeichen (=) zugewiesen wird.\n"
 "\n"
-"gltige Raid-Optionen sind:\n"
-"\tstride=<stride length in blocks>\n"
+"Gltige erweiterte Optionen sind:\n"
+"\tsuperblock=<Nummer des Spuperblocks>\n"
+"\tblocksize=<Blockgrsse>\n"
 "\n"
 
 #: misc/dumpe2fs.c:449 misc/mke2fs.c:1199
@@ -3316,7 +3299,7 @@ msgstr ""
 #: misc/e2image.c:50
 #, c-format
 msgid "Usage: %s [-rsI] device image_file\n"
-msgstr "Verwendung: %s [-r] Gertedatei\n"
+msgstr "Aufruf: %s [-r] Gertedatei\n"
 
 #: misc/e2image.c:62
 msgid "Couldn't allocate header buffer\n"
@@ -3381,7 +3364,7 @@ msgstr "e2label: Fehler beim Schreiben d
 #: misc/e2label.c:116 misc/tune2fs.c:496
 #, c-format
 msgid "Usage: e2label device [newlabel]\n"
-msgstr "Verwendung: e2label Gert [neuer_Name]\n"
+msgstr "Aufruf: e2label Gert [neuer_Name]\n"
 
 #: misc/fsck.c:343
 #, c-format
@@ -3400,7 +3383,7 @@ msgid ""
 "\tshould fix your /etc/fstab file as soon as you can.\n"
 "\n"
 msgstr ""
-"\a\a\aWARNUNG: Ihre /etc/fstab enthlt kein 'fsck passno'\n"
+"\a\a\aWARNUNG: Ihre /etc/fstab enthlt kein fsck passno\n"
 "\tFeld.  Ich werde dieses ignorieren, aber Sie\n"
 "\tsollten ihre /etc/fstab so schnell wie mglich korrigieren.\n"
 "\n"
@@ -3440,7 +3423,7 @@ msgid ""
 "Either all or none of the filesystem types passed to -t must be prefixed\n"
 "with 'no' or '!'.\n"
 msgstr ""
-"Bei -t mssen entweder allen oder keinem Dateisystem ein 'no' bzw. '!'\n"
+"Bei -t mssen entweder allen oder keinem Dateisystem ein no bzw. !\n"
 "vorangestellt werden.\n"
 
 #: misc/fsck.c:749
@@ -3449,10 +3432,10 @@ msgstr "Kann keinen Speicher fr Dateis
 
 #: misc/fsck.c:872
 #, c-format
-msgid ""
-"%s: skipping bad line in /etc/fstab: bind mount with nonzero fsck pass "
-"number\n"
+msgid "%s: skipping bad line in /etc/fstab: bind mount with nonzero fsck pass number\n"
 msgstr ""
+"%s: berspringe die ungltige Zeile in /etc/fstab: bind mount mit\n"
+" Durchgangsnummer fr fsck, die nicht Null ist\n"
 
 #: misc/fsck.c:899
 #, c-format
@@ -3469,12 +3452,8 @@ msgid "--waiting-- (pass %d)\n"
 msgstr "--warten-- (Durchgang %d)\n"
 
 #: misc/fsck.c:1066
-#, fuzzy
-msgid ""
-"Usage: fsck [-AMNPRTV] [ -C [ fd ] ] [-t fstype] [fs-options] [filesys ...]\n"
-msgstr ""
-"Verwendung: fsck [-ACNPRTV] [-t Datesystemtyp] [fs-Optionen] "
-"[Dateisystem...]\n"
+msgid "Usage: fsck [-AMNPRTV] [ -C [ fd ] ] [-t fstype] [fs-options] [filesys ...]\n"
+msgstr "Aufruf: fsck [-AMNPRTV] [ -C [ fd ] ] [-t Datesystemtyp] [FS-Optionen] [Dateisystem...]\n"
 
 #: misc/fsck.c:1108
 #, c-format
@@ -3489,7 +3468,7 @@ msgstr "%s: zu viele Argumente\n"
 #: misc/lsattr.c:73
 #, c-format
 msgid "Usage: %s [-RVadlv] [files...]\n"
-msgstr "Verwendung: %s [-RVadlv] [Dateien...]\n"
+msgstr "Aufruf: %s [-RVadlv] [Dateien...]\n"
 
 #: misc/lsattr.c:83
 #, c-format
@@ -3502,7 +3481,7 @@ msgid "While reading version on %s"
 msgstr "Beim Lesen der Version von %s"
 
 #: misc/mke2fs.c:97
-#, fuzzy, c-format
+#, c-format
 msgid ""
 "Usage: %s [-c|-l filename] [-b block-size] [-f fragment-size]\n"
 "\t[-i bytes-per-inode] [-I inode-size] [-J journal-options]\n"
@@ -3511,11 +3490,12 @@ msgid ""
 "\t[-O feature[,...]] [-r fs-revision] [-E extended-option[,...]]\n"
 "\t[-T fs-type] [-jnqvFSV] device [blocks-count]\n"
 msgstr ""
-"Verwendung: %s [-c|-t|-l Dateiname] [-b Blockgre] [-f Fragmentgre]\n"
-"\t[-i Bytes-pro-Inode] [-j] [-J Journal-Optionen] [-N Anzahl_der_Inoden]\n"
-"\t[-m Reservierte-Blcke-Prozent] [-o creator-os] [-g Blcke-pro-Gruppe]\n"
-"\t[-L volume-label] [-M last-mounted-directory] [-O feature[,...]]\n"
-"\t[-r fs-revision] [-R raid_opts] [-qvSV] Gert [Blockanzahl]\n"
+"Aufruf: %s [-c|-t|-l Dateiname] [-b Blockgre] [-f Fragmentgre]\n"
+"\t[-i Bytes-pro-Inode] [-I Inodegrsse] [-J Journal-Optionen]\n"
+"\t[-N Anzahl_der_Inodes] [-m Reservierte-Blcke-Prozent] [-o Erzeuger-OS]\n"
+"\t[-g Blcke-pro-Gruppe] [-L Volume-Label]\n"
+"\t[-M letztes-eingehngtes-Verzeichnis] [-O feature[,...]] [-r fs-revision]\n"
+"\t[-R raid_opts] [-jnqvFSV] Gert [Blockanzahl]\n"
 
 #: misc/mke2fs.c:198
 #, c-format
@@ -3525,11 +3505,11 @@ msgstr "Fhre aus: %s\n"
 #: misc/mke2fs.c:202
 #, c-format
 msgid "while trying to run '%s'"
-msgstr "whrend des Ausfhrungsversuchs von '%s'"
+msgstr "whrend des Versuchs, %s auszufhren"
 
 #: misc/mke2fs.c:209
 msgid "while processing list of bad blocks from program"
-msgstr "beim Auswerten der 'Bad Block'-Liste vom Programm"
+msgstr "beim Auswerten der Bad Block-Liste vom Programm"
 
 #: misc/mke2fs.c:236
 #, c-format
@@ -3537,11 +3517,11 @@ msgid "Block %d in primary superblock/gr
 msgstr "Block %d im primren Superblock/Gruppendeskriptorbereich defekt.\n"
 
 #: misc/mke2fs.c:238
-#, fuzzy, c-format
+#, c-format
 msgid "Blocks %u through %u must be good in order to build a filesystem.\n"
 msgstr ""
-"Die Blcke %u bis einschlielich %d mssen i.O. sein um ein Dateisystem zu "
-"erstellen.\n"
+"Die Blcke %u bis einschlielich %u mssen in Ordung sein, um ein\n"
+"\tDateisystem zu erstellen.\n"
 
 #: misc/mke2fs.c:241
 msgid "Aborting....\n"
@@ -3554,22 +3534,21 @@ msgid ""
 "\tbad blocks.\n"
 "\n"
 msgstr ""
-"Warnung: die Sicherung des Superblock bzw. Gruppendeskriptors in Block %u "
-"enthlt\n"
+"Warnung: die Sicherung des Superblock bzw. Gruppendeskriptors in Block %u enthlt\n"
 "\tdefekte Blcke.\n"
 "\n"
 
 #: misc/mke2fs.c:279
 msgid "while marking bad blocks as used"
-msgstr "beim Markieren von defekten Blcken als 'belegt'"
+msgstr "beim Markieren von defekten Blcken als belegt"
 
 #: misc/mke2fs.c:337
 msgid "done                            \n"
-msgstr "erledigt                           \n"
+msgstr "erledigt                        \n"
 
 #: misc/mke2fs.c:372
 msgid "while allocating zeroizing buffer"
-msgstr "while allocating zeroizing buffer"
+msgstr "beim reservieren eines Puffers zum Nullen"
 
 #: misc/mke2fs.c:414
 msgid "Writing inode tables: "
@@ -3610,7 +3589,7 @@ msgstr "beim Expandieren von /lost+found
 
 #: misc/mke2fs.c:559
 msgid "while setting bad block inode"
-msgstr "beim Setzen des 'Bad Block'-Inodes"
+msgstr "beim Setzen des Bad Block-Inodes"
 
 #: misc/mke2fs.c:591
 #, c-format
@@ -3723,9 +3702,9 @@ msgid "Invalid stride parameter: %s\n"
 msgstr "Ungltiger \"stride\"-Parameter: %s\n"
 
 #: misc/mke2fs.c:808
-#, fuzzy, c-format
+#, c-format
 msgid "Invalid stripe-width parameter: %s\n"
-msgstr "Ungltiger \"stride\"-Parameter: %s\n"
+msgstr "Ungltiger Stripebreite-Parameter: %s\n"
 
 #: misc/mke2fs.c:830
 #, c-format
@@ -3735,17 +3714,17 @@ msgstr "Ungltiger \"resize\"-Parameter
 #: misc/mke2fs.c:837
 #, c-format
 msgid "The resize maximum must be greater than the filesystem size.\n"
-msgstr ""
-"Das Maximum der Vergrsserung muss oberhalb als der Dateisystem-Grsse "
-"liegen.\n"
+msgstr "Das Maximum der Vergrsserung muss oberhalb als der Dateisystem-Grsse liegen.\n"
 
 #: misc/mke2fs.c:861
 #, c-format
 msgid "On-line resizing not supported with revision 0 filesystems\n"
 msgstr ""
+"Online-Grssennderungen werden bei Revison 0 Dateisystemen nicht\n"
+"\tuntersttzt\n"
 
 #: misc/mke2fs.c:878
-#, fuzzy, c-format
+#, c-format
 msgid ""
 "\n"
 "Bad option(s) specified: %s\n"
@@ -3761,15 +3740,19 @@ msgid ""
 "\ttest_fs\n"
 msgstr ""
 "\n"
-"falsche Raid-Optionen angegeben.\n"
+"Ungltige Option(en) angegeben: %s\n"
 "\n"
-"Raid-Optionen werden mit Kommatas getrennt angegeben, sie knnen ein "
-"Argument\n"
-"\terhalten welches mit Gleichheitszeichen ('=') zugewiesen wird.\n"
+"Erweiterte Optionen werden durch Kommatas getrennt. Manche erwarten ein\n"
+"\tArgument, welches mit Gleichheitszeichen (=) zugewiesen wird.\n"
 "\n"
-"gltige Raid-Optionen sind:\n"
-"\tstride=<stride length in blocks>\n"
+"\terhalten welches mit Gleichheitszeichen (=) zugewiesen wird.\n"
 "\n"
+"gltige erweiterte Optionen sind:\n"
+"\tstride=<RAID Segmentgrsse in Blcken>\n"
+"\tstripe-width=<RAID Stride * Datenplatten in Blcken>\n"
+"\tresize=<Obergrenze fr Grssennderung in Blcken>\n"
+"\n"
+"\ttest_fs\n"
 
 #: misc/mke2fs.c:893
 #, c-format
@@ -3778,6 +3761,10 @@ msgid ""
 "Warning: RAID stripe-width %u not an even multiple of stride %u.\n"
 "\n"
 msgstr ""
+"\n"
+"Warnung: RAID Stripe-Breite %u ist kein ganzzahliges Vielfaches von\n"
+"\tStride %u.\n"
+"\n"
 
 #: misc/mke2fs.c:920
 #, c-format
@@ -3785,6 +3772,8 @@ msgid ""
 "Syntax error in mke2fs config file (%s, line #%d)\n"
 "\t%s\n"
 msgstr ""
+"Syntax Fehler in der Konfigurationsdatei von mkefs (%s, Zeile %d)\n"
+"\t%s\n"
 
 #: misc/mke2fs.c:933 misc/tune2fs.c:335
 #, c-format
@@ -3865,10 +3854,8 @@ msgstr "%d-Byte Blcke zu gro fr da
 
 #: misc/mke2fs.c:1247
 #, c-format
-msgid ""
-"Warning: %d-byte blocks too big for system (max %d), forced to continue\n"
-msgstr ""
-"Warnung: %d-byte Blcke zu gro fr das System (max %d), fahre dennoch fort\n"
+msgid "Warning: %d-byte blocks too big for system (max %d), forced to continue\n"
+msgstr "Warnung: %d-byte Blcke zu gro fr das System (max %d), fahre dennoch fort\n"
 
 #: misc/mke2fs.c:1265
 msgid "filesystem"
@@ -3907,18 +3894,20 @@ msgstr "Dateisystem ist grer als aug
 #, c-format
 msgid "Filesystem features not supported with revision 0 filesystems\n"
 msgstr ""
+"Dateisystem-Eigenschaften werden fr Dateisysteme der Revision 0 nicht\n"
+"\tuntersttzt\n"
 
 #: misc/mke2fs.c:1374
 #, c-format
 msgid "Sparse superblocks not supported with revision 0 filesystems\n"
 msgstr ""
+"Verteilte Superblcke werden fr Dateisysteme der Revision 0 nicht\n"
+"\tuntersttzt\n"
 
 #: misc/mke2fs.c:1386
-#, fuzzy, c-format
+#, c-format
 msgid "Journals not supported with revision 0 filesystems\n"
-msgstr ""
-"\n"
-"Das Journal ist zu gro fr dieses Dateisystem.\n"
+msgstr "Journale werden fr Dateisysteme der Revision 0 nicht untersttzt\n"
 
 #: misc/mke2fs.c:1412
 msgid "while trying to determine hardware sector size"
@@ -3927,16 +3916,20 @@ msgstr "beim Ermitteln der Hardware-Sekt
 #: misc/mke2fs.c:1464
 msgid "reserved online resize blocks not supported on non-sparse filesystem"
 msgstr ""
+"Fr Online-Grssennderungen reservierte Blcke werden auf Dateisystemen\n"
+"\tohne Untersttzung fr Lckenkompression  nicht untersttzt"
 
 #: misc/mke2fs.c:1473
 msgid "blocks per group count out of range"
-msgstr "Anzahl der Blcke pro Gruppe nicht im gltigen Bereich"
+msgstr "Anzahl der Blcke pro Gruppe ausserhaalb des gltigen Bereichs"
 
 #: misc/mke2fs.c:1480
 msgid ""
 "Filesystem too large.  No more than 2**31-1 blocks\n"
 "\t (8TB using a blocksize of 4k) are currently supported."
 msgstr ""
+"Das Dateisystem ist zu gross. Derzeit werden maximal 2^31-1 Blcke\n"
+"\t (8TiB bei einer Blockgrsse von 4 KiB) untersttzt."
 
 #: misc/mke2fs.c:1487
 #, c-format
@@ -3946,6 +3939,9 @@ msgid ""
 "\tusing ext3.  Use -b 4096 if this is an issue for you.\n"
 "\n"
 msgstr ""
+"\n"
+"Warnung: einige 2.4'er Kernel untersttzen fr ext3 keine Blockgrssen\n"
+"\tber 4096. Verwenden Sie bitte -b 4096 in solchen Fllen.\n"
 
 #: misc/mke2fs.c:1504
 #, c-format
@@ -3953,20 +3949,19 @@ msgid "invalid inode size %d (min %d/max
 msgstr "ungltige Inode-Gre %d (min %d/max %d)"
 
 #: misc/mke2fs.c:1510
-#, fuzzy, c-format
+#, c-format
 msgid "Warning: %d-byte inodes not usable on older systems\n"
-msgstr ""
-"Warnung: %d-Byte Inodes sind auf den meisten Systemen nicht benutzbar\n"
+msgstr "Warnung: %d-Byte Inodes sind auf lteren Systemen nicht benutzbar\n"
 
 #: misc/mke2fs.c:1522
 #, c-format
 msgid "too many inodes (%llu), raise inode ratio?"
-msgstr ""
+msgstr "zu viele Inodes (%llu), Inode-Verhltnis erhhen?"
 
 #: misc/mke2fs.c:1527
 #, c-format
 msgid "too many inodes (%llu), specify < 2^32 inodes"
-msgstr ""
+msgstr "zu viele Inodes (%llu), sie mssen weniger als 2^32 Inodes angeben"
 
 #: misc/mke2fs.c:1542
 #, c-format
@@ -3975,6 +3970,9 @@ msgid ""
 "\tfilesystem with %lu blocks, specify higher inode_ratio (-i)\n"
 "\tor lower inode count (-N).\n"
 msgstr ""
+"inode_size (%u) * inodes_count (%u) is zu gross fr ein\n"
+"\tDateisystem mit %lu Blcken, geben Sie bitte entweder ein hheres\n"
+"\tinode_ratio (-i) oder eine niedrigere Anzahl an Inodes (-N) an.\n"
 
 #: misc/mke2fs.c:1591
 msgid "while setting up superblock"
@@ -4047,14 +4045,14 @@ msgstr ""
 #: misc/mklost+found.c:49
 #, c-format
 msgid "Usage: mklost+found\n"
-msgstr "Verwendung: mklost+found\n"
+msgstr "Aufruf: mklost+found\n"
 
 #: misc/tune2fs.c:91
 msgid "Please run e2fsck on the filesystem.\n"
 msgstr "Bitte e2fsck ber das Dateisystem laufen lassen.\n"
 
 #: misc/tune2fs.c:98
-#, fuzzy, c-format
+#, c-format
 msgid ""
 "Usage: %s [-c max_mounts_count] [-e errors_behavior] [-g group]\n"
 "\t[-i interval[d|m|w]] [-j] [-J journal_options] [-l]\n"
@@ -4063,12 +4061,13 @@ msgid ""
 "\t[-M last_mounted_dir] [-O [^]feature[,...]]\n"
 "\t[-E extended-option[,...]] [-T last_check_time] [-U UUID] device\n"
 msgstr ""
-"Verwendung: %s [-c max-mounts-count] [-e errors-behavior] [-g group]\n"
-"\t[-i interval[d|m|w]] [-j] [-J journal-options]\n"
-"\t[-l] [-s sparse-flag] [-m reserved-blocks-percent]\n"
-"\t[-o [^]mount-options[,...]] [-r reserved-blocks-count]\n"
-"\t[-u user] [-C mount-count] [-L volume-label] [-M last-mounted-dir]\n"
-"\t[-O [^]feature[,...]] [-T last-check-time] [-U UUID] Gert\n"
+"Aufruf: %s [-c max-Anzahl-Mounts] [-e Fehler-Verhalten] [-g Gruppe]\n"
+"\t[-i Intervall[d|m|w]] [-j] [-J Journal-Optionen[,...]]\n"
+"\t[-m reservierte_Blcke_Prozent] [-o [^]Einhng_Optionen[,...]]\n"
+"\t[-r Anzahl_reservierte_Blcke] [-u Benutzer] [-C Anzahl_Einhngen]\n"
+"\t[-L Volume_Label] [-M letztes_eingehngtes_Verzeichnis]\n"
+"\t[-O [^]Eigenschaft[,...]] [-E erweiterte-Option[,...]]\n"
+"\t[-T letzter_Prfzeitpunkt] [-U UUID] Gert\n"
 
 #: misc/tune2fs.c:171
 msgid "while trying to open external journal"
@@ -4115,20 +4114,20 @@ msgstr "Ungltige Einhnge-Option gese
 #: misc/tune2fs.c:338
 #, c-format
 msgid "Clearing filesystem feature '%s' not supported.\n"
-msgstr ""
+msgstr "Das Zurcksetzen von Dateisystem-Eigenschaft %s wird nicht untersttzt.\n"
 
 #: misc/tune2fs.c:344
 #, fuzzy, c-format
 msgid "Setting filesystem feature '%s' not supported.\n"
-msgstr "Setze Zeit des letzten Dateisystemchecks auf %s\n"
+msgstr "Das Setzen der Dateisystem-Eigenschaft %s wird nicht untersttzt.\n"
 
 #: misc/tune2fs.c:353
 msgid ""
 "The has_journal flag may only be cleared when the filesystem is\n"
 "unmounted or mounted read-only.\n"
 msgstr ""
-"Das has_jounal Flag kann nur gelscht werden, wenn das Dateisystem\n"
-"nicht eingehngt oder im Nur-Lesen-Modus ist.\n"
+"Das has_jounal Flag kann nur zurckgesetzt werden, wenn das Dateisystem\n"
+"nicht oder im Nur-Lesen-Modus eingehngt ist.\n"
 
 #: misc/tune2fs.c:361
 msgid ""
@@ -4136,7 +4135,7 @@ msgid ""
 "the has_journal flag.\n"
 msgstr ""
 "Das needs_recovery Flag ist gesetzt. Bitte starten sie e2fsck vor\n"
-"der Lschung des has_journal Flags.\n"
+"der Zurcksetzung des has_journal Flags.\n"
 
 #: misc/tune2fs.c:428
 msgid "The filesystem already has a journal.\n"
@@ -4163,7 +4162,7 @@ msgstr "beim Hinzufgen des Dateisystem
 
 #: misc/tune2fs.c:463
 msgid "Creating journal inode: "
-msgstr "Erstelle Journal-Inode: "
+msgstr "E5Arstelle Journal-Inode: "
 
 #: misc/tune2fs.c:472
 msgid ""
@@ -4222,17 +4221,17 @@ msgid "bad uid/user name - %s"
 msgstr "ungltige(r) UID/Benutzername - %s"
 
 #: misc/tune2fs.c:842
-#, fuzzy, c-format
+#, c-format
 msgid "Invalid RAID stride: %s\n"
-msgstr "Ungltiger \"stride\"-Parameter: %s\n"
+msgstr "Ungltiger RAID Stride: %s\n"
 
 #: misc/tune2fs.c:857
-#, fuzzy, c-format
+#, c-format
 msgid "Invalid RAID stripe-width: %s\n"
-msgstr "Ungltiger \"stride\"-Parameter: %s\n"
+msgstr "Ungltige RAID Stripe-Breite: %s\n"
 
 #: misc/tune2fs.c:867
-#, fuzzy, c-format
+#, c-format
 msgid ""
 "\n"
 "Bad options specified.\n"
@@ -4247,45 +4246,47 @@ msgid ""
 "\t^test_fs\n"
 msgstr ""
 "\n"
-"falsche Raid-Optionen angegeben.\n"
-"\n"
-"Raid-Optionen werden mit Kommatas getrennt angegeben, sie knnen ein "
-"Argument\n"
-"\terhalten welches mit Gleichheitszeichen ('=') zugewiesen wird.\n"
-"\n"
-"gltige Raid-Optionen sind:\n"
-"\tstride=<stride length in blocks>\n"
+"Falsche Optionen angegeben.\n"
 "\n"
+"Erweiterte Optionen werden mit Kommatas getrennt angegeben und bentigen\n"
+"\teventuell ein Argument, welches mit Gleichheitszeichen (=)\n"
+"\tzugewiesenwird.\n"
+"\n"
+"Gltige erweiterte Optionen sind:\n"
+"\tstride=<RAID Segmentgrsse pro PLatte in Blcken>\n"
+"\tstripe-width=<RAID Stride*Datenplatten in Blcken>\n"
+"\ttest_fs\n"
+"\t^test_fs\n"
 
 #: misc/tune2fs.c:927
 #, c-format
 msgid "Filesystem %s has unsupported features enabled.\n"
-msgstr ""
+msgstr "Fr Dateisystem %s wurden nicht unterstzte Eigenschaften aktiviert.\n"
 
 #: misc/tune2fs.c:951
 #, c-format
 msgid "Setting maximal mount count to %d\n"
-msgstr "Setze maximale Mount-Anzahl auf %d\n"
+msgstr "Setze die maximale Mount-Anzahl auf %d\n"
 
 #: misc/tune2fs.c:957
 #, c-format
 msgid "Setting current mount count to %d\n"
-msgstr "Setze derzeitige Mount-Anzahl auf %d\n"
+msgstr "Setze die derzeitige Mount-Anzahl auf %d\n"
 
 #: misc/tune2fs.c:962
 #, c-format
 msgid "Setting error behavior to %d\n"
-msgstr "Setze Fehler-Verhalten auf %d\n"
+msgstr "Setze das Fehler-Verhalten auf %d\n"
 
 #: misc/tune2fs.c:967
 #, c-format
 msgid "Setting reserved blocks gid to %lu\n"
-msgstr "Setze GID fr reservierte Blcke auf %lu\n"
+msgstr "Setze die GID fr reservierte Blcke auf %lu\n"
 
 #: misc/tune2fs.c:972
 #, c-format
 msgid "Setting interval between checks to %lu seconds\n"
-msgstr "Setze Intervall zwischen Checks auf %lu Sekunden\n"
+msgstr "Setze das Intervall zwischen Checks auf %lu Sekunden\n"
 
 #: misc/tune2fs.c:978
 #, c-format
@@ -4295,12 +4296,12 @@ msgstr "Setze den Prozentsatz reserviert
 #: misc/tune2fs.c:984
 #, c-format
 msgid "reserved blocks count is too big (%lu)"
-msgstr "Anzahl der reservierten Blcke zu gro (%lu)"
+msgstr "Anzahl der reservierten Blcke ist zu gross (%lu)"
 
 #: misc/tune2fs.c:990
 #, c-format
 msgid "Setting reserved blocks count to %lu\n"
-msgstr "Setze Anzahl der reservierten Blcke auf %lu\n"
+msgstr "Setze die Anzahl der reservierten Blcke auf %lu\n"
 
 #: misc/tune2fs.c:996
 msgid ""
@@ -4308,7 +4309,7 @@ msgid ""
 "The filesystem already has sparse superblocks.\n"
 msgstr ""
 "\n"
-"Das Dateisystem hat bereits einen \"sparse superblock\".\n"
+"Das Dateisystem hat bereits verteilte Superblcke.\n"
 
 #: misc/tune2fs.c:1003
 #, c-format
@@ -4317,37 +4318,40 @@ msgid ""
 "Sparse superblock flag set.  %s"
 msgstr ""
 "\n"
-"Sparse superblock Flag gesetzt.  %s"
+"Kennzeichen fr verteilten Superblock gesetzt. %s"
 
 #: misc/tune2fs.c:1008
 msgid ""
 "\n"
 "Clearing the sparse superflag not supported.\n"
 msgstr ""
+"\n"
+"Das Zurcksetzen des Kennzeichens fr verteilter Superblock wird nicht\n"
+"\tuntersttzt.\n"
 
 #: misc/tune2fs.c:1015
 #, c-format
 msgid "Setting time filesystem last checked to %s\n"
-msgstr "Setze Zeit des letzten Dateisystemchecks auf %s\n"
+msgstr "Setze die Zeit des letzten Dateisystemchecks auf %s\n"
 
 #: misc/tune2fs.c:1021
 #, c-format
 msgid "Setting reserved blocks uid to %lu\n"
-msgstr "Setze UID fr reservierte Blcke auf %lu\n"
+msgstr "Setze die UID fr reservierte Blcke auf %lu\n"
 
 #: misc/tune2fs.c:1056
 msgid "Invalid UUID format\n"
 msgstr "Ungltiges UUID Format\n"
 
 #: misc/tune2fs.c:1067
-#, fuzzy, c-format
+#, c-format
 msgid "Setting stride size to %d\n"
-msgstr "Setze GID fr reservierte Blcke auf %lu\n"
+msgstr "Setze Stride-Gre auf %d\n"
 
 #: misc/tune2fs.c:1072
-#, fuzzy, c-format
+#, c-format
 msgid "Setting stripe width to %d\n"
-msgstr "Setze GID fr reservierte Blcke auf %lu\n"
+msgstr "Setze die Stripe-Breite auf %d\n"
 
 #: misc/util.c:72
 msgid "Proceed anyway? (y,n) "
@@ -4356,7 +4360,7 @@ msgstr "Trotzdem fortsetzen? (y,n) "
 #: misc/util.c:93
 #, c-format
 msgid "Could not stat %s --- %s\n"
-msgstr "Could not stat %s --- %s\n"
+msgstr "Status fr %s konnte nicht ermittelt werden --- %s\n"
 
 #: misc/util.c:96
 msgid ""
@@ -4364,7 +4368,7 @@ msgid ""
 "The device apparently does not exist; did you specify it correctly?\n"
 msgstr ""
 "\n"
-"Das Gert scheint nicht zu existieren, haben Sie es richtig angegeben?\n"
+"Das Gert existiert offensichtlich nicht; haben Sie es richtig angegeben?\n"
 
 #: misc/util.c:107
 #, c-format
@@ -4374,11 +4378,11 @@ msgstr "%s ist kein spezielles Block-Ger
 #: misc/util.c:136
 #, c-format
 msgid "%s is entire device, not just one partition!\n"
-msgstr "%s ist ein vollstndiges Gert, nicht nur eine Partition!\n"
+msgstr "%s ist das ganze Gert, nicht nur eine Partition!\n"
 
 #: misc/util.c:158
 msgid "mke2fs forced anyway.  Hope /etc/mtab is incorrect.\n"
-msgstr "mke2fs trotzdem erzwungen. Hoffentlich stimmt /etc/mtab nicht.\n"
+msgstr "mke2fs trotzdem erzwungen. Hoffentlich ist /etc/mtab ungltig.\n"
 
 #: misc/util.c:163
 #, c-format
@@ -4391,7 +4395,7 @@ msgstr "mke2fs wird sowieso erzwungen.\n
 
 #: misc/util.c:186
 msgid "Couldn't allocate memory to parse journal options!\n"
-msgstr "Konnte keinen Speicher zuweisen, um Journal-Optionen zu parsen!\n"
+msgstr "Konnte keinen Speicher zur Analyse der Journal-Optionen anfordern!\n"
 
 #: misc/util.c:228
 msgid ""
@@ -4411,15 +4415,15 @@ msgstr ""
 "\n"
 "Ungltioge Journal-Optionen angegeben.\n"
 "\n"
-"Journal-Optionen werden mit Kommata getrennt angegeben, sie knnen ein "
-"Argument\n"
-"\terhalten welches mit Gleichheitszeichen ('=') zugewiesen wird.\n"
+"Journal-Optionen werden durch Kommatas getrennt. Manche erwarten ein\n"
+"\tArgument, welches mit Gleichheitszeichen (=) zugewiesen wird.\n"
 "\n"
 "Gltige Journal-Optionen sind:\n"
 "\tsize=<Journalgre in Megabytes>\n"
 "\tdevice=<Journal-Gert>\n"
 "\n"
-"Die Journalgre muss zwischen 1024 und 102400 Dateisystem-Blcken liegen.\n"
+"Die Grsse des Journals muss zwischen 1024 und 102400 Dateisystem-Blcken\n"
+"\tliegen.\n"
 "\n"
 
 #: misc/util.c:258
@@ -4428,18 +4432,18 @@ msgid ""
 "Filesystem too small for a journal\n"
 msgstr ""
 "\n"
-"Dateisystem zu klein fr ein Journal\n"
+"Das Dateisystem ist zu klein fr ein Journal\n"
 
 #: misc/util.c:265
-#, fuzzy, c-format
+#, c-format
 msgid ""
 "\n"
 "The requested journal size is %d blocks; it must be\n"
 "between 1024 and 10240000 blocks.  Aborting.\n"
 msgstr ""
 "\n"
-"Die angegebene Journalgre ist %d Blcke. Sie muss aber zwischen\n"
-"1024 und 102400 Dateisystem-Blcken liegen. Breche ab! \n"
+"Die angegebene Journalgre betrgt %d Blcke. Sie muss aber zwischen\n"
+"1024 und 102400 Dateisystem-Blcken liegen. Abbruch! \n"
 
 #: misc/util.c:273
 msgid ""
@@ -4455,14 +4459,14 @@ msgid ""
 "This filesystem will be automatically checked every %d mounts or\n"
 "%g days, whichever comes first.  Use tune2fs -c or -i to override.\n"
 msgstr ""
-"Das Dateisystem wird automatisch alle %d Mounts bzw. alle %g Tage "
-"berprft,\n"
-"je nachdem, was zuerst eintritt. Vernderbar mit tune2fs -c oder -t .\n"
+"Das Dateisystem wird automatisch nach jeweils %d Einhng-Vorgngen bzw.\n"
+"alle %g Tage berprft, je nachdem, was zuerst eintritt. Vernderbar mit\n"
+"tune2fs -c oder -t .\n"
 
 #: misc/uuidgen.c:31
 #, c-format
 msgid "Usage: %s [-r] [-t]\n"
-msgstr "Verwendung: %s [-r] [-t]\n"
+msgstr "Aufruf: %s [-r] [-t]\n"
 
 #: resize/extent.c:196
 msgid "# Extent dump:\n"
@@ -4484,28 +4488,28 @@ msgid ""
 "Usage: %s [-d debug_flags] [-f] [-F] [-p] device [new_size]\n"
 "\n"
 msgstr ""
-"Verwendung: %s [-d debug_flags] [-f] [-F] [-p] Gert [neue_Gre]\n"
+"Aufruf: %s [-d Debug_Kennzeichen] [-f] [-F] [-p] Gert [neue_Gre]\n"
 "\n"
 
 #: resize/main.c:61
 msgid "Extending the inode table"
-msgstr "Vergrere Inode-Tabelle"
+msgstr "Vergrere die Inode-Tabelle"
 
 #: resize/main.c:64
 msgid "Relocating blocks"
-msgstr "Verteile Blcke neu"
+msgstr "Verteile die Blcke neu"
 
 #: resize/main.c:67
 msgid "Scanning inode table"
-msgstr "Scanne Inode-Tabelle"
+msgstr "Prfe die Inode-Tabelle"
 
 #: resize/main.c:70
 msgid "Updating inode references"
-msgstr "Aktualisiere Inode-Referenzen"
+msgstr "Aktualisiere die Inode-Referenzen"
 
 #: resize/main.c:73
 msgid "Moving inode table"
-msgstr "Verschiebe Inode-Tabelle"
+msgstr "Verschiebe die Inode-Tabelle"
 
 #: resize/main.c:76
 msgid "Unknown pass?!?"
@@ -4514,7 +4518,7 @@ msgstr "Unbekannter Durchgang?!?"
 #: resize/main.c:79
 #, c-format
 msgid "Begin pass %d (max = %lu)\n"
-msgstr "Beginne Durchgang %d (max = %lu)\n"
+msgstr "Start von Durchgang %d (max = %lu)\n"
 
 #: resize/main.c:253
 #, c-format
@@ -4525,7 +4529,7 @@ msgstr "beim ffnen von %s"
 #: resize/main.c:265
 #, c-format
 msgid "while getting stat information for %s"
-msgstr "beim Setzen der Version in %s"
+msgstr "beim Ermitteln der Statusinformation fr %s"
 
 #: resize/main.c:339
 #, c-format
@@ -4533,9 +4537,8 @@ msgid "bad filesystem size - %s"
 msgstr "ungltige Dateisystemgre - %s"
 
 #: resize/main.c:353
-#, fuzzy
 msgid "Invalid stride length"
-msgstr "Ungltiger \"stride\"-Parameter: %s\n"
+msgstr "Ungltige Stride-Lnge"
 
 #: resize/main.c:377
 #, c-format
@@ -4544,8 +4547,8 @@ msgid ""
 "You requested a new size of %u blocks.\n"
 "\n"
 msgstr ""
-"Die Partition (oder das Gert) enthlt nur %u (%dk) Blcke.\n"
-"Die geforderte neue Gre ist %u Blcke.\n"
+"Die Partition (oder das Gert) ist nur %u (%dk) Blcke gro.\n"
+"Die gewnschte Gre war %u Blcke.\n"
 "\n"
 
 #: resize/main.c:384
@@ -4563,7 +4566,7 @@ msgid ""
 "Please run 'e2fsck -f %s' first.\n"
 "\n"
 msgstr ""
-"Bitte zuerst 'e2fsck -f %s ' laufen lassen.\n"
+"Bitte zuerst e2fsck -f %s laufen lassen.\n"
 "\n"
 
 #: resize/main.c:406
@@ -4583,7 +4586,7 @@ msgstr ""
 #: resize/resize2fs.c:233
 #, c-format
 msgid "inodes (%llu) must be less than %u"
-msgstr ""
+msgstr "Die Anzahl der Indoes (%llu) muss unter %u liegen"
 
 #: resize/resize2fs.c:642
 msgid "reserved blocks"
@@ -4591,7 +4594,7 @@ msgstr "reservierte Blcke"
 
 #: resize/resize2fs.c:647
 msgid "blocks to be moved"
-msgstr "zu verschiebene Blcke"
+msgstr "zu verschiebende Blcke"
 
 #: resize/resize2fs.c:652
 msgid "meta-data blocks"
@@ -4600,4 +4603,4 @@ msgstr "Metadaten-Blcke"
 #: resize/resize2fs.c:1550
 #, c-format
 msgid "Should never happen: resize inode corrupt!\n"
-msgstr "Sollte niemals passieren: Die zu verndernde Inode ist defekt!\n"
+msgstr "Das sollte niemals passieren: Die zu verndernde Inode ist defekt!\n"
diff -Nurp e2fsprogs-1.40.8/README.subset e2fsprogs/README.subset
--- e2fsprogs-1.40.8/README.subset	1970-01-01 01:00:00.000000000 +0100
+++ e2fsprogs/README.subset	2008-03-29 01:20:43.000000000 +0100
@@ -0,0 +1,15 @@
+This distribution contains a subset of the e2fsprogs package; it
+contains the base libraries (ss, et, uuid, blkid) which may be used by
+other non-ext2-related applications.
+
+This may be useful for non-Linux operating systems that need these
+libraries for GNOME, but who do not need the ext2/ext3 filesystem
+utilities.
+
+The full e2fsprogs distributions can be found at the e2fsprogs web
+page, which is:
+
+	http://e2fsprogs.sourceforge.net
+
+In case of bugs in these libraries, please contact Ted Ts'o at
+tytso@mit.edu or tytso@alum.mit.edu.
diff -Nurp e2fsprogs-1.40.8/RELEASE-NOTES e2fsprogs/RELEASE-NOTES
--- e2fsprogs-1.40.8/RELEASE-NOTES	2008-03-14 01:01:03.000000000 +0100
+++ e2fsprogs/RELEASE-NOTES	2008-03-29 01:20:43.000000000 +0100
@@ -1,3 +1,20 @@
+E2fsprogs 1.40.9-WIP (March 14, 2008)
+=====================================
+
+SuSE's security team audited uuidd and came up with a few minor
+issues.  None of them are serious given that uuidd runs setuid as a
+unprivileged user which has no special access other than libuuid
+directory, but it's good to get them fixed.
+
+One additional fix in ext2fs_swap_inode_full() needed for resize2fs to
+work correctly with in-inode extended attributes.
+
+Programmer's notes:
+-------------------
+
+Fixed various Debian packaging issues --- see debian/changelog for
+details.
+
 E2fsprogs 1.40.8 (March 13, 2008)
 =================================
 
diff -Nurp e2fsprogs-1.40.8/resize/main.c e2fsprogs/resize/main.c
--- e2fsprogs-1.40.8/resize/main.c	2008-03-13 23:20:46.000000000 +0100
+++ e2fsprogs/resize/main.c	2008-03-29 01:20:43.000000000 +0100
@@ -36,8 +36,8 @@ char *program_name, *device_name, *io_op
 
 static void usage (char *prog)
 {
-	fprintf (stderr, _("Usage: %s [-d debug_flags] [-f] [-F] [-p] "
-			   "device [new_size]\n\n"), prog);
+	fprintf (stderr, _("Usage: %s [-d debug_flags] [-f] [-F] [-M] [-P] "
+			   "[-p] device [new_size]\n\n"), prog);
 
 	exit (1);
 }
@@ -152,6 +152,8 @@ int main (int argc, char ** argv)
 	int		flush = 0;
 	int		force = 0;
 	int		io_flags = 0;
+	int		force_min_size = 0;
+	int		print_min_size = 0;
 	int		fd, ret;
 	blk_t		new_size = 0;
 	blk_t		max_size = 0;
@@ -183,7 +185,7 @@ int main (int argc, char ** argv)
 	if (argc && *argv)
 		program_name = *argv;
 
-	while ((c = getopt (argc, argv, "d:fFhpS:")) != EOF) {
+	while ((c = getopt (argc, argv, "d:fFhMPpS:")) != EOF) {
 		switch (c) {
 		case 'h':
 			usage(program_name);
@@ -194,6 +196,12 @@ int main (int argc, char ** argv)
 		case 'F':
 			flush = 1;
 			break;
+		case 'M':
+			force_min_size = 1;
+			break;
+		case 'P':
+			print_min_size = 1;
+			break;
 		case 'd':
 			flags |= atoi(optarg);
 			break;
@@ -298,6 +306,13 @@ int main (int argc, char ** argv)
 		printf (_("Couldn't find valid filesystem superblock.\n"));
 		exit (1);
 	}
+
+	if (fs->super->s_feature_ro_compat & EXT4_FEATURE_RO_COMPAT_GDT_CSUM) {
+		com_err(program_name, EXT2_ET_RO_UNSUPP_FEATURE,
+			":- uninit_groups");
+		exit(1);
+	}
+
 	/*
 	 * Check for compatibility with the feature sets.  We need to
 	 * be more stringent than ext2fs_open().
@@ -308,6 +323,12 @@ int main (int argc, char ** argv)
 		exit(1);
 	}
 	
+	if (print_min_size) {
+		printf("Estimated minimum size of the filesystem: %lu\n",
+		       calculate_minimum_resize_size(fs));
+		exit(0);
+	}
+
 	/* Determine the system page size if possible */
 #ifdef HAVE_SYSCONF
 #if (!defined(_SC_PAGESIZE) && defined(_SC_PAGE_SIZE))
@@ -332,14 +353,11 @@ int main (int argc, char ** argv)
 			_("while trying to determine filesystem size"));
 		exit(1);
 	}
-	if (new_size_str) {
+	if (force_min_size)
+		new_size = calculate_minimum_resize_size(fs);
+	else if (new_size_str) {
 		new_size = parse_num_blocks(new_size_str, 
 					    fs->super->s_log_block_size);
-		if (!new_size) {
-			com_err(program_name, 0, _("bad filesystem size - %s"),
-				new_size_str);
-			exit(1);
-		}
 	} else {
 		new_size = max_size;
 		/* Round down to an even multiple of a pagesize */
diff -Nurp e2fsprogs-1.40.8/resize/Makefile.pq e2fsprogs/resize/Makefile.pq
--- e2fsprogs-1.40.8/resize/Makefile.pq	1970-01-01 01:00:00.000000000 +0100
+++ e2fsprogs/resize/Makefile.pq	2008-03-29 01:20:43.000000000 +0100
@@ -0,0 +1,11 @@
+TOPSRC=..
+LIBNAME=RESIZE.LIB
+OBJFILE=RESIZE.LST
+
+OBJS= extent.obj \
+	ext2_block_move.obj \
+	ext2_inode_move.obj \
+	resize2fs.obj
+
+!include $(TOPSRC)\powerquest\MCONFIG
+
diff -Nurp e2fsprogs-1.40.8/resize/resize2fs.8.in e2fsprogs/resize/resize2fs.8.in
--- e2fsprogs-1.40.8/resize/resize2fs.8.in	2008-02-19 05:33:10.000000000 +0100
+++ e2fsprogs/resize/resize2fs.8.in	2008-03-29 01:20:43.000000000 +0100
@@ -8,6 +8,9 @@ resize2fs \- ext2/ext3 file system resiz
 .SH SYNOPSIS
 .B resize2fs
 [
+.B \-fFpPM
+]
+[
 .B \-d 
 .I debug-flags
 ]
@@ -15,15 +18,6 @@ resize2fs \- ext2/ext3 file system resiz
 .B \-S
 .I RAID-stride
 ]
-[
-.B \-f
-]
-[
-.B \-F
-]
-[
-.B \-p
-]
 .I device
 [
 .I size
@@ -99,19 +93,6 @@ from the following list:
 \	8\	\-\ Debug inode relocations
 .br
 \	16\	\-\ Debug moving the inode table
-.TP
-.B \-S \fIRAID-stride
-The 
-.B resize2fs
-program will heuristically determine the RAID stride that was specified 
-when the filesystem was created.  This option allows the user to 
-explicitly specify a RAID stride setting to be used by resize2fs instead.
-.TP
-.B \-p
-Prints out a percentage completion bars for each 
-.B resize2fs
-operation, so that the user can keep track of what
-the program is doing.
 .TP 
 .B \-f
 Forces resize2fs to proceed with the filesystem resize operation, overriding 
@@ -122,6 +103,28 @@ Flush the filesystem device's buffer cac
 really useful for doing 
 .B resize2fs
 time trials.
+.TP
+.B \-M
+Shrink the filesystem to the minimum size.
+.TP
+.B \-p
+Prints out a percentage completion bars for each
+.B resize2fs
+operation, so that the user can keep track of what
+the program is doing.
+.TP
+.B \-P
+Print the minimum size of the filesystem and exit.
+.TP
+.B \-S \fIRAID-stride
+The
+.B resize2fs
+program will heuristically determine the RAID stride that was specified
+when the filesystem was created.  This option allows the user to
+explicitly specify a RAID stride setting to be used by resize2fs instead.
+.SH KNOWN BUGS
+The minimum size of the filesystem as estimated by resize2fs may be
+incorrect, especially for filesystems with 1k and 2k blocksizes.
 .SH AUTHOR
 .B resize2fs
 was written by Theodore Ts'o <tytso@mit.edu>.
diff -Nurp e2fsprogs-1.40.8/resize/resize2fs.c e2fsprogs/resize/resize2fs.c
--- e2fsprogs-1.40.8/resize/resize2fs.c	2008-03-13 23:20:46.000000000 +0100
+++ e2fsprogs/resize/resize2fs.c	2008-03-29 01:20:43.000000000 +0100
@@ -63,7 +63,9 @@ static errcode_t ext2fs_calculate_summar
 				 ((blk) < (FS_INODE_TB((fs), (i)) + \
 					   (fs)->inode_blocks_per_group)))
 
-
+#define META_OVERHEAD(fs) (2 + (fs)->inode_blocks_per_group)
+#define SUPER_OVERHEAD(fs) (1 + (fs)->desc_blocks +\
+			    (fs)->super->s_reserved_gdt_blocks)
 
 /*
  * This is the top-level routine which does the dirty deed....
@@ -339,7 +341,8 @@ retry:
 		numblocks = fs->super->s_blocks_per_group;
 	i = old_fs->group_desc_count - 1;
 	fs->group_desc[i].bg_free_blocks_count += (numblocks-old_numblocks);
-		
+	ext2fs_group_desc_csum_set(fs, i);
+
 	/*
 	 * If the number of block groups is staying the same, we're
 	 * done and can exit now.  (If the number block groups is
@@ -383,8 +386,7 @@ retry:
 			ext2fs_mark_block_bitmap(fs->block_map, group_block);
 			adjblocks++;
 		}
-		meta_bg_size = (fs->blocksize /
-				sizeof (struct ext2_group_desc));
+		meta_bg_size = EXT2_DESC_PER_BLOCK(fs->super);
 		meta_bg = i / meta_bg_size;
 		if (!(fs->super->s_feature_incompat &
 		      EXT2_FEATURE_INCOMPAT_META_BG) ||
@@ -415,6 +417,7 @@ retry:
 		fs->group_desc[i].bg_free_inodes_count =
 			fs->super->s_inodes_per_group;
 		fs->group_desc[i].bg_used_dirs_count = 0;
+		ext2fs_group_desc_csum_set(fs, i);
 
 		retval = ext2fs_allocate_group_table(fs, i, 0);
 		if (retval) goto errout;
@@ -550,7 +553,7 @@ static errcode_t mark_table_blocks(ext2_
 	unsigned long		meta_bg_size;
 	unsigned int		old_desc_blocks;
 
-	meta_bg_size = (fs->blocksize / sizeof (struct ext2_group_desc));
+	meta_bg_size = EXT2_DESC_PER_BLOCK(fs->super);
 	if (fs->super->s_feature_incompat & EXT2_FEATURE_INCOMPAT_META_BG)
 		old_desc_blocks = fs->super->s_first_meta_bg;
 	else
@@ -717,7 +720,7 @@ static errcode_t blocks_to_move(ext2_res
 	 * If we're increasing the number of descriptor blocks, life
 	 * gets interesting....  
 	 */
-	meta_bg_size = (fs->blocksize / sizeof (struct ext2_group_desc));
+	meta_bg_size = EXT2_DESC_PER_BLOCK(fs->super);
 	for (i = 0; i < max_groups; i++) {
 		has_super = ext2fs_bg_has_super(fs, i);
 		if (has_super)
@@ -1232,9 +1235,11 @@ static errcode_t inode_scan_and_fix(ext2
 		if (retval) goto errout;
 
 		group = (new_inode-1) / EXT2_INODES_PER_GROUP(rfs->new_fs->super);
-		if (LINUX_S_ISDIR(inode->i_mode))
+		if (LINUX_S_ISDIR(inode->i_mode)) {
 			rfs->new_fs->group_desc[group].bg_used_dirs_count++;
-		
+			ext2fs_group_desc_csum_set(rfs->new_fs, group);
+		}
+
 #ifdef RESIZE2FS_DEBUG
 		if (rfs->flags & RESIZE_DEBUG_INODEMAP)
 			printf("Inode moved %u->%u\n", ino, new_inode);
@@ -1489,6 +1494,7 @@ static errcode_t move_itables(ext2_resiz
 			ext2fs_unmark_block_bitmap(fs->block_map, blk);
 
 		rfs->old_fs->group_desc[i].bg_inode_table = new_blk;
+		ext2fs_group_desc_csum_set(rfs->old_fs, i);
 		ext2fs_mark_super_dirty(rfs->old_fs);
 		ext2fs_flush(rfs->old_fs);
 
@@ -1586,8 +1592,10 @@ static errcode_t ext2fs_calculate_summar
 		count++;
 		if ((count == fs->super->s_blocks_per_group) ||
 		    (blk == fs->super->s_blocks_count-1)) {
-			fs->group_desc[group++].bg_free_blocks_count =
+			fs->group_desc[group].bg_free_blocks_count =
 				group_free;
+			ext2fs_group_desc_csum_set(fs, group);
+			group++;
 			count = 0;
 			group_free = 0;
 		}
@@ -1611,8 +1619,10 @@ static errcode_t ext2fs_calculate_summar
 		count++;
 		if ((count == fs->super->s_inodes_per_group) ||
 		    (ino == fs->super->s_inodes_count)) {
-			fs->group_desc[group++].bg_free_inodes_count =
+			fs->group_desc[group].bg_free_inodes_count =
 				group_free;
+			ext2fs_group_desc_csum_set(fs, group);
+			group++;
 			count = 0;
 			group_free = 0;
 		}
@@ -1621,3 +1631,139 @@ static errcode_t ext2fs_calculate_summar
 	ext2fs_mark_super_dirty(fs);
 	return 0;
 }
+
+/*
+ * calcluate the minimum number of blocks the given fs can be resized to
+ */
+blk_t calculate_minimum_resize_size(ext2_filsys fs)
+{
+	blk_t inode_count, blks_needed, groups, blk, data_blocks;
+	blk_t grp, data_needed, last_start;
+	int overhead = 0, old_group = -1, num_of_superblocks = 0;
+
+	/*
+	 * first figure out how many group descriptors we need to
+	 * handle the number of inodes we have
+	 */
+	inode_count = fs->super->s_inodes_count -
+		fs->super->s_free_inodes_count;
+	blks_needed = ext2fs_div_ceil(inode_count,
+				      fs->super->s_inodes_per_group) *
+		EXT2_BLOCKS_PER_GROUP(fs->super);
+	groups = ext2fs_div_ceil(blks_needed,
+				 EXT2_BLOCKS_PER_GROUP(fs->super));
+
+	/*
+	 * we need to figure out how many backup superblocks we have so we can
+	 * account for that in the metadata
+	 */
+	for (grp = 0; grp < fs->group_desc_count; grp++) {
+		if (ext2fs_bg_has_super(fs, grp))
+			num_of_superblocks++;
+	}
+
+	/* calculate how many blocks are needed for data */
+	data_needed = fs->super->s_blocks_count -
+		fs->super->s_free_blocks_count;
+	data_needed -= SUPER_OVERHEAD(fs) * num_of_superblocks;
+	data_needed -= META_OVERHEAD(fs) * fs->group_desc_count;
+
+	/*
+	 * figure out how many data blocks we have given the number of groups
+	 * we need for our inodes
+	 */
+	data_blocks = groups * EXT2_BLOCKS_PER_GROUP(fs->super);
+	last_start = 0;
+	for (grp = 0; grp < groups; grp++) {
+		overhead = META_OVERHEAD(fs);
+
+		if (ext2fs_bg_has_super(fs, grp))
+			overhead += SUPER_OVERHEAD(fs);
+
+		/*
+		 * we want to keep track of how much data we can store in
+		 * the groups leading up to the last group so we can determine
+		 * how big the last group needs to be
+		 */
+		if (grp != (groups - 1))
+			last_start += EXT2_BLOCKS_PER_GROUP(fs->super) -
+				overhead;
+
+		data_blocks -= overhead;
+	}
+
+	/*
+	 * if we need more group descriptors in order to accomodate our data
+	 * then we need to add them here
+	 */
+	while (data_needed > data_blocks) {
+		blk_t remainder = data_needed - data_blocks;
+		blk_t extra_grps;
+
+		/* figure out how many more groups we need for the data */
+		extra_grps = ext2fs_div_ceil(remainder,
+					     EXT2_BLOCKS_PER_GROUP(fs->super));
+
+		data_blocks += extra_grps * EXT2_BLOCKS_PER_GROUP(fs->super);
+
+		/* ok we have to account for the last group */
+		overhead = META_OVERHEAD(fs);
+		if (ext2fs_bg_has_super(fs, groups-1))
+			overhead += SUPER_OVERHEAD(fs);
+		last_start += EXT2_BLOCKS_PER_GROUP(fs->super) - overhead;
+
+		for (grp = groups; grp < groups+extra_grps; grp++) {
+			overhead = META_OVERHEAD(fs);
+			if (ext2fs_bg_has_super(fs, grp))
+				overhead += SUPER_OVERHEAD(fs);
+
+			/*
+			 * again, we need to see how much data we cram into
+			 * all of the groups leading up to the last group
+			 */
+			if (grp != (groups + extra_grps - 1))
+				last_start += EXT2_BLOCKS_PER_GROUP(fs->super)
+					- overhead;
+
+			data_blocks -= overhead;
+		}
+
+		groups += extra_grps;
+	}
+
+	/* now for the fun voodoo */
+	overhead = META_OVERHEAD(fs);
+
+	/*
+	 * if this is the case then the last group is going to have data in it
+	 * so we need to adjust the size of the last group accordingly
+	 */
+	if (last_start < data_needed) {
+		blk_t remainder = data_needed - last_start;
+
+		/*
+		 * 50 is a magic number that mkfs/resize uses to see if its
+		 * even worth making/resizing the fs.  basically you need to
+		 * have at least 50 blocks in addition to the blocks needed
+		 * for the metadata in the last group
+		 */
+		if (remainder > 50)
+			overhead += remainder;
+		else
+			overhead += 50;
+	} else
+		overhead += 50;
+
+	if (ext2fs_bg_has_super(fs, groups-1))
+		overhead += SUPER_OVERHEAD(fs);
+
+	/*
+	 * since our last group doesn't have to be BLOCKS_PER_GROUP large, we
+	 * only do groups-1, and then add the number of blocks needed to
+	 * handle the group descriptor metadata+data that we need
+	 */
+	blks_needed = (groups-1) * EXT2_BLOCKS_PER_GROUP(fs->super);
+	blks_needed += overhead;
+
+	return blks_needed;
+}
diff -Nurp e2fsprogs-1.40.8/resize/resize2fs.h e2fsprogs/resize/resize2fs.h
--- e2fsprogs-1.40.8/resize/resize2fs.h	2007-06-30 14:58:35.000000000 +0200
+++ e2fsprogs/resize/resize2fs.h	2008-03-29 01:20:43.000000000 +0100
@@ -129,6 +129,7 @@ extern errcode_t resize_fs(ext2_filsys f
 
 extern errcode_t adjust_fs_info(ext2_filsys fs, ext2_filsys old_fs, 
 				blk_t new_size);
+extern blk_t calculate_minimum_resize_size(ext2_filsys fs);
 
 
 /* extent.c */
diff -Nurp e2fsprogs-1.40.8/tests/f_bad_disconnected_inode/expect.1 e2fsprogs/tests/f_bad_disconnected_inode/expect.1
--- e2fsprogs-1.40.8/tests/f_bad_disconnected_inode/expect.1	2008-03-13 23:20:46.000000000 +0100
+++ e2fsprogs/tests/f_bad_disconnected_inode/expect.1	2008-03-29 01:20:43.000000000 +0100
@@ -1,4 +1,13 @@
 Pass 1: Checking inodes, blocks, and sizes
+Inode 1 has EXTENTS_FL flag set on filesystem without extents support.
+Clear? yes
+
+Inode 15 has EXTENTS_FL flag set on filesystem without extents support.
+Clear? yes
+
+Inode 16 has EXTENTS_FL flag set on filesystem without extents support.
+Clear? yes
+
 Pass 2: Checking directory structure
 Pass 3: Checking directory connectivity
 /lost+found not found.  Create? yes
@@ -18,26 +27,6 @@ Clear? yes
 Inode 14 (...) has invalid mode (0154247).
 Clear? yes
 
-i_file_acl for inode 15 (...) is 1143674715, should be zero.
-Clear? yes
-
-Inode 15 (...) has invalid mode (074044).
-Clear? yes
-
-i_file_acl for inode 16 (...) is 2007517039, should be zero.
-Clear? yes
-
-i_faddr for inode 16 (...) is 1003914917, should be zero.
-Clear? yes
-
-i_blocks_hi for inode 16 (...) is 62762, should be zero.
-Clear? yes
-
-Unattached inode 16
-Connect to /lost+found? yes
-
-Inode 16 ref count is 5925, should be 1.  Fix? yes
-
 Pass 5: Checking group summary information
 Block bitmap differences:  -(9--19)
 Fix? yes
@@ -48,19 +37,16 @@ Fix? yes
 Free blocks count wrong (79, counted=91).
 Fix? yes
 
-Inode bitmap differences:  +16
-Fix? yes
-
-Free inodes count wrong for group #0 (7, counted=4).
+Free inodes count wrong for group #0 (6, counted=5).
 Fix? yes
 
 Directories count wrong for group #0 (3, counted=2).
 Fix? yes
 
-Free inodes count wrong (7, counted=4).
+Free inodes count wrong (6, counted=5).
 Fix? yes
 
 
 test_filesys: ***** FILE SYSTEM WAS MODIFIED *****
-test_filesys: 12/16 files (0.0% non-contiguous), 9/100 blocks
+test_filesys: 11/16 files (0.0% non-contiguous), 9/100 blocks
 Exit status is 1
diff -Nurp e2fsprogs-1.40.8/tests/f_bad_disconnected_inode/expect.2 e2fsprogs/tests/f_bad_disconnected_inode/expect.2
--- e2fsprogs-1.40.8/tests/f_bad_disconnected_inode/expect.2	2008-03-13 23:20:46.000000000 +0100
+++ e2fsprogs/tests/f_bad_disconnected_inode/expect.2	2008-03-29 01:20:43.000000000 +0100
@@ -3,5 +3,5 @@ Pass 2: Checking directory structure
 Pass 3: Checking directory connectivity
 Pass 4: Checking reference counts
 Pass 5: Checking group summary information
-test_filesys: 12/16 files (0.0% non-contiguous), 9/100 blocks
+test_filesys: 11/16 files (0.0% non-contiguous), 9/100 blocks
 Exit status is 0
diff -Nurp e2fsprogs-1.40.8/tests/f_dupfsblks/expect.1 e2fsprogs/tests/f_dupfsblks/expect.1
--- e2fsprogs-1.40.8/tests/f_dupfsblks/expect.1	2008-03-13 19:57:37.000000000 +0100
+++ e2fsprogs/tests/f_dupfsblks/expect.1	2008-03-29 01:20:43.000000000 +0100
@@ -44,7 +44,8 @@ Salvage? yes
 Directory inode 12, block 3, offset 0: directory corrupted
 Salvage? yes
 
-Entry '' in ??? (12) has deleted/unused inode 32.  Clear? yes
+Entry '' in ??? (12) has a zero-length name.
+Clear? yes
 
 Directory inode 12, block 4, offset 100: directory corrupted
 Salvage? yes
diff -Nurp e2fsprogs-1.40.8/tests/f_ea_checks/expect.1 e2fsprogs/tests/f_ea_checks/expect.1
--- e2fsprogs-1.40.8/tests/f_ea_checks/expect.1	1970-01-01 01:00:00.000000000 +0100
+++ e2fsprogs/tests/f_ea_checks/expect.1	2008-03-29 01:20:43.000000000 +0100
@@ -0,0 +1,57 @@
+Pass 1: Checking inodes, blocks, and sizes
+Inode 13 has a bad extended attribute block 26.  Clear? yes
+
+Inode 13, i_blocks is 4, should be 2.  Fix? yes
+
+Extended attribute in inode 14 has a hash (1649340189) which is invalid
+Clear? yes
+
+Inode 14, i_blocks is 2, should be 0.  Fix? yes
+
+Inode 17 has a bad extended attribute block 28.  Clear? yes
+
+Inode 17, i_blocks is 4, should be 2.  Fix? yes
+
+Inode 16 has a bad extended attribute block 29.  Clear? yes
+
+Inode 16, i_blocks is 2, should be 0.  Fix? yes
+
+Inode 19 has a bad extended attribute block 33.  Clear? yes
+
+Inode 19, i_blocks is 2, should be 0.  Fix? yes
+
+Inode 12 has a bad extended attribute block 55.  Clear? yes
+
+Inode 12, i_blocks is 2, should be 0.  Fix? yes
+
+Inode 15, i_blocks is 2, should be 0.  Fix? yes
+
+Pass 2: Checking directory structure
+Extended attribute block for inode 15 (/far) is invalid (999).
+Clear? yes
+
+Pass 3: Checking directory connectivity
+Pass 4: Checking reference counts
+Pass 5: Checking group summary information
+Block bitmap differences:  -(26--29) -33 -55
+Fix? yes
+
+Free blocks count wrong for group #0 (481, counted=484).
+Fix? yes
+
+Free blocks count wrong (481, counted=484).
+Fix? yes
+
+Inode bitmap differences:  -18
+Fix? yes
+
+Free inodes count wrong for group #0 (47, counted=46).
+Fix? yes
+
+Free inodes count wrong (47, counted=46).
+Fix? yes
+
+
+test_filesys: ***** FILE SYSTEM WAS MODIFIED *****
+test_filesys: 18/64 files (0.0% non-contiguous), 28/512 blocks
+Exit status is 1
diff -Nurp e2fsprogs-1.40.8/tests/f_ea_checks/expect.2 e2fsprogs/tests/f_ea_checks/expect.2
--- e2fsprogs-1.40.8/tests/f_ea_checks/expect.2	1970-01-01 01:00:00.000000000 +0100
+++ e2fsprogs/tests/f_ea_checks/expect.2	2008-03-29 01:20:43.000000000 +0100
@@ -0,0 +1,7 @@
+Pass 1: Checking inodes, blocks, and sizes
+Pass 2: Checking directory structure
+Pass 3: Checking directory connectivity
+Pass 4: Checking reference counts
+Pass 5: Checking group summary information
+test_filesys: 18/64 files (0.0% non-contiguous), 28/512 blocks
+Exit status is 0
Files e2fsprogs-1.40.8/tests/f_ea_checks/image.gz and e2fsprogs/tests/f_ea_checks/image.gz differ
diff -Nurp e2fsprogs-1.40.8/tests/f_ea_checks/name e2fsprogs/tests/f_ea_checks/name
--- e2fsprogs-1.40.8/tests/f_ea_checks/name	1970-01-01 01:00:00.000000000 +0100
+++ e2fsprogs/tests/f_ea_checks/name	2008-03-29 01:20:43.000000000 +0100
@@ -0,0 +1 @@
+extended attribute block checks
diff -Nurp e2fsprogs-1.40.8/tests/f_extents/expect.1 e2fsprogs/tests/f_extents/expect.1
--- e2fsprogs-1.40.8/tests/f_extents/expect.1	1970-01-01 01:00:00.000000000 +0100
+++ e2fsprogs/tests/f_extents/expect.1	2008-03-29 01:20:43.000000000 +0100
@@ -0,0 +1,52 @@
+Pass 1: Checking inodes, blocks, and sizes
+Inode 12 is in extent format, but superblock is missing EXTENTS feature
+Fix? yes
+
+Inode 12 has an invalid extent
+	(logical block 0, invalid physical block 21994527527949, len 17)
+Clear? yes
+
+Inode 12, i_blocks is 34, should be 0.  Fix? yes
+
+Inode 13 missing EXTENT_FL, but is in extents format
+Fix? yes
+
+Inode 17 has an invalid extent
+	(logical block 0, invalid physical block 22011707397135, len 15)
+Clear? yes
+
+Inode 17, i_blocks is 32, should be 0.  Fix? yes
+
+Error while reading over extent tree in inode 18: Corrupt extent header
+Clear inode? yes
+
+Inode 18, i_blocks is 2, should be 0.  Fix? yes
+
+Pass 2: Checking directory structure
+Entry 'fbad-flag' in / (2) has deleted/unused inode 18.  Clear? yes
+
+Pass 3: Checking directory connectivity
+Pass 4: Checking reference counts
+Pass 5: Checking group summary information
+Block bitmap differences:  -1081 +4611 -(5121--5142)
+Fix? yes
+
+Free blocks count wrong for group #0 (7081, counted=7098).
+Fix? yes
+
+Free blocks count wrong (7081, counted=7098).
+Fix? yes
+
+Inode bitmap differences:  -18
+Fix? yes
+
+Free inodes count wrong for group #0 (237, counted=238).
+Fix? yes
+
+Free inodes count wrong (237, counted=238).
+Fix? yes
+
+
+test_filesys: ***** FILE SYSTEM WAS MODIFIED *****
+test_filesys: 18/256 files (0.0% non-contiguous), 1094/8192 blocks
+Exit status is 1
diff -Nurp e2fsprogs-1.40.8/tests/f_extents/expect.2 e2fsprogs/tests/f_extents/expect.2
--- e2fsprogs-1.40.8/tests/f_extents/expect.2	1970-01-01 01:00:00.000000000 +0100
+++ e2fsprogs/tests/f_extents/expect.2	2008-03-29 01:20:43.000000000 +0100
@@ -0,0 +1,7 @@
+Pass 1: Checking inodes, blocks, and sizes
+Pass 2: Checking directory structure
+Pass 3: Checking directory connectivity
+Pass 4: Checking reference counts
+Pass 5: Checking group summary information
+test_filesys: 18/256 files (0.0% non-contiguous), 1094/8192 blocks
+Exit status is 0
diff -Nurp e2fsprogs-1.40.8/tests/f_extents/name e2fsprogs/tests/f_extents/name
--- e2fsprogs-1.40.8/tests/f_extents/name	1970-01-01 01:00:00.000000000 +0100
+++ e2fsprogs/tests/f_extents/name	2008-03-29 01:20:43.000000000 +0100
@@ -0,0 +1 @@
+basic extents support
diff -Nurp e2fsprogs-1.40.8/tests/f_extents/script e2fsprogs/tests/f_extents/script
--- e2fsprogs-1.40.8/tests/f_extents/script	2008-03-13 23:20:46.000000000 +0100
+++ e2fsprogs/tests/f_extents/script	1970-01-01 01:00:00.000000000 +0100
@@ -1,2 +0,0 @@
-rm -f $test_name.ok $test_name.failed
-echo "skipped"
diff -Nurp e2fsprogs-1.40.8/tests/f_swapfs/debugfs.cmd e2fsprogs/tests/f_swapfs/debugfs.cmd
--- e2fsprogs-1.40.8/tests/f_swapfs/debugfs.cmd	2008-03-13 23:20:46.000000000 +0100
+++ e2fsprogs/tests/f_swapfs/debugfs.cmd	1970-01-01 01:00:00.000000000 +0100
@@ -1,5 +0,0 @@
-ls
-stat sym
-stat double-indirect-test
-cat fluff
-quit
diff -Nurp e2fsprogs-1.40.8/tests/f_swapfs/expect e2fsprogs/tests/f_swapfs/expect
--- e2fsprogs-1.40.8/tests/f_swapfs/expect	2008-03-13 23:20:46.000000000 +0100
+++ e2fsprogs/tests/f_swapfs/expect	1970-01-01 01:00:00.000000000 +0100
@@ -1,133 +0,0 @@
-Swapfs test
-e2fsck -yf -N test_filesys
-Pass 1: Checking inodes, blocks, and sizes
-Pass 2: Checking directory structure
-Pass 3: Checking directory connectivity
-Pass 4: Checking reference counts
-Pass 5: Checking group summary information
-test_filesys: 25/256 files (0.0% non-contiguous), 418/1024 blocks
-Exit status is 0
-e2fsck -Sy -N test_filesys
-Pass 0: Doing byte-swap of filesystem
-Pass 1: Checking inodes, blocks, and sizes
-Pass 2: Checking directory structure
-Pass 3: Checking directory connectivity
-Pass 4: Checking reference counts
-Pass 5: Checking group summary information
-test_filesys: 25/256 files (0.0% non-contiguous), 418/1024 blocks
-Exit status is 0
-Running debugfs....
-debugfs: ls
- 2  (12) .    2  (12) ..    11  (20) lost+found    12  (16) fluff   
- 13  (28) indirect-fluff-test    14  (28) double-indirect-test   
- 15  (20) sym    16  (24) long-sym-test    17  (864) dir-test   
-debugfs: stat sym
-Inode: 15   Type: symlink    Mode:  0777   Flags: 0x0   Generation: 1
-User:     0   Group:     0   Size: 5
-File ACL: 0    Directory ACL: 0
-Links: 1   Blockcount: 0
-Fragment:  Address: 0    Number: 0    Size: 0
-ctime: 0x322737e2 -- Fri Aug 30 18:50:10 1996
-atime: 0x322737e2 -- Fri Aug 30 18:50:10 1996
-mtime: 0x322737e2 -- Fri Aug 30 18:50:10 1996
-Fast_link_dest: fluff
-debugfs: stat double-indirect-test
-Inode: 14   Type: regular    Mode:  0644   Flags: 0x0   Generation: 1
-User:     0   Group:     0   Size: 348960
-File ACL: 0    Directory ACL: 0
-Links: 1   Blockcount: 688
-Fragment:  Address: 0    Number: 0    Size: 0
-ctime: 0x322488cf -- Wed Aug 28 17:58:39 1996
-atime: 0x322488cf -- Wed Aug 28 17:58:39 1996
-mtime: 0x322488cf -- Wed Aug 28 17:58:39 1996
-BLOCKS:
-(0-11):70-81, (IND):82, (12-267):83-338, (DIND):339, (IND):340, (268-340):341-413
-TOTAL: 344
-
-debugfs: cat fluff
-yabba dabba doo.  cocka doodle doo.  yabba dabba doo.  cocka doodle doo. yipyip
-yabba dabba doo.  cocka doodle doo.  yabba dabba doo.  cocka doodle doo. yipyip
-yabba dabba doo.  cocka doodle doo.  yabba dabba doo.  cocka doodle doo. yipyip
-yabba dabba doo.  cocka doodle doo.  yabba dabba doo.  cocka doodle doo. yipyip
-yabba dabba doo.  cocka doodle doo.  yabba dabba doo.  cocka doodle doo. yipyip
-yabba dabba doo.  cocka doodle doo.  yabba dabba doo.  cocka doodle doo. yipyip
-yabba dabba doo.  cocka doodle doo.  yabba dabba doo.  cocka doodle doo. yipyip
-yabba dabba doo.  cocka doodle doo.  yabba dabba doo.  cocka doodle doo. yipyip
-yabba dabba doo.  cocka doodle doo.  yabba dabba doo.  cocka doodle doo. yipyip
-yabba dabba doo.  cocka doodle doo.  yabba dabba doo.  cocka doodle doo. yipyip
-yabba dabba doo.  cocka doodle doo.  yabba dabba doo.  cocka doodle doo. yipyip
-yabba dabba doo.  cocka doodle doo.  yabba dabba doo.  cocka doodle doo. yipyip
-yabba dabba doo.  cocka doodle doo.  yabba dabba doo.  cocka doodle doo. yipyip
-
-debugfs: quit
-Exit status is 0
-e2fsck -yf -N test_filesys
-Pass 1: Checking inodes, blocks, and sizes
-Pass 2: Checking directory structure
-Pass 3: Checking directory connectivity
-Pass 4: Checking reference counts
-Pass 5: Checking group summary information
-test_filesys: 25/256 files (0.0% non-contiguous), 418/1024 blocks
-Exit status is 0
-e2fsck -sy -N test_filesys
-Pass 0: Doing byte-swap of filesystem
-Pass 1: Checking inodes, blocks, and sizes
-Pass 2: Checking directory structure
-Pass 3: Checking directory connectivity
-Pass 4: Checking reference counts
-Pass 5: Checking group summary information
-test_filesys: 25/256 files (0.0% non-contiguous), 418/1024 blocks
-Exit status is 0
-Running debugfs....
-debugfs: ls
- 2  (12) .    2  (12) ..    11  (20) lost+found    12  (16) fluff   
- 13  (28) indirect-fluff-test    14  (28) double-indirect-test   
- 15  (20) sym    16  (24) long-sym-test    17  (864) dir-test   
-debugfs: stat sym
-Inode: 15   Type: symlink    Mode:  0777   Flags: 0x0   Generation: 1
-User:     0   Group:     0   Size: 5
-File ACL: 0    Directory ACL: 0
-Links: 1   Blockcount: 0
-Fragment:  Address: 0    Number: 0    Size: 0
-ctime: 0x322737e2 -- Fri Aug 30 18:50:10 1996
-atime: 0x322737e2 -- Fri Aug 30 18:50:10 1996
-mtime: 0x322737e2 -- Fri Aug 30 18:50:10 1996
-Fast_link_dest: fluff
-debugfs: stat double-indirect-test
-Inode: 14   Type: regular    Mode:  0644   Flags: 0x0   Generation: 1
-User:     0   Group:     0   Size: 348960
-File ACL: 0    Directory ACL: 0
-Links: 1   Blockcount: 688
-Fragment:  Address: 0    Number: 0    Size: 0
-ctime: 0x322488cf -- Wed Aug 28 17:58:39 1996
-atime: 0x322488cf -- Wed Aug 28 17:58:39 1996
-mtime: 0x322488cf -- Wed Aug 28 17:58:39 1996
-BLOCKS:
-(0-11):70-81, (IND):82, (12-267):83-338, (DIND):339, (IND):340, (268-340):341-413
-TOTAL: 344
-
-debugfs: cat fluff
-yabba dabba doo.  cocka doodle doo.  yabba dabba doo.  cocka doodle doo. yipyip
-yabba dabba doo.  cocka doodle doo.  yabba dabba doo.  cocka doodle doo. yipyip
-yabba dabba doo.  cocka doodle doo.  yabba dabba doo.  cocka doodle doo. yipyip
-yabba dabba doo.  cocka doodle doo.  yabba dabba doo.  cocka doodle doo. yipyip
-yabba dabba doo.  cocka doodle doo.  yabba dabba doo.  cocka doodle doo. yipyip
-yabba dabba doo.  cocka doodle doo.  yabba dabba doo.  cocka doodle doo. yipyip
-yabba dabba doo.  cocka doodle doo.  yabba dabba doo.  cocka doodle doo. yipyip
-yabba dabba doo.  cocka doodle doo.  yabba dabba doo.  cocka doodle doo. yipyip
-yabba dabba doo.  cocka doodle doo.  yabba dabba doo.  cocka doodle doo. yipyip
-yabba dabba doo.  cocka doodle doo.  yabba dabba doo.  cocka doodle doo. yipyip
-yabba dabba doo.  cocka doodle doo.  yabba dabba doo.  cocka doodle doo. yipyip
-yabba dabba doo.  cocka doodle doo.  yabba dabba doo.  cocka doodle doo. yipyip
-yabba dabba doo.  cocka doodle doo.  yabba dabba doo.  cocka doodle doo. yipyip
-
-debugfs: quit
-Exit status is 0
-e2fsck -yf -N test_filesys
-Pass 1: Checking inodes, blocks, and sizes
-Pass 2: Checking directory structure
-Pass 3: Checking directory connectivity
-Pass 4: Checking reference counts
-Pass 5: Checking group summary information
-test_filesys: 25/256 files (0.0% non-contiguous), 418/1024 blocks
-Exit status is 0
Files e2fsprogs-1.40.8/tests/f_swapfs/image and e2fsprogs/tests/f_swapfs/image differ
Files e2fsprogs-1.40.8/tests/f_swapfs/image.gz and e2fsprogs/tests/f_swapfs/image.gz differ
diff -Nurp e2fsprogs-1.40.8/tests/f_swapfs/name e2fsprogs/tests/f_swapfs/name
--- e2fsprogs-1.40.8/tests/f_swapfs/name	2008-03-13 23:20:46.000000000 +0100
+++ e2fsprogs/tests/f_swapfs/name	1970-01-01 01:00:00.000000000 +0100
@@ -1 +0,0 @@
-checking the e2fsck swapfs functionality
diff -Nurp e2fsprogs-1.40.8/tests/f_swapfs/script e2fsprogs/tests/f_swapfs/script
--- e2fsprogs-1.40.8/tests/f_swapfs/script	2008-03-13 23:20:46.000000000 +0100
+++ e2fsprogs/tests/f_swapfs/script	1970-01-01 01:00:00.000000000 +0100
@@ -1,79 +0,0 @@
-if $FSCK -SV > /dev/null 2>&1 ; then
-    IMAGE=$test_dir/image.gz
-    VERIFY_FSCK_OPT=-yf
-    SWAP_FSCK_OPT=-Sy
-    NATIVE_FSCK_OPT=-sy
-    OUT=$test_name.log
-    EXP=$test_dir/expect
-    
-    gunzip < $IMAGE > $TMPFILE
-    
-    echo "Swapfs test" > $OUT
-    
-    echo e2fsck $VERIFY_FSCK_OPT -N test_filesys > $OUT.new
-    $FSCK $VERIFY_FSCK_OPT -N test_filesys $TMPFILE >> $OUT.new 2>&1
-    status=$?
-    echo Exit status is $status >> $OUT.new
-    sed -e '2d' $OUT.new >> $OUT
-    
-    echo e2fsck $SWAP_FSCK_OPT -N test_filesys > $OUT.new
-    $FSCK $SWAP_FSCK_OPT -N test_filesys $TMPFILE >> $OUT.new 2>&1
-    status=$?
-    echo Exit status is $status >> $OUT.new
-    sed -e '2d' $OUT.new >> $OUT
-    
-    echo Running debugfs.... >> $OUT
-    $DEBUGFS -f $test_dir/debugfs.cmd $TMPFILE > $OUT.new 2>&1 
-    status=$?
-    echo Exit status is $status >> $OUT.new
-    sed -e '1d' $OUT.new >> $OUT
-    
-    echo e2fsck $VERIFY_FSCK_OPT -N test_filesys > $OUT.new
-    $FSCK $VERIFY_FSCK_OPT -N test_filesys $TMPFILE >> $OUT.new 2>&1
-    status=$?
-    echo Exit status is $status >> $OUT.new
-    sed -e '2d' $OUT.new >> $OUT
-    
-    echo e2fsck $NATIVE_FSCK_OPT -N test_filesys > $OUT.new
-    $FSCK $NATIVE_FSCK_OPT -N test_filesys $TMPFILE >> $OUT.new 2>&1
-    status=$?
-    echo Exit status is $status >> $OUT.new
-    sed -e '2d' $OUT.new >> $OUT
-    
-    echo Running debugfs.... >> $OUT
-    $DEBUGFS -f $test_dir/debugfs.cmd $TMPFILE > $OUT.new 2>&1 
-    status=$?
-    echo Exit status is $status >> $OUT.new
-    sed -e '1d' $OUT.new >> $OUT
-    
-    echo e2fsck $VERIFY_FSCK_OPT -N test_filesys > $OUT.new
-    $FSCK $VERIFY_FSCK_OPT -N test_filesys $TMPFILE >> $OUT.new 2>&1
-    status=$?
-    echo Exit status is $status >> $OUT.new
-    sed -e '2d' $OUT.new >> $OUT
-    rm -f $OUT.new
-    
-    rm $TMPFILE
-    
-    #
-    # Do the verification
-    #
-    
-    rm -f $test_name.ok $test_name.failed
-    cmp -s $OUT $EXP
-    status=$?
-    
-    if [ "$status" = 0 ] ; then
-	    echo "ok"
-	    touch $test_name.ok
-    else
-	    echo "failed"
-	    diff $DIFF_OPTS $EXP $OUT > $test_name.failed
-    fi
-    
-    unset IMAGE VERIFY_FSCK_OPT SWAP_FSCK_OPT NATIVE_FSCK_OPT OUT EXP 
-
-else
-    rm -f $test_name.ok $test_name.failed
-    echo "skipped"
-fi
diff -Nurp e2fsprogs-1.40.8/tests/f_unsorted_EAs/expect.1 e2fsprogs/tests/f_unsorted_EAs/expect.1
--- e2fsprogs-1.40.8/tests/f_unsorted_EAs/expect.1	1970-01-01 01:00:00.000000000 +0100
+++ e2fsprogs/tests/f_unsorted_EAs/expect.1	2008-03-29 01:20:43.000000000 +0100
@@ -0,0 +1,11 @@
+Adding dirhash hint to filesystem.
+
+Pass 1: Checking inodes, blocks, and sizes
+Pass 2: Checking directory structure
+Pass 3: Checking directory connectivity
+Pass 4: Checking reference counts
+Pass 5: Checking group summary information
+
+test_filesys: ***** FILE SYSTEM WAS MODIFIED *****
+test_filesys: 12/2048 files (0.0% non-contiguous), 1294/2048 blocks
+Exit status is 1
diff -Nurp e2fsprogs-1.40.8/tests/f_unsorted_EAs/expect.2 e2fsprogs/tests/f_unsorted_EAs/expect.2
--- e2fsprogs-1.40.8/tests/f_unsorted_EAs/expect.2	1970-01-01 01:00:00.000000000 +0100
+++ e2fsprogs/tests/f_unsorted_EAs/expect.2	2008-03-29 01:20:43.000000000 +0100
@@ -0,0 +1,7 @@
+Pass 1: Checking inodes, blocks, and sizes
+Pass 2: Checking directory structure
+Pass 3: Checking directory connectivity
+Pass 4: Checking reference counts
+Pass 5: Checking group summary information
+test_filesys: 12/2048 files (0.0% non-contiguous), 1294/2048 blocks
+Exit status is 0
Files e2fsprogs-1.40.8/tests/f_unsorted_EAs/image.gz and e2fsprogs/tests/f_unsorted_EAs/image.gz differ
diff -Nurp e2fsprogs-1.40.8/tests/f_unsorted_EAs/name e2fsprogs/tests/f_unsorted_EAs/name
--- e2fsprogs-1.40.8/tests/f_unsorted_EAs/name	1970-01-01 01:00:00.000000000 +0100
+++ e2fsprogs/tests/f_unsorted_EAs/name	2008-03-29 01:20:43.000000000 +0100
@@ -0,0 +1 @@
+unsorted EAs in inode should not be deleted
diff -Nurp e2fsprogs-1.40.8/tests/m_large_file/expect.1 e2fsprogs/tests/m_large_file/expect.1
--- e2fsprogs-1.40.8/tests/m_large_file/expect.1	2008-03-13 23:20:46.000000000 +0100
+++ e2fsprogs/tests/m_large_file/expect.1	2008-03-29 01:20:43.000000000 +0100
@@ -1,4 +1,3 @@
-Warning: 256-byte inodes not usable on older systems
 Filesystem label=
 OS type: Linux
 Block size=4096 (log=2)
diff -Nurp e2fsprogs-1.40.8/tests/m_lazy/expect.1 e2fsprogs/tests/m_lazy/expect.1
--- e2fsprogs-1.40.8/tests/m_lazy/expect.1	1970-01-01 01:00:00.000000000 +0100
+++ e2fsprogs/tests/m_lazy/expect.1	2008-03-29 01:20:43.000000000 +0100
@@ -0,0 +1,166 @@
+Filesystem label=
+OS type: Linux
+Block size=1024 (log=0)
+Fragment size=1024 (log=0)
+32768 inodes, 131072 blocks
+6553 blocks (5.00%) reserved for the super user
+First data block=1
+Maximum filesystem blocks=67371008
+16 block groups
+8192 blocks per group, 8192 fragments per group
+2048 inodes per group
+Superblock backups stored on blocks: 
+	8193, 24577, 40961, 57345, 73729
+
+Writing inode tables: done                            
+Writing superblocks and filesystem accounting information: done
+
+Filesystem features: ext_attr resize_inode dir_index lazy_bg filetype sparse_super
+ 
+Pass 1: Checking inodes, blocks, and sizes
+Pass 2: Checking directory structure
+Pass 3: Checking directory connectivity
+Pass 4: Checking reference counts
+Pass 5: Checking group summary information
+test_filesys: 28683/32768 files (0.0% non-contiguous), 77097/131072 blocks
+Exit status is 0
+
+Filesystem volume name:   <none>
+Last mounted on:          <not available>
+Filesystem magic number:  0xEF53
+Filesystem revision #:    1 (dynamic)
+Filesystem features:      ext_attr resize_inode dir_index lazy_bg filetype sparse_super
+Default mount options:    (none)
+Filesystem state:         clean
+Errors behavior:          Continue
+Filesystem OS type:       Linux
+Inode count:              32768
+Block count:              131072
+Reserved block count:     6553
+Free blocks:              53975
+Free inodes:              4085
+First block:              1
+Block size:               1024
+Fragment size:            1024
+Reserved GDT blocks:      256
+Blocks per group:         8192
+Fragments per group:      8192
+Inodes per group:         2048
+Inode blocks per group:   256
+Mount count:              0
+Check interval:           15552000 (6 months)
+Reserved blocks uid:      0
+Reserved blocks gid:      0
+First inode:              11
+Inode size:		  128
+Default directory hash:   tea
+
+
+Group 0: (Blocks 1-8192)
+  Primary superblock at 1, Group descriptors at 2-2
+  Reserved GDT blocks at 3-258
+  Block bitmap at 259 (+258), Inode bitmap at 260 (+259)
+  Inode table at 261-516 (+260)
+  7662 free blocks, 2037 free inodes, 2 directories
+  Free blocks: 531-8192
+  Free inodes: 12-2048
+Group 1: (Blocks 8193-16384) [Inode not init]
+  Backup superblock at 8193, Group descriptors at 8194-8194
+  Reserved GDT blocks at 8195-8450
+  Block bitmap at 8451 (+258), Inode bitmap at 8452 (+259)
+  Inode table at 8453-8708 (+260)
+  7676 free blocks, 0 free inodes, 0 directories
+  Free blocks: 8709-16384
+  Free inodes: 
+Group 2: (Blocks 16385-24576) [Inode not init, Block not init]
+  Block bitmap at 16385 (+0), Inode bitmap at 16386 (+1)
+  Inode table at 16387-16642 (+2)
+  0 free blocks, 0 free inodes, 0 directories
+  Free blocks: 
+  Free inodes: 
+Group 3: (Blocks 24577-32768) [Inode not init]
+  Backup superblock at 24577, Group descriptors at 24578-24578
+  Reserved GDT blocks at 24579-24834
+  Block bitmap at 24835 (+258), Inode bitmap at 24836 (+259)
+  Inode table at 24837-25092 (+260)
+  7676 free blocks, 0 free inodes, 0 directories
+  Free blocks: 25093-32768
+  Free inodes: 
+Group 4: (Blocks 32769-40960) [Inode not init, Block not init]
+  Block bitmap at 32769 (+0), Inode bitmap at 32770 (+1)
+  Inode table at 32771-33026 (+2)
+  0 free blocks, 0 free inodes, 0 directories
+  Free blocks: 
+  Free inodes: 
+Group 5: (Blocks 40961-49152) [Inode not init]
+  Backup superblock at 40961, Group descriptors at 40962-40962
+  Reserved GDT blocks at 40963-41218
+  Block bitmap at 41219 (+258), Inode bitmap at 41220 (+259)
+  Inode table at 41221-41476 (+260)
+  7676 free blocks, 0 free inodes, 0 directories
+  Free blocks: 41477-49152
+  Free inodes: 
+Group 6: (Blocks 49153-57344) [Inode not init, Block not init]
+  Block bitmap at 49153 (+0), Inode bitmap at 49154 (+1)
+  Inode table at 49155-49410 (+2)
+  0 free blocks, 0 free inodes, 0 directories
+  Free blocks: 
+  Free inodes: 
+Group 7: (Blocks 57345-65536) [Inode not init]
+  Backup superblock at 57345, Group descriptors at 57346-57346
+  Reserved GDT blocks at 57347-57602
+  Block bitmap at 57603 (+258), Inode bitmap at 57604 (+259)
+  Inode table at 57605-57860 (+260)
+  7676 free blocks, 0 free inodes, 0 directories
+  Free blocks: 57861-65536
+  Free inodes: 
+Group 8: (Blocks 65537-73728) [Inode not init, Block not init]
+  Block bitmap at 65537 (+0), Inode bitmap at 65538 (+1)
+  Inode table at 65539-65794 (+2)
+  0 free blocks, 0 free inodes, 0 directories
+  Free blocks: 
+  Free inodes: 
+Group 9: (Blocks 73729-81920) [Inode not init]
+  Backup superblock at 73729, Group descriptors at 73730-73730
+  Reserved GDT blocks at 73731-73986
+  Block bitmap at 73987 (+258), Inode bitmap at 73988 (+259)
+  Inode table at 73989-74244 (+260)
+  7676 free blocks, 0 free inodes, 0 directories
+  Free blocks: 74245-81920
+  Free inodes: 
+Group 10: (Blocks 81921-90112) [Inode not init, Block not init]
+  Block bitmap at 81921 (+0), Inode bitmap at 81922 (+1)
+  Inode table at 81923-82178 (+2)
+  0 free blocks, 0 free inodes, 0 directories
+  Free blocks: 
+  Free inodes: 
+Group 11: (Blocks 90113-98304) [Inode not init, Block not init]
+  Block bitmap at 90113 (+0), Inode bitmap at 90114 (+1)
+  Inode table at 90115-90370 (+2)
+  0 free blocks, 0 free inodes, 0 directories
+  Free blocks: 
+  Free inodes: 
+Group 12: (Blocks 98305-106496) [Inode not init, Block not init]
+  Block bitmap at 98305 (+0), Inode bitmap at 98306 (+1)
+  Inode table at 98307-98562 (+2)
+  0 free blocks, 0 free inodes, 0 directories
+  Free blocks: 
+  Free inodes: 
+Group 13: (Blocks 106497-114688) [Inode not init, Block not init]
+  Block bitmap at 106497 (+0), Inode bitmap at 106498 (+1)
+  Inode table at 106499-106754 (+2)
+  0 free blocks, 0 free inodes, 0 directories
+  Free blocks: 
+  Free inodes: 
+Group 14: (Blocks 114689-122880) [Inode not init, Block not init]
+  Block bitmap at 114689 (+0), Inode bitmap at 114690 (+1)
+  Inode table at 114691-114946 (+2)
+  0 free blocks, 0 free inodes, 0 directories
+  Free blocks: 
+  Free inodes: 
+Group 15: (Blocks 122881-131071)
+  Block bitmap at 122881 (+0), Inode bitmap at 122882 (+1)
+  Inode table at 122883-123138 (+2)
+  7933 free blocks, 2048 free inodes, 0 directories
+  Free blocks: 123139-131071
+  Free inodes: 30721-32768
diff -Nurp e2fsprogs-1.40.8/tests/m_lazy/script e2fsprogs/tests/m_lazy/script
--- e2fsprogs-1.40.8/tests/m_lazy/script	1970-01-01 01:00:00.000000000 +0100
+++ e2fsprogs/tests/m_lazy/script	2008-03-29 01:20:43.000000000 +0100
@@ -0,0 +1,4 @@
+DESCRIPTION="lazy group feature"
+FS_SIZE=131072
+MKE2FS_OPTS="-O lazy_bg"
+. $cmd_dir/run_mke2fs
diff -Nurp e2fsprogs-1.40.8/tests/m_raid_opt/expect.1 e2fsprogs/tests/m_raid_opt/expect.1
--- e2fsprogs-1.40.8/tests/m_raid_opt/expect.1	2008-03-13 19:57:37.000000000 +0100
+++ e2fsprogs/tests/m_raid_opt/expect.1	2008-03-29 01:20:43.000000000 +0100
@@ -46,57 +46,68 @@ Setting filetype for entry '..' in ??? (
 Directory inode 11, block 1, offset 0: directory corrupted
 Salvage? yes
 
-Entry '' in ??? (11) has deleted/unused inode 1063.  Clear? yes
+Entry '' in ??? (11) has a zero-length name.
+Clear? yes
 
 Directory inode 11, block 2, offset 0: directory corrupted
 Salvage? yes
 
-Entry '' in ??? (11) has deleted/unused inode 1064.  Clear? yes
+Entry '' in ??? (11) has a zero-length name.
+Clear? yes
 
 Directory inode 11, block 3, offset 0: directory corrupted
 Salvage? yes
 
-Entry '' in ??? (11) has deleted/unused inode 1065.  Clear? yes
+Entry '' in ??? (11) has a zero-length name.
+Clear? yes
 
 Directory inode 11, block 4, offset 0: directory corrupted
 Salvage? yes
 
-Entry '' in ??? (11) has deleted/unused inode 1066.  Clear? yes
+Entry '' in ??? (11) has a zero-length name.
+Clear? yes
 
 Directory inode 11, block 5, offset 0: directory corrupted
 Salvage? yes
 
-Entry '' in ??? (11) has deleted/unused inode 1067.  Clear? yes
+Entry '' in ??? (11) has a zero-length name.
+Clear? yes
 
 Directory inode 11, block 6, offset 0: directory corrupted
 Salvage? yes
 
-Entry '' in ??? (11) has deleted/unused inode 1068.  Clear? yes
+Entry '' in ??? (11) has a zero-length name.
+Clear? yes
 
 Directory inode 11, block 7, offset 0: directory corrupted
 Salvage? yes
 
-Entry '' in ??? (11) has deleted/unused inode 1069.  Clear? yes
+Entry '' in ??? (11) has a zero-length name.
+Clear? yes
 
 Directory inode 11, block 8, offset 0: directory corrupted
 Salvage? yes
 
-Entry '' in ??? (11) has deleted/unused inode 1070.  Clear? yes
+Entry '' in ??? (11) has a zero-length name.
+Clear? yes
 
 Directory inode 11, block 9, offset 0: directory corrupted
 Salvage? yes
 
-Entry '' in ??? (11) has deleted/unused inode 1071.  Clear? yes
+Entry '' in ??? (11) has a zero-length name.
+Clear? yes
 
 Directory inode 11, block 10, offset 0: directory corrupted
 Salvage? yes
 
-Entry '' in ??? (11) has deleted/unused inode 1072.  Clear? yes
+Entry '' in ??? (11) has a zero-length name.
+Clear? yes
 
 Directory inode 11, block 11, offset 0: directory corrupted
 Salvage? yes
 
-Entry '' in ??? (11) has deleted/unused inode 1073.  Clear? yes
+Entry '' in ??? (11) has a zero-length name.
+Clear? yes
 
 Pass 3: Checking directory connectivity
 '..' in / (2) is <The NULL inode> (0), should be / (2).
diff -Nurp e2fsprogs-1.40.8/tests/m_uninit/expect.1 e2fsprogs/tests/m_uninit/expect.1
--- e2fsprogs-1.40.8/tests/m_uninit/expect.1	1970-01-01 01:00:00.000000000 +0100
+++ e2fsprogs/tests/m_uninit/expect.1	2008-03-29 01:20:43.000000000 +0100
@@ -0,0 +1,166 @@
+Filesystem label=
+OS type: Linux
+Block size=1024 (log=0)
+Fragment size=1024 (log=0)
+32768 inodes, 131072 blocks
+6553 blocks (5.00%) reserved for the super user
+First data block=1
+Maximum filesystem blocks=67371008
+16 block groups
+8192 blocks per group, 8192 fragments per group
+2048 inodes per group
+Superblock backups stored on blocks: 
+	8193, 24577, 40961, 57345, 73729
+
+Writing inode tables: done                            
+Writing superblocks and filesystem accounting information: done
+
+Filesystem features: ext_attr resize_inode dir_index filetype sparse_super uninit_groups
+ 
+Pass 1: Checking inodes, blocks, and sizes
+Pass 2: Checking directory structure
+Pass 3: Checking directory connectivity
+Pass 4: Checking reference counts
+Pass 5: Checking group summary information
+test_filesys: 11/32768 files (9.1% non-contiguous), 5691/131072 blocks
+Exit status is 0
+
+Filesystem volume name:   <none>
+Last mounted on:          <not available>
+Filesystem magic number:  0xEF53
+Filesystem revision #:    1 (dynamic)
+Filesystem features:      ext_attr resize_inode dir_index filetype sparse_super uninit_groups
+Default mount options:    (none)
+Filesystem state:         clean
+Errors behavior:          Continue
+Filesystem OS type:       Linux
+Inode count:              32768
+Block count:              131072
+Reserved block count:     6553
+Free blocks:              125381
+Free inodes:              32757
+First block:              1
+Block size:               1024
+Fragment size:            1024
+Reserved GDT blocks:      256
+Blocks per group:         8192
+Fragments per group:      8192
+Inodes per group:         2048
+Inode blocks per group:   256
+Mount count:              0
+Check interval:           15552000 (6 months)
+Reserved blocks uid:      0
+Reserved blocks gid:      0
+First inode:              11
+Inode size:		  128
+Default directory hash:   tea
+
+
+Group 0: (Blocks 1-8192)
+  Primary superblock at 1, Group descriptors at 2-2
+  Reserved GDT blocks at 3-258
+  Block bitmap at 259 (+258), Inode bitmap at 260 (+259)
+  Inode table at 261-516 (+260)
+  7662 free blocks, 2037 free inodes, 2 directories, 2037 unused inodes
+  Free blocks: 531-8192
+  Free inodes: 12-2048
+Group 1: (Blocks 8193-16384) [Inode not init]
+  Backup superblock at 8193, Group descriptors at 8194-8194
+  Reserved GDT blocks at 8195-8450
+  Block bitmap at 8451 (+258), Inode bitmap at 8452 (+259)
+  Inode table at 8453-8708 (+260)
+  7676 free blocks, 2048 free inodes, 0 directories, 2048 unused inodes
+  Free blocks: 8709-16384
+  Free inodes: 
+Group 2: (Blocks 16385-24576) [Inode not init, Block not init]
+  Block bitmap at 16385 (+0), Inode bitmap at 16386 (+1)
+  Inode table at 16387-16642 (+2)
+  7934 free blocks, 2048 free inodes, 0 directories, 2048 unused inodes
+  Free blocks: 
+  Free inodes: 
+Group 3: (Blocks 24577-32768) [Inode not init]
+  Backup superblock at 24577, Group descriptors at 24578-24578
+  Reserved GDT blocks at 24579-24834
+  Block bitmap at 24835 (+258), Inode bitmap at 24836 (+259)
+  Inode table at 24837-25092 (+260)
+  7676 free blocks, 2048 free inodes, 0 directories, 2048 unused inodes
+  Free blocks: 25093-32768
+  Free inodes: 
+Group 4: (Blocks 32769-40960) [Inode not init, Block not init]
+  Block bitmap at 32769 (+0), Inode bitmap at 32770 (+1)
+  Inode table at 32771-33026 (+2)
+  7934 free blocks, 2048 free inodes, 0 directories, 2048 unused inodes
+  Free blocks: 
+  Free inodes: 
+Group 5: (Blocks 40961-49152) [Inode not init]
+  Backup superblock at 40961, Group descriptors at 40962-40962
+  Reserved GDT blocks at 40963-41218
+  Block bitmap at 41219 (+258), Inode bitmap at 41220 (+259)
+  Inode table at 41221-41476 (+260)
+  7676 free blocks, 2048 free inodes, 0 directories, 2048 unused inodes
+  Free blocks: 41477-49152
+  Free inodes: 
+Group 6: (Blocks 49153-57344) [Inode not init, Block not init]
+  Block bitmap at 49153 (+0), Inode bitmap at 49154 (+1)
+  Inode table at 49155-49410 (+2)
+  7934 free blocks, 2048 free inodes, 0 directories, 2048 unused inodes
+  Free blocks: 
+  Free inodes: 
+Group 7: (Blocks 57345-65536) [Inode not init]
+  Backup superblock at 57345, Group descriptors at 57346-57346
+  Reserved GDT blocks at 57347-57602
+  Block bitmap at 57603 (+258), Inode bitmap at 57604 (+259)
+  Inode table at 57605-57860 (+260)
+  7676 free blocks, 2048 free inodes, 0 directories, 2048 unused inodes
+  Free blocks: 57861-65536
+  Free inodes: 
+Group 8: (Blocks 65537-73728) [Inode not init, Block not init]
+  Block bitmap at 65537 (+0), Inode bitmap at 65538 (+1)
+  Inode table at 65539-65794 (+2)
+  7934 free blocks, 2048 free inodes, 0 directories, 2048 unused inodes
+  Free blocks: 
+  Free inodes: 
+Group 9: (Blocks 73729-81920) [Inode not init]
+  Backup superblock at 73729, Group descriptors at 73730-73730
+  Reserved GDT blocks at 73731-73986
+  Block bitmap at 73987 (+258), Inode bitmap at 73988 (+259)
+  Inode table at 73989-74244 (+260)
+  7676 free blocks, 2048 free inodes, 0 directories, 2048 unused inodes
+  Free blocks: 74245-81920
+  Free inodes: 
+Group 10: (Blocks 81921-90112) [Inode not init, Block not init]
+  Block bitmap at 81921 (+0), Inode bitmap at 81922 (+1)
+  Inode table at 81923-82178 (+2)
+  7934 free blocks, 2048 free inodes, 0 directories, 2048 unused inodes
+  Free blocks: 
+  Free inodes: 
+Group 11: (Blocks 90113-98304) [Inode not init, Block not init]
+  Block bitmap at 90113 (+0), Inode bitmap at 90114 (+1)
+  Inode table at 90115-90370 (+2)
+  7934 free blocks, 2048 free inodes, 0 directories, 2048 unused inodes
+  Free blocks: 
+  Free inodes: 
+Group 12: (Blocks 98305-106496) [Inode not init, Block not init]
+  Block bitmap at 98305 (+0), Inode bitmap at 98306 (+1)
+  Inode table at 98307-98562 (+2)
+  7934 free blocks, 2048 free inodes, 0 directories, 2048 unused inodes
+  Free blocks: 
+  Free inodes: 
+Group 13: (Blocks 106497-114688) [Inode not init, Block not init]
+  Block bitmap at 106497 (+0), Inode bitmap at 106498 (+1)
+  Inode table at 106499-106754 (+2)
+  7934 free blocks, 2048 free inodes, 0 directories, 2048 unused inodes
+  Free blocks: 
+  Free inodes: 
+Group 14: (Blocks 114689-122880) [Inode not init, Block not init]
+  Block bitmap at 114689 (+0), Inode bitmap at 114690 (+1)
+  Inode table at 114691-114946 (+2)
+  7934 free blocks, 2048 free inodes, 0 directories, 2048 unused inodes
+  Free blocks: 
+  Free inodes: 
+Group 15: (Blocks 122881-131071) [Inode not init, Block not init]
+  Block bitmap at 122881 (+0), Inode bitmap at 122882 (+1)
+  Inode table at 122883-123138 (+2)
+  7933 free blocks, 2048 free inodes, 0 directories, 2048 unused inodes
+  Free blocks: 
+  Free inodes: 
diff -Nurp e2fsprogs-1.40.8/tests/m_uninit/script e2fsprogs/tests/m_uninit/script
--- e2fsprogs-1.40.8/tests/m_uninit/script	1970-01-01 01:00:00.000000000 +0100
+++ e2fsprogs/tests/m_uninit/script	2008-03-29 01:20:43.000000000 +0100
@@ -0,0 +1,4 @@
+DESCRIPTION="uninitialized group feature"
+FS_SIZE=131072
+MKE2FS_OPTS="-O uninit_groups"
+. $cmd_dir/run_mke2fs
diff -Nurp e2fsprogs-1.40.8/tests/test_script.in e2fsprogs/tests/test_script.in
--- e2fsprogs-1.40.8/tests/test_script.in	2008-02-19 05:33:10.000000000 +0100
+++ e2fsprogs/tests/test_script.in	2008-03-29 01:20:43.000000000 +0100
@@ -8,7 +8,7 @@ export LC_ALL
 
 case "$1" in 
     --valgrind)
-    	export USE_VALGRIND="valgrind -q --weird-hacks=lax-ioctls"
+    	export USE_VALGRIND="valgrind -q --sim-hints=lax-ioctls"
 	shift;
 esac
 
diff -Nurp e2fsprogs-1.40.8/TODO e2fsprogs/TODO
--- e2fsprogs-1.40.8/TODO	1970-01-01 01:00:00.000000000 +0100
+++ e2fsprogs/TODO	2008-03-29 01:20:43.000000000 +0100
@@ -0,0 +1,277 @@
+Need to process the bad block inode *before* doing the inode scan.
+
+Also check to see if the first block of the inode table is not on the
+bad block scan, and fix that.  We need to check for an inaccurate
+blocks, and fix them before we start doing anything else with the
+filesystem!
+
+---------------------------------------------------
+User request:
+
+BTW: Could you please add some sort of deleted and possibly corrupted file
+     and inode list to e2fsck report. There should be filenames deleted
+     from directory inodes, files with duplicate blocks e.t.c.
+     It's pretty annoying to filter this information from e2fsck output
+     by hand :-
+
+------------------------------------------
+
+Add a "answer Yes always to this class of question" response.
+
+----------------------------------
+
+ext2fs_flush() should return a different error message for primary
+versus backup superblock flushing, so that mke2fs can print an
+appropriate error message.
+
+---------------------------------
+Date: Mon, 08 Mar 1999 21:46:14 +0100
+From: Sergio Polini <s.polini@mclink.it>
+
+
+I'm reading the sorce code of e2fsck 1.14.
+In pass2.c, lines 352-357, I read:
+
+if ((dirent->name_len & 0xFF) > EXT2_NAME_LEN) {
+        if (fix_problem(ctx, PR_2_FILENAME_LONG, &cd->pctx)) {
+                dirent->name_len = EXT2_NAME_LEN;
+                dir_modified++;
+        }
+}
+
+I think that I'll never see any messages about too long filenames,
+because "whatever & 0xFF" can never be "> 0xFF".
+Am I wrong?
+--------------------------------------
+
+Add chmod command to debugfs.
+
+------------------------------------------
+
+Date: Tue, 18 Jan 2000 17:54:53 -0800 (PST)
+From: Alan Blanchard <alan@abraxas.to>
+To: tytso@MIT.EDU
+Subject: DEBUGFS - thanks and a feature idea
+Content-Type: TEXT/PLAIN; charset=US-ASCII
+
+Theodore:
+
+First, let me thank you for writing debugfs. Recently, my Linux box
+(RH 6.0, 400 MHz PIII, on a DSL line) was hacked into.  The intruder did
+an "rm -Rf" on a 34 GB drive with about 5GB of data on it.  I was able to
+restore essentially the entire thing with debugfs and a bit of C code and Perl.
+Actually, I could have done the entire thing with debugfs and Perl, but I
+thought it would be too slow.
+
+During this exercise, I noticed that one small feature was lacking that would
+have made my job a bit easier.  The length of a deleted directory is
+reported as 0, hence debugfs won't dump the contents of the directory to a
+file using the "dump" command.  The only thing that saved me was that the
+list of disk blocks is not zeroed out.  I was able to dump the contents of the
+directories by using debugfs to get the relevant block numbers, then
+using dd to get the actual data.
+
+If debugfs had a feature where it ignored the size of a directory reported by
+the inode and instead just dumped all the blocks, it would have facilited
+things a bit. This seems like a very easy feature to add.
+
+Again, thanks for writing debugfs (and all the other Linux stuff you've written!).
+
+Cheers,
+Alan Blanchard
+alan@abraxas.to
+
+
+-------------------------------------------------------------------
+
+Date: Fri, 21 Jan 2000 14:07:12 -0800
+From: "H. Peter Anvin" <hpa@www.transmeta.com>
+Subject: mkfs -cc and fsck -c
+
+b) An option to mkfs to zero the partition.  Yes, it can be done with
+dd, but it would be a nicer way of doing it.
+
+------------------------------------------------------------------
+
+Add support for in ext2fs_block_iterate() for a returning the
+compressed flag blocks to block_iterate.  Change default to not return
+EXT2_COMPRESSED_BLKADDR.  Change e2fsck to pass this flag in.
+
+(The old compression patches did this by default all the time, which
+is bad, since it meant e2fsck never saw the EXT2_COMPRESSED_BLKADDR
+flagword.
+
+------------------------------------------------------------
+
+E2fsck should offer to clear all the blocks in an indirect block, not
+the entire inode, so there's better recovery for when an indirect
+block gets trashed.
+
+
+-------------------------------------------------------------
+
+From: Yann Dirson - LOGATIQUE <Yann.Dirson@France.Sun.COM>
+Date: Thu, 2 Mar 2000 13:52:13 +0100 (MET)
+
+During my experiments on the broken system, I noticed the following in
+the badblocks program (which I'm aware is not designed for IDE drives)
+- I'd probably have already fixed them if my home system was up :(
+
+* the syntax summary documents 2nd arg as blocks_count, which should
+probably read something like end_count.
+
+* testing past end of device is not detected, and lists those blocks
+as bad, whereas they simply do not exist.
+
+
+I think I'll probably add a "max count" option to findsuper(8), so
+that I do not have to wait for the whole disk to be scanned when the
+system had to be launched with "init=/bin/sh", in which case Ctrl-[CZ]
+and friends appear to be absolutely ignored.
+
+
+Somewhat unrelated, I just noticed the
+http://web.mit.edu/tytso/www/linux/ext2.html could be updated:
+
+- could mention SGI xfs (http://oss.sgi.com/projects/xfs/ - they just
+  release 0.03 snapshot)
+
+----------------------------------------------------------------
+
+Return-Path: <tytso@MIT.EDU>
+Date: Thu, 10 Feb 2000 13:20:14 -0500
+From: "Theodore Y. Ts'o" <tytso@MIT.EDU>
+To: R.E.Wolff@BitWizard.nl
+In-Reply-To: Rogier Wolff's message of Thu, 10 Feb 2000 08:46:30 +0100 (MET),
+	<200002100746.IAA24573@cave.bitwizard.nl>
+Subject: Re: e2fsck request for enhancement.
+Phone: (781) 391-3464
+
+   Date: Thu, 10 Feb 2000 08:46:30 +0100 (MET)
+   From: R.E.Wolff@BitWizard.nl (Rogier Wolff)
+
+   Lately, while trying to recover a broken disk, my system froze (twice,
+   until I tried something else) while copying the disk.
+
+   So I had a file of about 50Mb that was growing frantically at the
+   moment of the crash.
+
+   e2fsck, then finds an indirect block that is completely bogus. It
+   starts by asking me if it's ok to clear a few of the referenced
+   blocks. I say yes. Then it comes to the conclusion: 
+
+      too many invalid blocks. Clear inode?
+
+   and then I get the option to delete the whole file. Not to truncate
+   the file to a "working" size.
+
+
+   I'd MUCH rather have e2fsck say something like:
+
+      inode 1234 references an invalid block 134345454. Hmm.
+      inode 1234 references 567 out of 50176 invalid blocks, 
+			  all near the end. Truncate file to 49152 blocks?
+
+   Here you can see that of the 1024 blocks near the end of the file,
+   only 567 were detected as invalid. However now 48Mb of the file will
+   be recovered, instead of thrown away.
+
+That's a good point.  Actually, the right thing is for e2fsck to offer
+to clear all of the bad blocks in a particular indirect block.  I don't
+know how hard it would be to do that, but I'll put it on my e2fsprogs
+TODO list.
+
+							- Ted
+
+---------------------------------------------------------------
+From e2fsprogs Debian TODO file as of 1.10-13.
+
+* Maybe make -dbg packages. Look at how others do it.
+
+---------------------------------------------------------------
+
+Add --lba option to debian icheck command, and have ways of making it
+easier to translate LBA to filesystem block numbers.
+
+-------------------------------------------------------
+
+
+
+List of projects for e2fsprogs:
+
+
+1) Make debugfs's "ncheck <inode>" command list all of the pathnames
+to an inode, not just only the first link to the inode which is found.
+(A good "intro to libext2fs programming interfaces project)
+
+	Difficulty: Low		Priority: Low
+
+2) Use a code coverage tool such as Rational's PureCoverage to see
+what kind of code coverage we have for e2fsck, and try to add test
+cases to increase the code coverage for e2fsck.
+
+	Difficulty: Medium	Priorty: Low
+
+3) Use a code coverage tool such as Rational's PureCoverage to see
+what kind of code coverage we have for resize2fs, and try to add test
+cases to increase the code coverage for resize2fs.
+
+	Difficulty: Medium	Priorty: Medium
+
+4) Create a new I/O manager (i.e., test_io.c, unix_io.c, et.al.) which
+layers on top of an existing I/O manager which provides copy-on-write
+functionality.  This COW I/O manager takes will take two open I/O
+managers, call them "base" and "changed".  The "base" I/O manager is
+opened read/only, so any changes are written instead to the "changed"
+I/O manager, in a compact, non-sparse format containing the intended
+modification to the "base" filesystem.  
+
+This will allow resize2fs to figure out what changes need to made to
+extend a filesystem, or expand the size of inodes in the inode table,
+and the changes can be pushed the filesystem in one fell swoop.  (If
+the system crashes; the program which runs the "changed" file can be
+re-run, much like a journal replay.  My assumption is that the COW
+file will contain the filesystem UUID in a the COW superblock, and the
+COW file will be stored in some place such as /var/state/e2fsprogs,
+with an init.d file to automate the replay so we can recover cleanly
+from a crash during the resize2fs process.)
+
+	Difficulty: Medium	Priority: Medium
+
+5) Create a new I/O manager (i.e., test_io.c, unix_io.c, et.al.) which
+layers on top of an existing I/O manager which provides an "undo"
+functionality.  This undo I/O manager takes will take two open I/O
+managers, call them "base" and "undo".  The "base" I/O manager is be
+opened read/write, and when any writes are sent to the I/O manager,
+the I/O manager will check the "undo" I/O manager, using a file format
+identical to the one found in (5) above.  
+
+This is useful for allowing e2fsck to create an "undo" file, which
+would make things like "e2fsck -y" much safer.
+
+	Difficulty: Low (once 5 is done)  Priority: Low
+
+6) Modify resize2fs so that it can relocate and reorganize the
+filesystem in the following ways: (1) increase the inode size, so that
+an existing filesystem can use the EA-in-inode kernel patch, (2)
+reserve blocks in the resize inode to allow for on-line resizing.  Use
+the COW I/O manager described in (5) in order to provide robustness in
+case of a crash during the resize/reorganization operation.  
+
+	Difficulty: High	Priority: Medium
+
+7) Review the EA-in-inode patches to e2fsck for correctness/code
+cleanliness.  (I will probably have to do this myself -- Ted)
+
+	Difficulty: High	Priorty: Medium
+
+8) Add support for extent maps to e2fsprogs.  I need to review the
+extent maps first/in parallel. 
+
+	Difficulty: High	Priority: Medium
+
+----------------------------------
+
+Need to deal with the case where the resize inode overlaps with the
+bad blocks inode.
+
diff -Nurp e2fsprogs-1.40.8/util/Makefile.pq e2fsprogs/util/Makefile.pq
--- e2fsprogs-1.40.8/util/Makefile.pq	1970-01-01 01:00:00.000000000 +0100
+++ e2fsprogs/util/Makefile.pq	2008-03-29 01:20:43.000000000 +0100
@@ -0,0 +1,10 @@
+TOPSRC=..
+
+!include $(TOPSRC)\powerquest\MCONFIG
+
+ALL:: libecho.exe
+
+libecho.exe: libecho.c
+
+clean:: 
+	$(RM) libecho.exe
