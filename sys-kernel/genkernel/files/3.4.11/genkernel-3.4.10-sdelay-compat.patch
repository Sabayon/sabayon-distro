diff -Nurp genkernel-3.4.10.904.orig/defaults/initrd.scripts genkernel-3.4.10.904/defaults/initrd.scripts
--- genkernel-3.4.10.905.orig/defaults/initrd.scripts
+++ genkernel-3.4.10.905/defaults/initrd.scripts
@@ -794,6 +794,8 @@ sdelay() {
 	if [ -n "${SDELAY}" ]
 	then
 		sleep ${SDELAY}
+	elif grep cdroot /proc/cmdline > /dev/null 2>&1; then
+		sleep 3
 	else
 		sleep 1
 	fi
diff -Nurp genkernel-3.4.10.904.orig/defaults/initrd.scripts.orig genkernel-3.4.10.904/defaults/initrd.scripts.orig
--- genkernel-3.4.10.905.orig/defaults/initrd.scripts.orig
+++ genkernel-3.4.10.905/defaults/initrd.scripts.orig
@@ -0,0 +1,989 @@
+#!/bin/ash
+
+. /etc/initrd.defaults
+
+backup() {
+	echo -ne "\033[0G\033[0K"
+}
+
+parse_opt() {
+	case "$1" in
+		*\=*)
+			echo "$1" | cut -d= -f2-
+		;;
+	esac
+}
+
+modules_load() {
+	for module in $*
+	do
+		echo ${module} >> /etc/modules/extra_load
+	done
+
+	modules_scan extra_load
+}
+
+modules_scan() {
+	local MODS
+	[ -d "/etc/modules/${1}" ] || touch /etc/modules/${1}
+
+	[ -f "/etc/modules/${1}" ] && MODS=`cat /etc/modules/${1}`
+	for x in ${MODS}
+	do
+		MLOAD=`echo ${MLIST} | sed -e "s/.*${x}.*/${x}/"`
+		if [ "${MLOAD}" = "${x}" ] # Only module to no-load
+		then
+			echo -e "${BOLD}   ::${NORMAL} Skipping ${x}..."
+		elif [ "${MLOAD}" = "${MLIST}" ] # == No change == No specified no-load
+		then
+			[ -n "${DEBUG}" ] && echo -ne "${BOLD}   ::${NORMAL} Checking for ${x}..."
+			# find -name does not work since the return status is always zero
+			if find /lib/modules/${KV} | grep /"${x}${KSUFF}" >/dev/null 2>&1
+			then
+				echo -ne "${BOLD}   ::${NORMAL} Scanning for ${x}..."
+				modprobe ${x} -n
+				backup
+				echo -ne "${NORMAL}"
+			fi
+		else
+			echo -e "${BOLD}   ::${NORMAL} Skipping ${x}..."
+		fi
+	done
+}
+
+uppercase(){
+	# needs tr on busybox
+	echo $1 | tr 'a-z' 'A-Z'
+}
+
+
+findmediamount() {
+	# $1 = mount dir name / media name
+	# $2 = recognition file
+	# $3 = variable to have the device path
+	# $4 = directory before /mnt, like NEW_ROOT
+	# args remaining are possible devices 
+
+	local media=$1 recon=$2 vrbl=$3
+	local mntdir="${4}/mnt/${media}"
+	shift 4
+
+	good_msg "Looking for the ${media}" ${CRYPT_SILENT}
+
+	if [ "$#" -gt "0" ]
+	then
+
+		[ ! -d "${mntdir}" ] && mkdir -p ${mntdir} 2>/dev/null >/dev/null
+
+		for x in $*
+		do
+			# Check for a block device to mount
+			if [ -b "${x}" ]
+			then
+				skip=0
+				bsn=`basename "${x}"`
+				#
+				# If disk and it has at least one partition, skip.
+				# We use /sys/block/${bsn}/${bsn}[0-9]* to make sure that we
+				# don't skip device mapper devices. Even the craziest scenario
+				# deserves a fair chance.
+				#
+				for part in `ls /sys/block/${bsn}/${bsn}[0-9]* 2>/dev/null`
+				do
+					skip=1
+					break;
+				done
+				if [ ${skip} -eq 1 ]
+				then
+					continue
+				fi
+				good_msg "Attempting to mount media:- ${x}" ${CRYPT_SILENT}
+
+#				if [ "${media}" = "cdrom" ]; then
+#					mount -r -t iso9660 ${x} ${mntdir} &>/dev/null
+#				else
+#					mount -r -t auto ${x} ${mntdir} &>/dev/null
+#				fi
+				mount -r -t ${CDROOT_TYPE} ${x} ${mntdir} >/dev/null 2>&1
+				if [ "$?" = '0' ]
+				then
+					# Check for the media
+					if [ -f "${mntdir}/${recon}" ]
+					then
+						#set REAL_ROOT, CRYPT_ROOT_KEYDEV or whatever ${vrbl} is
+						eval ${vrbl}'='"${x}"
+						good_msg "Media found on ${x}" ${CRYPT_SILENT}
+						break
+					else
+						umount ${mntdir}
+					fi
+				fi
+			fi
+		done
+	fi
+
+	eval local result='$'${vrbl}
+
+	[ -n "${result}" ] || bad_msg "Media not found" ${CRYPT_SILENT}
+}
+
+devicelist(){
+	# Locate the cdrom device with our media on it.
+	# CDROM DEVICES
+	local DEVICES="/dev/cdroms/* /dev/ide/cd/* /dev/sr*"
+	# USB Keychain/Storage
+	DEVICES="$DEVICES /dev/sd*"
+	# IDE devices
+	DEVICES="$DEVICES /dev/hd*"
+	# USB using the USB Block Driver
+	DEVICES="$DEVICES /dev/ubd* /dev/ubd/*"
+	# iSeries devices
+	DEVICES="$DEVICES /dev/iseries/vcd*"
+	echo ${DEVICES}
+}
+
+bootstrapCD() {
+	local DEVICES=`devicelist`
+	# The device was specified on the command line, so there's no need to scan
+	# a bunch of extra devices
+	[ -n "${CDROOT_DEV}" ] && DEVICES="${CDROOT_DEV}"
+
+	findmediamount "cdrom" "${SUBDIR}/livecd" "REAL_ROOT" "${NEW_ROOT}" ${DEVICES}
+}
+
+bootstrapKey() {
+	# $1 = ROOT/SWAP
+	local KEYDEVS=`devicelist`
+	eval local keyloc='"${CRYPT_'${1}'_KEY}"'
+
+	findmediamount "key" "${keyloc}" "CRYPT_${1}_KEYDEV" "" ${KEYDEVS}
+}
+
+cache_cd_contents() {
+	# Check loop file exists and cache to ramdisk if DO_cache is enabled
+	if [ "${LOOPTYPE}" != "noloop" ] && [ "${LOOPTYPE}" != "sgimips" ]
+	then
+		check_loop
+		if [ "${DO_cache}" ]
+		then
+			# TODO: Check the size of the image versus the size of our tmpfs
+			# along with the amount of available RAM and increase tmpfs size
+			# if necessary. (Not having awk sucks...)
+			# z=0
+			# for i in $(cat /proc/meminfo | grep -e ^MemFree -e ^Cached | \
+			# cut -d: -f2 | cut -dk -f1 | sed -e "s/^\s*//") ; do
+			# z=$(($z + $i)) ; done
+			# echo $z
+			good_msg "Copying loop file for caching..."
+			cp -a ${NEW_ROOT}/mnt/cdrom/${LOOP} ${NEW_ROOT}/mnt/${LOOP}
+			if [ $? -ne 0 ]
+			then
+				bad_msg "Failed to cache the loop file! Lack of space?"
+				rm -rf ${NEW_ROOT}/mnt/livecd.* 2>/dev/null
+				rm -rf ${NEW_ROOT}/mnt/image.* 2>/dev/null
+				rm -rf ${NEW_ROOT}/mnt/zisofs 2>/dev/null
+			else
+				LOOPEXT='../'
+			fi
+		fi
+	fi
+}
+
+mount_sysfs() {
+	mount -t sysfs /sys /sys >/dev/null 2>&1
+	ret=$?
+	[ "$ret" -eq '0' ] || bad_msg "Failed to mount /sys!"
+}
+
+findnfsmount() {
+	if [ "${IP}" != '' ] || busybox udhcpc -n -T 15 -q
+	then
+		[ -e /rootpath ] && NFSROOT=`cat /rootpath`
+
+		if [ "${NFSROOT}" = '' ]
+		then
+			# Obtain NFSIP	
+			OPTIONS=`busybox dmesg | grep rootserver | sed -e "s/,/ /g"`
+			for OPTION in $OPTIONS
+			do
+				if [ `echo $OPTION | sed -e "s/=/ /g" | cut -d " " -f 1` = 'rootserver' ]
+				then
+					NFSIP=`echo $OPTION | sed -e "s/=/ /g" | cut -d " " -f 2`
+				fi 
+			done
+			
+			# Obtain NFSPATH
+			OPTIONS=`busybox dmesg | grep rootpath | sed -e "s/,/ /g"`	
+			for OPTION in $OPTIONS
+			do
+				if [ `echo $OPTION | sed -e "s/=/ /g" | cut -d " " -f 1` = 'rootpath' ]
+				then
+					NFSPATH=`echo $OPTION | sed -e "s/=/ /g" | cut -d " " -f 2`
+		 		fi
+			done
+
+			# Setup NFSROOT
+			if [ "${NFSIP}" != '' ] && [ "$NFSPATH" != '' ]
+			then
+				NFSROOT="${NFSIP}:${NFSPATH}"
+			else
+				bad_msg "The DHCP Server did not send a valid root-path."
+				bad_msg "Please check your DHCP setup, or provide a nfsroot=<...> parameter."
+			fi
+		fi
+
+		if [ "${NFSROOT}" != '' ]
+		then
+			if [ "${CDROOT}" != '0' ]
+			then
+				good_msg "Attempting to mount NFS CD image on ${NFSROOT}"
+				mount -t nfs -o ro,nolock,rsize=1024,wsize=1024 ${NFSROOT} ${NEW_ROOT}/mnt/cdrom
+				if [ "$?" = '0' ]
+				then
+					REAL_ROOT="/dev/nfs"
+				else
+					bad_msg "NFS Mounting failed. Is the path corrent ?"
+				fi
+			else	
+				good_msg "Attempting to mount NFS root on ${NFSROOT}"
+				mount -t nfs -o ro,nolock,rsize=1024,wsize=1024 ${NFSROOT} ${NEW_ROOT}
+				if [ "$?" = '0' ]
+				then
+					REAL_ROOT="/dev/nfs"
+				else
+					bad_msg "NFS Mounting failed. Is the path correct ?"
+				fi
+				# FIXME: Need to start portmap and the other rpc daemons in
+				# order to remount rw.
+			fi
+
+		fi
+	fi
+}
+
+check_loop() {
+	if [ "${LOOP}" = '' -o ! -e "mnt/cdrom/${LOOP}" ]
+	then
+	
+		bad_msg "Invalid loop location: ${LOOP}"
+		bad_msg 'Please export LOOP with a valid location, or reboot and pass a proper loop=...'
+		bad_msg 'kernel command line!'
+	
+		run_shell
+	fi
+}
+
+run_shell() {
+	/bin/ash
+}
+
+runmdev() {
+	# busybox udev replacement
+	mdev -s
+}
+
+test_success() {
+	retcode=$?
+	# If last command failed send error message and fall back to a shell	
+	if [ "$retcode" != '0' ]
+	then
+		error_string=$1
+		error_string="${error_string:-run command}"
+		bad_msg 'Failed to $1; failing back to the shell...'
+		run_shell
+	fi
+}
+
+
+# msg functions arguments
+# $1 string
+# $2 hide flag
+
+good_msg() {	
+	msg_string=$1
+	msg_string="${msg_string:-...}"
+	[ "$2" != 1 ] && echo -e "${GOOD}>>${NORMAL}${BOLD} ${msg_string} ${NORMAL}"
+}
+
+bad_msg() {
+	msg_string=$1
+	msg_string="${msg_string:-...}"
+	if [ "$2" != 1 ]
+	then
+		splash 'verbose' > /dev/null &
+		echo -e "${BAD}!!${NORMAL}${BOLD} ${msg_string} ${NORMAL}"
+	fi
+} 
+
+warn_msg() {
+	msg_string=$1
+	msg_string="${msg_string:-...}"
+	[ "$2" != 1 ] && echo -e "${WARN}**${NORMAL}${BOLD} ${msg_string} ${NORMAL}"
+}
+
+crypt_filter() {
+	if [ ${CRYPT_SILENT} -eq 1 ]
+	then
+		eval $1 >/dev/null 2>/dev/null
+	else
+		eval $1
+	fi
+}
+
+whereis(){
+	# $1 = variable whose value is the path (examples: "REAL_ROOT",
+	#      "LUKS_KEYDEV")
+	# $2 = label
+	# $3 = optional explanations for failure
+
+	eval local oldvalue='$'${1}
+
+	[ \( $# != 2 \) -a \( $# != 3 \) ] && \
+		bad_msg "Bad invocation of function whereis, please file a bug \
+		report with this message" && exit 1
+	[ -n "${3}" ] && local explnt=" or : ${3}" || local explnt="."
+	
+	bad_msg "Could not find the ${2} in ${oldvalue}${explnt}"
+	echo '   Please specify another value or: press Enter for the same, type "shell" for a shell, or "q" to skip...'
+	echo -n "${2}(${oldvalue}) :: "
+	read ${1}
+	case `eval echo '$'${1}` in
+		'q')
+			eval ${1}'='${oldvalue}
+			warn_msg "Skipping step, this will likely cause a boot failure."
+			break
+			;;
+		'shell')
+			eval ${1}'='${oldvalue}
+			echo "To leave and try again just press <Ctrl>+D"
+			run_shell
+			;;
+		'')
+			eval ${1}'='${oldvalue}
+			;;
+	esac
+}
+
+bind_mount_dev() {
+	# bind-mount /dev/ so that loop devices can be found
+	mount -o bind ${NEW_ROOT}/dev /dev
+}
+
+setup_hotplug() {
+	if [ "${KV_2_6_OR_GREATER}" ]
+	then
+		echo /sbin/mdev > /proc/sys/kernel/hotplug
+	fi
+}
+
+check_slowusb() {
+	[ "${DO_slowusb}" ] || \
+	for dir in /sys/bus/usb/drivers/usb-storage/*
+	do
+		[ -d "${dir}" ] && FORCE_slowusb="1"
+	done
+}
+
+start_dev_mgr() {
+	if [ "${KV_2_6_OR_GREATER}" ]
+	then
+		cd /sys
+		[ "${DO_slowusb}" ] && sdelay
+		check_slowusb
+		[ "${FORCE_slowusb}" ] && sdelay
+		good_msg 'Activating mdev'
+		runmdev
+		[ "${DO_slowusb}" ] || \
+		[ "${FORCE_slowusb}" ] && sdelay
+		cd /
+	fi
+}
+
+cmdline_hwopts() {
+	# Scan CMDLINE for any "doscsi" or "noscsi"-type arguments
+	local FOUND
+	local TMP_HWOPTS
+
+	for x in $HWOPTS
+	do
+		for y in $CMDLINE
+		do
+			if [ "${y}" = "do${x}" ]
+			then
+				MY_HWOPTS="${MY_HWOPTS} $x"
+			elif [ "${y}" = "no${x}" ]
+			then
+				MY_HWOPTS="`echo ${MY_HWOPTS} | sed -e \"s/${x}//g\" -`"
+			fi
+			if [ "$(echo ${y} | cut -b -7)" = "keymap=" ]
+			then
+				MY_HWOPTS="${MY_HWOPTS} dokeymap"
+			fi
+		done
+	done
+   
+	# Shouldnt need to sort this as the following loop should figure out the
+	# duplicates and strip them out
+	#MY_HWOPTS=`echo ${MY_HWOPTS}|  sort`
+	
+	for x in ${MY_HWOPTS}
+	do
+		FOUND=0
+		for y in ${TMP_HWOPTS}
+		do
+			if [ "${y}" = "${x}" ]
+			then 
+				continue 2
+			fi
+		done
+		TMP_HWOPTS="${TMP_HWOPTS} ${x}"
+		eval DO_`echo ${x} | sed 's/-//'`=1
+	done
+
+	MY_HWOPTS=${TMP_HWOPTS}
+}
+
+load_modules() {
+	# Load modules listed in MY_HWOPTS if /lib/modules exists for the running
+	# kernel version
+	if [ -d "/lib/modules/${KV}" ]
+	then
+		good_msg 'Loading modules'
+		# Load appropriate kernel modules
+		for modules in $MY_HWOPTS
+		do
+			modules_scan $modules
+		done
+	else
+		good_msg 'Skipping module load; no modules in the ramdisk!'
+	fi
+}
+
+setup_keymap() {
+	if [ "${DO_keymap}" ]
+	then
+		if [ ! -e /dev/vc/0 -a ! -e /dev/tty0 ]
+		then
+			DEVBIND=1
+			mount -o bind ${NEW_ROOT}/dev /dev
+		fi
+		[ ! -e /dev/tty0 ] && ln -s /dev/tty1 /dev/tty0
+
+		[ -f /lib/keymaps/keymapList ] && chooseKeymap
+
+		[ "${DEVBIND}" = '1' ] && umount /dev
+		
+		if [ -e /etc/sysconfig/keyboard -a "${CDROOT}" -eq '1' ]
+		then
+			mkdir -p ${NEW_ROOT}/etc/sysconfig/
+			cp /etc/sysconfig/keyboard ${NEW_ROOT}/etc/sysconfig/keyboard
+		fi
+	fi
+}
+
+chooseKeymap() {
+	good_msg "Loading keymaps"
+	if [ -z "${keymap}" ]
+	then
+		cat /lib/keymaps/keymapList
+		read -t 10 -p '<< Load keymap (Enter for default): ' keymap
+		case ${keymap} in
+			1|azerty) keymap=azerty ;;
+			2|be) keymap=be ;;
+			3|bg) keymap=bg ;;
+			4|br-a) keymap=br-a ;;
+			5|br-l) keymap=br-l ;;
+			6|by) keymap=by ;;
+			7|cf) keymap=cf ;;
+			8|croat) keymap=croat ;;
+			9|cz) keymap=cz ;;
+			10|de) keymap=de ;;
+			11|dk) keymap=dk ;;
+			12|dvorak) keymap=dvorak ;;
+			13|es) keymap=es ;;
+			14|et) keymap=et ;;
+			15|fi) keymap=fi ;;
+			16|fr) keymap=fr ;;
+			17|gr) keymap=gr ;;
+			18|hu) keymap=hu ;;
+			19|il) keymap=il ;;
+			20|is) keymap=is ;;
+			21|it) keymap=it ;;
+			22|jp) keymap=jp ;;
+			23|la) keymap=la ;;
+			24|lt) keymap=lt ;;
+			25|mk) keymap=mk ;;
+			26|nl) keymap=nl ;;
+			27|no) keymap=no ;;
+			28|pl) keymap=pl ;;
+			29|pt) keymap=pt ;;
+			30|ro) keymap=ro ;;
+			31|ru) keymap=ru ;;
+			32|se) keymap=se ;;
+			33|sg) keymap=sg ;;
+			34|sk-y) keymap=sk-y ;;
+			35|sk-z) keymap=sk-z ;;
+			36|slovene) keymap=slovene ;;
+			37|trf) keymap=trf ;;
+			38|trq) keymap=trq ;;
+			39|ua) keymap=ua ;;
+			40|uk) keymap=uk ;;
+			41|us) keymap=us ;;
+			42|wangbe) keymap=wangbe ;;
+		esac
+	fi
+	if [ -e /lib/keymaps/${keymap}.map ]
+	then
+		good_msg "Loading the ''${keymap}'' keymap"
+		loadkmap < /lib/keymaps/${keymap}.map
+#		xkeymap=${keymap}
+#		echo ${keymap} | egrep -e "[0-9]+" >/dev/null 2>&1
+#		if [ "$?" -eq '0'  ]
+#		then
+#			xkeymap=`tail -n 7 /lib/keymaps/keymapList | grep ${keymap} | sed -r "s/.*\s+${keymap}\s+([a-z-]+).*/\1/g" | egrep -v 1`
+#		fi
+		mkdir -p /etc/sysconfig
+#		echo "XKEYBOARD=${xkeymap}" > /etc/sysconfig/keyboard
+		echo "XKEYBOARD=${keymap}" > /etc/sysconfig/keyboard
+	elif [ -z "${keymap}" ]
+	then
+		echo
+		good_msg "Keeping default keymap"
+	else
+		bad_msg "Sorry, but keymap ''${keymap}'' is invalid!"
+		unset keymap
+		chooseKeymap
+	fi
+}
+
+startVolumes() {
+	#good_msg 'Checking if volumes need to be started...'
+
+	# Here, we check for /dev/device-mapper, and if it exists, we setup a
+	# a symlink, which should hopefully fix bug #142775 and bug #147015
+	if [ -e /dev/device-mapper ] && [ ! -e /dev/mapper/control ]
+	then
+		mkdir -p /dev/mapper
+		ln -sf /dev/device-mapper /dev/mapper/control
+	fi
+	
+	if [ "${USE_MDADM}" -eq '1' ]
+	then
+		if [ ! -e '/etc/mdadm.conf' ]
+		then
+			/sbin/mdadm --examine > /etc/mdadm.conf
+		fi
+		/sbin/mdadm --assemble
+	fi
+
+	if [ "${USE_DMRAID_NORMAL}" = '1' ]
+	then
+		if [ -e '/sbin/dmraid' ]
+		then
+			good_msg "Activating Device-Mapper RAID(s)"
+			if [ '${DMRAID_OPTS}' = '' ]
+			then
+				/sbin/dmraid -ay
+			else
+				/sbin/dmraid -ay ${DMRAID_OPTS}
+			fi
+		fi
+	fi
+
+	if [ "${USE_LVM_NORMAL}" = '1' ]
+	then
+		if [ -e '/bin/vgscan' -a -e '/bin/vgchange' ]
+		then
+			for dev in ${RAID_DEVICES}
+			do
+				setup_md_device "${dev}"
+			done
+
+			good_msg "Scanning for Volume Groups"
+			/bin/vgscan --ignorelockingfailure --mknodes 2>/dev/null
+			sleep 2
+			good_msg "Activating Volume Groups"
+			/bin/vgchange -ay --ignorelockingfailure 2>/dev/null
+
+			# Disable EVMS since lvm is activated and they dont work together.
+			if [ "${USE_EVMS_NORMAL}" = '1' ]
+			then
+				bad_msg "Disabling EVMS Support because LVM started"
+				bad_msg "Do not add dolvm to the cmdline if this is not what you want"
+				bad_msg "LVM and EVMS do not work well together"
+				USE_EVMS_NORMAL=0
+			fi
+		else
+			bad_msg "vgscan or vgchange not found: skipping LVM volume group activation!"
+		fi
+	fi
+
+	if [ "${USE_EVMS_NORMAL}" = '1' ]
+	then
+		if [ -e '/sbin/evms_activate' ]
+		then
+			good_msg "Activating EVMS"
+			evms_activate
+		fi
+	fi
+}
+
+# Open a LUKS device
+# It is either the root or a swap, other devices are supported in the scripts provided with sys-fs/cryptsetup-luks
+# $1 - root/swap
+openLUKS() {
+	# please use 'tr' and this line, or remove it
+	# eval local TYPE=`uppercase $1`
+
+	case $1 in
+		root)
+			local TYPE=ROOT
+			;;
+		swap)
+			local TYPE=SWAP
+			;;
+	esac
+
+	eval local LUKS_DEVICE='"${CRYPT_'${TYPE}'}"' LUKS_NAME="$1" LUKS_KEY='"${CRYPT_'${TYPE}'_KEY}"' LUKS_KEYDEV='"${CRYPT_'${TYPE}'_KEYDEV}"'
+	local DEV_ERROR=0 KEY_ERROR=0 KEYDEV_ERROR=0
+	local mntkey="/mnt/key/" cryptsetup_options=''
+
+	[ ! -e /sbin/cryptsetup ] && bad_msg "The ramdisk does not support LUKS" && exit 1
+	while [ 1 ]
+	do
+		# if crypt_silent=1 and some error occurs, enter shell quietly
+		if [ \( ${CRYPT_SILENT} -eq 1 \) -a \( \( \( ${DEV_ERROR} -eq 1 \) -o \( ${KEY_ERROR} -eq 1 \) \) -o \( ${KEYDEV_ERROR} -eq 1 \) \) ]
+		then
+			run_shell
+		elif [ ${DEV_ERROR} -eq 1 ]
+		then
+			whereis "LUKS_DEVICE" "${LUKS_NAME}"
+			DEV_ERROR=0
+		elif [ ${KEY_ERROR} -eq 1 ]
+		then
+			whereis "LUKS_KEY" "${LUKS_NAME} key"
+			KEY_ERROR=0
+		elif [ ${KEYDEV_ERROR} -eq 1 ]
+		then
+			whereis "LUKS_KEYDEV" "${LUKS_NAME} key device"
+			KEYDEV_ERROR=0
+		else
+			setup_md_device ${LUKS_DEVICE}
+			cryptsetup isLuks ${LUKS_DEVICE}
+			if [ ! "$?" -eq '0' ]
+			then
+				bad_msg "The LUKS device ${LUKS_DEVICE} does not contain a LUKS header" ${CRYPT_SILENT}
+				DEV_ERROR=1
+				continue
+			else
+				# Handle keys
+				if [ -n "${LUKS_KEY}" ] 
+				then
+					if [ ! -e "${mntkey}${LUKS_KEY}" ] 
+					then
+						if [ -b "${LUKS_KEYDEV}" ]
+						then good_msg "Using key device ${LUKS_KEYDEV}." ${CRYPT_SILENT}
+						else
+							good_msg "Please insert removable device ${LUKS_KEYDEV} for ${LUKS_NAME}" ${CRYPT_SILENT}
+							# abort after 10 secs
+							local count=10
+							while [ ${count} -gt 0 ]
+							do 
+								count=$((count-1))
+								sleep 1
+								if [ -b "${LUKS_KEYDEV}" ]
+								then
+									good_msg "Removable device ${LUKS_KEYDEV} detected." ${CRYPT_SILENT}
+									break
+								fi
+							done
+							if [ ! -b "${LUKS_KEYDEV}" ]
+							then
+								eval CRYPT_${TYPE}_KEY=${LUKS_KEY}
+								bootstrapKey ${TYPE}
+								eval LUKS_KEYDEV='"${CRYPT_'${TYPE}'_KEYDEV}"'
+								if [ ! -b "${LUKS_KEYDEV}" ]; then
+									KEYDEV_ERROR=1
+									bad_msg "Removable device ${LUKS_KEYDEV} not found." ${CRYPT_SILENT}
+									continue
+								fi
+								# continue otherwise will mount keydev which is mounted by bootstrap
+								continue
+							fi
+						fi
+						# At this point a device was recognized, now let's see if the key is there
+						[ ! -d "$mntkey" ] && mkdir -p ${mntkey} 2>/dev/null >/dev/null
+
+						mount -n -o ro ${LUKS_KEYDEV} ${mntkey} >/dev/null 2>/dev/null
+						if [ "$?" != '0' ]
+						then
+							KEYDEV_ERROR=1
+							bad_msg "Mounting of device ${LUKS_KEYDEV} failed." ${CRYPT_SILENT}
+							continue
+						else
+							good_msg "Removable device ${LUKS_KEYDEV} mounted." ${CRYPT_SILENT}
+							sleep 2
+							# keyfile exists?
+							if [ ! -e "${mntkey}${LUKS_KEY}" ]; then
+								umount -n ${mntkey} 2>/dev/null >/dev/null
+								KEY_ERROR=1
+								KEYDEV_ERROR=1
+								bad_msg "Key {LUKS_KEY} on device ${LUKS_KEYDEV} not found." ${CRYPT_SILENT}
+								continue
+							fi
+						fi
+					fi
+					# At this point a candidate key exists (either mounted before or not)
+					good_msg "${LUKS_KEY} on device ${LUKS_KEYDEV} found" ${CRYPT_SILENT}
+					cryptsetup_options="-d ${mntkey}${LUKS_KEY}"
+				fi
+				# At this point, keyfile or not, we're ready!
+				crypt_filter "cryptsetup ${cryptsetup_options} luksOpen ${LUKS_DEVICE} ${LUKS_NAME}"
+				if [ $? -eq 0 ]
+				then
+					good_msg "LUKS device ${LUKS_DEVICE} opened" ${CRYPT_SILENT}
+					break
+				else
+					bad_msg "Failed to open LUKS device ${LUKS_DEVICE}" ${CRYPT_SILENT}
+					DEV_ERROR=1
+					KEY_ERROR=1
+					KEYDEV_ERROR=1
+				fi
+			fi
+		fi
+	done
+	umount ${mntkey} 2>/dev/null >/dev/null
+	rmdir -p ${mntkey} 2>/dev/null >/dev/null
+}
+
+startLUKS() {
+
+	# if key is set but key device isn't, find it
+	
+	[ -n "${CRYPT_ROOT_KEY}" ] && [ -z "${CRYPT_ROOT_KEYDEV}" ] \
+		&& sleep 6 && bootstrapKey "ROOT"
+
+	if [ -n "${CRYPT_ROOT}" ]; then
+		openLUKS "root"
+		if [ -n "${REAL_ROOT}" ]
+		then
+			# Rescan volumes
+			startVolumes
+		else
+			REAL_ROOT="/dev/mapper/root"
+		fi
+	fi
+
+	# same for swap, but no need to sleep if root was unencrypted
+	[ -n "${CRYPT_SWAP_KEY}" ] && [ -z "${CRYPT_SWAP_KEYDEV}" ] \
+		&& { [ -z "${CRYPT_ROOT}" ] && sleep 6; bootstrapKey "SWAP"; }
+
+	if [ -n "${CRYPT_SWAP}" ]; then
+		openLUKS "swap"
+		if [ -z "${REAL_RESUME}" ]
+		then
+			# Resume from swap as default
+			REAL_RESUME="/dev/mapper/swap"
+		fi
+	fi
+}
+
+sdelay() {
+	# Sleep a specific number of seconds if SDELAY is set otherwise only sleep
+	# 1 second
+	if [ -n "${SDELAY}" ]
+	then
+		sleep ${SDELAY}
+	else
+		sleep 1
+	fi
+}
+
+quiet_kmsg() {
+	# if QUIET is set make the kernel less chatty
+	[ -n "$QUIET" ] && echo '0' > /proc/sys/kernel/printk
+}
+
+verbose_kmsg() {
+	# if QUIET is set make the kernel less chatty
+	[ -n "$QUIET" ] && echo '6' > /proc/sys/kernel/printk
+}
+
+
+cdupdate() {
+	if [ "${CDROOT}" = '1' ]
+	then
+		if [ -x /${NEW_ROOT}/mnt/cdrom/cdupdate.sh ]
+		then
+			good_msg "Running cdupdate.sh"
+			${NEW_ROOT}/mnt/cdrom/cdupdate.sh
+			if [ "$?" != '0' ]
+			then
+				bad_msg "Executing cdupdate.sh failed!"
+				run_shell
+			fi
+		else
+			good_msg 'No cdupdate.sh script found, skipping...'
+		fi
+	fi
+}
+
+setup_md_device() {
+	local device
+
+	[ -z "$1" ] && device="${REAL_ROOT}" || device="$1"
+	[ -z "${device}" ] && return # LiveCD
+
+	if [ `echo ${device}|sed -e 's#\(luks:\)\?\(/dev/md\)[[:digit:]]\+#\2#'` = "/dev/md" ]
+	then
+		good_msg 'Detected real_root as a md device. Setting up the device node...'
+		MD_NUMBER=`echo ${device}|sed -e 's#\(luks:\)\?/dev/md\([[:digit:]]\+\)#\2#'`
+		if [ ! -e /dev/md${MD_NUMBER} ]
+		then
+			mknod /dev/md${MD_NUMBER} b 9 ${MD_NUMBER} >/dev/null 2>&1
+			[ "$?" -ne 0 ] && bad_msg "Creation of /dev/md${MD_NUMBER} failed..."
+		fi
+		mdstart ${MDPART} /dev/md${MD_NUMBER}
+	fi
+}
+
+rundebugshell() {
+	if [ -n "$DEBUG" ]
+	then
+		good_msg 'Starting debug shell as requested by "debug" option.'
+		good_msg 'Type "exit" to continue with normal bootup.'
+		[ -x /bin/sh ] && /bin/sh || /bin/ash
+	fi
+}
+
+swsusp_resume() {
+	# determine swap resume partition
+	local device=$(ls -l "${REAL_RESUME}" | sed 's/\ */ /g' | cut -d \  -f 6-7 | sed 's/,\ */:/')
+	[ -f /sys/power/resume ] && echo "${device}" > /sys/power/resume
+	return 0
+}
+
+tuxonice_resume() {
+	[ -d /proc/suspend2 -o -d /sys/power/suspend2 -o -d /sys/power/tuxonice ] || return
+
+	local splash_theme
+
+	if grep "splash=" /proc/cmdline > /dev/null 2>&1; then
+		splash_theme=$(cat /proc/cmdline | sed 's/.*splash=/splash=/' | sed 's/ .*//' | sed 's/.*theme://' | sed 's/,.*//')
+	fi
+
+	local tuxonice_userui_program="/sys/power/tuxonice/user_interface/program"
+	local tuxonice_do_resume="/sys/power/tuxonice/do_resume"
+
+	#
+	# Backward compatibility
+	#
+	if [ -e /sys/power/suspend2 ]; then
+		tuxonice_userui_program="/sys/power/suspend2/user_interface/program"
+		tuxonice_do_resume="/sys/power/suspend2/do_resume"
+	elif [ -e /proc/suspend2 ]; then
+		tuxonice_userui_program="/proc/suspend2/userui_program"
+		tuxonice_do_resume="/proc/suspend2/do_resume"
+	fi
+
+	modules_scan tuxonice
+
+	if ! grep suspend_noui /proc/cmdline > /dev/null 2>&1; then
+		which suspend2ui_text > /dev/null 2>&1 && which suspend2ui_text > "${tuxonice_userui_program}"
+		which tuxoniceui_text > /dev/null 2>&1 && which tuxoniceui_text > "${tuxonice_userui_program}"
+
+		if [ -n "${splash_theme}" ]; then
+			ln -s /etc/splash/${splash_theme} /etc/splash/suspend2
+			ln -s /etc/splash/${splash_theme} /etc/splash/tuxonice
+
+			which suspend2ui_fbsplash > /dev/null 2>&1 && which suspend2ui_fbsplash > "${tuxonice_userui_program}"
+			which tuxoniceui_fbsplash > /dev/null 2>&1 && which tuxoniceui_fbsplash > "${tuxonice_userui_program}"
+		fi
+
+		echo > "${tuxonice_do_resume}"
+	fi
+}
+
+find_loop() {
+	CDROM="${NEW_ROOT}/mnt/cdrom"
+	for loop in ${LOOPS}
+	do
+		if [ -e "${CDROM}""${loop}" ]
+		then
+			LOOP="${loop}"
+		fi
+	done
+}
+
+find_looptype() {
+	LOOPTYPE="${LOOP##*.}"
+	[ "${LOOPTYPE}" == "loop" ] && LOOPTYPE="normal"
+	[ "${LOOP}" == "/zisofs" ] && LOOPTYPE="${LOOP#/}"
+	[ -z "${LOOPTYPE}" ] && LOOPTYPE="noloop"
+}
+
+getdvhoff() {
+	echo $(( $(hexdump -n 4 -s $((316 + 12 * $2)) -e '"%i"' $1) * 512))
+}
+
+setup_unionfs() {
+	local rw_dir=$1
+	local ro_dir=$2
+	if [ "${USE_UNIONFS_NORMAL}" = '1' ]
+	then
+		# Directory used for rw changes in union mount filesystem
+		UNION=/union
+#		MEMORY=/memory
+#		if [ -z "$UID" ]
+#		then
+#			CHANGES=$MEMORY/unionfs_changes/default
+#		else
+#			CHANGES=$MEMORY/unionfs_changes/$UID
+#		fi
+
+#		mkdir -p ${MEMORY}
+		mkdir -p ${UNION}
+		good_msg "Loading fuse module"
+		modprobe fuse > /dev/null 2>&1
+#                 if [ -n "${UNIONFS}" ] 	 
+#                 then 	 
+#                         CHANGESDEV=${UNIONFS} 	 
+#                         good_msg "mounting $CHANGESDEV to $MEMORY for unionfs support" 	 
+#                         mount -t auto $CHANGESDEV $MEMORY 	 
+#                         # mount tmpfs only in the case when changes= boot parameter was 	 
+#                         # empty or we were not able to mount the storage device 	 
+#                         ret=$? 	 
+#                         if [ "${ret}" -ne 0 ] 	 
+#                         then 	 
+#                                 bad_msg "mount of $CHANGESDEV failed falling back to ramdisk based unionfs" 	 
+#                                 mount -t tmpfs tmpfs $MEMORY 	 
+#                         fi 	 
+#                         if [ "${CDROOT}" -eq '1' -a ! -f ${MEMORY}/livecd.unionfs  ] 	 
+#                         then 	 
+#                                 umount $MEMORY 	 
+#                                 bad_msg "failed to find livecd.unionfs file on $CHANGESDEV" 	 
+#                                 bad_msg "create a livecd.unionfs file on this device if you wish to use it for unionfs" 	 
+#                                 bad_msg "falling back to ramdisk based unionfs for safety" 	 
+#                                 mount -t tmpfs tmpfs $MEMORY 	 
+#                         fi 	 
+#                 else 	 
+#                         good_msg "Mounting ramdisk to $MEMORY for unionfs support..." 	 
+#                         mount -t tmpfs tmpfs $MEMORY 	 
+#                 fi 	 
+  	 
+		mkdir /tmp
+		mkdir -p ${UNION}
+#		mkdir -p $CHANGES
+#		mount -t unionfs -o dirs=$CHANGES=rw unionfs ${UNION}
+		good_msg "Creating union mount"
+		unionfs -o allow_other,cow,noinitgroups,suid,dev,default_permissions,use_ino ${rw_dir}=RW:${ro_dir}=RO ${UNION} 2>/dev/null
+		ret=$?
+		if [ "${ret}" -ne 0 ]
+		then
+			bad_msg "Can't setup union mount!"
+			USE_UNIONFS_NORMAL=0
+		fi
+	else
+		USE_UNIONFS_NORMAL=0
+	fi
+}
