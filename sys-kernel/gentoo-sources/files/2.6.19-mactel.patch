--- a/drivers/acpi/blacklist.c	2006-06-26 08:32:21.000000000 +0200
+++ a/drivers/acpi/blacklist.c	2006-06-26 08:32:59.000000000 +0200
@@ -78,6 +78,10 @@
 static int __init blacklist_by_year(void)
 {
 	int year = dmi_get_year(DMI_BIOS_DATE);
+
+	if (efi_enabled)
+		return 0;
+
 	/* Doesn't exist? Likely an old system */
 	if (year == -1) 
 		return 1;
diff -pruN linux/drivers/hwmon.vanilla/Kconfig linux/drivers/hwmon/Kconfig
--- linux/drivers/hwmon.vanilla/Kconfig	2006-11-30 21:14:48.000000000 +0800
+++ linux/drivers/hwmon/Kconfig	2006-11-30 20:52:23.000000000 +0800
@@ -539,6 +539,28 @@ config SENSORS_HDAPS
 	  Say Y here if you have an applicable laptop and want to experience
 	  the awesome power of hdaps.
 
+config SENSORS_APPLESMC
+	tristate "Apple SMC (Motion sensor, light sensor, keyboard backlight)"
+	depends on HWMON && INPUT && X86
+	select NEW_LEDS
+	select LEDS_CLASS
+	default n
+	help
+	  This driver provides support for the Apple System Management
+	  Controller, which provides an accelerometer (Apple Sudden Motion
+	  Sensor), light sensors, and keyboard backlight control.
+
+	  Only Intel-based Apple's laptops are supported (MacBook Pro, MacBook).
+
+	  The accelerometer and light sensors data is readable via sysfs, and
+	  the keyboard backlight is writable.
+
+	  This driver also provides an absolute input class device, allowing
+	  the laptop to act as a pinball machine-esque joystick.
+
+	  Say Y here if you have an applicable laptop and want to experience
+	  the awesome power of applesmc.
+
 config HWMON_DEBUG_CHIP
 	bool "Hardware Monitoring Chip debugging messages"
 	depends on HWMON
diff -pruN linux/drivers/hwmon.vanilla/Makefile linux/drivers/hwmon/Makefile
--- linux/drivers/hwmon.vanilla/Makefile	2006-11-30 21:14:48.000000000 +0800
+++ linux/drivers/hwmon/Makefile	2006-11-30 20:47:51.000000000 +0800
@@ -18,6 +18,7 @@ obj-$(CONFIG_SENSORS_ADM1025)	+= adm1025
 obj-$(CONFIG_SENSORS_ADM1026)	+= adm1026.o
 obj-$(CONFIG_SENSORS_ADM1031)	+= adm1031.o
 obj-$(CONFIG_SENSORS_ADM9240)	+= adm9240.o
+obj-$(CONFIG_SENSORS_APPLESMC)	+= applesmc.o
 obj-$(CONFIG_SENSORS_ATXP1)	+= atxp1.o
 obj-$(CONFIG_SENSORS_CORETEMP)	+= coretemp.o
 obj-$(CONFIG_SENSORS_DS1621)	+= ds1621.o
diff -pruN linux/drivers/hwmon.vanilla/applesmc.c linux/drivers/hwmon/applesmc.c
--- linux/drivers/hwmon.vanilla/applesmc.c	1970-01-01 07:30:00.000000000 +0730
+++ linux/drivers/hwmon/applesmc.c	2006-11-30 20:47:51.000000000 +0800
@@ -0,0 +1,913 @@
+/*
+ * drivers/hwmon/applesmc.c - driver for Apple's SMC (various sensors,
+ * fan control)
+ *
+ * Copyright (C) 2006 Nicolas Boichat <nicolas@boichat.ch>
+ *
+ * Based on hdaps.c driver:
+ * Copyright (C) 2005 Robert Love <rml@novell.com>
+ * Copyright (C) 2005 Jesper Juhl <jesper.juhl@gmail.com>
+ *
+ * Fan control based on smcFanControl:
+ * Copyright (C) 2006 Hendrik Holtmann <holtmann@mac.com>
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License v2 as published by the
+ * Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA
+ */
+
+#include <linux/delay.h>
+#include <linux/platform_device.h>
+#include <linux/input.h>
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/timer.h>
+#include <linux/dmi.h>
+#include <asm/io.h>
+#include <linux/leds.h>
+
+/* data port used by apple SMC */
+#define APPLESMC_DATA_PORT	0x300
+/* command/status port used by apple SMC */
+#define APPLESMC_CMD_PORT	0x304
+
+#define APPLESMC_NR_PORTS	5     /* 0x300-0x304 */
+
+#define APPLESMC_STATUS_MASK	0x0f
+#define APPLESMC_READ_CMD	0x10
+#define APPLESMC_WRITE_CMD	0x11
+
+#define LIGHT_SENSOR_LEFT_KEY	"ALV0" //r-o length 6
+#define LIGHT_SENSOR_RIGHT_KEY	"ALV1" //r-o length 6
+#define BACKLIGHT_KEY 		"LKSB" //w-o
+
+#define CLAMSHELL_KEY 		"MSLD" //r-o length 1 (unused)
+
+#define MOTION_SENSOR_X_KEY	"MO_X" //r-o length 2
+#define MOTION_SENSOR_Y_KEY	"MO_Y" //r-o length 2
+#define MOTION_SENSOR_Z_KEY	"MO_Z" //r-o length 2
+#define MOTION_SENSOR_KEY       "MOCN" //r/w length 2
+
+#define FANS_COUNT              "FNum" //r-o length 1
+#define FANS_MANUAL             "FS! " //r-w length 2
+#define FAN_ACTUAL_SPEED        "F0Ac" //r-o length 2
+#define FAN_MIN_SPEED           "F0Mn" //r-o length 2
+#define FAN_MAX_SPEED           "F0Mx" //r-o length 2
+#define FAN_SAFE_SPEED          "F0Sf" //r-o length 2
+#define FAN_TARGET_SPEED        "F0Tg" //r-w length 2
+
+static const char* temperature_sensors_sets[][8] =
+{
+	{ "TB0T", "TC0D", "TC0P", "Th0H", "Ts0P", "Th1H", "Ts1P", NULL },
+	{ "TC0D", "TC0P", NULL }
+};
+
+#define INIT_TIMEOUT_MSECS	5000	/* wait up to 5s for device init ... */
+#define INIT_WAIT_MSECS		50	/* ... in 50ms increments */
+
+#define APPLESMC_POLL_PERIOD	(HZ/20)	/* poll for input every 1/20s */
+#define APPLESMC_INPUT_FUZZ	4	/* input event threshold */
+#define APPLESMC_INPUT_FLAT	4
+
+#define SENSOR_X 0
+#define SENSOR_Y 1
+#define SENSOR_Z 2
+
+/* Structure to be passed to DMI_MATCH function */
+struct dmi_match_data {
+/* Indicate whether this computer has an accelerometer. */
+	int accelerometer;
+/* Indicate whether this computer has light sensors and keyboard backlight. */
+	int light;
+/* Indicate which temperature sensors set to use. */
+	int temperature_set;
+};
+
+static int debug = 0;
+static struct platform_device *pdev;
+static s16 rest_x;
+static s16 rest_y;
+static struct timer_list applesmc_timer;
+static struct input_dev *applesmc_idev;
+
+/* Indicate whether this computer has an accelerometer. */
+static unsigned int applesmc_accelerometer = 0;
+
+/* Indicate whether this computer has light sensors and keyboard backlight. */
+static unsigned int applesmc_light = 0;
+
+/* Indicate which temperature sensors set to use. */
+static unsigned int applesmc_temperature_set = 0;
+
+static DECLARE_MUTEX(applesmc_sem);
+
+/*
+ * __wait_status - Wait up to 100ms for the status port to get a certain value
+ * (masked with 0x0f), returning zero if the value is obtained.  Callers must
+ * hold applesmc_sem.
+ */
+static int __wait_status(u8 val)
+{
+	unsigned int i;
+
+	val = val & APPLESMC_STATUS_MASK;
+
+	for (i = 0; i < 10000; i++) {
+		if ((inb(APPLESMC_CMD_PORT) & APPLESMC_STATUS_MASK) == val)
+			return 0;
+		udelay(10);
+	}
+
+	printk(KERN_WARNING "applesmc: wait status failed: %x != %x\n",
+						val, inb(APPLESMC_CMD_PORT));
+
+	return -EIO;
+}
+
+/*
+ * applesmc_read_key - reads len bytes from a given key, and put them in buffer.
+ * Returns zero on success or a negative error on failure. Callers must
+ * hold applesmc_sem.
+ */
+static int applesmc_read_key(const char* key, u8* buffer, u8 len)
+{
+	int ret = -EIO;
+	int i;
+
+	outb(APPLESMC_READ_CMD, APPLESMC_CMD_PORT);
+	if (__wait_status(0x0c))
+		goto out;
+	
+	for (i = 0; i < 4; i++) {
+		outb(key[i], APPLESMC_DATA_PORT);
+		if (__wait_status(0x04))
+			goto out;
+	}
+	if (debug) printk(KERN_DEBUG "<%s", key);
+
+	outb(len, APPLESMC_DATA_PORT);
+	if (debug) printk(KERN_DEBUG ">%x", len);
+
+	for (i = 0; i < len; i++) {
+		if (__wait_status(0x05))
+			goto out;
+		buffer[i] = inb(APPLESMC_DATA_PORT);
+		if (debug) printk(KERN_DEBUG "<%x", buffer[i]);
+	}
+	if (debug) printk(KERN_DEBUG "\n");
+	ret = 0;
+
+out:
+	return ret;
+}
+
+/*
+ * applesmc_write_key - writes len bytes from buffer to a given key.
+ * Returns zero on success or a negative error on failure. Callers must
+ * hold applesmc_sem.
+ */
+static int applesmc_write_key(const char* key, u8* buffer, u8 len)
+{
+	int ret = -EIO;
+	int i;
+
+	outb(APPLESMC_WRITE_CMD, APPLESMC_CMD_PORT);
+	if (__wait_status(0x0c))
+		goto out;
+	
+	for (i = 0; i < 4; i++) {
+		outb(key[i], APPLESMC_DATA_PORT);
+		if (__wait_status(0x04))
+			goto out;
+	}
+
+	outb(len, APPLESMC_DATA_PORT);
+
+	for (i = 0; i < len; i++) {
+		if (__wait_status(0x04))
+			goto out;
+		outb(buffer[i], APPLESMC_DATA_PORT);
+	}
+
+	ret = 0;
+out:
+	return ret;
+}
+
+/*
+ * applesmc_read_motion_sensor - Read motion sensor (X, Y or Z). Callers must
+ * hold applesmc_sem.
+ */
+static int applesmc_read_motion_sensor(int index, s16* value) {
+	u8 buffer[2];
+	int ret;
+
+	switch (index) {
+	case SENSOR_X:
+		ret = applesmc_read_key(MOTION_SENSOR_X_KEY, buffer, 2);
+		break;
+	case SENSOR_Y:
+		ret = applesmc_read_key(MOTION_SENSOR_Y_KEY, buffer, 2);
+		break;
+	case SENSOR_Z:
+		ret = applesmc_read_key(MOTION_SENSOR_Z_KEY, buffer, 2);
+		break;
+	default:
+		ret = -EINVAL;
+	}
+
+	*value = ((s16)buffer[0] << 8) | buffer[1];
+
+	return ret;
+}
+
+/*
+ * applesmc_device_init - initialize the accelerometer.  Returns zero on success
+ * and negative error code on failure.  Can sleep.
+ */
+static int applesmc_device_init(void)
+{
+	int total, ret = -ENXIO;
+	u8 buffer[2];
+
+	if (!applesmc_accelerometer) return 0;
+
+	down(&applesmc_sem);
+
+	for (total = INIT_TIMEOUT_MSECS; total > 0; total -= INIT_WAIT_MSECS) {
+		if (debug) printk(KERN_DEBUG "applesmc try %d\n", total);
+		if (!applesmc_read_key(MOTION_SENSOR_KEY, buffer, 2) &&
+				(buffer[0] != 0x00 || buffer[1] != 0x00)) {
+			if (total == INIT_TIMEOUT_MSECS) {
+				printk(KERN_DEBUG "applesmc: device has" 
+						" already been initialized"
+						" (0x%02x, 0x%02x).\n",
+						buffer[0], buffer[1]);
+			}
+			else {
+				printk(KERN_DEBUG "applesmc: device" 
+						" successfully initialized"
+						" (0x%02x, 0x%02x).\n",
+						buffer[0], buffer[1]);
+			}
+			ret = 0;
+			goto out;
+		}
+		buffer[0] = 0xe0;
+		buffer[1] = 0x00;
+		applesmc_write_key(MOTION_SENSOR_KEY, buffer, 2);
+		msleep(INIT_WAIT_MSECS);
+	}
+
+	printk(KERN_WARNING "applesmc: failed to init the device\n");
+
+out:
+	up(&applesmc_sem);
+	return ret;
+}
+
+/*
+ * applesmc_get_fan_count - get the number of fans. Callers must NOT hold
+ * applesmc_sem.
+ */
+static int applesmc_get_fan_count(void)
+{
+	int ret;
+	u8 buffer[1];
+
+	down(&applesmc_sem);
+
+	ret = applesmc_read_key(FANS_COUNT, buffer, 1);
+
+	up(&applesmc_sem);
+	if (ret)
+		return ret;
+	else
+		return buffer[0];
+}
+
+/* Device model stuff */
+static int applesmc_probe(struct platform_device *dev)
+{
+	int ret;
+
+	ret = applesmc_device_init();
+	if (ret)
+		return ret;
+
+	printk(KERN_INFO "applesmc: device successfully initialized.\n");
+	return 0;
+}
+
+static int applesmc_resume(struct platform_device *dev)
+{
+	return applesmc_device_init();
+}
+
+static struct platform_driver applesmc_driver = {
+	.probe = applesmc_probe,
+	.resume = applesmc_resume,
+	.driver	= {
+		.name = "applesmc",
+		.owner = THIS_MODULE,
+	},
+};
+
+/*
+ * applesmc_calibrate - Set our "resting" values.  Callers must hold applesmc_sem.
+ */
+static void applesmc_calibrate(void)
+{
+	applesmc_read_motion_sensor(SENSOR_X, &rest_x);
+	applesmc_read_motion_sensor(SENSOR_Y, &rest_y);
+}
+
+static void applesmc_mousedev_poll(unsigned long unused)
+{
+	s16 x, y;
+
+	/* Cannot sleep.  Try nonblockingly.  If we fail, try again later. */
+	if (down_trylock(&applesmc_sem)) {
+		mod_timer(&applesmc_timer,jiffies + APPLESMC_POLL_PERIOD);
+		return;
+	}
+
+	if (applesmc_read_motion_sensor(SENSOR_X, &x))
+		goto out;
+	if (applesmc_read_motion_sensor(SENSOR_Y, &y))
+		goto out;
+
+
+	input_report_abs(applesmc_idev, ABS_X, x - rest_x);
+	input_report_abs(applesmc_idev, ABS_Y, y - rest_y);
+	input_sync(applesmc_idev);
+
+out:
+	mod_timer(&applesmc_timer, jiffies + APPLESMC_POLL_PERIOD);
+
+	up(&applesmc_sem);
+}
+
+/* Sysfs Files */
+
+static ssize_t applesmc_position_show(struct device *dev,
+				   struct device_attribute *attr, char *buf)
+{
+	int ret;
+	s16 x, y, z;
+
+	down(&applesmc_sem);
+
+	ret = applesmc_read_motion_sensor(SENSOR_X, &x);
+	if (ret)
+		goto out;
+	ret = applesmc_read_motion_sensor(SENSOR_Y, &y);
+	if (ret)
+		goto out;
+	ret = applesmc_read_motion_sensor(SENSOR_Z, &z);
+	if (ret)
+		goto out;
+
+out:
+	up(&applesmc_sem);
+	if (ret)
+		return ret;
+	else
+		return sprintf(buf, "(%d,%d,%d)\n", x, y, z);
+}
+
+static ssize_t applesmc_light_show(struct device *dev,
+				   struct device_attribute *attr, char *buf)
+{
+	int ret;
+	u8 left = 0, right = 0;
+	u8 buffer[6];
+
+	down(&applesmc_sem);
+
+	ret = applesmc_read_key(LIGHT_SENSOR_LEFT_KEY, buffer, 6);
+	left = buffer[2];
+	if (ret)
+		goto out;
+	ret = applesmc_read_key(LIGHT_SENSOR_RIGHT_KEY, buffer, 6);
+	right = buffer[2];
+
+out:
+	up(&applesmc_sem);
+	if (ret)
+		return ret;
+	else
+		return sprintf(buf, "(%d,%d)\n", left, right);
+}
+
+/* Displays Â°C * 100 */
+static ssize_t applesmc_show_temperature(struct device *dev, char *buf, const char *key)
+{
+    int ret;
+    u8 buffer[2];
+    unsigned int temp;
+    
+    down(&applesmc_sem);
+
+    ret = applesmc_read_key(key, buffer, 2);
+    temp = buffer[0]*100;
+    temp += (buffer[1] >> 6) * 25;
+
+    up(&applesmc_sem);
+
+    if (ret)
+	return ret;
+    else
+	return sprintf(buf, "%u\n", temp);
+}
+
+static ssize_t applesmc_show_fan_speed(struct device *dev, char *buf,
+						const char* key, int offset)
+{
+	int ret;
+	unsigned int speed = 0;
+	char newkey[5];
+	u8 buffer[2];
+
+	newkey[0] = key[0];
+	newkey[1] = '0' + offset;
+	newkey[2] = key[2];
+	newkey[3] = key[3];
+	newkey[4] = 0;
+
+	down(&applesmc_sem);
+
+	ret = applesmc_read_key(newkey, buffer, 2);
+	speed = ((buffer[0] << 8 | buffer[1]) >> 2);
+
+	up(&applesmc_sem);
+	if (ret)
+		return ret;
+	else
+		return sprintf(buf, "%u\n", speed);
+}
+
+static ssize_t applesmc_store_fan_speed(struct device *dev, const char *buf,
+					size_t count, const char* key, int offset)
+{
+	int ret;
+	u32 speed;
+	char newkey[5];
+	u8 buffer[2];
+
+	speed = simple_strtoul(buf, NULL, 10);
+
+	if (speed > 0x4000) /* Bigger than a 14-bit value */
+		return -EINVAL;
+
+	newkey[0] = key[0];
+	newkey[1] = '0' + offset;
+	newkey[2] = key[2];
+	newkey[3] = key[3];
+	newkey[4] = 0;
+
+	down(&applesmc_sem);
+
+	buffer[0] = (speed >> 6) & 0xff;
+	buffer[1] = (speed << 2) & 0xff;
+	ret = applesmc_write_key(newkey, buffer, 2);
+
+	up(&applesmc_sem);
+	if (ret)
+		return ret;
+	else
+		return count;
+}
+
+static ssize_t applesmc_show_fan_manual(struct device *dev, char *buf,
+								int offset)
+{
+	int ret;
+	u16 manual = 0;
+	u8 buffer[2];
+
+	down(&applesmc_sem);
+
+	ret = applesmc_read_key(FANS_MANUAL, buffer, 2);
+	manual = ((buffer[0] << 8 | buffer[1]) >> offset) & 0x01;
+
+	up(&applesmc_sem);
+	if (ret)
+		return ret;
+	else
+		return sprintf(buf, "%d\n", manual);
+}
+
+static ssize_t applesmc_store_fan_manual(struct device *dev, const char *buf,
+						size_t count, int offset)
+{
+	int ret;
+	u8 buffer[2];
+	u32 input;
+	u16 val;
+
+	input = simple_strtoul(buf, NULL, 10);
+
+	down(&applesmc_sem);
+
+	ret = applesmc_read_key(FANS_MANUAL, buffer, 2);
+	val = (buffer[0] << 8 | buffer[1]);
+	if (ret)
+		goto out;
+
+	if (input)
+		val = val | (0x01 << offset);
+	else 
+		val = val & ~(0x01 << offset);
+
+	buffer[0] = (val >> 8) & 0xFF;
+	buffer[1] = val & 0xFF;
+
+	ret = applesmc_write_key(FANS_MANUAL, buffer, 2);
+
+out:
+	up(&applesmc_sem);
+	if (ret)
+		return ret;
+	else
+		return count;
+}
+
+static ssize_t applesmc_calibrate_show(struct device *dev,
+				    struct device_attribute *attr, char *buf)
+{
+	return sprintf(buf, "(%d,%d)\n", rest_x, rest_y);
+}
+
+static ssize_t applesmc_calibrate_store(struct device *dev,
+				     struct device_attribute *attr,
+				     const char *buf, size_t count)
+{
+	down(&applesmc_sem);
+	applesmc_calibrate();
+	up(&applesmc_sem);
+
+	return count;
+}
+
+static void applesmc_backlight_set(struct led_classdev *led_cdev,
+				enum led_brightness value)
+{
+	u8 buffer[2];
+	
+	down(&applesmc_sem);
+	buffer[0] = value;
+	buffer[1] = 0x00;
+	applesmc_write_key(BACKLIGHT_KEY, buffer, 2);
+	up(&applesmc_sem);
+}
+
+static struct led_classdev applesmc_backlight = {
+	.name			= "smc:kbd_backlight",
+	.default_trigger	= "nand-disk",
+	.brightness_set		= applesmc_backlight_set,
+};
+
+static DEVICE_ATTR(position, 0444, applesmc_position_show, NULL);
+static DEVICE_ATTR(calibrate, 0644, applesmc_calibrate_show,applesmc_calibrate_store);
+
+static DEVICE_ATTR(light, 0444, applesmc_light_show, NULL);
+
+#define sysfs_fan_speeds_offset(offset) \
+static ssize_t show_fan_actual_speed_##offset (struct device *dev, \
+				struct device_attribute *attr, char *buf) \
+{ \
+	return applesmc_show_fan_speed(dev, buf, FAN_ACTUAL_SPEED, offset); \
+} \
+static DEVICE_ATTR(fan##offset##_actual_speed, S_IRUGO, \
+					show_fan_actual_speed_##offset, NULL); \
+\
+static ssize_t show_fan_minimum_speed_##offset (struct device *dev, \
+				struct device_attribute *attr, char *buf) \
+{ \
+	return applesmc_show_fan_speed(dev, buf, FAN_MIN_SPEED, offset); \
+} \
+static ssize_t store_fan_minimum_speed_##offset (struct device *dev, \
+               struct device_attribute *attr, const char *buf, size_t count) \
+{ \
+    return applesmc_store_fan_speed(dev, buf, count, FAN_MIN_SPEED, offset); \
+} \
+static DEVICE_ATTR(fan##offset##_minimum_speed, S_IRUGO | S_IWUSR, \
+		show_fan_minimum_speed_##offset, store_fan_minimum_speed_##offset); \
+\
+static ssize_t show_fan_maximum_speed_##offset (struct device *dev, \
+				struct device_attribute *attr, char *buf) \
+{ \
+	return applesmc_show_fan_speed(dev, buf, FAN_MAX_SPEED, offset); \
+} \
+static DEVICE_ATTR(fan##offset##_maximum_speed, S_IRUGO, \
+				show_fan_maximum_speed_##offset, NULL); \
+\
+static ssize_t show_fan_safe_speed_##offset (struct device *dev, \
+				struct device_attribute *attr, char *buf) \
+{ \
+	return applesmc_show_fan_speed(dev, buf, FAN_SAFE_SPEED, offset); \
+} \
+static DEVICE_ATTR(fan##offset##_safe_speed, S_IRUGO, \
+					show_fan_safe_speed_##offset, NULL); \
+\
+static ssize_t show_fan_target_speed_##offset (struct device *dev, \
+				struct device_attribute *attr, char *buf) \
+{ \
+    return applesmc_show_fan_speed(dev, buf, FAN_TARGET_SPEED, offset); \
+} \
+static ssize_t store_fan_target_speed_##offset (struct device *dev, \
+		struct device_attribute *attr, const char *buf, size_t count) \
+{ \
+    return applesmc_store_fan_speed(dev, buf, count, FAN_TARGET_SPEED, offset); \
+} \
+static DEVICE_ATTR(fan##offset##_target_speed, S_IRUGO | S_IWUSR, \
+	show_fan_target_speed_##offset, store_fan_target_speed_##offset);
+
+#define sysfs_fan_manual_offset(offset) \
+static ssize_t show_fan_manual_##offset (struct device *dev, \
+				struct device_attribute *attr, char *buf) \
+{ \
+    return applesmc_show_fan_manual(dev, buf, offset); \
+} \
+static ssize_t store_fan_manual_##offset (struct device *dev, \
+		struct device_attribute *attr, const char *buf, size_t count) \
+{ \
+    return applesmc_store_fan_manual(dev, buf, count, offset); \
+} \
+static DEVICE_ATTR(fan##offset##_manual, S_IRUGO | S_IWUSR, \
+		   show_fan_manual_##offset, store_fan_manual_##offset);
+
+
+sysfs_fan_speeds_offset(0);
+sysfs_fan_manual_offset(0);
+sysfs_fan_speeds_offset(1);
+sysfs_fan_manual_offset(1);
+
+#define device_create_file_fan(client, offset) \
+do { \
+sysfs_create_file(client, &dev_attr_fan##offset##_actual_speed.attr); \
+sysfs_create_file(client, &dev_attr_fan##offset##_minimum_speed.attr); \
+sysfs_create_file(client, &dev_attr_fan##offset##_maximum_speed.attr); \
+sysfs_create_file(client, &dev_attr_fan##offset##_safe_speed.attr); \
+sysfs_create_file(client, &dev_attr_fan##offset##_target_speed.attr); \
+sysfs_create_file(client, &dev_attr_fan##offset##_manual.attr); \
+} while (0)
+
+#define sysfs_temperature_offset(offset) \
+static ssize_t show_temperature_##offset (struct device *dev, \
+				struct device_attribute *attr, char *buf) \
+{ \
+	return applesmc_show_temperature(dev, buf, temperature_sensors_sets[applesmc_temperature_set][offset]);  \
+} \
+static DEVICE_ATTR(temperature_##offset, S_IRUGO, \
+					show_temperature_##offset, NULL);
+
+sysfs_temperature_offset(0);
+sysfs_temperature_offset(1);
+sysfs_temperature_offset(2);
+sysfs_temperature_offset(3);
+sysfs_temperature_offset(4);
+sysfs_temperature_offset(5);
+sysfs_temperature_offset(6);
+
+#define device_create_files_temperature(client, offset) \
+{ \
+	sysfs_create_file(client, &dev_attr_temperature_##offset.attr); \
+} while (0)
+
+/* Module stuff */
+
+/* 
+ * applesmc_dmi_match - found a match.  return one, short-circuiting 
+ * the hunt.
+ */
+static int applesmc_dmi_match(struct dmi_system_id *id)
+{
+	int i = 0;
+	struct dmi_match_data* dmi_data =
+					(struct dmi_match_data*)id->driver_data;
+	printk(KERN_INFO "applesmc: %s detected:\n", id->ident);
+	applesmc_accelerometer = dmi_data->accelerometer;
+	printk(KERN_INFO "applesmc:  - Model %s accelerometer\n",
+				applesmc_accelerometer ? "with" : "without");
+	applesmc_light = dmi_data->light;
+	printk(KERN_INFO "applesmc:  - Model %s light sensors and backlight\n",
+					applesmc_light ? "with" : "without");
+
+	applesmc_temperature_set =  dmi_data->temperature_set;
+	while (temperature_sensors_sets[applesmc_temperature_set][i] != NULL) i++;
+	printk(KERN_INFO "applesmc:  - Model with %d temperature sensors\n", i);
+	return 1;
+}
+
+/* Create accelerometer ressources */
+static int applesmc_create_accelerometer(void) {
+	int ret;
+
+	ret = sysfs_create_file(&pdev->dev.kobj, &dev_attr_position.attr);
+	if (ret)
+		goto out;
+
+	ret = sysfs_create_file(&pdev->dev.kobj, &dev_attr_calibrate.attr);
+	if (ret)
+		goto out;
+
+	applesmc_idev = input_allocate_device();
+	if (!applesmc_idev) {
+		ret = -ENOMEM;
+		goto out;
+	}
+
+	/* initial calibrate for the input device */
+	applesmc_calibrate();
+
+	/* initialize the input class */
+	applesmc_idev->name = "applesmc";
+	applesmc_idev->cdev.dev = &pdev->dev;
+	applesmc_idev->evbit[0] = BIT(EV_ABS);
+	input_set_abs_params(applesmc_idev, ABS_X,
+			-256, 256, APPLESMC_INPUT_FUZZ, APPLESMC_INPUT_FLAT);
+	input_set_abs_params(applesmc_idev, ABS_Y,
+			-256, 256, APPLESMC_INPUT_FUZZ, APPLESMC_INPUT_FLAT);
+
+	input_register_device(applesmc_idev);
+
+	/* start up our timer for the input device */
+	init_timer(&applesmc_timer);
+	applesmc_timer.function = applesmc_mousedev_poll;
+	applesmc_timer.expires = jiffies + APPLESMC_POLL_PERIOD;
+	add_timer(&applesmc_timer);
+
+	return 0;
+
+out:
+	printk(KERN_WARNING "applesmc: driver init failed (ret=%d)!\n", ret);
+	return ret;
+}
+
+/* Release all ressources used by the accelerometer */
+static void applesmc_release_accelerometer(void) {
+	del_timer_sync(&applesmc_timer);
+	input_unregister_device(applesmc_idev);
+}
+
+static int __init applesmc_init(void)
+{
+	int ret;
+
+	struct dmi_match_data applesmc_dmi_data[] = {
+	  { .accelerometer = 1, .light = 1, .temperature_set = 0 },
+	  { .accelerometer = 1, .light = 0, .temperature_set = 0 },
+	  { .accelerometer = 0, .light = 0, .temperature_set = 1 }
+	};
+
+	/* Note that DMI_MATCH(...,"MacBook") will match "MacBookPro1,1".
+	 * So we need to put APPLESMC_MACBOOKPRO_DMI_MATCH before 
+	 * APPLESMC_MACBOOK_DMI_MATCH. */
+	struct dmi_system_id applesmc_whitelist[] = {
+		{ applesmc_dmi_match, "Apple MacBook Pro", {
+		  DMI_MATCH(DMI_BOARD_VENDOR,"Apple"),
+		  DMI_MATCH(DMI_PRODUCT_NAME,"MacBookPro") },
+			(void*)&applesmc_dmi_data[0]},
+		{ applesmc_dmi_match, "Apple MacBook", {
+		  DMI_MATCH(DMI_BOARD_VENDOR,"Apple"),
+		  DMI_MATCH(DMI_PRODUCT_NAME,"MacBook") },
+			(void*)&applesmc_dmi_data[1]},
+		{ applesmc_dmi_match, "Apple Macmini", {
+		  DMI_MATCH(DMI_BOARD_VENDOR,"Apple"),
+		  DMI_MATCH(DMI_PRODUCT_NAME,"Macmini") },
+			(void*)&applesmc_dmi_data[2]},
+		{ .ident = NULL }
+	};
+
+	if (!dmi_check_system(applesmc_whitelist)) {
+		printk(KERN_WARNING "applesmc: supported laptop not found!\n");
+		ret = -ENODEV;
+		goto out;
+	}
+
+	if (!request_region(APPLESMC_DATA_PORT, APPLESMC_NR_PORTS,
+								"applesmc")) {
+		ret = -ENXIO;
+		goto out;
+	}
+
+	ret = platform_driver_register(&applesmc_driver);
+	if (ret)
+		goto out_region;
+
+	pdev = platform_device_register_simple("applesmc", -1, NULL, 0);
+	if (IS_ERR(pdev)) {
+		ret = PTR_ERR(pdev);
+		goto out_driver;
+	}
+
+	/* create fan files */
+	ret = applesmc_get_fan_count();
+	if (ret < 0) {
+		printk(KERN_ERR "applesmc: Cannot get the number of fans.\n");
+	}
+	else {
+		printk(KERN_INFO "applesmc: %d fans found.\n", ret);
+
+		switch (ret) {
+		default:
+			printk(KERN_WARNING "applesmc: More than 2 fans found,"
+					" but at most 2 fans are supported"
+						" by the driver.\n");
+		case 2:
+			device_create_file_fan(&pdev->dev.kobj, 1);
+		case 1:
+			device_create_file_fan(&pdev->dev.kobj, 0);
+		case 0:
+			;
+		}
+	}
+
+	ret = 0;
+	while (temperature_sensors_sets[applesmc_temperature_set][ret] != NULL) ret++;
+
+	switch (ret) {
+	default:
+	case 7:
+		device_create_files_temperature(&pdev->dev.kobj, 6);
+	case 6:
+		device_create_files_temperature(&pdev->dev.kobj, 5);
+	case 5:
+		device_create_files_temperature(&pdev->dev.kobj, 4);
+	case 4:
+		device_create_files_temperature(&pdev->dev.kobj, 3);
+	case 3:
+		device_create_files_temperature(&pdev->dev.kobj, 2);
+	case 2:
+		device_create_files_temperature(&pdev->dev.kobj, 1);
+	case 1:
+		device_create_files_temperature(&pdev->dev.kobj, 0);
+	case 0:
+		;
+	}
+
+	if (applesmc_accelerometer) {
+		ret = applesmc_create_accelerometer();
+		if (ret)
+			goto out_device;
+	}
+
+	if (applesmc_light) {
+		/* Add light sensor file */
+		ret = sysfs_create_file(&pdev->dev.kobj, &dev_attr_light.attr);
+		if (ret)
+			goto out_accelerometer;
+
+		/* register as a led device */
+		ret = led_classdev_register(&pdev->dev, &applesmc_backlight);
+		if (ret < 0)
+			goto out_accelerometer;
+	}
+
+	printk(KERN_INFO "applesmc: driver successfully loaded.\n");
+	return 0;
+
+out_accelerometer:
+	if (applesmc_accelerometer)
+		applesmc_release_accelerometer();
+out_device:
+	platform_device_unregister(pdev);
+out_driver:
+	platform_driver_unregister(&applesmc_driver);
+out_region:
+	release_region(APPLESMC_DATA_PORT, APPLESMC_NR_PORTS);
+out:
+	printk(KERN_WARNING "applesmc: driver init failed (ret=%d)!\n", ret);
+	return ret;
+}
+
+static void __exit applesmc_exit(void)
+{
+	if (applesmc_light)
+		led_classdev_unregister(&applesmc_backlight);
+	if (applesmc_accelerometer)
+		applesmc_release_accelerometer();
+	platform_device_unregister(pdev);
+	platform_driver_unregister(&applesmc_driver);
+	release_region(APPLESMC_DATA_PORT, APPLESMC_NR_PORTS);
+
+	printk(KERN_INFO "applesmc: driver unloaded.\n");
+}
+
+module_init(applesmc_init);
+module_exit(applesmc_exit);
+
+MODULE_AUTHOR("Nicolas Boichat");
+MODULE_DESCRIPTION("Apple SMC");
+MODULE_LICENSE("GPL v2");
--- linux/drivers/usb/input/appletouch.c.orig	2006-11-08 11:28:43.000000000 -0600
+++ linux/drivers/usb/input/appletouch.c	2006-11-08 10:10:21.000000000 -0600
@@ -47,6 +47,10 @@
 #define GEYSER3_ISO_PRODUCT_ID	0x0218
 #define GEYSER3_JIS_PRODUCT_ID	0x0219
 
+#define GEYSER4_ANSI_PRODUCT_ID 0x021A
+#define GEYSER4_ISO_PRODUCT_ID	0x021B
+#define GEYSER4_JIS_PRODUCT_ID	0x021C
+
 #define ATP_DEVICE(prod)					\
 	.match_flags = USB_DEVICE_ID_MATCH_DEVICE |		\
 		       USB_DEVICE_ID_MATCH_INT_CLASS |		\
@@ -72,6 +76,10 @@
 	{ ATP_DEVICE(GEYSER3_ISO_PRODUCT_ID) },
 	{ ATP_DEVICE(GEYSER3_JIS_PRODUCT_ID) },
 
+	{ ATP_DEVICE(GEYSER4_ANSI_PRODUCT_ID) },
+	{ ATP_DEVICE(GEYSER4_ISO_PRODUCT_ID) },
+	{ ATP_DEVICE(GEYSER4_JIS_PRODUCT_ID) },
+
 	/* Terminating entry */
 	{ }
 };
@@ -174,7 +182,10 @@
 
 	return (productId == GEYSER3_ANSI_PRODUCT_ID) ||
 		(productId == GEYSER3_ISO_PRODUCT_ID) ||
-		(productId == GEYSER3_JIS_PRODUCT_ID);
+		(productId == GEYSER3_JIS_PRODUCT_ID) ||
+	        (productId == GEYSER4_ANSI_PRODUCT_ID) ||
+		(productId == GEYSER4_ISO_PRODUCT_ID) ||
+		(productId == GEYSER4_JIS_PRODUCT_ID);
 }
 
 static int atp_calculate_abs(int *xy_sensors, int nb_sensors, int fact,
Index: linux-2.6.19-rc2/arch/i386/kernel/msr.c
===================================================================
--- linux-2.6.19-rc2.orig/arch/i386/kernel/msr.c	2006-10-17 23:10:39.470361250 +0200
+++ linux-2.6.19-rc2/arch/i386/kernel/msr.c	2006-10-17 23:15:54.470047500 +0200
@@ -90,7 +90,7 @@
 		cmd->err = rdmsr_eio(cmd->reg, &cmd->data[0], &cmd->data[1]);
 }
 
-static inline int do_wrmsr(int cpu, u32 reg, u32 eax, u32 edx)
+int msr_write(int cpu, u32 reg, u32 eax, u32 edx)
 {
 	struct msr_command cmd;
 	int ret;
@@ -111,7 +111,7 @@
 	return ret;
 }
 
-static inline int do_rdmsr(int cpu, u32 reg, u32 * eax, u32 * edx)
+int msr_read(int cpu, u32 reg, u32 * eax, u32 * edx)
 {
 	struct msr_command cmd;
 	int ret;
@@ -136,19 +136,22 @@
 
 #else				/* ! CONFIG_SMP */
 
-static inline int do_wrmsr(int cpu, u32 reg, u32 eax, u32 edx)
+int msr_write(int cpu, u32 reg, u32 eax, u32 edx)
 {
 	return wrmsr_eio(reg, eax, edx);
 }
 
-static inline int do_rdmsr(int cpu, u32 reg, u32 *eax, u32 *edx)
+int msr_read(int cpu, u32 reg, u32 *eax, u32 *edx)
 {
 	return rdmsr_eio(reg, eax, edx);
 }
 
 #endif				/* ! CONFIG_SMP */
 
-static loff_t msr_seek(struct file *file, loff_t offset, int orig)
+EXPORT_SYMBOL_GPL(msr_write);
+EXPORT_SYMBOL_GPL(msr_read);
+
+static loff_t msr_fseek(struct file *file, loff_t offset, int orig)
 {
 	loff_t ret = -EINVAL;
 
@@ -166,7 +169,7 @@
 	return ret;
 }
 
-static ssize_t msr_read(struct file *file, char __user * buf,
+static ssize_t msr_fread(struct file *file, char __user * buf,
 			size_t count, loff_t * ppos)
 {
 	u32 __user *tmp = (u32 __user *) buf;
@@ -179,7 +182,7 @@
 		return -EINVAL;	/* Invalid chunk size */
 
 	for (; count; count -= 8) {
-		err = do_rdmsr(cpu, reg, &data[0], &data[1]);
+		err = msr_read(cpu, reg, &data[0], &data[1]);
 		if (err)
 			return err;
 		if (copy_to_user(tmp, &data, 8))
@@ -190,7 +193,7 @@
 	return ((char __user *)tmp) - buf;
 }
 
-static ssize_t msr_write(struct file *file, const char __user *buf,
+static ssize_t msr_fwrite(struct file *file, const char __user *buf,
 			 size_t count, loff_t *ppos)
 {
 	const u32 __user *tmp = (const u32 __user *)buf;
@@ -206,7 +209,7 @@
 	for (rv = 0; count; count -= 8) {
 		if (copy_from_user(&data, tmp, 8))
 			return -EFAULT;
-		err = do_wrmsr(cpu, reg, data[0], data[1]);
+		err = msr_write(cpu, reg, data[0], data[1]);
 		if (err)
 			return err;
 		tmp += 2;
@@ -215,7 +218,7 @@
 	return ((char __user *)tmp) - buf;
 }
 
-static int msr_open(struct inode *inode, struct file *file)
+static int msr_fopen(struct inode *inode, struct file *file)
 {
 	unsigned int cpu = iminor(file->f_dentry->d_inode);
 	struct cpuinfo_x86 *c = &(cpu_data)[cpu];
@@ -233,10 +236,10 @@
  */
 static struct file_operations msr_fops = {
 	.owner = THIS_MODULE,
-	.llseek = msr_seek,
-	.read = msr_read,
-	.write = msr_write,
-	.open = msr_open,
+	.llseek = msr_fseek,
+	.read = msr_fread,
+	.write = msr_fwrite,
+	.open = msr_fopen,
 };
 
 static int msr_class_device_create(int i)
Index: linux-2.6.19-rc2/include/asm-i386/msr.h
===================================================================
--- linux-2.6.19-rc2.orig/include/asm-i386/msr.h	2006-10-17 23:10:39.446359750 +0200
+++ linux-2.6.19-rc2/include/asm-i386/msr.h	2006-10-17 23:10:52.211157500 +0200
@@ -78,6 +78,9 @@
 			  : "=a" (low), "=d" (high) \
 			  : "c" (counter))
 
+int msr_write(int cpu, u32 reg, u32 eax, u32 edx);
+int msr_read(int cpu, u32 reg, u32 *eax, u32 *edx);
+
 /* symbolic names for some interesting MSRs */
 /* Intel defined MSRs. */
 #define MSR_IA32_P5_MC_ADDR		0
Index: linux-2.6.19-rc2/include/asm-x86_64/msr.h
===================================================================
--- linux-2.6.19-rc2.orig/include/asm-x86_64/msr.h	2006-10-17 23:10:39.382355750 +0200
+++ linux-2.6.19-rc2/include/asm-x86_64/msr.h	2006-10-17 23:18:29.347726750 +0200
@@ -160,7 +160,8 @@
 #define MSR_IA32_UCODE_WRITE		0x79
 #define MSR_IA32_UCODE_REV		0x8b
 
-
+int msr_write(int cpu, u32 reg, u32 eax, u32 edx);
+int msr_read(int cpu, u32 reg, u32 *eax, u32 *edx);
 #endif
 
 /* AMD/K8 specific MSRs */ 
Index: linux-2.6.19-rc2/drivers/hwmon/coretemp.c
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ linux-2.6.19-rc2/drivers/hwmon/coretemp.c	2006-10-17 23:12:39.589868250 +0200
@@ -0,0 +1,400 @@
+/*
+ * coretemp.c - Linux kernel module for hardware monitoring
+ *
+ * Copyright (C) 2006 Rudolf Marek <r.marek@assembler.cz>
+ *
+ * Inspired from many hwmon drivers
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
+ * 02110-1301 USA.
+ */
+
+#include <linux/module.h>
+#include <linux/delay.h>
+#include <linux/init.h>
+#include <linux/slab.h>
+#include <linux/jiffies.h>
+#include <linux/hwmon.h>
+#include <linux/sysfs.h>
+#include <linux/hwmon-sysfs.h>
+#include <linux/err.h>
+#include <linux/mutex.h>
+#include <linux/list.h>
+#include <linux/platform_device.h>
+#include <asm/msr.h>
+#include <linux/cpu.h>
+
+#define DRVNAME		"coretemp"
+
+typedef enum { SHOW_TEMP, SHOW_TJMAX, SHOW_LABEL, SHOW_NAME } SHOW;
+
+/*
+ * Functions declaration
+ */
+
+static struct coretemp_data *coretemp_update_device(struct device *dev);
+
+struct coretemp_data {
+	struct class_device *class_dev;
+	struct mutex update_lock;
+	const char *name;
+	u32 id;
+	char valid;		/* zero until following fields are valid */
+	unsigned long last_updated;	/* in jiffies */
+	int temp;
+	int tjmax;
+	/* registers values */
+	u32 therm_status;
+};
+
+static struct coretemp_data *coretemp_update_device(struct device *dev);
+
+/*
+ * Sysfs stuff
+ */
+
+
+static ssize_t show_name(struct device *dev, struct device_attribute
+			  *devattr, char *buf)
+{
+	int ret;
+	struct sensor_device_attribute *attr = to_sensor_dev_attr(devattr);
+	struct coretemp_data *data = dev_get_drvdata(dev);
+
+	if (attr->index == SHOW_NAME)
+		ret = sprintf(buf, "%s\n", data->name);
+	else	/* show label */
+		ret = sprintf(buf, "Core %d\n", data->id);
+	return ret;
+}
+
+static ssize_t show_alarm(struct device *dev, struct device_attribute
+			  *devattr, char *buf)
+{
+	struct coretemp_data *data = coretemp_update_device(dev);
+	/* read the Out-of-spec log, never clear */
+	return sprintf(buf, "%d\n", (data->therm_status >> 5) & 1);
+}
+
+static ssize_t show_temp(struct device *dev,
+			 struct device_attribute *devattr, char *buf)
+{
+	struct sensor_device_attribute *attr = to_sensor_dev_attr(devattr);
+	struct coretemp_data *data = coretemp_update_device(dev);
+	return sprintf(buf, "%d\n",
+		       attr->index ==
+		       SHOW_TEMP ? data->temp : data->tjmax);
+}
+
+static SENSOR_DEVICE_ATTR(temp1_input, S_IRUGO, show_temp, NULL,
+			  SHOW_TEMP);
+static SENSOR_DEVICE_ATTR(temp1_crit, S_IRUGO, show_temp, NULL,
+			  SHOW_TJMAX);
+static DEVICE_ATTR(temp1_crit_alarm, S_IRUGO, show_alarm, NULL);
+static SENSOR_DEVICE_ATTR(temp1_label, S_IRUGO, show_name, NULL, SHOW_LABEL);
+static SENSOR_DEVICE_ATTR(name, S_IRUGO, show_name, NULL, SHOW_NAME);
+
+static struct attribute *coretemp_attributes[] = {
+	&sensor_dev_attr_name.dev_attr.attr,
+	&sensor_dev_attr_temp1_label.dev_attr.attr,
+	&dev_attr_temp1_crit_alarm.attr,
+	&sensor_dev_attr_temp1_input.dev_attr.attr,
+	&sensor_dev_attr_temp1_crit.dev_attr.attr,
+	NULL
+};
+
+static const struct attribute_group coretemp_group = {
+	.attrs = coretemp_attributes,
+};
+
+static struct coretemp_data *coretemp_update_device(struct device *dev)
+{
+	struct coretemp_data *data = dev_get_drvdata(dev);
+
+	mutex_lock(&data->update_lock);
+
+	if (!data->valid || time_after(jiffies, data->last_updated + HZ)) {
+		u32 eax, edx;
+
+		data->valid = 0;
+		msr_read(data->id, MSR_IA32_THERM_STATUS, &eax, &edx);
+		data->therm_status = eax;
+
+		/* update only if data has been valid */
+		if (eax & 0x80000000) {
+			data->temp = data->tjmax - (((data->therm_status >> 16)
+							& 0x7f) * 1000);
+			data->valid = 1;
+		}
+		data->last_updated = jiffies;
+	}
+
+	mutex_unlock(&data->update_lock);
+	return data;
+}
+
+static int __devinit coretemp_probe(struct platform_device *pdev)
+{
+	struct coretemp_data *data;
+	struct cpuinfo_x86 *c = &(cpu_data)[pdev->id];
+	int err;
+	u32 eax, edx;
+
+	if (!(data = kzalloc(sizeof(struct coretemp_data), GFP_KERNEL))) {
+		err = -ENOMEM;
+		dev_err(&pdev->dev, "Out of memory\n");
+		goto exit;
+	}
+
+	data->id = pdev->id;
+	data->name = "coretemp";
+	mutex_init(&data->update_lock);
+	/* Tjmax default is 100C */
+	data->tjmax = 100000;
+
+	/* Some processors have Tjmax 85 following magic should detect it */
+	/* family is always 0x6 */
+
+	if (((c->x86_model == 0xf) && (c->x86_mask > 3 )) ||
+		(c->x86_model == 0xe))  {
+
+		err = msr_read(data->id, 0xee, &eax, &edx);
+		if (err) {
+			dev_warn(&pdev->dev,
+				 "Unable to access MSR 0xEE, Tjmax left at %d\n",
+				 data->tjmax);
+		} else if (eax & 0x40000000) {
+			data->tjmax = 85000;
+		}
+	}
+
+	/* test if we can access the THERM_STATUS MSR */
+	err = msr_read(data->id, MSR_IA32_THERM_STATUS, &eax, &edx);
+
+	if (err) {
+		dev_err(&pdev->dev,
+			"Unable to access THERM_STATUS MSR, giving up\n");
+		goto exit_free;
+	}
+	platform_set_drvdata(pdev, data);
+
+	if ((err = sysfs_create_group(&pdev->dev.kobj, &coretemp_group)))
+		goto exit_free;
+
+	data->class_dev = hwmon_device_register(&pdev->dev);
+	if (IS_ERR(data->class_dev)) {
+		err = PTR_ERR(data->class_dev);
+		dev_err(&pdev->dev, "Class registration failed (%d)\n",
+			err);
+		goto exit_class;
+	}
+
+	return 0;
+
+exit_class:
+	sysfs_remove_group(&pdev->dev.kobj, &coretemp_group);
+exit_free:
+	kfree(data);
+exit:
+	return err;
+}
+
+static int __devexit coretemp_remove(struct platform_device *pdev)
+{
+	struct coretemp_data *data = platform_get_drvdata(pdev);
+
+	hwmon_device_unregister(data->class_dev);
+	sysfs_remove_group(&pdev->dev.kobj, &coretemp_group);
+	platform_set_drvdata(pdev, NULL);
+	kfree(data);
+	return 0;
+}
+
+static struct platform_driver coretemp_driver = {
+	.driver = {
+		   .owner = THIS_MODULE,
+		   .name = DRVNAME,
+		   },
+	.probe = coretemp_probe,
+	.remove = __devexit_p(coretemp_remove),
+};
+
+struct pdev_entry {
+	struct list_head list;
+	struct platform_device *pdev;
+	unsigned int cpu;
+};
+
+static LIST_HEAD(pdev_list);
+static DEFINE_MUTEX(pdev_list_mutex);
+
+static int __cpuinit coretemp_devices_add(unsigned int cpu)
+{
+	int err;
+	struct platform_device *pdev;
+	struct pdev_entry *pdev_entry;
+
+	pdev = platform_device_alloc(DRVNAME, cpu);
+	if (!pdev) {
+		err = -ENOMEM;
+		printk(KERN_ERR DRVNAME ": Device allocation failed\n");
+		goto exit;
+
+	}
+
+	pdev_entry = kzalloc(sizeof(struct pdev_entry), GFP_KERNEL);
+
+	if (!pdev_entry) {
+		err = -ENOMEM;
+		goto exit_device_put;
+	}
+
+	err = platform_device_add(pdev);
+
+	if (err) {
+		printk(KERN_ERR DRVNAME ": Device addition failed (%d)\n",
+		       err);
+		goto exit_device_free;
+	}
+
+	pdev_entry->pdev = pdev;
+	pdev_entry->cpu = cpu;
+	mutex_lock(&pdev_list_mutex);
+	list_add_tail(&pdev_entry->list, &pdev_list);
+	mutex_unlock(&pdev_list_mutex);
+
+	return 0;
+
+exit_device_free:
+	kfree(pdev_entry);
+exit_device_put:
+	platform_device_put(pdev);
+exit:
+	return err;
+}
+
+#ifdef CONFIG_HOTPLUG_CPU
+void coretemp_devices_remove(unsigned int cpu)
+{
+	struct pdev_entry *p, *n;
+	mutex_lock(&pdev_list_mutex);
+	list_for_each_entry_safe(p, n, &pdev_list, list) {
+		if (p->cpu == cpu) {
+			platform_device_unregister(p->pdev);
+			list_del(&p->list);
+			kfree(p);
+		}
+	}
+	mutex_unlock(&pdev_list_mutex);
+}
+
+static int coretemp_cpu_callback(struct notifier_block *nfb,
+				 unsigned long action, void *hcpu)
+{
+	unsigned int cpu = (unsigned long) hcpu;
+
+	switch (action) {
+	case CPU_ONLINE:
+		coretemp_devices_add(cpu);
+		break;
+	case CPU_DEAD:
+		coretemp_devices_remove(cpu);
+		break;
+	}
+	return NOTIFY_OK;
+}
+
+static struct notifier_block __cpuinitdata coretemp_cpu_notifier = {
+	.notifier_call = coretemp_cpu_callback,
+};
+#endif				/* !CONFIG_HOTPLUG_CPU */
+
+static int __init coretemp_init(void)
+{
+	int i, err = -ENODEV;
+	struct pdev_entry *p, *n;
+
+	if (current_cpu_data.x86_vendor != X86_VENDOR_INTEL)
+		goto exit;
+
+	err = platform_driver_register(&coretemp_driver);
+	if (err)
+		goto exit;
+
+	for_each_online_cpu(i) {
+		struct cpuinfo_x86 *c = &(cpu_data)[i];
+
+		/* check if family 6, models e, f */
+		if ((c->cpuid_level < 0) || (c->x86 != 0x6) ||
+		    !((c->x86_model == 0xe) || (c->x86_model == 0xf))) {
+
+			/* supported CPU not found, but report the unknown
+			   family 6 CPU */
+			if ((c->x86 == 0x6) && (c->x86_model > 0xf))
+				printk(KERN_WARNING DRVNAME ": Unknown CPU, please"
+ 			   " report to the lm-sensors@lm-sensors.org\n");
+			continue;
+		}
+
+		err = coretemp_devices_add(i);
+		if (err)
+			goto exit_driver;
+	}
+	if (list_empty(&pdev_list)) {
+		err = -ENODEV;
+		goto exit_driver_unreg;
+	}
+
+#ifdef CONFIG_HOTPLUG_CPU
+	register_hotcpu_notifier(&coretemp_cpu_notifier);
+#endif
+	return 0;
+
+exit_driver:
+	mutex_lock(&pdev_list_mutex);
+	list_for_each_entry_safe(p, n, &pdev_list, list) {
+		platform_device_unregister(p->pdev);
+		list_del(&p->list);
+		kfree(p);
+	}
+	mutex_unlock(&pdev_list_mutex);
+exit_driver_unreg:
+	platform_driver_unregister(&coretemp_driver);
+exit:
+	return err;
+}
+
+static void __exit coretemp_exit(void)
+{
+	struct pdev_entry *p, *n;
+#ifdef CONFIG_HOTPLUG_CPU
+	unregister_hotcpu_notifier(&coretemp_cpu_notifier);
+#endif
+	mutex_lock(&pdev_list_mutex);
+	list_for_each_entry_safe(p, n, &pdev_list, list) {
+		platform_device_unregister(p->pdev);
+		list_del(&p->list);
+		kfree(p);
+	}
+	mutex_unlock(&pdev_list_mutex);
+	platform_driver_unregister(&coretemp_driver);
+}
+
+MODULE_AUTHOR("Rudolf Marek <r.marek@assembler.cz>");
+MODULE_DESCRIPTION("Intel Core temperature monitor");
+MODULE_LICENSE("GPL");
+
+module_init(coretemp_init)
+module_exit(coretemp_exit)
Index: linux-2.6.19-rc2/drivers/hwmon/Kconfig
===================================================================
--- linux-2.6.19-rc2.orig/drivers/hwmon/Kconfig	2006-10-17 23:05:20.178406750 +0200
+++ linux-2.6.19-rc2/drivers/hwmon/Kconfig	2006-10-17 23:11:36.021895500 +0200
@@ -131,6 +131,15 @@
 	  This driver can also be built as a module.  If so, the module
 	  will be called atxp1.
 
+config SENSORS_CORETEMP
+	tristate "Intel Core (2) Duo/Solo temperature sensor"
+	depends on HWMON && X86 && EXPERIMENTAL
+	select X86_MSR
+	help
+	  If you say yes here you get support for the temperature
+	  sensor inside your CPU. Supported all are all known variants
+	  of Intel Core family.
+
 config SENSORS_DS1621
 	tristate "Dallas Semiconductor DS1621 and DS1625"
 	depends on HWMON && I2C
Index: linux-2.6.19-rc2/drivers/hwmon/Makefile
===================================================================
--- linux-2.6.19-rc2.orig/drivers/hwmon/Makefile	2006-10-17 23:05:20.138404250 +0200
+++ linux-2.6.19-rc2/drivers/hwmon/Makefile	2006-10-17 23:11:36.025895750 +0200
@@ -20,6 +19,7 @@
 obj-$(CONFIG_SENSORS_ADM1031)	+= adm1031.o
 obj-$(CONFIG_SENSORS_ADM9240)	+= adm9240.o
 obj-$(CONFIG_SENSORS_ATXP1)	+= atxp1.o
+obj-$(CONFIG_SENSORS_CORETEMP)	+= coretemp.o
 obj-$(CONFIG_SENSORS_DS1621)	+= ds1621.o
 obj-$(CONFIG_SENSORS_F71805F)	+= f71805f.o
 obj-$(CONFIG_SENSORS_FSCHER)	+= fscher.o
--- a/arch/i386/kernel/setup.c	2006-06-19 09:12:09.000000000 +0200
+++ b/arch/i386/kernel/setup.c	2006-06-19 09:12:24.000000000 +0200
@@ -862,24 +862,28 @@
 	u64 start = s;
 	u64 end = e;
 	int i;
-	for (i = 0; i < e820.nr_map; i++) {
-		struct e820entry *ei = &e820.map[i];
-		if (type && ei->type != type)
-			continue;
-		/* is the region (part) in overlap with the current region ?*/
-		if (ei->addr >= end || ei->addr + ei->size <= start)
-			continue;
-		/* if the region is at the beginning of <start,end> we move
-		 * start to the end of the region since it's ok until there
-		 */
-		if (ei->addr <= start)
-			start = ei->addr + ei->size;
-		/* if start is now at or beyond end, we're done, full
-		 * coverage */
-		if (start >= end)
-			return 1; /* we're done */
+	if(!efi_enabled) {
+		for (i = 0; i < e820.nr_map; i++) {
+			struct e820entry *ei = &e820.map[i];
+			if (type && ei->type != type)
+				continue;
+			/* is the region (part) in overlap with the current region ?*/
+			if (ei->addr >= end || ei->addr + ei->size <= start)
+				continue;
+			/* if the region is at the beginning of <start,end> we move
+			 * start to the end of the region since it's ok until there
+			 */
+			if (ei->addr <= start)
+				start = ei->addr + ei->size;
+			/* if start is now at or beyond end, we're done, full
+			 * coverage */
+			if (start >= end)
+				return 1; /* we're done */
+		}
+		return 0;
+	} else {
+		return 1;
 	}
-	return 0;
 }
 
 /*
--- linux-2.6.16.1/drivers/usb/input/Makefile	2006-03-28 07:49:02.000000000 +0100
+++ linux-2.6.16.1-imac-sky2-rtc/drivers/usb/input/Makefile	2006-05-22 13:14:40.000000000 +0100
@@ -36,6 +36,7 @@
 obj-$(CONFIG_USB_HID)		+= usbhid.o
 obj-$(CONFIG_USB_KBD)		+= usbkbd.o
 obj-$(CONFIG_USB_KBTAB)		+= kbtab.o
+obj-$(CONFIG_USB_APPLEIR)		+= appleir.o
 obj-$(CONFIG_USB_KEYSPAN_REMOTE)	+= keyspan_remote.o
 obj-$(CONFIG_USB_MOUSE)		+= usbmouse.o
 obj-$(CONFIG_USB_MTOUCH)	+= mtouchusb.o
--- linux-2.6.16.1/drivers/usb/input/Kconfig	2006-03-28 07:49:02.000000000 +0100
+++ linux-2.6.16.1-imac-sky2-rtc/drivers/usb/input/Kconfig	2006-05-22 13:15:16.000000000 +0100
@@ -183,6 +183,10 @@
 	  To compile this driver as a module, choose M here: the
 	  module will be called acecad.
 
+config USB_APPLEIR
+	tristate "Apple Mac Mini USB IR receiver (built in)"
+	depends on USB && INPUT
+	
 config USB_KBTAB
 	tristate "KB Gear JamStudio tablet support"
 	depends on USB && INPUT
--- linux-2.6.16.1/drivers/usb/input/appleir.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.16.1-imac-sky2-rtc/drivers/usb/input/appleir.c	2006-05-29 09:47:40.000000000 +0100
@@ -0,0 +1,390 @@
+#include <linux/kernel.h>
+#include <linux/slab.h>
+#include <linux/input.h>
+#include <linux/module.h>
+#include <linux/init.h>
+#include <linux/usb.h>
+#include <linux/usb/input.h>
+#include <asm/unaligned.h>
+#include <asm/byteorder.h>
+
+/*
+ * Version Information
+ *
+ */
+
+#if 0
+#define DUMP_PACKETS
+#else
+#undef DUMP_PACKETS
+#endif
+
+#define DRIVER_VERSION "v1.1"
+#define DRIVER_AUTHOR "James McKenzie"
+#define DRIVER_DESC "USB Apple MacMini IR Receiver driver"
+#define DRIVER_LICENSE "GPL"
+
+MODULE_AUTHOR (DRIVER_AUTHOR);
+MODULE_DESCRIPTION (DRIVER_DESC);
+MODULE_LICENSE (DRIVER_LICENSE);
+
+#ifndef USB_VENDOR_ID_APPLE
+#define USB_VENDOR_ID_APPLE	0x05ac
+#endif
+#ifndef USB_DEVICE_ID_APPLE_IR
+#define USB_DEVICE_ID_APPLE_IR  0x8240
+#endif
+
+#define URB_SIZE 32
+
+#define MAX_KEYS 8
+#define MAX_KEYS_MASK (MAX_KEYS - 1 )
+
+struct appleir
+{
+  struct input_dev *dev;
+  uint8_t *data;
+  dma_addr_t dma_buf;
+  struct usb_device *usbdev;
+  struct urb *urb;
+  int timer_initted;
+  struct timer_list key_up_timer;
+  int current_key;
+  char phys[32];
+};
+
+
+static struct usb_device_id appleir_ids[] = {
+  {USB_DEVICE (USB_VENDOR_ID_APPLE, USB_DEVICE_ID_APPLE_IR),.driver_info = 0},
+  {}
+};
+
+MODULE_DEVICE_TABLE (usb, appleir_ids);
+
+
+/* I have two devices both of which report the following */
+/* 25 87 ee 83 0a  	+  */
+/* 25 87 ee 83 0c  	-  */
+/* 25 87 ee 83 09	<< */
+/* 25 87 ee 83 06	>> */
+/* 25 87 ee 83 05	>" */
+/* 25 87 ee 83 03	menu */
+/* 26 00 00 00 00	for key repeat*/
+
+/* Thomas Glanzmann reports the following responses */
+/* 25 87 ee ca 0b	+  */
+/* 25 87 ee ca 0d	-  */
+/* 25 87 ee ca 08	<< */
+/* 25 87 ee ca 07	>> */
+/* 25 87 ee ca 04	>" */
+/* 25 87 ee ca 02 	menu */
+/* 26 00 00 00 00       for key repeat*/
+/* He also observes the following event sometimes */
+/* sent after a key is release, which I interpret */
+/* as a flat battery message */
+/* 25 87 e0 ca 06	flat battery */
+
+
+static int keymap[MAX_KEYS] = {
+  KEY_RESERVED, KEY_MENU,
+  KEY_PLAYPAUSE, KEY_NEXTSONG,
+  KEY_PREVIOUSSONG, KEY_VOLUMEUP,
+  KEY_VOLUMEDOWN, KEY_RESERVED
+};
+
+static void
+dump_packet (struct appleir *appleir, char *msg, uint8_t * data, int len)
+{
+  int i;
+
+  printk (KERN_ERR "appleir: %s (%d bytes)", msg, len);
+
+  for (i = 0; i < len; ++i)
+    {
+      printk (" %02x", data[i]);
+    }
+
+  printk ("\n");
+}
+
+
+static void
+key_up (struct appleir *appleir, int key)
+{
+  //printk (KERN_ERR "key %d up\n", key);
+  input_report_key (appleir->dev, key, 0);
+  input_sync (appleir->dev);
+}
+
+static void
+key_down (struct appleir *appleir, int key)
+{
+  //printk (KERN_ERR "key %d down\n", key);
+  input_report_key (appleir->dev, key, 1);
+  input_sync (appleir->dev);
+}
+
+static void
+battery_flat (struct appleir *appleir)
+{
+  printk (KERN_ERR "appleir: possible flat battery?\n");
+}
+
+static void
+key_up_tick (unsigned long data)
+{
+  struct appleir *appleir = (struct appleir *) data;
+
+  if (appleir->current_key)
+    {
+      key_up (appleir, appleir->current_key);
+      appleir->current_key = 0;
+    }
+}
+
+static void
+new_data (struct appleir *appleir, uint8_t * data, int len)
+{
+  static const uint8_t keydown[] = { 0x25, 0x87, 0xee };
+  static const uint8_t keyrepeat[] = { 0x26, 0x00, 0x00, 0x00, 0x00 };
+  static const uint8_t flatbattery[] = { 0x25, 0x87, 0xe0 };
+
+#ifdef DUMP_PACKETS
+  dump_packet (appleir, "received", data, len);
+#endif
+
+  if (len != 5)
+    return;
+
+  if (!memcmp (data, keydown, sizeof (keydown)))
+    {
+      /*If we already have a key down, take it up before marking */
+      /*this one down */
+      if (appleir->current_key)
+        key_up (appleir, appleir->current_key);
+      appleir->current_key = keymap[(data[4] >> 1) & MAX_KEYS_MASK];
+
+      key_down (appleir, appleir->current_key);
+      /*remote doesn't do key up, either pull them up, in the test */
+      /*above, or here set a timer which pulls them up after 1/8 s */
+      mod_timer (&appleir->key_up_timer, jiffies + HZ / 8);
+
+      return;
+    }
+
+  if (!memcmp (data, keyrepeat, sizeof (keyrepeat)))
+    {
+      key_down (appleir, appleir->current_key);
+      /*remote doesn't do key up, either pull them up, in the test */
+      /*above, or here set a timer which pulls them up after 1/8 s */
+      mod_timer (&appleir->key_up_timer, jiffies + HZ / 8);
+      return;
+    }
+
+  if (!memcmp (data, flatbattery, sizeof (flatbattery)))
+    {
+      battery_flat (appleir);
+      /*Fall through */
+    }
+
+  dump_packet (appleir, "unknown packet", data, len);
+}
+
+static void
+appleir_urb (struct urb *urb, struct pt_regs *regs)
+{
+  struct appleir *appleir = urb->context;
+  int retval;
+
+  switch (urb->status)
+    {
+    case 0:
+      new_data (appleir, urb->transfer_buffer, urb->actual_length);
+      break;
+    case -ECONNRESET:
+    case -ENOENT:
+    case -ESHUTDOWN:
+      /* this urb is terminated, clean up */
+      dbg ("%s - urb shutting down with status: %d", __FUNCTION__,
+           urb->status);
+      return;
+    default:
+      dbg ("%s - nonzero urb status received: %d", __FUNCTION__, urb->status);
+    }
+
+  retval = usb_submit_urb (urb, GFP_ATOMIC);
+  if (retval)
+    err ("%s - usb_submit_urb failed with result %d", __FUNCTION__, retval);
+}
+
+
+static int
+appleir_open (struct input_dev *dev)
+{
+  struct appleir *appleir = dev->private;
+
+  //appleir->urb->dev = appleir->usbdev;
+
+  if (usb_submit_urb (appleir->urb, GFP_KERNEL))
+    return -EIO;
+
+  return 0;
+}
+
+static void
+appleir_close (struct input_dev *dev)
+{
+  struct appleir *appleir = dev->private;
+  usb_kill_urb (appleir->urb);
+  del_timer_sync (&appleir->key_up_timer);
+}
+
+
+
+
+static int
+appleir_probe (struct usb_interface *intf, const struct usb_device_id *id)
+{
+  struct usb_device *dev = interface_to_usbdev (intf);
+  struct usb_endpoint_descriptor *endpoint;
+  struct appleir *appleir = NULL;
+  struct input_dev *input_dev;
+  int i;
+
+  appleir = kzalloc (sizeof (struct appleir), GFP_KERNEL);
+  if (!appleir)
+    goto fail;
+
+  memset (appleir, 0, sizeof (struct appleir));
+
+
+  appleir->data =
+    usb_buffer_alloc (dev, URB_SIZE, GFP_KERNEL, &appleir->dma_buf);
+  if (!appleir->data)
+    goto fail;
+
+  appleir->urb = usb_alloc_urb (0, GFP_KERNEL);
+  if (!appleir->urb)
+    goto fail;
+
+  appleir->usbdev = dev;
+
+  input_dev = input_allocate_device ();
+  if (!input_dev)
+    goto fail;
+
+  appleir->dev = input_dev;
+
+
+  usb_make_path (dev, appleir->phys, sizeof (appleir->phys));
+  strlcpy (appleir->phys, "/input0", sizeof (appleir->phys));
+
+  input_dev->name = "Apple Mac mini infrared remote control driver";
+  input_dev->phys = appleir->phys;
+  usb_to_input_id (dev, &input_dev->id);
+  input_dev->cdev.dev = &intf->dev;
+  input_dev->private = appleir;
+
+  input_dev->evbit[0] = BIT (EV_KEY) | BIT (EV_REP);
+  input_dev->ledbit[0] = 0;
+
+  for (i = 0; i < MAX_KEYS; i++)
+    {
+      set_bit (keymap[i], input_dev->keybit);
+    }
+
+  clear_bit (0, input_dev->keybit);
+
+  input_dev->open = appleir_open;
+  input_dev->close = appleir_close;
+
+  endpoint = &intf->cur_altsetting->endpoint[0].desc;
+
+  usb_fill_int_urb (appleir->urb, dev,
+                    usb_rcvintpipe (dev, endpoint->bEndpointAddress),
+                    appleir->data, 8,
+                    appleir_urb, appleir, endpoint->bInterval);
+
+  appleir->urb->transfer_dma = appleir->dma_buf;
+  appleir->urb->transfer_flags |= URB_NO_TRANSFER_DMA_MAP;
+
+  usb_set_intfdata (intf, appleir);
+
+  init_timer (&appleir->key_up_timer);
+
+  appleir->key_up_timer.function = key_up_tick;
+  appleir->key_up_timer.data = (unsigned long) appleir;
+
+  appleir->timer_initted++;
+
+  input_register_device (appleir->dev);
+
+  return 0;
+
+fail:
+
+  if (appleir)
+    {
+
+
+      if (appleir->data)
+        usb_buffer_free (dev, URB_SIZE, appleir->data, appleir->dma_buf);
+
+      if (appleir->timer_initted)
+        del_timer_sync (&appleir->key_up_timer);
+
+      if (appleir->dev)
+        input_free_device (appleir->dev);
+
+      kfree (appleir);
+    }
+
+  return -ENOMEM;
+}
+
+static void
+appleir_disconnect (struct usb_interface *intf)
+{
+  struct appleir *appleir = usb_get_intfdata (intf);
+
+  usb_set_intfdata (intf, NULL);
+  if (appleir)
+    {
+      input_unregister_device (appleir->dev);
+      if (appleir->timer_initted)
+        del_timer_sync (&appleir->key_up_timer);
+      usb_kill_urb (appleir->urb);
+      usb_free_urb (appleir->urb);
+      usb_buffer_free (interface_to_usbdev (intf), URB_SIZE, appleir->data,
+                       appleir->dma_buf);
+      kfree (appleir);
+    }
+}
+
+static struct usb_driver appleir_driver = {
+  .name = "appleir",
+  .probe = appleir_probe,
+  .disconnect = appleir_disconnect,
+  .id_table = appleir_ids,
+};
+
+static int __init
+appleir_init (void)
+{
+  int retval;
+  retval = usb_register (&appleir_driver);
+  if (retval)
+    goto out;
+  info (DRIVER_VERSION ":" DRIVER_DESC);
+out:
+  return retval;
+}
+
+static void __exit
+appleir_exit (void)
+{
+  usb_deregister (&appleir_driver);
+}
+
+module_init (appleir_init);
+module_exit (appleir_exit);
diff -uNr linux-2.6.16.1/drivers/Makefile linux-2.6.16.1-imac/drivers/Makefile
--- linux-2.6.16.1/drivers/Makefile	2006-03-20 05:53:29.000000000 +0000
+++ linux-2.6.16.1-imac/drivers/Makefile	2006-04-01 23:51:38.000000000 +0000
@@ -30,7 +30,7 @@
 obj-y				+= base/ block/ misc/ mfd/ net/ media/
 obj-$(CONFIG_NUBUS)		+= nubus/
 obj-$(CONFIG_ATM)		+= atm/
-obj-$(CONFIG_PPC_PMAC)		+= macintosh/
+obj-y				+= macintosh/
 obj-$(CONFIG_IDE)		+= ide/
 obj-$(CONFIG_FC4)		+= fc4/
 obj-$(CONFIG_SCSI)		+= scsi/
diff -uNr linux-2.6.16.1/drivers/macintosh/Kconfig linux-2.6.16.1-imac/drivers/macintosh/Kconfig
--- linux-2.6.16.1/drivers/macintosh/Kconfig	2006-03-20 05:53:29.000000000 +0000
+++ linux-2.6.16.1-imac/drivers/macintosh/Kconfig	2006-04-01 23:51:38.000000000 +0000
@@ -1,6 +1,6 @@
 
 menu "Macintosh device drivers"
-	depends on PPC || MAC
+	depends on PPC || MAC || X86
 
 config ADB
 	bool "Apple Desktop Bus (ADB) support"
@@ -162,7 +162,7 @@
 
 config MAC_EMUMOUSEBTN
 	bool "Support for mouse button 2+3 emulation"
-	depends on INPUT_ADBHID
+#	depends on INPUT_ADBHID
 	help
 	  This provides generic support for emulating the 2nd and 3rd mouse
 	  button with keypresses.  If you say Y here, the emulation is still
--- linux-2.6.16.1/drivers/ide/ide-io.c	2006-03-28 07:49:02.000000000 +0100
+++ linux-2.6.16.1-imac-sky2-rtc/drivers/ide/ide-io.c	2006-05-15 03:24:57.000000000 +0100
@@ -1610,6 +1610,8 @@
 			 * Whack the status register, just in case
 			 * we have a leftover pending IRQ.
 			 */
+			/* Ack the interrupt for ich7 - XXX possible race */
+			hwif->OUTB( (hwif->INB(hwif->dma_status) |4) & ~2, hwif->dma_status);
 			(void) hwif->INB(hwif->io_ports[IDE_STATUS_OFFSET]);
 #endif /* CONFIG_BLK_DEV_IDEPCI */
 		}
@@ -1652,6 +1654,9 @@
 	startstop = handler(drive);
 	spin_lock_irq(&ide_lock);
 
+	/* Ack the interrupt for ich7 - XXX possible race */
+	hwif->OUTB( (hwif->INB(hwif->dma_status) |4) & ~2, hwif->dma_status);
+
 	/*
 	 * Note that handler() may have set things up for another
 	 * interrupt to occur soon, but it cannot happen until
--- a/drivers/acpi/sleep/poweroff.c	2006-06-11 05:22:53.000000000 -0700
+++ b/drivers/acpi/sleep/poweroff.c	2006-06-11 05:06:36.000000000 -0700
@@ -63,8 +63,15 @@ static int acpi_shutdown(struct sys_devi
 	}
 }
 
+static int acpi_resume(struct sys_device *x)
+{
+	acpi_set_register(ACPI_BITREG_SCI_ENABLE, 1, ACPI_MTX_DO_NOT_LOCK);
+	return 0;
+}
+
 static struct sysdev_class acpi_sysclass = {
 	set_kset_name("acpi"),
+	.resume = acpi_resume,
 	.shutdown = acpi_shutdown
 };
 


From: Ryan Lortie <desrt@desrt.ca>
Date: Sat, 10 Jun 2006 20:22:56 +0000 (-0400)
Subject: [UBUNTU:ich7-sci-en-quirk] poke the SCI_EN bit on Macbook resume
X-Git-Url: http://www.kernel.org/git/?p=linux/kernel/git/bcollins/ubuntu-dapper.git;a=commitdiff;h=d1d9b907570c5c9178e3d66ff208bd483d1dfd61

[UBUNTU:ich7-sci-en-quirk] poke the SCI_EN bit on Macbook resume

The following patch deals with the problem that the SCI_EN bit is
disabled when the Macbook comes back from sleeping.

It does this by registering a quirk in the exact way that another one is
registered in the same file (for a Toshiba laptop with a similar
problem).

The quirk matches based on DMI product name of "MacBook1,1" so it should
really only affect the Macbook.

The actual bit-poking is done immediately on return from
do_suspend_lowlevel().  If I do it in the 'finish' function it is too
late (as at this point IRQs have been enabled again for some time).

Cheers.

Signed-off-by: Ben Collins <bcollins@ubuntu.com>
---

--- a/drivers/acpi/sleep/main.c
+++ b/drivers/acpi/sleep/main.c
@@ -17,6 +17,7 @@
 #include <linux/suspend.h>
 #include <acpi/acpi_bus.h>
 #include <acpi/acpi_drivers.h>
+#include <asm/io.h>
 #include "sleep.h"
 
 u8 sleep_states[ACPI_S_STATE_COUNT];
@@ -34,6 +35,7 @@ static u32 acpi_suspend_states[] = {
 };
 
 static int init_8259A_after_S1;
+static int ich7_sci_en_quirk_enabled;
 
 /**
  *	acpi_pm_prepare - Do preliminary suspend work.
@@ -92,6 +94,14 @@ static int acpi_pm_enter(suspend_state_t
 
 	case PM_SUSPEND_MEM:
 		do_suspend_lowlevel();
+
+		if (ich7_sci_en_quirk_enabled)
+		{
+			int pm1c = inw(0x404);
+			pm1c |= 0x01; /* SCI_EN */
+			outw (pm1c, 0x404);
+		}
+
 		break;
 
 	case PM_SUSPEND_DISK:
@@ -191,12 +201,36 @@ static int __init init_ints_after_s1(str
 	return 0;
 }
 
+/*
+ * Apple Macbook comes back from sleep with the SCI_EN bit disabled
+ * causing a flood of unacknowledged IRQ9s.  We need to set SCI_EN
+ * as soon as we come back
+ */
+static int __init init_ich7_sci_en_quirk(struct dmi_system_id *d)
+{
+	printk(KERN_WARNING "%s detected (ICH7 SCI_EN quirk enabled)\n",
+               d->ident);
+	ich7_sci_en_quirk_enabled = 1;
+	return 0;
+}
+
+
 static struct dmi_system_id __initdata acpisleep_dmi_table[] = {
 	{
 	 .callback = init_ints_after_s1,
 	 .ident = "Toshiba Satellite 4030cdt",
 	 .matches = {DMI_MATCH(DMI_PRODUCT_NAME, "S4030CDT/4.3"),},
 	 },
+	{
+	 .callback = init_ich7_sci_en_quirk,
+	 .ident = "Apple MacBook",
+	 .matches = {DMI_MATCH(DMI_PRODUCT_NAME, "MacBook1,1"),},
+	 },
+	{
+	 .callback = init_ich7_sci_en_quirk,
+	 .ident = "Apple MacBook",
+	 .matches = {DMI_MATCH(DMI_PRODUCT_NAME, "MacBook2,1"),},
+	 },
 	{},
 };
 
diff -pruN linux/sound/pci/hda.vanilla/patch_sigmatel.c linux/sound/pci/hda/patch_sigmatel.c
--- linux/sound/pci/hda.vanilla/patch_sigmatel.c	2006-11-26 11:20:30.000000000 +0800
+++ linux/sound/pci/hda/patch_sigmatel.c	2006-11-26 12:13:42.000000000 +0800
@@ -364,11 +364,39 @@ static unsigned int d945gtp5_pin_configs
 	0x02a19320, 0x40000100,
 };
 
+/* Microphone working, but no front (old Bootcamp, proto2.ini) */
+/*static unsigned int macmini_pin_configs[10] = {
+	0x0121E230, 0x90A70120, 0x9017E110, 0x400000FE,
+	0x400000FD, 0x0181E021, 0x1145E040, 0x400000FA,
+	0x400000FC, 0x400000FB
+};*/
+
+/* Microphone working, but no front (old Bootcamp, proto.ini) */
+/*static unsigned int macmini_pin_configs[10] = {
+	0x0121E220, 0x400000FF, 0x9017E110, 0x400000FE,
+	0x400000FD, 0x0181E040, 0x1145E030, 0x11C5E040,
+	0x400000FC, 0x400000FB
+};*/
+
+/* Jason's working pins */
+/*static unsigned int macmini_pin_configs[10] = {
+	0x0321E230, 0x03A1E020, 0x9017E110, 0x400000FD,
+	0x400000FE, 0x0381E021, 0x1345E240, 0x13C5E22E,
+	0x400000FC, 0x400000FB,
+};*/
+
+/* Nicolas' working pins, map unmapped pins from Jason's pins with the default */
+static unsigned int macmini_pin_configs[10] = {
+	0x0321E230, 0x03A1E020, 0x9017E110, 0x01014010,
+	0x01a19021, 0x0381E021, 0x1345E240, 0x13C5E22E,
+	0x02a19320, 0x400000FB,
+};
+
 static unsigned int *stac922x_brd_tbl[STAC_922X_MODELS] = {
 	[STAC_REF] =	ref922x_pin_configs,
 	[STAC_D945GTP3] = d945gtp3_pin_configs,
 	[STAC_D945GTP5] = d945gtp5_pin_configs,
-	[STAC_MACMINI] = d945gtp5_pin_configs,
+	[STAC_MACMINI] = macmini_pin_configs,
 };
 
 static struct hda_board_config stac922x_cfg_tbl[] = {
diff -uNr linux-2.6.19/drivers/usb/input/hid-core.c linux-2.6.19-mactel/drivers/usb/input/hid-core.c
--- linux-2.6.19/drivers/usb/input/hid-core.c	2006-11-29 22:57:37.000000000 +0100
+++ linux-2.6.19-mactel/drivers/usb/input/hid-core.c	2006-11-30 09:20:49.000000000 +0100
@@ -1627,6 +1627,16 @@
 
 #define USB_VENDOR_ID_APPLE		0x05ac
 #define USB_DEVICE_ID_APPLE_MIGHTYMOUSE	0x0304
+#define USB_DEVICE_ID_APPLE_GEYSER_ANSI	0x0214
+#define USB_DEVICE_ID_APPLE_GEYSER_ISO	0x0215
+#define USB_DEVICE_ID_APPLE_GEYSER_JIS	0x0216
+#define USB_DEVICE_ID_APPLE_GEYSER3_ANSI	0x0217
+#define USB_DEVICE_ID_APPLE_GEYSER3_ISO		0x0218
+#define USB_DEVICE_ID_APPLE_GEYSER3_JIS		0x0219
+#define USB_DEVICE_ID_APPLE_GEYSER4_ANSI	0x021A
+#define USB_DEVICE_ID_APPLE_GEYSER4_ISO		0x021B
+#define USB_DEVICE_ID_APPLE_GEYSER4_JIS		0x021C
+#define USB_DEVICE_ID_APPLE_IR		0x8240
 
 #define USB_VENDOR_ID_CHERRY		0x046a
 #define USB_DEVICE_ID_CHERRY_CYMOTION	0x0023
@@ -1794,17 +1804,21 @@
 
 	{ USB_VENDOR_ID_CHERRY, USB_DEVICE_ID_CHERRY_CYMOTION, HID_QUIRK_CYMOTION },
 
-	{ USB_VENDOR_ID_APPLE, 0x020E, HID_QUIRK_POWERBOOK_HAS_FN },
-	{ USB_VENDOR_ID_APPLE, 0x020F, HID_QUIRK_POWERBOOK_HAS_FN },
-	{ USB_VENDOR_ID_APPLE, 0x0214, HID_QUIRK_POWERBOOK_HAS_FN },
-	{ USB_VENDOR_ID_APPLE, 0x0215, HID_QUIRK_POWERBOOK_HAS_FN | HID_QUIRK_POWERBOOK_ISO_KEYBOARD},
-	{ USB_VENDOR_ID_APPLE, 0x0216, HID_QUIRK_POWERBOOK_HAS_FN },
-	{ USB_VENDOR_ID_APPLE, 0x0217, HID_QUIRK_POWERBOOK_HAS_FN },
-	{ USB_VENDOR_ID_APPLE, 0x0218, HID_QUIRK_POWERBOOK_HAS_FN | HID_QUIRK_POWERBOOK_ISO_KEYBOARD},
-	{ USB_VENDOR_ID_APPLE, 0x0219, HID_QUIRK_POWERBOOK_HAS_FN },
-	{ USB_VENDOR_ID_APPLE, 0x021B, HID_QUIRK_POWERBOOK_HAS_FN },
-	{ USB_VENDOR_ID_APPLE, 0x030A, HID_QUIRK_POWERBOOK_HAS_FN },
-	{ USB_VENDOR_ID_APPLE, 0x030B, HID_QUIRK_POWERBOOK_HAS_FN },
+	{ USB_VENDOR_ID_APPLE, USB_DEVICE_ID_APPLE_GEYSER_ANSI, HID_QUIRK_POWERBOOK_HAS_FN | HID_QUIRK_IGNORE_MOUSE},
+	{ USB_VENDOR_ID_APPLE, USB_DEVICE_ID_APPLE_GEYSER_ISO, HID_QUIRK_POWERBOOK_HAS_FN | HID_QUIRK_IGNORE_MOUSE | HID_QUIRK_POWERBOOK_ISO_KEYBOARD},
+	{ USB_VENDOR_ID_APPLE, USB_DEVICE_ID_APPLE_GEYSER_JIS, HID_QUIRK_POWERBOOK_HAS_FN | HID_QUIRK_IGNORE_MOUSE},
+	{ USB_VENDOR_ID_APPLE, USB_DEVICE_ID_APPLE_GEYSER3_ANSI, HID_QUIRK_POWERBOOK_HAS_FN | HID_QUIRK_IGNORE_MOUSE},
+	{ USB_VENDOR_ID_APPLE, USB_DEVICE_ID_APPLE_GEYSER3_ISO, HID_QUIRK_POWERBOOK_HAS_FN | HID_QUIRK_IGNORE_MOUSE | HID_QUIRK_POWERBOOK_ISO_KEYBOARD},
+	{ USB_VENDOR_ID_APPLE, USB_DEVICE_ID_APPLE_GEYSER3_JIS, HID_QUIRK_POWERBOOK_HAS_FN | HID_QUIRK_IGNORE_MOUSE},
+	{ USB_VENDOR_ID_APPLE, USB_DEVICE_ID_APPLE_GEYSER4_ANSI, HID_QUIRK_POWERBOOK_HAS_FN | HID_QUIRK_IGNORE_MOUSE},
+	{ USB_VENDOR_ID_APPLE, USB_DEVICE_ID_APPLE_GEYSER4_ISO, HID_QUIRK_POWERBOOK_HAS_FN | HID_QUIRK_IGNORE_MOUSE | HID_QUIRK_POWERBOOK_ISO_KEYBOARD},
+	{ USB_VENDOR_ID_APPLE, USB_DEVICE_ID_APPLE_GEYSER4_JIS, HID_QUIRK_POWERBOOK_HAS_FN | HID_QUIRK_IGNORE_MOUSE},
+	{ USB_VENDOR_ID_APPLE, 0x020E, HID_QUIRK_POWERBOOK_HAS_FN | HID_QUIRK_IGNORE_MOUSE},
+	{ USB_VENDOR_ID_APPLE, 0x020F, HID_QUIRK_POWERBOOK_HAS_FN | HID_QUIRK_IGNORE_MOUSE},
+	{ USB_VENDOR_ID_APPLE, 0x030A, HID_QUIRK_POWERBOOK_HAS_FN | HID_QUIRK_IGNORE_MOUSE},
+	{ USB_VENDOR_ID_APPLE, 0x030B, HID_QUIRK_POWERBOOK_HAS_FN | HID_QUIRK_IGNORE_MOUSE},
+
+	{ USB_VENDOR_ID_APPLE, USB_DEVICE_ID_APPLE_IR, HID_QUIRK_IGNORE },
 
 	{ USB_VENDOR_ID_PANJIT, 0x0001, HID_QUIRK_IGNORE },
 	{ USB_VENDOR_ID_PANJIT, 0x0002, HID_QUIRK_IGNORE },
@@ -1903,6 +1917,10 @@
 	if (quirks & HID_QUIRK_IGNORE)
 		return NULL;
 
+	if ((quirks & HID_QUIRK_IGNORE_MOUSE) &&
+		(interface->desc.bInterfaceProtocol == USB_INTERFACE_PROTOCOL_MOUSE))
+			return NULL;
+
 	if (usb_get_extra_descriptor(interface, HID_DT_HID, &hdesc) &&
 	    (!interface->desc.bNumEndpoints ||
 	     usb_get_extra_descriptor(&interface->endpoint[0], HID_DT_HID, &hdesc))) {
diff -uNr linux-2.6.19/drivers/usb/input/hid.h linux-2.6.19-mactel/drivers/usb/input/hid.h
--- linux-2.6.19/drivers/usb/input/hid.h	2006-11-29 22:57:37.000000000 +0100
+++ linux-2.6.19-mactel/drivers/usb/input/hid.h	2006-11-30 09:21:18.000000000 +0100
@@ -261,6 +261,7 @@
 #define HID_QUIRK_POWERBOOK_FN_ON		0x00002000
 #define HID_QUIRK_INVERT_HWHEEL			0x00004000
 #define HID_QUIRK_POWERBOOK_ISO_KEYBOARD	0x00008000
+#define HID_QUIRK_IGNORE_MOUSE			0x00010000
 
 /*
  * This is the global environment of the parser. This information is
