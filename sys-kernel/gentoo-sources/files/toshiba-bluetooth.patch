--- linux-source-2.6.14.orig/drivers/acpi/toshiba_acpi.c	2005-10-28 02:02:08.000000000 +0200
+++ linux-source-2.6.14/drivers/acpi/toshiba_acpi.c	2005-11-12 14:14:05.000000000 +0100
@@ -33,7 +33,7 @@
  *
  */
 
-#define TOSHIBA_ACPI_VERSION	"0.18"
+#define TOSHIBA_ACPI_VERSION	"0.18-p1"
 #define PROC_INTERFACE_VERSION	1
 
 #include <linux/kernel.h>
@@ -209,10 +209,36 @@ static acpi_status hci_read1(u32 reg, u3
 	return status;
 }
 
+static acpi_status
+hci_write2(u32 reg, u32 in1, u32 in2, u32* result)
+{
+        u32 in[HCI_WORDS] = { HCI_SET, reg, in1, in2, 0, 0 };
+        u32 out[HCI_WORDS];
+        acpi_status status = hci_raw(in, out);
+        *result = (status == AE_OK) ? out[0] : HCI_FAILURE;
+        return status;
+}
+
+static acpi_status
+hci_read2(u32 reg, u32* out1, u32* out2, u32* result)
+{
+        u32 in[HCI_WORDS] = { HCI_GET, reg, *out1, *out2, 0, 0 };
+        u32 out[HCI_WORDS];
+        acpi_status status = hci_raw(in, out);
+        *out1 = out[2];
+        *out2 = out[3];
+        *result = (status == AE_OK) ? out[0] : HCI_FAILURE;
+        return status;
+}
+
+
+
+
 static struct proc_dir_entry *toshiba_proc_dir /*= 0*/ ;
 static int force_fan;
 static int last_key_event;
 static int key_event_valid;
+static int arbitrary, arbitrary2, arbitrary1;
 
 typedef struct _ProcItem {
 	const char *name;
@@ -455,6 +481,171 @@ static unsigned long write_keys(const ch
 	return count;
 }
 
+static char*
+read_wk(char* p)
+{
+        u32 hci_result;
+        u32 value, value2;
+        value = 0;
+        value2 = 0x0001;
+        hci_read2(0x0056, &value, &value2, &hci_result);
+        if (hci_result == HCI_SUCCESS) {
+                p += sprintf(p,"wireless key:                  %d\n", value );
+        } else {
+                p += sprintf(p, "ERROR\n");
+        }
+
+        return p;
+}
+
+static char*
+read_bt(char* p)
+{
+        u32 hci_result;
+        u32 value, value2;
+        value = 0;
+        value2 = 0;
+        hci_read2(0x0056, &value, &value2, &hci_result);
+        if (hci_result == HCI_SUCCESS) {
+/*              p += sprintf(p,"present:                  %d\n", value);*/
+                p += sprintf(p,"present:                  %d\n", (value & 0x0f)?1:0);
+        } else {
+                p += sprintf(p, "ERROR\n");
+        }
+        value = 0;
+        value2 = 0x0001;
+        hci_read2(0x0056, &value, &value2, &hci_result);
+        if (hci_result == HCI_SUCCESS) {
+                p += sprintf(p,"power:                    %d\n", (value & 128) >> 7);
+                p += sprintf(p,"attach:                   %d\n", (value &  64) >> 6);
+                p += sprintf(p,"wireless:                 %d\n", (value & 512) >> 9);
+        } else {
+                p += sprintf(p, "ERROR\n");
+        }
+
+        return p;
+}
+
+static unsigned long
+write_bt(const char* buffer, unsigned long count)
+{
+        int value, value2;
+        u32 hci_result;
+        value2 = 0x0080;
+
+        if (sscanf(buffer, " power : %i", &value) == 1 &&
+                        value >= 0 && value <= 1) {
+                hci_write2(0x0056, value, value2, &hci_result);
+                if (hci_result != HCI_SUCCESS)
+                        return -EFAULT;
+        } else
+        if (sscanf(buffer, " attach : %i", &value) == 1 &&
+                        value >= 0 && value <= 1) {
+                value2 = 0x0040;
+                hci_write2(0x0056, value, value2, &hci_result);
+                if (hci_result != HCI_SUCCESS)
+                        return -EFAULT;
+        } else
+        if (sscanf(buffer, " orinoco : %i", &value) == 1 &&
+                        value >= 0 && value <= 1) {
+                value2 = 0x0200;
+                hci_write2(0x0056, value, value2, &hci_result);
+                if (hci_result != HCI_SUCCESS)
+                        return -EFAULT;
+        } else {
+                return -EINVAL;
+        }
+
+        return count;
+}
+
+static char*
+read_arb(char* p)
+{
+        u32 hci_result;
+        u32 value, value2;
+        value = 0;
+        value2 = arbitrary2;
+                p += sprintf(p,"arg1 :                  %d\n", value  );
+                p += sprintf(p,"arg2 :                  %d\n", value2 );
+        hci_read2(arbitrary, &value, &value2, &hci_result);
+        if (hci_result == HCI_SUCCESS) {
+                p += sprintf(p,"arbitrary call:                  %d\n", arbitrary);
+
+                p += sprintf(p,"return1:                  %x\n", value);
+                p += sprintf(p,"return2:                  %x\n",value2);
+        } else
+                p += sprintf(p, "ERROR\n");
+
+        return p;
+}
+
+static unsigned long
+write_arb(const char* buffer, unsigned long count)
+{
+        int value, value2, i;
+        u32 hci_result;
+        value2 = 0x0080;
+
+        sscanf(buffer, " arb : %i", &value) ;
+        	arbitrary=value;
+        i=0;
+        while(buffer[i]!=';')i++;  
+        if (sscanf(buffer+i+1, " arb2 : %i", &value) == 1 )
+        	arbitrary2=value;
+        else      
+                return -EINVAL;
+
+        return count;
+}
+
+
+static char*
+read_arb_c(char* p)
+{
+	u32 hci_result;
+	u32 value, value2;
+
+	value = arbitrary1;
+	value2 = arbitrary2;
+	p += sprintf(p,"arg1 :                  %d\n", value  );
+	p += sprintf(p,"arg2 :                  %d\n", value2 );
+
+	hci_write2(arbitrary, value, value2, &hci_result);
+	if (hci_result == HCI_SUCCESS) {
+		p += sprintf(p,"arbitrary call:                  %d\n", arbitrary);
+		p += sprintf(p,"return1:                  %d\n", value);
+		p += sprintf(p,"return2:                  %d\n",value2);
+        } else
+		p += sprintf(p, "ERROR\n");
+
+	return p;
+}
+
+static unsigned long
+write_arb_c(const char* buffer, unsigned long count)
+{
+	int value, value2, i;
+	u32 hci_result;
+	value2 = 0x0080;
+
+	sscanf(buffer, " arb : %i", &value) ;
+	arbitrary=value;
+	i=0;
+	while(buffer[i]!=';')i++;
+	sscanf(buffer+i+1, " arb2 : %i", &value);
+	arbitrary2=value;
+	i++;  
+	while(buffer[i]!=';')i++;  
+	if (sscanf(buffer+i+1, " arb1 : %i", &value) == 1 )
+		arbitrary1=value;
+	else      
+		return -EINVAL;
+
+	return count;
+}
+
+
 static char *read_version(char *p)
 {
 	p += sprintf(p, "driver:                  %s\n", TOSHIBA_ACPI_VERSION);
@@ -474,6 +665,8 @@ static ProcItem proc_items[] = {
 	{"fan", read_fan, write_fan},
 	{"keys", read_keys, write_keys},
 	{"version", read_version, NULL},
+	{ "wireless_key", read_wk       , 0             },
+	{ "bluetooth"   , read_bt       , write_bt      },
 	{NULL}
 };
 
@@ -484,7 +677,7 @@ static acpi_status __init add_device(voi
 
 	for (item = proc_items; item->name; ++item) {
 		proc = create_proc_read_entry(item->name,
-					      S_IFREG | S_IRUGO | S_IWUSR,
+					      S_IFREG | S_IRUGO | S_IWUGO,
 					      toshiba_proc_dir,
 					      (read_proc_t *) dispatch_read,
 					      item);
