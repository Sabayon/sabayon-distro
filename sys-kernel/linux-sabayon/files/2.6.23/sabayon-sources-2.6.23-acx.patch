diff -Nurp linux-2.6.23-sabayon.orig/drivers/net/wireless/acx/acx_config.h linux-2.6.23-sabayon/drivers/net/wireless/acx/acx_config.h
--- linux-2.6.23-sabayon.orig/drivers/net/wireless/acx/acx_config.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.23-sabayon/drivers/net/wireless/acx/acx_config.h	2007-10-10 10:51:23.000000000 +0200
@@ -0,0 +1,44 @@
+/* temporary hack until proper Kconfig integration */
+//#define CONFIG_ACX_MAC80211_PCI 1
+//#define CONFIG_ACX_MAC80211_USB 1
+
+#define ACX_RELEASE "v0.3.36-mac80211"
+
+/* set to 0 if you don't want any debugging code to be compiled in */
+/* set to 1 if you want some debugging */
+/* set to 2 if you want extensive debug log */
+#define ACX_DEBUG 2
+#define ACX_DEFAULT_MSG (L_ASSOC|L_INIT)
+
+/* assume 32bit I/O width
+ * (16bit is also compatible with Compact Flash) */
+#define ACX_IO_WIDTH 32
+
+/* Set this to 1 if you want monitor mode to use
+ * phy header. Currently it is not useful anyway since we
+ * don't know what useful info (if any) is in phy header.
+ * If you want faster/smaller code, say 0 here */
+#define WANT_PHY_HDR 0
+
+/* whether to do Tx descriptor cleanup in softirq (i.e. not in IRQ
+ * handler) or not. Note that doing it later does slightly increase
+ * system load, so still do that stuff in the IRQ handler for now,
+ * even if that probably means worse latency */
+#define TX_CLEANUP_IN_SOFTIRQ 0
+
+/* if you want very experimental 802.11 power save mode features */
+#define POWER_SAVE_80211 0
+
+/* if you want very early packet fragmentation bits and pieces */
+#define ACX_FRAGMENTATION 0
+
+/* Locking: */
+/* very talkative */
+/* #define PARANOID_LOCKING 1 */
+/* normal (use when bug-free) */
+#define DO_LOCKING 1
+/* else locking is disabled! */
+
+/* 0 - normal mode */
+/* 1 - development/debug: probe for IEs on modprobe */
+#define CMD_DISCOVERY 0
diff -Nurp linux-2.6.23-sabayon.orig/drivers/net/wireless/acx/acx_func.h linux-2.6.23-sabayon/drivers/net/wireless/acx/acx_func.h
--- linux-2.6.23-sabayon.orig/drivers/net/wireless/acx/acx_func.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.23-sabayon/drivers/net/wireless/acx/acx_func.h	2007-10-10 10:51:23.000000000 +0200
@@ -0,0 +1,645 @@
+/** (legal) claimer in README
+** Copyright (C) 2003  ACX100 Open Source Project
+*/
+
+
+/***********************************************************************
+** LOGGING
+**
+** - Avoid SHOUTING needlessly. Avoid excessive verbosity.
+**   Gradually remove messages which are old debugging aids.
+**
+** - Use printk() for messages which are to be always logged.
+**   Supply either 'acx:' or '<devname>:' prefix so that user
+**   can figure out who's speaking among other kernel chatter.
+**   acx: is for general issues (e.g. "acx: no firmware image!")
+**   while <devname>: is related to a particular device
+**   (think about multi-card setup). Double check that message
+**   is not confusing to the average user.
+**
+** - use printk KERN_xxx level only if message is not a WARNING
+**   but is INFO, ERR etc.
+**
+** - Use printk_ratelimited() for messages which may flood
+**   (e.g. "rx DUP pkt!").
+**
+** - Use log() for messages which may be omitted (and they
+**   _will_ be omitted in non-debug builds). Note that
+**   message levels may be disabled at compile-time selectively,
+**   thus select them wisely. Example: L_DEBUG is the lowest
+**   (most likely to be compiled out) -> use for less important stuff.
+**
+** - Do not print important stuff with log(), or else people
+**   will never build non-debug driver.
+**
+** Style:
+** hex: capital letters, zero filled (e.g. 0x02AC)
+** str: dont start from capitals, no trailing periods ("tx: queue is stopped")
+*/
+#if ACX_DEBUG > 1
+
+void log_fn_enter(const char *funcname);
+void log_fn_exit(const char *funcname);
+void log_fn_exit_v(const char *funcname, int v);
+
+#define FN_ENTER \
+	do { \
+		if (unlikely(acx_debug & L_FUNC)) { \
+			log_fn_enter(__func__); \
+		} \
+	} while (0)
+
+#define FN_EXIT1(v) \
+	do { \
+		if (unlikely(acx_debug & L_FUNC)) { \
+			log_fn_exit_v(__func__, v); \
+		} \
+	} while (0)
+#define FN_EXIT0 \
+	do { \
+		if (unlikely(acx_debug & L_FUNC)) { \
+			log_fn_exit(__func__); \
+		} \
+	} while (0)
+
+#else
+
+#define FN_ENTER
+#define FN_EXIT1(v)
+#define FN_EXIT0
+
+#endif /* ACX_DEBUG > 1 */
+
+
+#if ACX_DEBUG
+
+#define log(chan, args...) \
+	do { \
+		if (acx_debug & (chan)) \
+			printk(args); \
+	} while (0)
+#define printk_ratelimited(args...) printk(args)
+
+#else /* Non-debug build: */
+
+#define log(chan, args...)
+/* Standard way of log flood prevention */
+#define printk_ratelimited(args...) \
+do { \
+	if (printk_ratelimit()) \
+		printk(args); \
+} while (0)
+
+#endif /* ACX_DEBUG */
+
+void acx_print_mac(const char *head, const u8 *mac, const char *tail);
+
+/* Optimized out to nothing in non-debug build */
+static inline void
+acxlog_mac(int level, const char *head, const u8 *mac, const char *tail)
+{
+	if (acx_debug & level) {
+		acx_print_mac(head, mac, tail);
+	}
+}
+
+
+/***********************************************************************
+** MAC address helpers
+*/
+static inline void
+MAC_COPY(u8 *mac, const u8 *src)
+{
+	memcpy(mac, src, ETH_ALEN);
+}
+
+static inline void
+MAC_FILL(u8 *mac, u8 val)
+{
+	memset(mac, val, ETH_ALEN);
+}
+
+static inline void
+MAC_BCAST(u8 *mac)
+{
+	((u16*)mac)[2] = *(u32*)mac = -1;
+}
+
+static inline void
+MAC_ZERO(u8 *mac)
+{
+	((u16*)mac)[2] = *(u32*)mac = 0;
+}
+
+static inline int
+mac_is_equal(const u8 *a, const u8 *b)
+{
+	/* can't beat this */
+	return memcmp(a, b, ETH_ALEN) == 0;
+}
+
+static inline int
+mac_is_bcast(const u8 *mac)
+{
+	/* AND together 4 first bytes with sign-extended 2 last bytes
+	** Only bcast address gives 0xffffffff. +1 gives 0 */
+	return ( *(s32*)mac & ((s16*)mac)[2] ) + 1 == 0;
+}
+
+static inline int
+mac_is_zero(const u8 *mac)
+{
+	return ( *(u32*)mac | ((u16*)mac)[2] ) == 0;
+}
+
+static inline int
+mac_is_directed(const u8 *mac)
+{
+	return (mac[0] & 1)==0;
+}
+
+static inline int
+mac_is_mcast(const u8 *mac)
+{
+	return (mac[0] & 1) && !mac_is_bcast(mac);
+}
+
+#define MACSTR "%02X:%02X:%02X:%02X:%02X:%02X"
+#define MAC(bytevector) \
+	((unsigned char *)bytevector)[0], \
+	((unsigned char *)bytevector)[1], \
+	((unsigned char *)bytevector)[2], \
+	((unsigned char *)bytevector)[3], \
+	((unsigned char *)bytevector)[4], \
+	((unsigned char *)bytevector)[5]
+
+
+/***********************************************************************
+** Random helpers
+*/
+#define TO_STRING(x)	#x
+#define STRING(x)	TO_STRING(x)
+
+#define CLEAR_BIT(val, mask) ((val) &= ~(mask))
+#define SET_BIT(val, mask) ((val) |= (mask))
+#define CHECK_BIT(val, mask) ((val) & (mask))
+
+/* undefined if v==0 */
+static inline unsigned int
+lowest_bit(u16 v)
+{
+	unsigned int n = 0;
+	while (!(v & 0xf)) { v>>=4; n+=4; }
+	while (!(v & 1)) { v>>=1; n++; }
+	return n;
+}
+
+/* undefined if v==0 */
+static inline unsigned int
+highest_bit(u16 v)
+{
+	unsigned int n = 0;
+	while (v>0xf) { v>>=4; n+=4; }
+	while (v>1) { v>>=1; n++; }
+	return n;
+}
+
+/* undefined if v==0 */
+static inline int
+has_only_one_bit(u16 v)
+{
+	return ((v-1) ^ v) >= v;
+}
+
+
+static inline int
+is_hidden_essid(char *essid)
+{
+	return (('\0' == essid[0]) ||
+		((' ' == essid[0]) && ('\0' == essid[1])));
+}
+
+/***********************************************************************
+** LOCKING
+** We have adev->sem and adev->lock.
+**
+** We employ following naming convention in order to get locking right:
+**
+** acx_e_xxxx - external entry points called from process context.
+**	It is okay to sleep. adev->sem is to be taken on entry.
+** acx_i_xxxx - external entry points possibly called from atomic context.
+**	Sleeping is not allowed (and thus down(sem) is not legal!)
+** acx_s_xxxx - potentially sleeping functions. Do not ever call under lock!
+** acx_l_xxxx - functions which expect lock to be already taken.
+** rest       - non-sleeping functions which do not require locking
+**		but may be run under lock
+**
+** A small number of local helpers do not have acx_[eisl]_ prefix.
+** They are always close to caller and are to be reviewed locally.
+**
+** Theory of operation:
+**
+** All process-context entry points (_e_ functions) take sem
+** immediately. IRQ handler and other 'atomic-context' entry points
+** (_i_ functions) take lock immediately on entry, but dont take sem
+** because that might sleep.
+**
+** Thus *all* code is either protected by sem or lock, or both.
+**
+** Code which must not run concurrently with IRQ takes lock.
+** Such code is marked with _l_.
+**
+** This results in the following rules of thumb useful in code review:
+**
+** + If a function calls _s_ fn, it must be an _s_ itself.
+** + You can call _l_ fn only (a) from another _l_ fn
+**   or (b) from _s_, _e_ or _i_ fn by taking lock, calling _l_,
+**   and dropping lock.
+** + All IRQ code runs under lock.
+** + Any _s_ fn is running under sem.
+** + Code under sem can race only with IRQ code.
+** + Code under sem+lock cannot race with anything.
+*/
+
+/* These functions *must* be inline or they will break horribly on SPARC, due
+ * to its weird semantics for save/restore flags */
+
+#if defined(PARANOID_LOCKING) /* Lock debugging */
+
+void acx_lock_debug(acx_device_t *adev, const char* where);
+void acx_unlock_debug(acx_device_t *adev, const char* where);
+void acx_down_debug(acx_device_t *adev, const char* where);
+void acx_up_debug(acx_device_t *adev, const char* where);
+void acx_lock_unhold(void);
+void acx_sem_unhold(void);
+
+static inline void
+acx_lock_helper(acx_device_t *adev, unsigned long *fp, const char* where)
+{
+	acx_lock_debug(adev, where);
+	spin_lock_irqsave(&adev->lock, *fp);
+}
+static inline void
+acx_unlock_helper(acx_device_t *adev, unsigned long *fp, const char* where)
+{
+	acx_unlock_debug(adev, where);
+	spin_unlock_irqrestore(&adev->lock, *fp);
+}
+#define acx_lock(adev, flags)	acx_lock_helper(adev, &(flags), __FILE__ ":" STRING(__LINE__))
+#define acx_unlock(adev, flags)	acx_unlock_helper(adev, &(flags), __FILE__ ":" STRING(__LINE__))
+#define acx_sem_lock(adev)	mutex_lock(&(adev)->mutex)
+#define acx_sem_unlock(adev)	mutex_unlock(&(adev)->mutex)
+
+#elif defined(DO_LOCKING)
+
+#define acx_lock(adev, flags)	spin_lock_irqsave(&adev->lock, flags)
+#define acx_unlock(adev, flags)	spin_unlock_irqrestore(&adev->lock, flags)
+#define acx_sem_lock(adev)	mutex_lock(&(adev)->mutex)
+#define acx_sem_unlock(adev)	mutex_unlock(&(adev)->mutex)
+#define acx_lock_unhold()	((void)0)
+#define acx_sem_unhold()	((void)0)
+
+#else /* no locking! :( */
+
+#define acx_lock(adev, flags)	((void)0)
+#define acx_unlock(adev, flags)	((void)0)
+#define acx_sem_lock(adev)	((void)0)
+#define acx_sem_unlock(adev)	((void)0)
+#define acx_lock_unhold()	((void)0)
+#define acx_sem_unhold()	((void)0)
+
+#endif
+
+
+/***********************************************************************
+*/
+
+/* Can race with rx path (which is not protected by sem):
+** rx -> process_[re]assocresp() -> set_status(ASSOCIATED) -> wake_queue()
+** Can race with tx_complete IRQ:
+** IRQ -> acxpci_l_clean_txdesc -> acx_wake_queue
+** Review carefully all callsites */
+static inline void
+acx_stop_queue(struct ieee80211_hw *hw, const char *msg)
+{/*
+	if (netif_queue_stopped(ndev))
+		return;
+*/
+	ieee80211_stop_queues(hw);
+	if (msg)
+		log(L_BUFT, "tx: stop queue %s\n", msg);
+}
+
+/*static inline int
+acx_queue_stopped(struct ieee80211_hw *ieee)
+{
+	return netif_queue_stopped(ieee);
+}
+
+
+static inline void
+acx_start_queue(struct ieee80211_hw *hw, const char *msg)
+{
+	ieee80211_start_queues(hw);
+	if (msg)
+		log(L_BUFT, "tx: start queue %s\n", msg);
+}
+*/
+static inline void
+acx_wake_queue(struct ieee80211_hw *hw, const char *msg)
+{
+	ieee80211_wake_queues(hw);
+	if (msg)
+		log(L_BUFT, "tx: wake queue %s\n", msg);
+}
+/*
+static inline void
+acx_carrier_off(struct net_device *ndev, const char *msg)
+{
+	netif_carrier_off(ndev);
+	if (msg)
+		log(L_BUFT, "tx: carrier off %s\n", msg);
+}
+
+static inline void
+acx_carrier_on(struct net_device *ndev, const char *msg)
+{
+	netif_carrier_on(ndev);
+	if (msg)
+		log(L_BUFT, "tx: carrier on %s\n", msg);
+}
+
+*/
+
+
+/***********************************************************************
+** Communication with firmware
+*/
+#define CMD_TIMEOUT_MS(n)	(n)
+#define ACX_CMD_TIMEOUT_DEFAULT	CMD_TIMEOUT_MS(50)
+
+#if ACX_DEBUG
+
+/* We want to log cmd names */
+int acxpci_s_issue_cmd_timeo_debug(acx_device_t *adev, unsigned cmd, void *param, unsigned len, unsigned timeout, const char* cmdstr);
+int acxusb_s_issue_cmd_timeo_debug(acx_device_t *adev, unsigned cmd, void *param, unsigned len, unsigned timeout, const char* cmdstr);
+static inline int
+acx_s_issue_cmd_timeo_debug(acx_device_t *adev, unsigned cmd, void *param, unsigned len, unsigned timeout, const char* cmdstr)
+{
+	if (IS_PCI(adev))
+		return acxpci_s_issue_cmd_timeo_debug(adev, cmd, param, len, timeout, cmdstr);
+	return acxusb_s_issue_cmd_timeo_debug(adev, cmd, param, len, timeout, cmdstr);
+}
+#define acx_s_issue_cmd(adev,cmd,param,len) \
+	acx_s_issue_cmd_timeo_debug(adev,cmd,param,len,ACX_CMD_TIMEOUT_DEFAULT,#cmd)
+#define acx_s_issue_cmd_timeo(adev,cmd,param,len,timeo) \
+	acx_s_issue_cmd_timeo_debug(adev,cmd,param,len,timeo,#cmd)
+int acx_s_configure_debug(acx_device_t *adev, void *pdr, int type, const char* str);
+#define acx_s_configure(adev,pdr,type) \
+	acx_s_configure_debug(adev,pdr,type,#type)
+int acx_s_interrogate_debug(acx_device_t *adev, void *pdr, int type, const char* str);
+#define acx_s_interrogate(adev,pdr,type) \
+	acx_s_interrogate_debug(adev,pdr,type,#type)
+
+#else
+
+int acxpci_s_issue_cmd_timeo(acx_device_t *adev, unsigned cmd, void *param, unsigned len, unsigned timeout);
+int acxusb_s_issue_cmd_timeo(acx_device_t *adev, unsigned cmd, void *param, unsigned len, unsigned timeout);
+static inline int
+acx_s_issue_cmd_timeo(acx_device_t *adev, unsigned cmd,	void *param, unsigned len, unsigned timeout)
+{
+	if (IS_PCI(adev))
+		return acxpci_s_issue_cmd_timeo(adev, cmd, param, len, timeout);
+	return acxusb_s_issue_cmd_timeo(adev, cmd, param, len, timeout);
+}
+static inline int
+acx_s_issue_cmd(acx_device_t *adev, unsigned cmd, void *param, unsigned len)
+{
+	if (IS_PCI(adev))
+		return acxpci_s_issue_cmd_timeo(adev, cmd, param, len, ACX_CMD_TIMEOUT_DEFAULT);
+	return acxusb_s_issue_cmd_timeo(adev, cmd, param, len, ACX_CMD_TIMEOUT_DEFAULT);
+}
+int acx_s_configure(acx_device_t *adev, void *pdr, int type);
+int acx_s_interrogate(acx_device_t *adev, void *pdr, int type);
+
+#endif
+
+void acx_s_cmd_start_scan(acx_device_t *adev);
+
+
+/***********************************************************************
+** Ioctls
+*/
+/*int
+acx111pci_ioctl_info(
+	struct net_device *ndev,
+	struct iw_request_info *info,
+	struct iw_param *vwrq,
+	char *extra);
+int
+acx100pci_ioctl_set_phy_amp_bias(
+	struct net_device *ndev,
+	struct iw_request_info *info,
+	struct iw_param *vwrq,
+	char *extra);
+*/
+
+/***********************************************************************
+** /proc
+*/
+#ifdef CONFIG_PROC_FS
+int acx_proc_register_entries(struct ieee80211_hw *ieee);
+int acx_proc_unregister_entries(struct ieee80211_hw *ieee);
+#else
+static inline int
+acx_proc_register_entries(const struct ieee80211_hw *ieee) { return OK; }
+static inline int
+acx_proc_unregister_entries(const struct ieee80211_hw *ieee) { return OK; }
+#endif
+
+
+/***********************************************************************
+*/
+firmware_image_t *acx_s_read_fw(struct device *dev, const char *file, u32 *size);
+int acxpci_s_upload_radio(acx_device_t *adev);
+
+
+/***********************************************************************
+** Unsorted yet :)
+*/
+int acxpci_s_read_phy_reg(acx_device_t *adev, u32 reg, u8 *charbuf);
+int acxusb_s_read_phy_reg(acx_device_t *adev, u32 reg, u8 *charbuf);
+static inline int
+acx_s_read_phy_reg(acx_device_t *adev, u32 reg, u8 *charbuf)
+{
+	if (IS_PCI(adev))
+		return acxpci_s_read_phy_reg(adev, reg, charbuf);
+	return acxusb_s_read_phy_reg(adev, reg, charbuf);
+}
+
+int acxpci_s_write_phy_reg(acx_device_t *adev, u32 reg, u8 value);
+int acxusb_s_write_phy_reg(acx_device_t *adev, u32 reg, u8 value);
+static inline int
+acx_s_write_phy_reg(acx_device_t *adev, u32 reg, u8 value)
+{
+	if (IS_PCI(adev))
+		return acxpci_s_write_phy_reg(adev, reg, value);
+	return acxusb_s_write_phy_reg(adev, reg, value);
+}
+
+tx_t* acxpci_l_alloc_tx(acx_device_t *adev);
+tx_t* acxusb_l_alloc_tx(acx_device_t *adev);
+static inline tx_t*
+acx_l_alloc_tx(acx_device_t *adev)
+{
+	if (IS_PCI(adev))
+		return acxpci_l_alloc_tx(adev);
+	return acxusb_l_alloc_tx(adev);
+}
+
+void acxusb_l_dealloc_tx(tx_t *tx_opaque);
+static inline void
+acx_l_dealloc_tx(acx_device_t *adev, tx_t *tx_opaque)
+{
+	if (IS_USB(adev))
+		acxusb_l_dealloc_tx(tx_opaque);
+}
+
+void* acxpci_l_get_txbuf(acx_device_t *adev, tx_t *tx_opaque);
+void* acxusb_l_get_txbuf(acx_device_t *adev, tx_t *tx_opaque);
+static inline void*
+acx_l_get_txbuf(acx_device_t *adev, tx_t *tx_opaque)
+{
+	if (IS_PCI(adev))
+		return acxpci_l_get_txbuf(adev, tx_opaque);
+	return acxusb_l_get_txbuf(adev, tx_opaque);
+}
+
+void acxpci_l_tx_data(acx_device_t *adev, tx_t *tx_opaque, int len,
+                        struct ieee80211_tx_control *ieeectl, struct sk_buff *skb);
+void acxusb_l_tx_data(acx_device_t *adev, tx_t *tx_opaque, int len, struct ieee80211_tx_control *ieeectl,
+			struct sk_buff *skb);
+static inline void
+acx_l_tx_data(acx_device_t *adev, tx_t *tx_opaque, int len,
+                        struct ieee80211_tx_control *ieeectl, struct sk_buff *skb)
+{
+	if (IS_PCI(adev))
+		acxpci_l_tx_data(adev, tx_opaque, len, ieeectl,skb);
+	else
+		acxusb_l_tx_data(adev, tx_opaque, len, ieeectl,skb);
+}
+
+static inline struct ieee80211_hdr *
+acx_get_wlan_hdr(acx_device_t *adev, const rxbuffer_t *rxbuf)
+{
+	return (struct ieee80211_hdr *)((u8 *)&rxbuf->hdr_a3 + adev->phy_header_len);
+}
+void acxpci_put_devname(acx_device_t *adev, struct ethtool_drvinfo *info);
+void acxusb_put_devname(acx_device_t *adev, struct ethtool_drvinfo *info);
+static inline void acx_put_devname(acx_device_t *adev, struct ethtool_drvinfo *info)
+{
+	if (IS_PCI(adev))
+		acxpci_put_devname(adev,info);
+	else
+		acxusb_put_devname(adev,info);
+}
+void acxpci_l_power_led(acx_device_t *adev, int enable);
+int acxpci_read_eeprom_byte(acx_device_t *adev, u32 addr, u8 *charbuf);
+unsigned int acxpci_l_clean_txdesc(acx_device_t *adev);
+void acxpci_l_clean_txdesc_emergency(acx_device_t *adev);
+int acxpci_s_create_hostdesc_queues(acx_device_t *adev);
+void acxpci_create_desc_queues(acx_device_t *adev, u32 tx_queue_start, u32 rx_queue_start);
+void acxpci_free_desc_queues(acx_device_t *adev);
+char* acxpci_s_proc_diag_output(char *p, acx_device_t *adev);
+int acxpci_proc_eeprom_output(char *p, acx_device_t *adev);
+void acxpci_set_interrupt_mask(acx_device_t *adev);
+int acx100pci_s_set_tx_level(acx_device_t *adev, u8 level_dbm);
+
+void acx_s_msleep(int ms);
+int acx_s_init_mac(acx_device_t *adev);
+void acx_set_reg_domain(acx_device_t *adev, unsigned char reg_dom_id);
+void acx_update_capabilities(acx_device_t *adev);
+void acx_s_start(acx_device_t *adev);
+
+void acx_s_update_card_settings(acx_device_t *adev);
+void acx_s_parse_configoption(acx_device_t *adev, const acx111_ie_configoption_t *pcfg);
+void acx_l_update_ratevector(acx_device_t *adev);
+
+void acx_init_task_scheduler(acx_device_t *adev);
+void acx_schedule_task(acx_device_t *adev, unsigned int set_flag);
+
+int acx_e_ioctl_old(struct net_device *ndev, struct ifreq *ifr, int cmd);
+
+client_t *acx_l_sta_list_get(acx_device_t *adev, const u8 *address);
+void acx_l_sta_list_del(acx_device_t *adev, client_t *clt);
+
+void acx_i_timer(unsigned long a);
+
+struct sk_buff *acx_rxbuf_to_ether(acx_device_t *adev, rxbuffer_t *rxbuf);
+int acx_ether_to_txbuf(acx_device_t *adev, void *txbuf, const struct sk_buff *skb);
+
+u8 acx_signal_determine_quality(u8 signal, u8 noise);
+
+void acx_l_process_rxbuf(acx_device_t *adev, rxbuffer_t *rxbuf);
+void acx_l_handle_txrate_auto(acx_device_t *adev, struct client *txc,
+			u16 intended_rate, u8 rate100, u16 rate111, u8 error,
+			int pkts_to_ignore);
+
+void acx_dump_bytes(const void *, int);
+
+u8 acx_rate111to100(u16);
+
+void acx_s_set_defaults(acx_device_t *adev);
+
+#if !ACX_DEBUG
+static inline const char* acx_get_packet_type_string(u16 fc) { return ""; }
+#else
+const char* acx_get_packet_type_string(u16 fc);
+#endif
+const char* acx_cmd_status_str(unsigned int state);
+
+/*** Devicescape functions ***/
+int acx_setup_modes(acx_device_t *adev);
+void acx_free_modes(acx_device_t *adev);
+int acx_i_start_xmit(struct ieee80211_hw* ieee, 
+			struct sk_buff *skb, 
+			struct ieee80211_tx_control *ctl);
+int acx_add_interface(struct ieee80211_hw* ieee,
+		struct ieee80211_if_init_conf *conf);
+void acx_remove_interface(struct ieee80211_hw* ieee,
+		struct ieee80211_if_init_conf *conf);
+int acx_net_reset(struct ieee80211_hw* ieee);
+int acx_net_set_key(struct ieee80211_hw *hw, 
+		set_key_cmd cmd,
+		u8 *addr,
+		struct ieee80211_key_conf *key,
+		int aid);
+int acx_config_interface(struct ieee80211_hw* ieee, int if_id, 
+		struct ieee80211_if_conf *conf);
+int acx_net_config(struct ieee80211_hw* ieee, struct ieee80211_conf *conf);
+int acx_net_get_tx_stats(struct ieee80211_hw* ieee, struct ieee80211_tx_queue_stats *stats);
+int acx_net_conf_tx(struct ieee80211_hw* ieee, int queue,
+		const struct ieee80211_tx_queue_params *params);
+//int acx_passive_scan(struct net_device *net_dev, int state, struct ieee80211_scan_conf *conf);
+//static void acx_netdev_init(struct net_device *ndev);
+int acxpci_s_reset_dev(acx_device_t *adev);
+void acx_e_after_interrupt_task(struct work_struct* work);
+void acx_i_set_multicast_list(struct ieee80211_hw *hw,
+                            unsigned short netflags, int mc_count);
+
+/*** End DeviceScape Functions **/
+
+void great_inquisitor(acx_device_t *adev);
+
+void acx_s_get_firmware_version(acx_device_t *adev);
+void acx_display_hardware_details(acx_device_t *adev);
+
+int acx_e_change_mtu(struct ieee80211_hw *hw, int mtu);
+int acx_e_get_stats(struct ieee80211_hw *hw, struct ieee80211_low_level_stats *stats);
+struct iw_statistics* acx_e_get_wireless_stats(struct ieee80211_hw *hw);
+void acx_interrupt_tasklet(struct work_struct *work);
+
+int __init acxpci_e_init_module(void);
+int __init acxusb_e_init_module(void);
+void __exit acxpci_e_cleanup_module(void);
+void __exit acxusb_e_cleanup_module(void);
diff -Nurp linux-2.6.23-sabayon.orig/drivers/net/wireless/acx/acx.h linux-2.6.23-sabayon/drivers/net/wireless/acx/acx.h
--- linux-2.6.23-sabayon.orig/drivers/net/wireless/acx/acx.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.23-sabayon/drivers/net/wireless/acx/acx.h	2007-10-10 10:51:23.000000000 +0200
@@ -0,0 +1,6 @@
+#include <net/mac80211.h>
+#include <net/ieee80211.h>
+#include "acx_config.h"
+#include "acx_mac80211.h"
+#include "acx_struct.h"
+#include "acx_func.h"
diff -Nurp linux-2.6.23-sabayon.orig/drivers/net/wireless/acx/acx_mac80211.h linux-2.6.23-sabayon/drivers/net/wireless/acx/acx_mac80211.h
--- linux-2.6.23-sabayon.orig/drivers/net/wireless/acx/acx_mac80211.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.23-sabayon/drivers/net/wireless/acx/acx_mac80211.h	2007-10-10 10:51:23.000000000 +0200
@@ -0,0 +1,70 @@
+struct acx_key {
+	u8 enabled:1;
+	u8 algorithm;
+};
+
+struct acx_stats {        
+        u8 link_quality;
+        /* Store the last TX/RX times here for updating the leds. */
+        unsigned long last_tx;
+        unsigned long last_rx;
+};
+struct acx_interface {                
+        /* Opaque ID of the operating interface (!= monitor
+         * interface) from the ieee80211 subsystem.
+         * Do not modify.
+         */
+        int if_id;
+        /* MAC address. */                  
+        u8 *mac_addr;        
+        /* Current BSSID (if any). */       
+        u8 *bssid;
+
+        /* Interface type. (IEEE80211_IF_TYPE_XXX) */
+        int type; 
+        /* Counter of active monitor interfaces. */
+        int monitor;
+        /* Is the card operating in AP, STA or IBSS mode? */
+        unsigned int operating:1;           
+        /* Promisc mode active?             
+         * Note that (monitor != 0) implies promisc.
+         */
+        unsigned int promisc:1;             
+};
+#ifdef TODO
+# undef TODO
+#endif
+#define TODO()  \
+        do {                                                                            \
+                printk(KERN_INFO "TODO: Incomplete code in %s() at %s:%d\n",        \
+                       __FUNCTION__, __FILE__, __LINE__);                               \
+        } while (0)
+
+#ifdef FIXME
+# undef FIXME
+#endif
+#define FIXME()  \
+        do {                                                                            \
+                printk(KERN_INFO "FIXME: Possibly broken code in %s() at %s:%d\n",  \
+                       __FUNCTION__, __FILE__, __LINE__);                               \
+        } while (0)     
+
+
+
+#define ACX_MODE_NOTADHOC 0xFFFF
+#define ACX_MODE_PROMISC 0x5
+
+/** Rate values **/
+#define ACX_CCK_RATE_1MB            0x02
+#define ACX_CCK_RATE_2MB            0x04
+#define ACX_CCK_RATE_5MB            0x0B
+#define ACX_CCK_RATE_11MB           0x16
+#define ACX_OFDM_RATE_6MB           0x0C
+#define ACX_OFDM_RATE_9MB           0x12
+#define ACX_OFDM_RATE_12MB          0x18
+#define ACX_OFDM_RATE_18MB          0x24
+#define ACX_OFDM_RATE_24MB          0x30
+#define ACX_OFDM_RATE_36MB          0x48
+#define ACX_OFDM_RATE_48MB          0x60               
+#define ACX_OFDM_RATE_54MB          0x6C
+extern struct ethtool_ops acx_ethtool_ops;  
diff -Nurp linux-2.6.23-sabayon.orig/drivers/net/wireless/acx/acx_struct.h linux-2.6.23-sabayon/drivers/net/wireless/acx/acx_struct.h
--- linux-2.6.23-sabayon.orig/drivers/net/wireless/acx/acx_struct.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.23-sabayon/drivers/net/wireless/acx/acx_struct.h	2007-10-10 10:51:23.000000000 +0200
@@ -0,0 +1,2045 @@
+/**** (legal) claimer in README
+** Copyright (C) 2003  ACX100 Open Source Project
+*/
+
+/***********************************************************************
+** Forward declarations of types
+*/
+typedef struct tx tx_t;
+typedef struct acx_device acx_device_t;
+typedef struct client client_t;
+typedef struct rxdesc rxdesc_t;
+typedef struct txdesc txdesc_t;
+typedef struct rxhostdesc rxhostdesc_t;
+typedef struct txhostdesc txhostdesc_t;
+
+
+/***********************************************************************
+** Debug / log functionality
+*/
+enum {
+	L_LOCK		= (ACX_DEBUG>1)*0x0001,	/* locking debug log */
+	L_INIT		= (ACX_DEBUG>0)*0x0002,	/* special card initialization logging */
+	L_IRQ		= (ACX_DEBUG>0)*0x0004,	/* interrupt stuff */
+	L_ASSOC		= (ACX_DEBUG>0)*0x0008,	/* assocation (network join) and station log */
+	L_FUNC		= (ACX_DEBUG>1)*0x0020,	/* logging of function enter / leave */
+	L_XFER		= (ACX_DEBUG>1)*0x0080,	/* logging of transfers and mgmt */
+	L_DATA		= (ACX_DEBUG>1)*0x0100,	/* logging of transfer data */
+	L_DEBUG		= (ACX_DEBUG>1)*0x0200,	/* log of debug info */
+	L_IOCTL		= (ACX_DEBUG>0)*0x0400,	/* log ioctl calls */
+	L_CTL		= (ACX_DEBUG>1)*0x0800,	/* log of low-level ctl commands */
+	L_BUFR		= (ACX_DEBUG>1)*0x1000,	/* debug rx buffer mgmt (ring buffer etc.) */
+	L_XFER_BEACON	= (ACX_DEBUG>1)*0x2000,	/* also log beacon packets */
+	L_BUFT		= (ACX_DEBUG>1)*0x4000,	/* debug tx buffer mgmt (ring buffer etc.) */
+	L_USBRXTX	= (ACX_DEBUG>0)*0x8000,	/* debug USB rx/tx operations */
+	L_BUF		= L_BUFR + L_BUFT,
+	L_ANY		= 0xffff
+};
+
+#if ACX_DEBUG
+extern unsigned int acx_debug;
+#else
+enum { acx_debug = 0 };
+#endif
+
+
+/***********************************************************************
+** Random helpers
+*/
+#define ACX_PACKED __attribute__ ((packed))
+
+/***********************************************************************
+** Constants
+*/
+#define OK	0
+#define NOT_OK	1
+
+/* The supported chip models */
+#define CHIPTYPE_ACX100		1
+#define CHIPTYPE_ACX111		2
+
+#define IS_ACX100(adev)	((adev)->chip_type == CHIPTYPE_ACX100)
+#define IS_ACX111(adev)	((adev)->chip_type == CHIPTYPE_ACX111)
+
+/* Supported interfaces */
+#define DEVTYPE_PCI		0
+#define DEVTYPE_USB		1
+
+#if !defined(CONFIG_ACX_MAC80211_PCI) && !defined(CONFIG_ACX_MAC80211_USB)
+#error Driver must include PCI and/or USB support. You selected neither.
+#endif
+
+#if defined(CONFIG_ACX_MAC80211_PCI)
+ #if !defined(CONFIG_ACX_MAC80211_USB)
+  #define IS_PCI(adev)	1
+ #else
+  #define IS_PCI(adev)	((adev)->dev_type == DEVTYPE_PCI)
+ #endif
+#else
+ #define IS_PCI(adev)	0
+#endif
+
+#if defined(CONFIG_ACX_MAC80211_USB)
+ #if !defined(CONFIG_ACX_MAC80211_PCI)
+  #define IS_USB(adev)	1
+ #else
+  #define IS_USB(adev)	((adev)->dev_type == DEVTYPE_USB)
+ #endif
+#else
+ #define IS_USB(adev)	0
+#endif
+
+/* Driver defaults */
+#define DEFAULT_DTIM_INTERVAL	10
+/* used to be 2048, but FreeBSD driver changed it to 4096 to work properly
+** in noisy wlans */
+#define DEFAULT_MSDU_LIFETIME	4096
+#define DEFAULT_RTS_THRESHOLD	2312	/* max. size: disable RTS mechanism */
+#define DEFAULT_BEACON_INTERVAL	100
+
+#define ACX100_BAP_DATALEN_MAX		4096
+#define ACX100_RID_GUESSING_MAXLEN	2048	/* I'm not really sure */
+#define ACX100_RIDDATA_MAXLEN		ACX100_RID_GUESSING_MAXLEN
+
+/* Support Constants */
+/* Radio type names, found in Win98 driver's TIACXLN.INF */
+#define RADIO_MAXIM_0D		0x0d
+#define RADIO_RFMD_11		0x11
+#define RADIO_RALINK_15		0x15
+/* used in ACX111 cards (WG311v2, WL-121, ...): */
+#define RADIO_RADIA_16		0x16
+/* most likely *sometimes* used in ACX111 cards: */
+#define RADIO_UNKNOWN_17	0x17
+/* FwRad19.bin was found in a Safecom driver; must be an ACX111 radio: */
+#define RADIO_UNKNOWN_19	0x19
+#define RADIO_UNKNOWN_1B	0x1b    /* radio in SafeCom SWLUT-54125 USB adapter; entirely unknown!! */
+
+/* Controller Commands */
+/* can be found in table cmdTable in firmware "Rev. 1.5.0" (FW150) */
+#define ACX1xx_CMD_RESET		0x00
+#define ACX1xx_CMD_INTERROGATE		0x01
+#define ACX1xx_CMD_CONFIGURE		0x02
+#define ACX1xx_CMD_ENABLE_RX		0x03
+#define ACX1xx_CMD_ENABLE_TX		0x04
+#define ACX1xx_CMD_DISABLE_RX		0x05
+#define ACX1xx_CMD_DISABLE_TX		0x06
+#define ACX1xx_CMD_FLUSH_QUEUE		0x07
+#define ACX1xx_CMD_SCAN			0x08
+#define ACX1xx_CMD_STOP_SCAN		0x09
+#define ACX1xx_CMD_CONFIG_TIM		0x0a
+#define ACX1xx_CMD_JOIN			0x0b
+#define ACX1xx_CMD_WEP_MGMT		0x0c
+#ifdef OLD_FIRMWARE_VERSIONS
+#define ACX100_CMD_HALT			0x0e	/* mapped to unknownCMD in FW150 */
+#else
+#define ACX1xx_CMD_MEM_READ		0x0d
+#define ACX1xx_CMD_MEM_WRITE		0x0e
+#endif
+#define ACX1xx_CMD_SLEEP		0x0f
+#define ACX1xx_CMD_WAKE			0x10
+#define ACX1xx_CMD_UNKNOWN_11		0x11	/* mapped to unknownCMD in FW150 */
+#define ACX100_CMD_INIT_MEMORY		0x12
+#define ACX1FF_CMD_DISABLE_RADIO	0x12	/* new firmware? TNETW1450? */
+#define ACX1xx_CMD_CONFIG_BEACON	0x13
+#define ACX1xx_CMD_CONFIG_PROBE_RESPONSE	0x14
+#define ACX1xx_CMD_CONFIG_NULL_DATA	0x15
+#define ACX1xx_CMD_CONFIG_PROBE_REQUEST	0x16
+#define ACX1xx_CMD_FCC_TEST		0x17
+#define ACX1xx_CMD_RADIOINIT		0x18
+#define ACX111_CMD_RADIOCALIB		0x19
+#define ACX1FF_CMD_NOISE_HISTOGRAM	0x1c /* new firmware? TNETW1450? */
+#define ACX1FF_CMD_RX_RESET		0x1d /* new firmware? TNETW1450? */
+#define ACX1FF_CMD_LNA_CONTROL		0x20 /* new firmware? TNETW1450? */
+#define ACX1FF_CMD_CONTROL_DBG_TRACE	0x21 /* new firmware? TNETW1450? */
+
+/* 'After Interrupt' Commands */
+#define ACX_AFTER_IRQ_CMD_STOP_SCAN	0x01
+#define ACX_AFTER_IRQ_CMD_ASSOCIATE	0x02
+#define ACX_AFTER_IRQ_CMD_RADIO_RECALIB	0x04
+#define ACX_AFTER_IRQ_UPDATE_CARD_CFG	0x08
+#define ACX_AFTER_IRQ_TX_CLEANUP	0x10
+#define ACX_AFTER_IRQ_COMPLETE_SCAN	0x20
+#define ACX_AFTER_IRQ_RESTART_SCAN	0x40
+
+/***********************************************************************
+** Tx/Rx buffer sizes and watermarks
+**
+** This will alloc and use DMAable buffers of
+** WLAN_A4FR_MAXLEN_WEP_FCS * (RX_CNT + TX_CNT) bytes
+** RX/TX_CNT=32 -> ~150k DMA buffers
+** RX/TX_CNT=16 -> ~75k DMA buffers
+**
+** 2005-10-10: reduced memory usage by lowering both to 16
+*/
+#define RX_CNT 16
+#define TX_CNT 16
+
+/* we clean up txdescs when we have N free txdesc: */
+#define TX_CLEAN_BACKLOG (TX_CNT/4)
+#define TX_START_CLEAN (TX_CNT - TX_CLEAN_BACKLOG)
+#define TX_EMERG_CLEAN 2
+/* we stop queue if we have < N free txbufs: */
+#define TX_STOP_QUEUE 3
+/* we start queue if we have >= N free txbufs: */
+#define TX_START_QUEUE 5
+
+/***********************************************************************
+** Interrogate/Configure cmd constants
+**
+** NB: length includes JUST the data part of the IE
+** (does not include size of the (type,len) pair)
+**
+** TODO: seems that acx100, acx100usb, acx111 have some differences,
+** fix code with regard to this!
+*/
+
+#define DEF_IE(name, val, len) enum { ACX##name=val, ACX##name##_LEN=len }
+
+/* Information Elements: Network Parameters, Static Configuration Entities */
+/* these are handled by real_cfgtable in firmware "Rev 1.5.0" (FW150) */
+DEF_IE(1xx_IE_UNKNOWN_00		,0x0000, -1);	/* mapped to cfgInvalid in FW150 */
+DEF_IE(100_IE_ACX_TIMER			,0x0001, 0x10);
+DEF_IE(1xx_IE_POWER_MGMT		,0x0002, 0x06); /* TNETW1450: length 0x18!! */
+DEF_IE(1xx_IE_QUEUE_CONFIG		,0x0003, 0x1c);
+DEF_IE(100_IE_BLOCK_SIZE		,0x0004, 0x02);
+DEF_IE(1FF_IE_SLOT_TIME			,0x0004, 0x08); /* later firmware versions only? */
+DEF_IE(1xx_IE_MEMORY_CONFIG_OPTIONS	,0x0005, 0x14);
+DEF_IE(1FF_IE_QUEUE_HEAD		,0x0005, 0x14 /* FIXME: length? */);
+DEF_IE(1xx_IE_RATE_FALLBACK		,0x0006, 0x01); /* TNETW1450: length 2 */
+DEF_IE(100_IE_WEP_OPTIONS		,0x0007, 0x03);
+DEF_IE(111_IE_RADIO_BAND		,0x0007, -1);
+DEF_IE(1FF_IE_TIMING_CFG		,0x0007, -1);	/* later firmware versions; TNETW1450 only? */
+DEF_IE(100_IE_SSID			,0x0008, 0x20); /* huh? */
+DEF_IE(1xx_IE_MEMORY_MAP		,0x0008, 0x28); /* huh? TNETW1450 has length 0x40!! */
+DEF_IE(1xx_IE_SCAN_STATUS		,0x0009, 0x04); /* mapped to cfgInvalid in FW150 */
+DEF_IE(1xx_IE_ASSOC_ID			,0x000a, 0x02);
+DEF_IE(1xx_IE_UNKNOWN_0B		,0x000b, -1);	/* mapped to cfgInvalid in FW150 */
+DEF_IE(1FF_IE_TX_POWER_LEVEL_TABLE	,0x000b, 0x18); /* later firmware versions; TNETW1450 only? */
+DEF_IE(100_IE_UNKNOWN_0C		,0x000c, -1);	/* very small implementation in FW150! */
+/* ACX100 has an equivalent struct in the cmd mailbox directly after reset.
+ * 0x14c seems extremely large, will trash stack on failure (memset!)
+ * in case of small input struct --> OOPS! */
+DEF_IE(111_IE_CONFIG_OPTIONS		,0x000c, 0x14c);
+DEF_IE(1xx_IE_FWREV			,0x000d, 0x18);
+DEF_IE(1xx_IE_FCS_ERROR_COUNT		,0x000e, 0x04);
+DEF_IE(1xx_IE_MEDIUM_USAGE		,0x000f, 0x08);
+DEF_IE(1xx_IE_RXCONFIG			,0x0010, 0x04);
+DEF_IE(100_IE_UNKNOWN_11		,0x0011, -1);	/* NONBINARY: large implementation in FW150! link quality readings or so? */
+DEF_IE(111_IE_QUEUE_THRESH		,0x0011, -1);
+DEF_IE(100_IE_UNKNOWN_12		,0x0012, -1);	/* NONBINARY: VERY large implementation in FW150!! */
+DEF_IE(111_IE_BSS_POWER_SAVE		,0x0012, /* -1 */ 2);
+DEF_IE(1xx_IE_FIRMWARE_STATISTICS	,0x0013, 0x9c); /* TNETW1450: length 0x134!! */
+DEF_IE(1FF_IE_RX_INTR_CONFIG		,0x0014, 0x14); /* later firmware versions, TNETW1450 only? */
+DEF_IE(1xx_IE_FEATURE_CONFIG		,0x0015, 0x08);
+DEF_IE(111_IE_KEY_CHOOSE		,0x0016, 0x04);	/* for rekeying. really len=4?? */
+DEF_IE(1FF_IE_MISC_CONFIG_TABLE		,0x0017, 0x04); /* later firmware versions, TNETW1450 only? */
+DEF_IE(1FF_IE_WONE_CONFIG		,0x0018, -1);	/* later firmware versions, TNETW1450 only? */
+DEF_IE(1FF_IE_TID_CONFIG		,0x001a, 0x2c); /* later firmware versions, TNETW1450 only? */
+DEF_IE(1FF_IE_CALIB_ASSESSMENT		,0x001e, 0x04); /* later firmware versions, TNETW1450 only? */
+DEF_IE(1FF_IE_BEACON_FILTER_OPTIONS	,0x001f, 0x02); /* later firmware versions, TNETW1450 only? */
+DEF_IE(1FF_IE_LOW_RSSI_THRESH_OPT	,0x0020, 0x04); /* later firmware versions, TNETW1450 only? */
+DEF_IE(1FF_IE_NOISE_HISTOGRAM_RESULTS	,0x0021, 0x30); /* later firmware versions, TNETW1450 only? */
+DEF_IE(1FF_IE_PACKET_DETECT_THRESH	,0x0023, 0x04); /* later firmware versions, TNETW1450 only? */
+DEF_IE(1FF_IE_TX_CONFIG_OPTIONS		,0x0024, 0x04); /* later firmware versions, TNETW1450 only? */
+DEF_IE(1FF_IE_CCA_THRESHOLD		,0x0025, 0x02); /* later firmware versions, TNETW1450 only? */
+DEF_IE(1FF_IE_EVENT_MASK		,0x0026, 0x08); /* later firmware versions, TNETW1450 only? */
+DEF_IE(1FF_IE_DTIM_PERIOD		,0x0027, 0x02); /* later firmware versions, TNETW1450 only? */
+DEF_IE(1FF_IE_ACI_CONFIG_SET		,0x0029, 0x06); /* later firmware versions; maybe TNETW1450 only? */
+DEF_IE(1FF_IE_EEPROM_VER		,0x0030, 0x04); /* later firmware versions; maybe TNETW1450 only? */
+DEF_IE(1xx_IE_DOT11_STATION_ID		,0x1001, 0x06);
+DEF_IE(100_IE_DOT11_UNKNOWN_1002	,0x1002, -1);	/* mapped to cfgInvalid in FW150 */
+DEF_IE(111_IE_DOT11_FRAG_THRESH		,0x1002, -1);	/* mapped to cfgInvalid in FW150; TNETW1450 has length 2!! */
+DEF_IE(100_IE_DOT11_BEACON_PERIOD	,0x1003, 0x02);	/* mapped to cfgInvalid in FW150 */
+DEF_IE(1xx_IE_DOT11_DTIM_PERIOD		,0x1004, -1);	/* mapped to cfgInvalid in FW150 */
+DEF_IE(1FF_IE_DOT11_MAX_RX_LIFETIME	,0x1004, -1);	/* later firmware versions; maybe TNETW1450 only? */
+DEF_IE(1xx_IE_DOT11_SHORT_RETRY_LIMIT	,0x1005, 0x01); /* TNETW1450: length 2 */
+DEF_IE(1xx_IE_DOT11_LONG_RETRY_LIMIT	,0x1006, 0x01); /* TNETW1450: length 2 */
+DEF_IE(100_IE_DOT11_WEP_DEFAULT_KEY_WRITE	,0x1007, 0x20);	/* configure default keys; TNETW1450 has length 0x24!! */
+DEF_IE(1xx_IE_DOT11_MAX_XMIT_MSDU_LIFETIME	,0x1008, 0x04);
+DEF_IE(1xx_IE_DOT11_GROUP_ADDR		,0x1009, -1);
+DEF_IE(1xx_IE_DOT11_CURRENT_REG_DOMAIN	,0x100a, 0x02);
+/* It's harmless to have larger struct. Use USB case always. */
+DEF_IE(1xx_IE_DOT11_CURRENT_ANTENNA	,0x100b, 0x02);	/* in fact len=1 for PCI */
+DEF_IE(1xx_IE_DOT11_UNKNOWN_100C	,0x100c, -1);	/* mapped to cfgInvalid in FW150 */
+DEF_IE(1xx_IE_DOT11_TX_POWER_LEVEL	,0x100d, 0x01); /* TNETW1450 has length 2!! */
+DEF_IE(1xx_IE_DOT11_CURRENT_CCA_MODE	,0x100e, 0x02);	/* in fact len=1 for PCI */
+/* USB doesn't return anything - len==0?! */
+DEF_IE(100_IE_DOT11_ED_THRESHOLD	,0x100f, 0x04);
+DEF_IE(1xx_IE_DOT11_WEP_DEFAULT_KEY_SET	,0x1010, 0x01);	/* set default key ID; TNETW1450: length 2 */
+DEF_IE(100_IE_DOT11_UNKNOWN_1011	,0x1011, -1);	/* mapped to cfgInvalid in FW150 */
+DEF_IE(1FF_IE_DOT11_CURR_5GHZ_REGDOM	,0x1011, -1);	/* later firmware versions; maybe TNETW1450 only? */
+DEF_IE(100_IE_DOT11_UNKNOWN_1012	,0x1012, -1);	/* mapped to cfgInvalid in FW150 */
+DEF_IE(100_IE_DOT11_UNKNOWN_1013	,0x1013, -1);	/* mapped to cfgInvalid in FW150 */
+
+#if 0
+/* Experimentally obtained on acx100, fw 1.9.8.b
+** -1 means that fw returned 'invalid IE'
+** 0200 FC00 nnnn... are test read contents: u16 type, u16 len, data
+** (AA are poison bytes marking bytes not written by fw)
+**
+** Looks like acx100 fw does not update len field (thus len=256-4=FC here)
+** A number of IEs seem to trash type,len fields
+** IEs marked 'huge' return gobs of data (no poison bytes remain)
+*/
+DEF_IE(100_IE_INVAL_00,			0x0000, -1);
+DEF_IE(100_IE_INVAL_01,			0x0001, -1);	/* IE_ACX_TIMER, len=16 on older fw */
+DEF_IE(100_IE_POWER_MGMT,		0x0002, 4);	/* 0200FC00 00040000 AAAAAAAA */
+DEF_IE(100_IE_QUEUE_CONFIG,		0x0003, 28);	/* 0300FC00 48060000 9CAD0000 0101AAAA DCB00000 E4B00000 9CAA0000 00AAAAAA */
+DEF_IE(100_IE_BLOCK_SIZE,		0x0004, 2);	/* 0400FC00 0001AAAA AAAAAAAA AAAAAAAA */
+/* write only: */
+DEF_IE(100_IE_MEMORY_CONFIG_OPTIONS,	0x0005, 20);
+DEF_IE(100_IE_RATE_FALLBACK,		0x0006, 1);	/* 0600FC00 00AAAAAA AAAAAAAA AAAAAAAA */
+/* write only: */
+DEF_IE(100_IE_WEP_OPTIONS,		0x0007, 3);
+DEF_IE(100_IE_MEMORY_MAP,		0x0008, 40);	/* huge: 0800FC00 30000000 6CA20000 70A20000... */
+/* gives INVAL on read: */
+DEF_IE(100_IE_SCAN_STATUS,		0x0009, -1);
+DEF_IE(100_IE_ASSOC_ID,			0x000a, 2);	/* huge: 0A00FC00 00000000 01040800 00000000... */
+DEF_IE(100_IE_INVAL_0B,			0x000b, -1);
+/* 'command rejected': */
+DEF_IE(100_IE_CONFIG_OPTIONS,		0x000c, -3);
+DEF_IE(100_IE_FWREV,			0x000d, 24);	/* 0D00FC00 52657620 312E392E 382E6200 AAAAAAAA AAAAAAAA 05050201 AAAAAAAA */
+DEF_IE(100_IE_FCS_ERROR_COUNT,		0x000e, 4);
+DEF_IE(100_IE_MEDIUM_USAGE,		0x000f, 8);	/* E41F0000 2D780300 FCC91300 AAAAAAAA */
+DEF_IE(100_IE_RXCONFIG,			0x0010, 4);	/* 1000FC00 00280000 AAAAAAAA AAAAAAAA */
+DEF_IE(100_IE_QUEUE_THRESH,		0x0011, 12);	/* 1100FC00 AAAAAAAA 00000000 00000000 */
+DEF_IE(100_IE_BSS_POWER_SAVE,		0x0012, 1);	/* 1200FC00 00AAAAAA AAAAAAAA AAAAAAAA */
+/* read only, variable len */
+DEF_IE(100_IE_FIRMWARE_STATISTICS,	0x0013, 256); /* 0000AC00 00000000 ... */
+DEF_IE(100_IE_INT_CONFIG,		0x0014, 20);	/* 00000000 00000000 00000000 00000000 5D74D105 00000000 AAAAAAAA AAAAAAAA */
+DEF_IE(100_IE_FEATURE_CONFIG,		0x0015, 8);	/* 1500FC00 16000000 AAAAAAAA AAAAAAAA */
+/* returns 'invalid MAC': */
+DEF_IE(100_IE_KEY_CHOOSE,		0x0016, -4);
+DEF_IE(100_IE_INVAL_17,			0x0017, -1);
+DEF_IE(100_IE_UNKNOWN_18,		0x0018, 0);	/* null len?! 1800FC00 AAAAAAAA AAAAAAAA AAAAAAAA */
+DEF_IE(100_IE_UNKNOWN_19,		0x0019, 256);	/* huge: 1900FC00 9C1F00EA FEFFFFEA FEFFFFEA... */
+DEF_IE(100_IE_INVAL_1A,			0x001A, -1);
+
+DEF_IE(100_IE_DOT11_INVAL_1000,			0x1000, -1);
+DEF_IE(100_IE_DOT11_STATION_ID,			0x1001, 6);	/* huge: 0110FC00 58B10E2F 03000000 00000000... */
+DEF_IE(100_IE_DOT11_INVAL_1002,			0x1002, -1);
+DEF_IE(100_IE_DOT11_INVAL_1003,			0x1003, -1);
+DEF_IE(100_IE_DOT11_INVAL_1004,			0x1004, -1);
+DEF_IE(100_IE_DOT11_SHORT_RETRY_LIMIT,		0x1005, 1);
+DEF_IE(100_IE_DOT11_LONG_RETRY_LIMIT,		0x1006, 1);
+/* write only: */
+DEF_IE(100_IE_DOT11_WEP_DEFAULT_KEY_WRITE,	0x1007, 32);
+DEF_IE(100_IE_DOT11_MAX_XMIT_MSDU_LIFETIME,	0x1008, 4);	/* huge: 0810FC00 00020000 F4010000 00000000... */
+/* undoc but returns something */
+DEF_IE(100_IE_DOT11_GROUP_ADDR,			0x1009, 12);	/* huge: 0910FC00 00000000 00000000 00000000... */
+DEF_IE(100_IE_DOT11_CURRENT_REG_DOMAIN,		0x100a, 1);	/* 0A10FC00 30AAAAAA AAAAAAAA AAAAAAAA */
+DEF_IE(100_IE_DOT11_CURRENT_ANTENNA,		0x100b, 1);	/* 0B10FC00 8FAAAAAA AAAAAAAA AAAAAAAA */
+DEF_IE(100_IE_DOT11_INVAL_100C,			0x100c, -1);
+DEF_IE(100_IE_DOT11_TX_POWER_LEVEL,		0x100d, 2);	/* 00000000 0100AAAA AAAAAAAA AAAAAAAA */
+DEF_IE(100_IE_DOT11_CURRENT_CCA_MODE,		0x100e, 1);	/* 0E10FC00 0DAAAAAA AAAAAAAA AAAAAAAA */
+DEF_IE(100_IE_DOT11_ED_THRESHOLD,		0x100f, 4);	/* 0F10FC00 70000000 AAAAAAAA AAAAAAAA */
+/* set default key ID  */
+DEF_IE(100_IE_DOT11_WEP_DEFAULT_KEY_SET,	0x1010, 1);	/* 1010FC00 00AAAAAA AAAAAAAA AAAAAAAA */
+DEF_IE(100_IE_DOT11_INVAL_1011,			0x1011, -1);
+DEF_IE(100_IE_DOT11_INVAL_1012,			0x1012, -1);
+DEF_IE(100_IE_DOT11_INVAL_1013,			0x1013, -1);
+DEF_IE(100_IE_DOT11_UNKNOWN_1014,		0x1014, 256);	/* huge */
+DEF_IE(100_IE_DOT11_UNKNOWN_1015,		0x1015, 256);	/* huge */
+DEF_IE(100_IE_DOT11_UNKNOWN_1016,		0x1016, 256);	/* huge */
+DEF_IE(100_IE_DOT11_UNKNOWN_1017,		0x1017, 256);	/* huge */
+DEF_IE(100_IE_DOT11_UNKNOWN_1018,		0x1018, 256);	/* huge */
+DEF_IE(100_IE_DOT11_UNKNOWN_1019,		0x1019, 256);	/* huge */
+#endif
+
+#if 0
+/* Experimentally obtained on PCI acx111 Xterasys XN-2522g, fw 1.2.1.34
+** -1 means that fw returned 'invalid IE'
+** 0400 0800 nnnn... are test read contents: u16 type, u16 len, data
+** (AA are poison bytes marking bytes not written by fw)
+**
+** Looks like acx111 fw reports real len!
+*/
+DEF_IE(111_IE_INVAL_00,			0x0000, -1);
+DEF_IE(111_IE_INVAL_01,			0x0001, -1);
+DEF_IE(111_IE_POWER_MGMT,		0x0002, 12);
+/* write only, variable len: 12 + rxqueue_cnt*8 + txqueue_cnt*4: */
+DEF_IE(111_IE_MEMORY_CONFIG,		0x0003, 24);
+DEF_IE(111_IE_BLOCK_SIZE,		0x0004, 8); /* 04000800 AA00AAAA AAAAAAAA */
+/* variable len: 8 + rxqueue_cnt*8 + txqueue_cnt*8: */
+DEF_IE(111_IE_QUEUE_HEAD,		0x0005, 24);
+DEF_IE(111_IE_RATE_FALLBACK,		0x0006, 1);
+/* acx100 name:WEP_OPTIONS */
+/* said to have len:1 (not true, actually returns 12 bytes): */
+DEF_IE(111_IE_RADIO_BAND,		0x0007, 12); /* 07000C00 AAAA1F00 FF03AAAA AAAAAAAA */
+DEF_IE(111_IE_MEMORY_MAP,		0x0008, 48);
+/* said to have len:4, but gives INVAL on read: */
+DEF_IE(111_IE_SCAN_STATUS,		0x0009, -1);
+DEF_IE(111_IE_ASSOC_ID,			0x000a, 2);
+/* write only, len is not known: */
+DEF_IE(111_IE_UNKNOWN_0B,		0x000b, 0);
+/* read only, variable len. I see 67 byte reads: */
+DEF_IE(111_IE_CONFIG_OPTIONS,		0x000c, 67); /* 0C004300 01160500 ... */
+DEF_IE(111_IE_FWREV,			0x000d, 24);
+DEF_IE(111_IE_FCS_ERROR_COUNT,		0x000e, 4);
+DEF_IE(111_IE_MEDIUM_USAGE,		0x000f, 8);
+DEF_IE(111_IE_RXCONFIG,			0x0010, 4);
+DEF_IE(111_IE_QUEUE_THRESH,		0x0011, 12);
+DEF_IE(111_IE_BSS_POWER_SAVE,		0x0012, 1);
+/* read only, variable len. I see 240 byte reads: */
+DEF_IE(111_IE_FIRMWARE_STATISTICS,	0x0013, 240); /* 1300F000 00000000 ... */
+/* said to have len=17. looks like fw pads it to 20: */
+DEF_IE(111_IE_INT_CONFIG,		0x0014, 20); /* 14001400 00000000 00000000 00000000 00000000 00000000 */
+DEF_IE(111_IE_FEATURE_CONFIG,		0x0015, 8);
+/* said to be name:KEY_INDICATOR, len:4, but gives INVAL on read: */
+DEF_IE(111_IE_KEY_CHOOSE,		0x0016, -1);
+/* said to have len:4, but in fact returns 8: */
+DEF_IE(111_IE_MAX_USB_XFR,		0x0017, 8); /* 17000800 00014000 00000000 */
+DEF_IE(111_IE_INVAL_18,			0x0018, -1);
+DEF_IE(111_IE_INVAL_19,			0x0019, -1);
+/* undoc but returns something: */
+/* huh, fw indicates len=20 but uses 4 more bytes in buffer??? */
+DEF_IE(111_IE_UNKNOWN_1A,		0x001A, 20); /* 1A001400 AA00AAAA 0000020F FF030000 00020000 00000007 04000000 */
+
+DEF_IE(111_IE_DOT11_INVAL_1000,			0x1000, -1);
+DEF_IE(111_IE_DOT11_STATION_ID,			0x1001, 6);
+DEF_IE(111_IE_DOT11_FRAG_THRESH,		0x1002, 2);
+/* acx100 only? gives INVAL on read: */
+DEF_IE(111_IE_DOT11_BEACON_PERIOD,		0x1003, -1);
+/* said to be MAX_RECV_MSDU_LIFETIME: */
+DEF_IE(111_IE_DOT11_DTIM_PERIOD,		0x1004, 4);
+DEF_IE(111_IE_DOT11_SHORT_RETRY_LIMIT,		0x1005, 1);
+DEF_IE(111_IE_DOT11_LONG_RETRY_LIMIT,		0x1006, 1);
+/* acx100 only? gives INVAL on read: */
+DEF_IE(111_IE_DOT11_WEP_DEFAULT_KEY_WRITE,	0x1007, -1);
+DEF_IE(111_IE_DOT11_MAX_XMIT_MSDU_LIFETIME,	0x1008, 4);
+/* undoc but returns something. maybe it's 2 multicast MACs to listen to? */
+DEF_IE(111_IE_DOT11_GROUP_ADDR,			0x1009, 12); /* 09100C00 00000000 00000000 00000000 */
+DEF_IE(111_IE_DOT11_CURRENT_REG_DOMAIN,		0x100a, 1);
+DEF_IE(111_IE_DOT11_CURRENT_ANTENNA,		0x100b, 2);
+DEF_IE(111_IE_DOT11_INVAL_100C,			0x100c, -1);
+DEF_IE(111_IE_DOT11_TX_POWER_LEVEL,		0x100d, 1);
+/* said to have len=1 but gives INVAL on read: */
+DEF_IE(111_IE_DOT11_CURRENT_CCA_MODE,		0x100e, -1);
+/* said to have len=4 but gives INVAL on read: */
+DEF_IE(111_IE_DOT11_ED_THRESHOLD,		0x100f, -1);
+/* set default key ID. write only: */
+DEF_IE(111_IE_DOT11_WEP_DEFAULT_KEY_SET,	0x1010, 1);
+/* undoc but returns something: */
+DEF_IE(111_IE_DOT11_UNKNOWN_1011,		0x1011, 1); /* 11100100 20 */
+DEF_IE(111_IE_DOT11_INVAL_1012,			0x1012, -1);
+DEF_IE(111_IE_DOT11_INVAL_1013,			0x1013, -1);
+#endif
+
+
+/***********************************************************************
+**Information Frames Structures
+*/
+
+/* Used in beacon frames and the like */
+#define DOT11RATEBYTE_1		(1*2)
+#define DOT11RATEBYTE_2		(2*2)
+#define DOT11RATEBYTE_5_5	(5*2+1)
+#define DOT11RATEBYTE_11	(11*2)
+#define DOT11RATEBYTE_22	(22*2)
+#define DOT11RATEBYTE_6_G	(6*2)
+#define DOT11RATEBYTE_9_G	(9*2)
+#define DOT11RATEBYTE_12_G	(12*2)
+#define DOT11RATEBYTE_18_G	(18*2)
+#define DOT11RATEBYTE_24_G	(24*2)
+#define DOT11RATEBYTE_36_G	(36*2)
+#define DOT11RATEBYTE_48_G	(48*2)
+#define DOT11RATEBYTE_54_G	(54*2)
+#define DOT11RATEBYTE_BASIC	0x80	/* flags rates included in basic rate set */
+
+
+/***********************************************************************
+** rxbuffer_t
+**
+** This is the format of rx data returned by acx
+*/
+
+/* I've hoped it's a 802.11 PHY header, but no...
+ * so far, I've seen on acx111:
+ * 0000 3a00 0000 0000 IBSS Beacons
+ * 0000 3c00 0000 0000 ESS Beacons
+ * 0000 2700 0000 0000 Probe requests
+ * --vda
+ */
+typedef struct phy_hdr {
+	u8	unknown[4];
+	u8	acx111_unknown[4];
+} ACX_PACKED phy_hdr_t;
+
+/* seems to be a bit similar to hfa384x_rx_frame.
+ * These fields are still not quite obvious, though.
+ * Some seem to have different meanings... */
+
+#define RXBUF_HDRSIZE 12
+#define RXBUF_BYTES_RCVD(adev, rxbuf) \
+		((le16_to_cpu((rxbuf)->mac_cnt_rcvd) & 0xfff) - (adev)->phy_header_len)
+#define RXBUF_BYTES_USED(rxbuf) \
+		((le16_to_cpu((rxbuf)->mac_cnt_rcvd) & 0xfff) + RXBUF_HDRSIZE)
+/* USBism */
+#define RXBUF_IS_TXSTAT(rxbuf) (le16_to_cpu((rxbuf)->mac_cnt_rcvd) & 0x8000)
+/*
+mac_cnt_rcvd:
+    12 bits: length of frame from control field to first byte of FCS
+    3 bits: reserved
+    1 bit: 1 = it's a tx status info, not a rx packet (USB only)
+
+mac_cnt_mblks:
+    6 bits: number of memory block used to store frame in adapter memory
+    1 bit: Traffic Indicator bit in TIM of received Beacon was set
+
+mac_status: 1 byte (bitmap):
+    7 Matching BSSID
+    6 Matching SSID
+    5 BDCST	Address 1 field is a broadcast
+    4 VBM	received beacon frame has more than one set bit (?!)
+    3 TIM Set	bit representing this station is set in TIM of received beacon
+    2 GROUP	Address 1 is a multicast
+    1 ADDR1	Address 1 matches our MAC
+    0 FCSGD	FSC is good
+
+phy_stat_baseband: 1 byte (bitmap):
+    7 Preamble		frame had a long preamble
+    6 PLCP Error	CRC16 error in PLCP header
+    5 Unsup_Mod		unsupported modulation
+    4 Selected Antenna	antenna 1 was used to receive this frame
+    3 PBCC/CCK		frame used: 1=PBCC, 0=CCK modulation
+    2 OFDM		frame used OFDM modulation
+    1 TI Protection	protection frame was detected
+    0 Reserved
+
+phy_plcp_signal: 1 byte:
+    Receive PLCP Signal field from the Baseband Processor
+
+phy_level: 1 byte:
+    receive AGC gain level (can be used to measure receive signal strength)
+
+phy_snr: 1 byte:
+    estimated noise power of equalized receive signal
+    at input of FEC decoder (can be used to measure receive signal quality)
+
+time: 4 bytes:
+    timestamp sampled from either the Access Manager TSF counter
+    or free-running microsecond counter when the MAC receives
+    first byte of PLCP header.
+*/
+
+typedef struct rxbuffer {
+	u16	mac_cnt_rcvd;		/* only 12 bits are len! (0xfff) */
+	u8	mac_cnt_mblks;
+	u8	mac_status;
+	u8	phy_stat_baseband;	/* bit 0x80: used LNA (Low-Noise Amplifier) */
+	u8	phy_plcp_signal;
+	u8	phy_level;		/* PHY stat */
+	u8	phy_snr;		/* PHY stat */
+	u32	time;			/* timestamp upon MAC rcv first byte */
+/* 4-byte (acx100) or 8-byte (acx111) phy header will be here
+** if RX_CFG1_INCLUDE_PHY_HDR is in effect:
+**	phy_hdr_t phy			*/
+	struct ieee80211_hdr hdr_a3;
+	/* maximally sized data part of wlan packet */
+	u8	data_a3[30 + 2312 + 4 - 24]; /*WLAN_A4FR_MAXLEN_WEP_FCS - WLAN_HDR_A3_LEN]*/
+	/* can add hdr/data_a4 if needed */
+} ACX_PACKED rxbuffer_t;
+
+
+/*--- Firmware statistics ----------------------------------------------------*/
+
+/* define a random 100 bytes more to catch firmware versions which
+ * provide a bigger struct */
+#define FW_STATS_FUTURE_EXTENSION	100
+
+typedef struct fw_stats_tx {
+	u32	tx_desc_of;
+} ACX_PACKED fw_stats_tx_t;
+
+typedef struct fw_stats_rx {
+	u32	rx_oom;
+	u32	rx_hdr_of;
+	u32	rx_hw_stuck; /* old: u32	rx_hdr_use_next */
+	u32	rx_dropped_frame;
+	u32	rx_frame_ptr_err;
+	u32	rx_xfr_hint_trig;
+	u32	rx_aci_events; /* later versions only */
+	u32	rx_aci_resets; /* later versions only */
+} ACX_PACKED fw_stats_rx_t;
+
+typedef struct fw_stats_dma {
+	u32	rx_dma_req;
+	u32	rx_dma_err;
+	u32	tx_dma_req;
+	u32	tx_dma_err;
+} ACX_PACKED fw_stats_dma_t;
+
+typedef struct fw_stats_irq {
+	u32	cmd_cplt;
+	u32	fiq;
+	u32	rx_hdrs;
+	u32	rx_cmplt;
+	u32	rx_mem_of;
+	u32	rx_rdys;
+	u32	irqs;
+	u32	tx_procs;
+	u32	decrypt_done;
+	u32	dma_0_done;
+	u32	dma_1_done;
+	u32	tx_exch_complet;
+	u32	commands;
+	u32	rx_procs;
+	u32	hw_pm_mode_changes;
+	u32	host_acks;
+	u32	pci_pm;
+	u32	acm_wakeups;
+} ACX_PACKED fw_stats_irq_t;
+
+typedef struct fw_stats_wep {
+	u32	wep_key_count;
+	u32	wep_default_key_count;
+	u32	dot11_def_key_mib;
+	u32	wep_key_not_found;
+	u32	wep_decrypt_fail;
+	u32	wep_pkt_decrypt;
+	u32	wep_decrypt_irqs;
+} ACX_PACKED fw_stats_wep_t;
+
+typedef struct fw_stats_pwr {
+	u32	tx_start_ctr;
+	u32	no_ps_tx_too_short;
+	u32	rx_start_ctr;
+	u32	no_ps_rx_too_short;
+	u32	lppd_started;
+	u32	no_lppd_too_noisy;
+	u32	no_lppd_too_short;
+	u32	no_lppd_matching_frame;
+} ACX_PACKED fw_stats_pwr_t;
+
+typedef struct fw_stats_mic {
+	u32	mic_rx_pkts;
+	u32	mic_calc_fail;
+} ACX_PACKED fw_stats_mic_t;
+
+typedef struct fw_stats_aes {
+	u32	aes_enc_fail;
+	u32	aes_dec_fail;
+	u32	aes_enc_pkts;
+	u32	aes_dec_pkts;
+	u32	aes_enc_irq;
+	u32	aes_dec_irq;
+} ACX_PACKED fw_stats_aes_t;
+
+typedef struct fw_stats_event {
+	u32	heartbeat;
+	u32	calibration;
+	u32	rx_mismatch;
+	u32	rx_mem_empty;
+	u32	rx_pool;
+	u32	oom_late;
+	u32	phy_tx_err;
+	u32	tx_stuck;
+} ACX_PACKED fw_stats_event_t;
+
+/* mainly for size calculation only */
+typedef struct fw_stats {
+	u16			type;
+	u16			len;
+	fw_stats_tx_t		tx;
+	fw_stats_rx_t		rx;
+	fw_stats_dma_t		dma;
+	fw_stats_irq_t		irq;
+	fw_stats_wep_t		wep;
+	fw_stats_pwr_t		pwr;
+	fw_stats_mic_t		mic;
+	fw_stats_aes_t		aes;
+	fw_stats_event_t	evt;
+	u8			_padding[FW_STATS_FUTURE_EXTENSION];
+} fw_stats_t;
+
+/* Firmware version struct */
+
+typedef struct fw_ver {
+	u16	cmd;
+	u16	size;
+	char	fw_id[20];
+	u32	hw_id;
+} ACX_PACKED fw_ver_t;
+
+#define FW_ID_SIZE 20
+
+
+/*--- WEP stuff --------------------------------------------------------------*/
+#define DOT11_MAX_DEFAULT_WEP_KEYS	4
+
+/* non-firmware struct, no packing necessary */
+typedef struct wep_key {
+	size_t	size; /* most often used member first */
+	u8	index;
+	u8	key[29];
+	u16	strange_filler;
+} wep_key_t;			/* size = 264 bytes (33*8) */
+/* FIXME: We don't have size 264! Or is there 2 bytes beyond the key
+ * (strange_filler)? */
+
+/* non-firmware struct, no packing necessary */
+typedef struct key_struct {
+	u8	addr[ETH_ALEN];	/* 0x00 */
+	u16	filler1;	/* 0x06 */
+	u32	filler2;	/* 0x08 */
+	u32	index;		/* 0x0c */
+	u16	len;		/* 0x10 */
+	u8	key[29];	/* 0x12; is this long enough??? */
+} key_struct_t;			/* size = 276. FIXME: where is the remaining space?? */
+
+
+/*--- Client (peer) info -----------------------------------------------------*/
+/* adev->sta_list[] is used for:
+** accumulating and processing of scan results
+** keeping client info in AP mode
+** keeping AP info in STA mode (AP is the only one 'client')
+** keeping peer info in ad-hoc mode
+** non-firmware struct --> no packing necessary */
+enum {
+	CLIENT_EMPTY_SLOT_0 = 0,
+	CLIENT_EXIST_1 = 1,
+	CLIENT_AUTHENTICATED_2 = 2,
+	CLIENT_ASSOCIATED_3 = 3,
+	CLIENT_JOIN_CANDIDATE = 4
+};
+struct client {
+	/* most frequent access first */
+	u8	used;			/* misnamed, more like 'status' */
+	struct client*	next;
+	unsigned long	mtime;		/* last time we heard it, in jiffies */
+	size_t	essid_len;		/* length of ESSID (without '\0') */
+	u32	sir;			/* Standard IR */
+	u32	snr;			/* Signal to Noise Ratio */
+	u16	aid;			/* association ID */
+	u16	seq;			/* from client's auth req */
+	u16	auth_alg;		/* from client's auth req */
+	u16	cap_info;		/* from client's assoc req */
+	u16	rate_cap;		/* what client supports (all rates) */
+	u16	rate_bas;		/* what client supports (basic rates) */
+	u16	rate_cfg;		/* what is allowed (by iwconfig etc) */
+	u16	rate_cur;		/* currently used rate mask */
+	u8	rate_100;		/* currently used rate byte (acx100 only) */
+	u8	address[ETH_ALEN];
+	u8	bssid[ETH_ALEN];	/* ad-hoc hosts can have bssid != mac */
+	u8	channel;
+	u8	auth_step;
+	u8	ignore_count;
+	u8	fallback_count;
+	u8	stepup_count;
+	char	essid[IW_ESSID_MAX_SIZE + 1];	/* ESSID and trailing '\0'  */
+/* FIXME: this one is too damn big */
+	char	challenge_text[128]; /*WLAN_CHALLENGE_LEN*/
+};
+
+
+/***********************************************************************
+** Hardware structures
+*/
+
+/* An opaque typesafe helper type
+ *
+ * Some hardware fields are actually pointers,
+ * but they have to remain u32, since using ptr instead
+ * (8 bytes on 64bit systems!) would disrupt the fixed descriptor
+ * format the acx firmware expects in the non-user area.
+ * Since we cannot cram an 8 byte ptr into 4 bytes, we need to
+ * enforce that pointed to data remains in low memory
+ * (address value needs to fit in 4 bytes) on 64bit systems.
+ *
+ * This is easy to get wrong, thus we are using a small struct
+ * and special macros to access it. Macros will check for
+ * attempts to overflow an acx_ptr with value > 0xffffffff.
+ *
+ * Attempts to use acx_ptr without macros result in compile-time errors */
+
+typedef struct {
+	u32	v;
+} ACX_PACKED acx_ptr;
+
+#if ACX_DEBUG
+#define CHECK32(n) BUG_ON(sizeof(n)>4 && (long)(n)>0xffffff00)
+#else
+#define CHECK32(n) ((void)0)
+#endif
+
+/* acx_ptr <-> integer conversion */
+#define cpu2acx(n) ({ CHECK32(n); ((acx_ptr){ .v = cpu_to_le32(n) }); })
+#define acx2cpu(a) (le32_to_cpu(a.v))
+
+/* acx_ptr <-> pointer conversion */
+#define ptr2acx(p) ({ CHECK32(p); ((acx_ptr){ .v = cpu_to_le32((u32)(long)(p)) }); })
+#define acx2ptr(a) ((void*)le32_to_cpu(a.v))
+
+/* Values for rate field (acx100 only) */
+#define RATE100_1		10
+#define RATE100_2		20
+#define RATE100_5		55
+#define RATE100_11		110
+#define RATE100_22		220
+/* This bit denotes use of PBCC:
+** (PBCC encoding is usable with 11 and 22 Mbps speeds only) */
+#define RATE100_PBCC511		0x80
+
+/* Bit values for rate111 field */
+#define RATE111_1		0x0001	/* DBPSK */
+#define RATE111_2		0x0002	/* DQPSK */
+#define RATE111_5		0x0004	/* CCK or PBCC */
+#define RATE111_6		0x0008	/* CCK-OFDM or OFDM */
+#define RATE111_9		0x0010	/* CCK-OFDM or OFDM */
+#define RATE111_11		0x0020	/* CCK or PBCC */
+#define RATE111_12		0x0040	/* CCK-OFDM or OFDM */
+#define RATE111_18		0x0080	/* CCK-OFDM or OFDM */
+#define RATE111_22		0x0100	/* PBCC */
+#define RATE111_24		0x0200	/* CCK-OFDM or OFDM */
+#define RATE111_36		0x0400	/* CCK-OFDM or OFDM */
+#define RATE111_48		0x0800	/* CCK-OFDM or OFDM */
+#define RATE111_54		0x1000	/* CCK-OFDM or OFDM */
+#define RATE111_RESERVED	0x2000
+#define RATE111_PBCC511		0x4000  /* PBCC mod at 5.5 or 11Mbit (else CCK) */
+#define RATE111_SHORTPRE	0x8000  /* short preamble */
+/* Special 'try everything' value */
+#define RATE111_ALL		0x1fff
+/* These bits denote acx100 compatible settings */
+#define RATE111_ACX100_COMPAT	0x0127
+/* These bits denote 802.11b compatible settings */
+#define RATE111_80211B_COMPAT	0x0027
+
+/* Descriptor Ctl field bits
+ * init value is 0x8e, "idle" value is 0x82 (in idle tx descs)
+ */
+#define DESC_CTL_SHORT_PREAMBLE	0x01	/* preamble type: 0 = long; 1 = short */
+#define DESC_CTL_FIRSTFRAG	0x02	/* this is the 1st frag of the frame */
+#define DESC_CTL_AUTODMA	0x04
+#define DESC_CTL_RECLAIM	0x08	/* ready to reuse */
+#define DESC_CTL_HOSTDONE	0x20	/* host has finished processing */
+#define DESC_CTL_ACXDONE	0x40	/* acx has finished processing */
+/* host owns the desc [has to be released last, AFTER modifying all other desc fields!] */
+#define DESC_CTL_HOSTOWN	0x80
+#define	DESC_CTL_ACXDONE_HOSTOWN (DESC_CTL_ACXDONE | DESC_CTL_HOSTOWN)
+
+/* Descriptor Status field
+ */
+#define	DESC_STATUS_FULL	(1 << 31)
+
+/* NB: some bits may be interesting for Monitor mode tx (aka Raw tx): */
+#define DESC_CTL2_SEQ		0x01	/* don't increase sequence field */
+#define DESC_CTL2_FCS		0x02	/* don't add the FCS */
+#define DESC_CTL2_MORE_FRAG	0x04
+#define DESC_CTL2_RETRY		0x08	/* don't increase retry field */
+#define DESC_CTL2_POWER		0x10	/* don't increase power mgmt. field */
+#define DESC_CTL2_RTS		0x20	/* do RTS/CTS magic before sending */
+#define DESC_CTL2_WEP		0x40	/* encrypt this frame */
+#define DESC_CTL2_DUR		0x80	/* don't increase duration field */
+
+/***********************************************************************
+** PCI structures
+*/
+/* IRQ Constants
+** (outside of "#ifdef PCI" because USB (mis)uses HOST_INT_SCAN_COMPLETE) */
+#define HOST_INT_RX_DATA	0x0001
+#define HOST_INT_TX_COMPLETE	0x0002
+#define HOST_INT_TX_XFER	0x0004
+#define HOST_INT_RX_COMPLETE	0x0008
+#define HOST_INT_DTIM		0x0010
+#define HOST_INT_BEACON		0x0020
+#define HOST_INT_TIMER		0x0040
+#define HOST_INT_KEY_NOT_FOUND	0x0080
+#define HOST_INT_IV_ICV_FAILURE	0x0100
+#define HOST_INT_CMD_COMPLETE	0x0200
+#define HOST_INT_INFO		0x0400
+#define HOST_INT_OVERFLOW	0x0800
+#define HOST_INT_PROCESS_ERROR	0x1000
+#define HOST_INT_SCAN_COMPLETE	0x2000
+#define HOST_INT_FCS_THRESHOLD	0x4000
+#define HOST_INT_UNKNOWN	0x8000
+
+/* Outside of "#ifdef PCI" because USB needs to know sizeof()
+** of txdesc and rxdesc: */
+struct txdesc {
+	acx_ptr	pNextDesc;	/* pointer to next txdesc */
+	acx_ptr	HostMemPtr;			/* 0x04 */
+	acx_ptr	AcxMemPtr;			/* 0x08 */
+	u32	tx_time;			/* 0x0c */
+	u16	total_length;			/* 0x10 */
+	u16	Reserved;			/* 0x12 */
+
+/* The following 16 bytes do not change when acx100 owns the descriptor */
+/* BUG: fw clears last byte of this area which is supposedly reserved
+** for driver use. amd64 blew up. We dare not use it now */
+	u32	dummy[4];
+
+	u8	Ctl_8;			/* 0x24, 8bit value */
+	u8	Ctl2_8;			/* 0x25, 8bit value */
+	u8	error;			/* 0x26 */
+	u8	ack_failures;		/* 0x27 */
+	u8	rts_failures;		/* 0x28 */
+	u8	rts_ok;			/* 0x29 */
+	union {
+		struct {
+			u8	rate;		/* 0x2a */
+			u8	queue_ctrl;	/* 0x2b */
+		} ACX_PACKED r1;
+		struct {
+			u16	rate111;	/* 0x2a */
+		} ACX_PACKED r2;
+	} ACX_PACKED u;
+	u32	queue_info;			/* 0x2c (acx100, reserved on acx111) */
+} ACX_PACKED;		/* size : 48 = 0x30 */
+/* NB: acx111 txdesc structure is 4 byte larger */
+/* All these 4 extra bytes are reserved. tx alloc code takes them into account */
+
+struct rxdesc {
+	acx_ptr	pNextDesc;			/* 0x00 */
+	acx_ptr	HostMemPtr;			/* 0x04 */
+	acx_ptr	ACXMemPtr;			/* 0x08 */
+	u32	rx_time;			/* 0x0c */
+	u16	total_length;			/* 0x10 */
+	u16	WEP_length;			/* 0x12 */
+	u32	WEP_ofs;			/* 0x14 */
+
+/* the following 16 bytes do not change when acx100 owns the descriptor */
+	u8	driverWorkspace[16];		/* 0x18 */
+
+	u8	Ctl_8;
+	u8	rate;
+	u8	error;
+	u8	SNR;				/* Signal-to-Noise Ratio */
+	u8	RxLevel;
+	u8	queue_ctrl;
+	u16	unknown;
+	u32	unknown2;
+} ACX_PACKED;		/* size 52 = 0x34 */
+
+#ifdef ACX_MAC80211_PCI
+
+/* Register I/O offsets */
+#define ACX100_EEPROM_ID_OFFSET	0x380
+
+/* please add further ACX hardware register definitions only when
+   it turns out you need them in the driver, and please try to use
+   firmware functionality instead, since using direct I/O access instead
+   of letting the firmware do it might confuse the firmware's state
+   machine */
+
+/* ***** ABSOLUTELY ALWAYS KEEP OFFSETS IN SYNC WITH THE INITIALIZATION
+** OF THE I/O ARRAYS!!!! (grep for '^IO_ACX') ***** */
+enum {
+	IO_ACX_SOFT_RESET = 0,
+
+	IO_ACX_SLV_MEM_ADDR,
+	IO_ACX_SLV_MEM_DATA,
+	IO_ACX_SLV_MEM_CTL,
+	IO_ACX_SLV_END_CTL,
+
+	IO_ACX_FEMR,		/* Function Event Mask */
+
+	IO_ACX_INT_TRIG,
+	IO_ACX_IRQ_MASK,
+	IO_ACX_IRQ_STATUS_NON_DES,
+	IO_ACX_IRQ_STATUS_CLEAR, /* CLEAR = clear on read */
+	IO_ACX_IRQ_ACK,
+	IO_ACX_HINT_TRIG,
+
+	IO_ACX_ENABLE,
+
+	IO_ACX_EEPROM_CTL,
+	IO_ACX_EEPROM_ADDR,
+	IO_ACX_EEPROM_DATA,
+	IO_ACX_EEPROM_CFG,
+
+	IO_ACX_PHY_ADDR,
+	IO_ACX_PHY_DATA,
+	IO_ACX_PHY_CTL,
+
+	IO_ACX_GPIO_OE,
+
+	IO_ACX_GPIO_OUT,
+
+	IO_ACX_CMD_MAILBOX_OFFS,
+	IO_ACX_INFO_MAILBOX_OFFS,
+	IO_ACX_EEPROM_INFORMATION,
+
+	IO_ACX_EE_START,
+	IO_ACX_SOR_CFG,
+	IO_ACX_ECPU_CTRL
+};
+/* ***** ABSOLUTELY ALWAYS KEEP OFFSETS IN SYNC WITH THE INITIALIZATION
+** OF THE I/O ARRAYS!!!! (grep for '^IO_ACX') ***** */
+
+/* Values for IO_ACX_INT_TRIG register: */
+/* inform hw that rxdesc in queue needs processing */
+#define INT_TRIG_RXPRC		0x08
+/* inform hw that txdesc in queue needs processing */
+#define INT_TRIG_TXPRC		0x04
+/* ack that we received info from info mailbox */
+#define INT_TRIG_INFOACK	0x02
+/* inform hw that we have filled command mailbox */
+#define INT_TRIG_CMD		0x01
+
+struct txhostdesc {
+	acx_ptr	data_phy;			/* 0x00 [u8 *] */
+	u16	data_offset;			/* 0x04 */
+	u16	reserved;			/* 0x06 */
+	u16	Ctl_16;	/* 16bit value, endianness!! */
+	u16	length;			/* 0x0a */
+	acx_ptr	desc_phy_next;		/* 0x0c [txhostdesc *] */
+	acx_ptr	pNext;			/* 0x10 [txhostdesc *] */
+	u32	Status;			/* 0x14, unused on Tx */
+/* From here on you can use this area as you want (variable length, too!) */
+	u8	*data;
+	struct ieee80211_tx_status txstatus;
+	struct sk_buff *skb;	
+
+} ACX_PACKED;
+
+struct rxhostdesc {
+	acx_ptr	data_phy;			/* 0x00 [rxbuffer_t *] */
+	u16	data_offset;			/* 0x04 */
+	u16	reserved;			/* 0x06 */
+	u16	Ctl_16;			/* 0x08; 16bit value, endianness!! */
+	u16	length;			/* 0x0a */
+	acx_ptr	desc_phy_next;		/* 0x0c [rxhostdesc_t *] */
+	acx_ptr	pNext;			/* 0x10 [rxhostdesc_t *] */
+	u32	Status;			/* 0x14 */
+/* From here on you can use this area as you want (variable length, too!) */
+	rxbuffer_t *data;
+} ACX_PACKED;
+
+#endif /* ACX_PCI */
+
+/***********************************************************************
+** USB structures and constants
+*/
+#ifdef ACX_MAC80211_USB
+
+/* Used for usb_txbuffer.desc field */
+#define USB_TXBUF_TXDESC	0xA
+/* Size of header (everything up to data[]) */
+#define USB_TXBUF_HDRSIZE	14
+typedef struct usb_txbuffer {
+	u16	desc;
+	u16	mpdu_len;
+	u8	queue_index;
+	u8	rate;
+	u32	hostdata;
+	u8	ctrl1;
+	u8	ctrl2;
+	u16	data_len;
+	/* wlan packet content is placed here: */
+	u8	data[30 + 2312 + 4]; /*WLAN_A4FR_MAXLEN_WEP_FCS]*/
+} ACX_PACKED usb_txbuffer_t;
+
+/* USB returns either rx packets (see rxbuffer) or
+** these "tx status" structs: */
+typedef struct usb_txstatus {
+	u16	mac_cnt_rcvd;		/* only 12 bits are len! (0xfff) */
+	u8	queue_index;
+	u8	mac_status;		/* seen 0x20 on tx failure */
+	u32	hostdata;
+	u8	rate;
+	u8	ack_failures;
+	u8	rts_failures;
+	u8	rts_ok;
+//	struct ieee80211_tx_status txstatus;
+//	struct sk_buff *skb;	
+} ACX_PACKED usb_txstatus_t;
+
+typedef struct usb_tx {
+	unsigned	busy:1;
+	struct urb	*urb;
+	acx_device_t	*adev;
+	/* actual USB bulk output data block is here: */
+	usb_txbuffer_t	bulkout;
+} usb_tx_t;
+
+struct usb_rx_plain {
+	unsigned	busy:1;
+	struct urb	*urb;
+	acx_device_t	*adev;
+	rxbuffer_t	bulkin;
+};
+
+typedef struct usb_rx {
+	unsigned	busy:1;
+	struct urb	*urb;
+	acx_device_t	*adev;
+	rxbuffer_t	bulkin;
+	/* Make entire structure 4k */
+	u8 padding[4*1024 - sizeof(struct usb_rx_plain)];
+} usb_rx_t;
+#endif /* ACX_USB */
+
+
+/* Config Option structs */
+
+typedef struct co_antennas {
+	u8	type;
+	u8	len;
+	u8	list[2];
+} ACX_PACKED co_antennas_t;
+
+typedef struct co_powerlevels {
+	u8	type;
+	u8	len;
+	u16	list[8];
+} ACX_PACKED co_powerlevels_t;
+
+typedef struct co_datarates {
+	u8	type;
+	u8	len;
+	u8	list[8];
+} ACX_PACKED co_datarates_t;
+
+typedef struct co_domains {
+	u8	type;
+	u8	len;
+	u8	list[6];
+} ACX_PACKED co_domains_t;
+
+typedef struct co_product_id {
+	u8	type;
+	u8	len;
+	u8	list[128];
+} ACX_PACKED co_product_id_t;
+
+typedef struct co_manuf_id {
+	u8	type;
+	u8	len;
+	u8	list[128];
+} ACX_PACKED co_manuf_t;
+
+typedef struct co_fixed {
+	char	NVSv[8];
+/*	u16	NVS_vendor_offs;	ACX111-only */
+/*	u16	unknown;		ACX111-only */
+	u8	MAC[6];	/* ACX100-only */
+	u16	probe_delay;	/* ACX100-only */
+	u32	eof_memory;
+	u8	dot11CCAModes;
+	u8	dot11Diversity;
+	u8	dot11ShortPreambleOption;
+	u8	dot11PBCCOption;
+	u8	dot11ChannelAgility;
+	u8	dot11PhyType; /* FIXME: does 802.11 call it "dot11PHYType"? */
+	u8	dot11TempType;
+	u8	table_count;
+} ACX_PACKED co_fixed_t;
+
+typedef struct acx111_ie_configoption {
+	u16			type;
+	u16			len;
+/* Do not access below members directly, they are in fact variable length */
+	co_fixed_t		fixed;
+	co_antennas_t		antennas;
+	co_powerlevels_t	power_levels;
+	co_datarates_t		data_rates;
+	co_domains_t		domains;
+	co_product_id_t		product_id;
+	co_manuf_t		manufacturer;
+	u8			_padding[4];
+} ACX_PACKED acx111_ie_configoption_t;
+
+/***********************************************************************
+** Main acx per-device data structure
+*/
+#define ACX_STATE_FW_LOADED	0x01
+#define ACX_STATE_IFACE_UP	0x02
+
+/* MAC mode (BSS type) defines
+ * Note that they shouldn't be redefined, since they are also used
+ * during communication with firmware */
+#define ACX_MODE_0_ADHOC	0
+#define ACX_MODE_1_UNUSED	1
+#define ACX_MODE_2_STA		2
+#define ACX_MODE_3_AP		3
+/* These are our own inventions. Sending these to firmware
+** makes it stop emitting beacons, which is exactly what we want
+** for these modes */
+#define ACX_MODE_MONITOR	0xfe
+#define ACX_MODE_OFF		0xff
+/* 'Submode': identifies exact status of ADHOC/STA host */
+#define ACX_STATUS_0_STOPPED		0
+#define ACX_STATUS_1_SCANNING		1
+#define ACX_STATUS_2_WAIT_AUTH		2
+#define ACX_STATUS_3_AUTHENTICATED	3
+#define ACX_STATUS_4_ASSOCIATED		4
+
+/* FIXME: this should be named something like struct acx_priv (typedef'd to
+ * acx_priv_t) */
+
+/* non-firmware struct, no packing necessary */
+struct acx_device {
+	/* most frequent accesses first (dereferencing and cache line!) */
+
+	/*** Locking ***/
+	struct mutex		mutex;
+	spinlock_t		lock;
+#if defined(PARANOID_LOCKING) /* Lock debugging */
+	const char		*last_sem;
+	const char		*last_lock;
+	unsigned long		sem_time;
+	unsigned long		lock_time;
+#endif
+
+	/*** Linux network device ***/
+	//struct device	*dev;		/* pointer to linux netdevice */
+
+	/*** Device statistics ***/
+	struct ieee80211_low_level_stats	ieee_stats;		/* wireless device statistics */
+
+	/*** Device statistics ***/
+	struct net_device_stats	stats;		/* net device statistics */
+
+#ifdef WIRELESS_EXT
+//	struct iw_statistics	wstats;		/* wireless statistics */
+#endif
+	struct acx_stats	acx_stats;
+	struct ieee80211_hw	*ieee;
+	struct ieee80211_hw_mode	modes[2];
+	struct ieee80211_rx_status rx_status;
+	/*** Power managment ***/
+	struct pm_dev		*pm;		/* PM crap */
+
+	/*** Management timer ***/
+	struct timer_list	mgmt_timer;
+
+	/*** Hardware identification ***/
+	const char		*chip_name;
+	u8			dev_type;
+	u8			chip_type;
+	u8			form_factor;
+	u8			radio_type;
+	u8			eeprom_version;
+
+	/*** Config retrieved from EEPROM ***/
+	char			cfgopt_NVSv[8];
+	u16			cfgopt_NVS_vendor_offs;
+	u8			cfgopt_MAC[6];
+	u16			cfgopt_probe_delay;
+	u32			cfgopt_eof_memory;
+	u8			cfgopt_dot11CCAModes;
+	u8			cfgopt_dot11Diversity;
+	u8			cfgopt_dot11ShortPreambleOption;
+	u8			cfgopt_dot11PBCCOption;
+	u8			cfgopt_dot11ChannelAgility;
+	u8			cfgopt_dot11PhyType;
+	u8			cfgopt_dot11TempType;
+	co_antennas_t		cfgopt_antennas;
+	co_powerlevels_t	cfgopt_power_levels;
+	co_datarates_t		cfgopt_data_rates;
+	co_domains_t		cfgopt_domains;
+	co_product_id_t		cfgopt_product_id;
+	co_manuf_t		cfgopt_manufacturer;
+
+	/*** Firmware identification ***/
+	char		firmware_version[FW_ID_SIZE+1];
+	u32		firmware_numver;
+	u32		firmware_id;
+	const u16	*ie_len;
+	const u16	*ie_len_dot11;
+
+	/*** Device state ***/
+	u16		dev_state_mask;
+	u8		led_power;		/* power LED status */
+	u32		get_mask;		/* mask of settings to fetch from the card */
+	u32		set_mask;		/* mask of settings to write to the card */
+	u32		initialized:1;
+	/* Barely used in USB case */
+	u16		irq_status;
+	int		irq_savedstate;
+	int		irq_reason;
+	u8		after_interrupt_jobs;	/* mini job list for doing actions after an interrupt occurred */
+	struct work_struct	after_interrupt_task;	/* our task for after interrupt actions */
+
+	unsigned int	irq;
+
+	/*** scanning ***/
+	u16		scan_count;		/* number of times to do channel scan */
+	u8		scan_mode;		/* 0 == active, 1 == passive, 2 == background */
+	u8		scan_rate;
+	u16		scan_duration;
+	u16		scan_probe_delay;
+#if WIRELESS_EXT > 15
+//	struct iw_spy_data	spy_data;	/* FIXME: needs to be implemented! */
+#endif
+
+	/*** Virtual interface struct ***/
+	struct acx_interface interface;
+
+	/*** Wireless network settings ***/
+	/* copy of the device address (ifconfig hw ether) that we actually use
+	** for 802.11; copied over from the network device's MAC address
+	** (ifconfig) when it makes sense only */
+	u8		dev_addr[MAX_ADDR_LEN];
+	u8		bssid[ETH_ALEN];	/* the BSSID after having joined */
+	u8		ap[ETH_ALEN];		/* The AP we want, FF:FF:FF:FF:FF:FF is any */
+	u16		aid;			/* The Association ID sent from the AP / last used AID if we're an AP */
+	u16		mode;			/* mode from iwconfig */
+	int		monitor_type;		/* ARPHRD_IEEE80211 or ARPHRD_IEEE80211_PRISM */
+	u16		status;			/* 802.11 association status */
+	u8		essid_active;		/* specific ESSID active, or select any? */
+	u8		essid_len;		/* to avoid dozens of strlen() */
+	/* INCLUDES \0 termination for easy printf - but many places
+	** simply want the string data memcpy'd plus a length indicator!
+	** Keep that in mind... */
+	char		essid[IW_ESSID_MAX_SIZE+1];
+	/* essid we are going to use for association, in case of "essid 'any'"
+	** and in case of hidden ESSID (use configured ESSID then) */
+	char		essid_for_assoc[IW_ESSID_MAX_SIZE+1];
+	char		nick[IW_ESSID_MAX_SIZE+1]; /* see essid! */
+	u8		channel;
+	u8		reg_dom_id;		/* reg domain setting */
+	u16		reg_dom_chanmask;
+	u16		auth_or_assoc_retries;
+	u16		scan_retries;
+	unsigned long	scan_start;		/* YES, jiffies is defined as "unsigned long" */
+
+
+	/* MAC80211 Template Reference */
+	struct sk_buff *beacon_cache;
+	/* stations known to us (if we're an ap) */
+//	client_t	sta_list[32];		/* tab is larger than list, so that */
+//	client_t	*sta_hash_tab[64];	/* hash collisions are not likely */
+//	client_t	*ap_client;		/* this one is our AP (STA mode only) */
+
+	int		dup_count;
+	int		nondup_count;
+	unsigned long	dup_msg_expiry;
+	u16		last_seq_ctrl;		/* duplicate packet detection */
+
+	/* 802.11 power save mode */
+	u8		ps_wakeup_cfg;
+	u8		ps_listen_interval;
+	u8		ps_options;
+	u8		ps_hangover_period;
+	u32		ps_enhanced_transition_time;
+	u32		ps_beacon_rx_time;
+
+	/*** PHY settings ***/
+	u8		fallback_threshold;
+	u8		stepup_threshold;
+	u16		rate_basic;
+	u16		rate_oper;
+	u16		rate_bcast;
+	u16		rate_bcast100;
+	u8		rate_auto;		/* false if "iwconfig rate N" (WITHOUT 'auto'!) */
+	u8		preamble_mode;		/* 0 == Long Preamble, 1 == Short, 2 == Auto */
+	u8		preamble_cur;
+
+	u8		tx_disabled;
+	u8		tx_level_dbm;
+	/* u8		tx_level_val; */
+	/* u8		tx_level_auto;		whether to do automatic power adjustment */
+
+	unsigned long	recalib_time_last_success;
+	unsigned long	recalib_time_last_attempt;
+	int		recalib_failure_count;
+	int		recalib_msg_ratelimit;
+	int		retry_errors_msg_ratelimit;
+
+	unsigned long	brange_time_last_state_change;	/* time the power LED was last changed */
+	u8		brange_last_state;	/* last state of the LED */
+	u8		brange_max_quality;	/* maximum quality that equates to full speed */
+
+	u8		sensitivity;
+	u8		antenna;		/* antenna settings */
+	u8		ed_threshold;		/* energy detect threshold */
+	u8		cca;			/* clear channel assessment */
+
+	u16		rts_threshold;
+	u16		frag_threshold;
+	u32		short_retry;
+	u32		long_retry;
+	u16		msdu_lifetime;
+	u16		listen_interval;	/* given in units of beacon interval */
+	u32		beacon_interval;
+
+	u16		capabilities;
+	u8		rate_supported_len;
+	u8		rate_supported[13];
+
+	/*** Encryption settings (WEP) ***/
+	u32		auth_alg;		/* used in transmit_authen1 */
+	u8		wep_enabled;
+	u8		wep_restricted;
+	u8		wep_current_index;
+	wep_key_t	wep_keys[DOT11_MAX_DEFAULT_WEP_KEYS];	/* the default WEP keys */
+
+	key_struct_t	wep_key_struct[10];
+
+	/*** Encryption Replacement for mac80211 ***/
+	struct acx_key	key[54];
+	u16 security_offset;
+	u8 default_key_idx;
+
+
+	/*** Unknown ***/
+	u8		dtim_interval;
+
+	/*** Card Rx/Tx management ***/
+	u16		rx_config_1;
+	u16		rx_config_2;
+	u16		memblocksize;
+	unsigned int	tx_free;
+	unsigned int	tx_head; /* keep as close as possible to Tx stuff below (cache line) */
+	u16		phy_header_len;
+	
+/*************************************************************************
+ *** PCI/USB/... must be last or else hw agnostic code breaks horribly ***
+ *************************************************************************/
+
+	/* hack to let common code compile. FIXME */
+	dma_addr_t	rxhostdesc_startphy;
+
+	/*** PCI stuff ***/
+#ifdef ACX_MAC80211_PCI
+	/* pointers to tx buffers, tx host descriptors (in host memory)
+	** and tx descs in device memory */
+	unsigned int	tx_tail;
+	u8		*txbuf_start;
+	txhostdesc_t	*txhostdesc_start;
+	txdesc_t	*txdesc_start;	/* points to PCI-mapped memory */
+	dma_addr_t	txbuf_startphy;
+	dma_addr_t	txhostdesc_startphy;
+	/* sizes of above host memory areas */
+	unsigned int	txbuf_area_size;
+	unsigned int	txhostdesc_area_size;
+
+	unsigned int	txdesc_size;	/* size of txdesc; ACX111 = ACX100 + 4 */
+	client_t	*txc[TX_CNT];
+	u16		txr[TX_CNT];
+
+	/* same for rx */
+	unsigned int	rx_tail;
+	rxbuffer_t	*rxbuf_start;
+	rxhostdesc_t	*rxhostdesc_start;
+	rxdesc_t	*rxdesc_start;
+	/* physical addresses of above host memory areas */
+	dma_addr_t	rxbuf_startphy;
+	/* dma_addr_t	rxhostdesc_startphy; */
+	unsigned int	rxbuf_area_size;
+	unsigned int	rxhostdesc_area_size;
+
+	u8		need_radio_fw;
+	u8		irqs_active;	/* whether irq sending is activated */
+
+	const u16	*io;		/* points to ACX100 or ACX111 PCI I/O register address set */
+
+#ifdef CONFIG_PCI
+	struct pci_dev	*pdev;
+#endif
+#ifdef CONFIG_VLYNQ
+	struct vlynq_device	*vdev;
+#endif
+	struct device *bus_dev;
+
+	unsigned long	membase;
+	unsigned long	membase2;
+	void __iomem	*iobase;
+	void __iomem	*iobase2;
+	/* command interface */
+	u8 __iomem	*cmd_area;
+	u8 __iomem	*info_area;
+
+	u16		irq_mask;		/* interrupt types to mask out (not wanted) with many IRQs activated */
+	u16		irq_mask_off;		/* interrupt types to mask out (not wanted) with IRQs off */
+	unsigned int	irq_loops_this_jiffy;
+	unsigned long	irq_last_jiffies;
+#endif
+
+	/*** USB stuff ***/
+#ifdef ACX_MAC80211_USB
+	struct usb_device	*usbdev;
+
+	rxbuffer_t	rxtruncbuf;
+
+	usb_tx_t	*usb_tx;
+	usb_rx_t	*usb_rx;
+
+	int		bulkinep;	/* bulk-in endpoint */
+	int		bulkoutep;	/* bulk-out endpoint */
+	int		rxtruncsize;
+#endif
+
+};
+
+
+
+static inline
+acx_device_t * ieee2adev(struct ieee80211_hw *hw)
+{
+        return hw->priv;
+}
+
+
+/* For use with ACX1xx_IE_RXCONFIG */
+/*  bit     description
+ *    13   include additional header (length etc.) *required*
+ *		struct is defined in 'struct rxbuffer'
+ *		is this bit acx100 only? does acx111 always put the header,
+ *		and bit setting is irrelevant? --vda
+ *    10   receive frames only with SSID used in last join cmd
+ *     9   discard broadcast
+ *     8   receive packets for multicast address 1
+ *     7   receive packets for multicast address 0
+ *     6   discard all multicast packets
+ *     5   discard frames from foreign BSSID
+ *     4   discard frames with foreign destination MAC address
+ *     3   promiscuous mode (receive ALL frames, disable filter)
+ *     2   include FCS
+ *     1   include phy header
+ *     0   ???
+ */
+#define RX_CFG1_INCLUDE_RXBUF_HDR	0x2000 /* ACX100 only */
+#define RX_CFG1_FILTER_SSID		0x0400
+#define RX_CFG1_FILTER_BCAST		0x0200
+#define RX_CFG1_RCV_MC_ADDR1		0x0100
+#define RX_CFG1_RCV_MC_ADDR0		0x0080
+#define RX_CFG1_FILTER_ALL_MULTI	0x0040
+#define RX_CFG1_FILTER_BSSID		0x0020
+#define RX_CFG1_FILTER_MAC		0x0010
+#define RX_CFG1_RCV_PROMISCUOUS		0x0008
+#define RX_CFG1_INCLUDE_FCS		0x0004
+#define RX_CFG1_INCLUDE_PHY_HDR		(WANT_PHY_HDR ? 0x0002 : 0)
+/*  bit     description
+ *    11   receive association requests etc.
+ *    10   receive authentication frames
+ *     9   receive beacon frames
+ *     8   receive contention free packets
+ *     7   receive control frames
+ *     6   receive data frames
+ *     5   receive broken frames
+ *     4   receive management frames
+ *     3   receive probe requests
+ *     2   receive probe responses
+ *     1   receive RTS/CTS/ACK frames
+ *     0   receive other
+ */
+#define RX_CFG2_RCV_ASSOC_REQ		0x0800
+#define RX_CFG2_RCV_AUTH_FRAMES		0x0400
+#define RX_CFG2_RCV_BEACON_FRAMES	0x0200
+#define RX_CFG2_RCV_CONTENTION_FREE	0x0100
+#define RX_CFG2_RCV_CTRL_FRAMES		0x0080
+#define RX_CFG2_RCV_DATA_FRAMES		0x0040
+#define RX_CFG2_RCV_BROKEN_FRAMES	0x0020
+#define RX_CFG2_RCV_MGMT_FRAMES		0x0010
+#define RX_CFG2_RCV_PROBE_REQ		0x0008
+#define RX_CFG2_RCV_PROBE_RESP		0x0004
+#define RX_CFG2_RCV_ACK_FRAMES		0x0002
+#define RX_CFG2_RCV_OTHER		0x0001
+
+/* For use with ACX1xx_IE_FEATURE_CONFIG */
+#define FEATURE1_80MHZ_CLOCK	0x00000040L
+#define FEATURE1_4X		0x00000020L
+#define FEATURE1_LOW_RX		0x00000008L
+#define FEATURE1_EXTRA_LOW_RX	0x00000001L
+
+#define FEATURE2_SNIFFER	0x00000080L
+#define FEATURE2_NO_TXCRYPT	0x00000001L
+
+/*-- get and set mask values --*/
+#define GETSET_LED_POWER	0x00000001L
+#define GETSET_STATION_ID	0x00000002L
+#define SET_TEMPLATES		0x00000004L
+#define SET_STA_LIST		0x00000008L
+#define GETSET_TX		0x00000010L
+#define GETSET_RX		0x00000020L
+#define SET_RXCONFIG		0x00000040L
+#define GETSET_ANTENNA		0x00000080L
+#define GETSET_SENSITIVITY	0x00000100L
+#define GETSET_TXPOWER		0x00000200L
+#define GETSET_ED_THRESH	0x00000400L
+#define GETSET_CCA		0x00000800L
+#define GETSET_POWER_80211	0x00001000L
+#define GETSET_RETRY		0x00002000L
+#define GETSET_REG_DOMAIN	0x00004000L
+#define GETSET_CHANNEL		0x00008000L
+/* Used when ESSID changes etc and we need to scan for AP anew */
+#define GETSET_RESCAN		0x00010000L
+#define GETSET_MODE		0x00020000L
+#define GETSET_WEP		0x00040000L
+#define SET_WEP_OPTIONS		0x00080000L
+#define SET_MSDU_LIFETIME	0x00100000L
+#define SET_RATE_FALLBACK	0x00200000L
+
+/* keep in sync with the above */
+#define GETSET_ALL	(0 \
+/* GETSET_LED_POWER */	| 0x00000001L \
+/* GETSET_STATION_ID */	| 0x00000002L \
+/* SET_TEMPLATES */	| 0x00000004L \
+/* SET_STA_LIST */	| 0x00000008L \
+/* GETSET_TX */		| 0x00000010L \
+/* GETSET_RX */		| 0x00000020L \
+/* SET_RXCONFIG */	| 0x00000040L \
+/* GETSET_ANTENNA */	| 0x00000080L \
+/* GETSET_SENSITIVITY */| 0x00000100L \
+/* GETSET_TXPOWER */	| 0x00000200L \
+/* GETSET_ED_THRESH */	| 0x00000400L \
+/* GETSET_CCA */	| 0x00000800L \
+/* GETSET_POWER_80211 */| 0x00001000L \
+/* GETSET_RETRY */	| 0x00002000L \
+/* GETSET_REG_DOMAIN */	| 0x00004000L \
+/* GETSET_CHANNEL */	| 0x00008000L \
+/* GETSET_RESCAN */	| 0x00010000L \
+/* GETSET_MODE */	| 0x00020000L \
+/* GETSET_WEP */	| 0x00040000L \
+/* SET_WEP_OPTIONS */	| 0x00080000L \
+/* SET_MSDU_LIFETIME */	| 0x00100000L \
+/* SET_RATE_FALLBACK */	| 0x00200000L \
+			)
+
+/***********************************************************************
+*/
+typedef struct acx100_ie_memblocksize {
+	u16	type;
+	u16	len;
+	u16	size;
+} ACX_PACKED acx100_ie_memblocksize_t;
+
+typedef struct acx100_ie_queueconfig {
+	u16	type;
+	u16	len;
+	u32	AreaSize;
+	u32	RxQueueStart;
+	u8	QueueOptions;
+	u8	NumTxQueues;
+	u8	NumRxDesc;	 /* for USB only */
+	u8	pad1;
+	u32	QueueEnd;
+	u32	HostQueueEnd; /* QueueEnd2 */
+	u32	TxQueueStart;
+	u8	TxQueuePri;
+	u8	NumTxDesc;
+	u16	pad2;
+} ACX_PACKED acx100_ie_queueconfig_t;
+
+typedef struct acx111_ie_queueconfig {
+	u16	type;
+	u16	len;
+	u32	tx_memory_block_address;
+	u32	rx_memory_block_address;
+	u32	rx1_queue_address;
+	u32	reserved1;
+	u32	tx1_queue_address;
+	u8	tx1_attributes;
+	u16	reserved2;
+	u8	reserved3;
+} ACX_PACKED acx111_ie_queueconfig_t;
+
+typedef struct acx100_ie_memconfigoption {
+	u16	type;
+	u16	len;
+	u32	DMA_config;
+	acx_ptr	pRxHostDesc;
+	u32	rx_mem;
+	u32	tx_mem;
+	u16	RxBlockNum;
+	u16	TxBlockNum;
+} ACX_PACKED acx100_ie_memconfigoption_t;
+
+typedef struct acx111_ie_memoryconfig {
+	u16	type;
+	u16	len;
+	u16	no_of_stations;
+	u16	memory_block_size;
+	u8	tx_rx_memory_block_allocation;
+	u8	count_rx_queues;
+	u8	count_tx_queues;
+	u8	options;
+	u8	fragmentation;
+	u16	reserved1;
+	u8	reserved2;
+
+	/* start of rx1 block */
+	u8	rx_queue1_count_descs;
+	u8	rx_queue1_reserved1;
+	u8	rx_queue1_type; /* must be set to 7 */
+	u8	rx_queue1_prio; /* must be set to 0 */
+	acx_ptr	rx_queue1_host_rx_start;
+	/* end of rx1 block */
+
+	/* start of tx1 block */
+	u8	tx_queue1_count_descs;
+	u8	tx_queue1_reserved1;
+	u8	tx_queue1_reserved2;
+	u8	tx_queue1_attributes;
+	/* end of tx1 block */
+} ACX_PACKED acx111_ie_memoryconfig_t;
+
+typedef struct acx_ie_memmap {
+	u16	type;
+	u16	len;
+	u32	CodeStart;
+	u32	CodeEnd;
+	u32	WEPCacheStart;
+	u32	WEPCacheEnd;
+	u32	PacketTemplateStart;
+	u32	PacketTemplateEnd;
+	u32	QueueStart;
+	u32	QueueEnd;
+	u32	PoolStart;
+	u32	PoolEnd;
+} ACX_PACKED acx_ie_memmap_t;
+
+typedef struct acx111_ie_feature_config {
+	u16	type;
+	u16	len;
+	u32	feature_options;
+	u32	data_flow_options;
+} ACX_PACKED acx111_ie_feature_config_t;
+
+typedef struct acx111_ie_tx_level {
+	u16	type;
+	u16	len;
+	u8	level;
+} ACX_PACKED acx111_ie_tx_level_t;
+
+#define PS_CFG_ENABLE		0x80
+#define PS_CFG_PENDING		0x40 /* status flag when entering PS */
+#define PS_CFG_WAKEUP_MODE_MASK	0x07
+#define PS_CFG_WAKEUP_BY_HOST	0x03
+#define PS_CFG_WAKEUP_EACH_ITVL	0x02
+#define PS_CFG_WAKEUP_ON_DTIM	0x01
+#define PS_CFG_WAKEUP_ALL_BEAC	0x00
+
+/* Enhanced PS mode: sleep until Rx Beacon w/ the STA's AID bit set
+** in the TIM; newer firmwares only(?) */
+#define PS_OPT_ENA_ENHANCED_PS	0x04
+#define PS_OPT_TX_PSPOLL	0x02 /* send PSPoll frame to fetch waiting frames from AP (on frame with matching AID) */
+#define PS_OPT_STILL_RCV_BCASTS	0x01
+
+typedef struct acx100_ie_powersave {
+	u16	type;
+	u16	len;
+	u8	wakeup_cfg;
+	u8	listen_interval; /* for EACH_ITVL: wake up every "beacon units" interval */
+	u8	options;
+	u8	hangover_period; /* remaining wake time after Tx MPDU w/ PS bit, in values of 1/1024 seconds */
+	u16	enhanced_ps_transition_time; /* rem. wake time for Enh. PS */
+} ACX_PACKED acx100_ie_powersave_t;
+
+typedef struct acx111_ie_powersave {
+	u16	type;
+	u16	len;
+	u8	wakeup_cfg;
+	u8	listen_interval; /* for EACH_ITVL: wake up every "beacon units" interval */
+	u8	options;
+	u8	hangover_period; /* remaining wake time after Tx MPDU w/ PS bit, in values of 1/1024 seconds */
+	u32	beacon_rx_time;
+	u32	enhanced_ps_transition_time; /* rem. wake time for Enh. PS */
+} ACX_PACKED acx111_ie_powersave_t;
+
+
+/***********************************************************************
+** Commands and template structures
+*/
+
+/*
+** SCAN command structure
+**
+** even though acx100 scan rates match RATE100 constants,
+** acx111 ones do not match! Therefore we do not use RATE100 #defines */
+#define ACX_SCAN_RATE_1		10
+#define ACX_SCAN_RATE_2		20
+#define ACX_SCAN_RATE_5		55
+#define ACX_SCAN_RATE_11	110
+#define ACX_SCAN_RATE_22	220
+#define ACX_SCAN_RATE_PBCC	0x80	/* OR with this if needed */
+#define ACX_SCAN_OPT_ACTIVE	0x00	/* a bit mask */
+#define ACX_SCAN_OPT_PASSIVE	0x01
+/* Background scan: we go into Power Save mode (by transmitting
+** NULL data frame to AP with the power mgmt bit set), do the scan,
+** and then exit Power Save mode. A plus is that AP buffers frames
+** for us while we do background scan. Thus we avoid frame losses.
+** Background scan can be active or passive, just like normal one */
+#define ACX_SCAN_OPT_BACKGROUND	0x02
+typedef struct acx100_scan {
+	u16	count;	/* number of scans to do, 0xffff == continuous */
+	u16	start_chan;
+	u16	flags;	/* channel list mask; 0x8000 == all channels? */
+	u8	max_rate;	/* max. probe rate */
+	u8	options;	/* bit mask, see defines above */
+	u16	chan_duration;
+	u16	max_probe_delay;
+} ACX_PACKED acx100_scan_t;			/* length 0xc */
+
+#define ACX111_SCAN_RATE_6	0x0B
+#define ACX111_SCAN_RATE_9	0x0F
+#define ACX111_SCAN_RATE_12	0x0A
+#define ACX111_SCAN_RATE_18	0x0E
+#define ACX111_SCAN_RATE_24	0x09
+#define ACX111_SCAN_RATE_36	0x0D
+#define ACX111_SCAN_RATE_48	0x08
+#define ACX111_SCAN_RATE_54	0x0C
+#define ACX111_SCAN_OPT_5GHZ    0x04	/* else 2.4GHZ */
+#define ACX111_SCAN_MOD_SHORTPRE 0x01	/* you can combine SHORTPRE and PBCC */
+#define ACX111_SCAN_MOD_PBCC	0x80
+#define ACX111_SCAN_MOD_OFDM	0x40
+typedef struct acx111_scan {
+	u16	count;		/* number of scans to do */
+	u8	channel_list_select; /* 0: scan all channels, 1: from chan_list only */
+	u16	reserved1;
+	u8	reserved2;
+	u8	rate;		/* rate for probe requests (if active scan) */
+	u8	options;		/* bit mask, see defines above */
+	u16	chan_duration;	/* min time to wait for reply on one channel (in TU) */
+						/* (active scan only) (802.11 section 11.1.3.2.2) */
+	u16	max_probe_delay;	/* max time to wait for reply on one channel (active scan) */
+						/* time to listen on a channel (passive scan) */
+	u8	modulation;
+	u8	channel_list[26];	/* bits 7:0 first byte: channels 8:1 */
+						/* bits 7:0 second byte: channels 16:9 */
+						/* 26 bytes is enough to cover 802.11a */
+} ACX_PACKED acx111_scan_t;
+
+/*
+** Radio calibration command structure
+*/
+typedef struct acx111_cmd_radiocalib {
+/* 0x80000000 == automatic calibration by firmware, according to interval;
+ * bits 0..3: select calibration methods to go through:
+ * calib based on DC, AfeDC, Tx mismatch, Tx equilization */
+	u32	methods;
+	u32	interval;
+} ACX_PACKED acx111_cmd_radiocalib_t;
+
+/*
+** Packet template structures
+**
+** Packet templates store contents of Beacon, Probe response, Probe request,
+** Null data frame, and TIM data frame. Firmware automatically transmits
+** contents of template at appropriate time:
+** - Beacon: when configured as AP or Ad-hoc
+** - Probe response: when configured as AP or Ad-hoc, whenever
+**   a Probe request frame is received
+** - Probe request: when host issues SCAN command (active)
+** - Null data frame: when entering 802.11 power save mode
+** - TIM data: at the end of Beacon frames (if no TIM template
+**   is configured, then transmits default TIM)
+** NB:
+** - size field must be set to size of actual template
+**   (NOT sizeof(struct) - templates are variable in length),
+**   size field is not itself counted.
+** - members flagged with an asterisk must be initialized with host,
+**   rest must be zero filled.
+** - variable length fields shown only in comments */
+typedef struct acx_template_tim {
+	u16	size;
+	u8	tim_eid;	/* 00 1 TIM IE ID * */
+	u8	len;		/* 01 1 Length * */
+	u8	dtim_cnt;	/* 02 1 DTIM Count */
+	u8	dtim_period;	/* 03 1 DTIM Period */
+	u8	bitmap_ctrl;	/* 04 1 Bitmap Control * (except bit0) */
+					/* 05 n Partial Virtual Bitmap * */
+	u8	variable[0x100 - 1-1-1-1-1];
+} ACX_PACKED acx_template_tim_t;
+
+typedef struct acx_template_probereq {
+	u16	size;
+	u16	fc;		/* 00 2 fc * */
+	u16	dur;		/* 02 2 Duration */
+	u8	da[6];  	/* 04 6 Destination Address * */
+	u8	sa[6];   	/* 0A 6 Source Address * */
+	u8	bssid[6];	/* 10 6 BSSID * */
+	u16	seq;		/* 16 2 Sequence Control */
+				/* 18 n SSID * */
+				/* nn n Supported Rates * */
+	u8	variable[0x44 - 2-2-6-6-6-2];
+} ACX_PACKED acx_template_probereq_t;
+
+typedef struct acx_template_proberesp {
+	u16	size;
+	u16	fc;		/* 00 2 fc * (bits [15:12] and [10:8] per 802.11 section 7.1.3.1) */
+	u16	dur;		/* 02 2 Duration */
+	u8	da[6];	/* 04 6 Destination Address */
+	u8	sa[6];	/* 0A 6 Source Address */
+	u8	bssid[6];	/* 10 6 BSSID */
+	u16	seq;		/* 16 2 Sequence Control */
+	u8	timestamp[8];/* 18 8 Timestamp */
+	u16	beacon_interval; /* 20 2 Beacon Interval * */
+	u16	cap;		/* 22 2 Capability Information * */
+					/* 24 n SSID * */
+					/* nn n Supported Rates * */
+					/* nn 1 DS Parameter Set * */
+	u8	variable[0x54 - 2-2-6-6-6-2-8-2-2];
+} ACX_PACKED acx_template_proberesp_t;
+#define acx_template_beacon_t acx_template_proberesp_t
+#define acx_template_beacon acx_template_proberesp
+
+typedef struct acx_template_nullframe {
+	u16	size;
+	struct ieee80211_hdr hdr;
+} ACX_PACKED acx_template_nullframe_t;
+
+
+/*
+** JOIN command structure
+**
+** as opposed to acx100, acx111 dtim interval is AFTER rates_basic111.
+** NOTE: took me about an hour to get !@#$%^& packing right --> struct packing is eeeeevil... */
+typedef struct acx_joinbss {
+	u8	bssid[ETH_ALEN];
+	u16	beacon_interval;
+	union {
+		struct {
+			u8	dtim_interval;
+			u8	rates_basic;
+			u8	rates_supported;
+		} ACX_PACKED acx100;
+		struct {
+			u16	rates_basic;
+			u8	dtim_interval;
+		} ACX_PACKED acx111;
+	} ACX_PACKED u;
+	u8	genfrm_txrate;	/* generated frame (bcn, proberesp, RTS, PSpoll) tx rate */
+	u8	genfrm_mod_pre;	/* generated frame modulation/preamble:
+						** bit7: PBCC, bit6: OFDM (else CCK/DQPSK/DBPSK)
+						** bit5: short pre */
+	u8	macmode;	/* BSS Type, must be one of ACX_MODE_xxx */
+	u8	channel;
+	u8	essid_len;
+	char	essid[IW_ESSID_MAX_SIZE];
+} ACX_PACKED acx_joinbss_t;
+
+#define JOINBSS_RATES_1		0x01
+#define JOINBSS_RATES_2		0x02
+#define JOINBSS_RATES_5		0x04
+#define JOINBSS_RATES_11	0x08
+#define JOINBSS_RATES_22	0x10
+
+/* Looks like missing bits are used to indicate 11g rates!
+** (it follows from the fact that constants below match 1:1 to RATE111_nn)
+** This was actually seen! Look at that Assoc Request sent by acx111,
+** it _does_ contain 11g rates in basic set:
+01:30:20.070772 Beacon (xxx) [1.0* 2.0* 5.5* 11.0* 6.0* 9.0* 12.0* 18.0* 24.0* 36.0* 48.0* 54.0* Mbit] ESS CH: 1
+01:30:20.074425 Authentication (Open System)-1: Succesful
+01:30:20.076539 Authentication (Open System)-2:
+01:30:20.076620 Acknowledgment
+01:30:20.088546 Assoc Request (xxx) [1.0* 2.0* 5.5* 6.0* 9.0* 11.0* 12.0* 18.0* 24.0* 36.0* 48.0* 54.0* Mbit]
+01:30:20.122413 Assoc Response AID(1) :: Succesful
+01:30:20.122679 Acknowledgment
+01:30:20.173204 Beacon (xxx) [1.0* 2.0* 5.5* 11.0* 6.0* 9.0* 12.0* 18.0* 24.0* 36.0* 48.0* 54.0* Mbit] ESS CH: 1
+*/
+#define JOINBSS_RATES_BASIC111_1	0x0001
+#define JOINBSS_RATES_BASIC111_2	0x0002
+#define JOINBSS_RATES_BASIC111_5	0x0004
+#define JOINBSS_RATES_BASIC111_11	0x0020
+#define JOINBSS_RATES_BASIC111_22	0x0100
+
+
+/***********************************************************************
+*/
+typedef struct mem_read_write {
+	u16	addr;
+	u16	type; /* 0x0 int. RAM / 0xffff MAC reg. / 0x81 PHY RAM / 0x82 PHY reg.; or maybe it's actually 0x30 for MAC? Better verify it by writing and reading back and checking whether the value holds! */
+	u32	len;
+	u32	data;
+} ACX_PACKED mem_read_write_t;
+
+typedef struct firmware_image {
+	u32	chksum;
+	u32	size;
+	u8	data[1]; /* the byte array of the actual firmware... */
+} ACX_PACKED firmware_image_t;
+
+typedef struct acx_cmd_radioinit {
+	u32	offset;
+	u32	len;
+} ACX_PACKED acx_cmd_radioinit_t;
+
+typedef struct acx100_ie_wep_options {
+	u16	type;
+	u16	len;
+	u16	NumKeys;	/* max # of keys */
+	u8	WEPOption;	/* 0 == decrypt default key only, 1 == override decrypt */
+	u8	Pad;		/* used only for acx111 */
+} ACX_PACKED acx100_ie_wep_options_t;
+
+typedef struct ie_dot11WEPDefaultKey {
+	u16	type;
+	u16	len;
+	u8	action;
+	u8	keySize;
+	u8	defaultKeyNum;
+	u8	key[29];	/* check this! was Key[19] */
+} ACX_PACKED ie_dot11WEPDefaultKey_t;
+
+typedef struct acx111WEPDefaultKey {
+	u8	MacAddr[ETH_ALEN];
+	u16	action;	/* NOTE: this is a u16, NOT a u8!! */
+	u16	reserved;
+	u8	keySize;
+	u8	type;
+	u8	index;
+	u8	defaultKeyNum;
+	u8	counter[6];
+	u8	key[32];	/* up to 32 bytes (for TKIP!) */
+} ACX_PACKED acx111WEPDefaultKey_t;
+
+typedef struct ie_dot11WEPDefaultKeyID {
+	u16	type;
+	u16	len;
+	u8	KeyID;
+} ACX_PACKED ie_dot11WEPDefaultKeyID_t;
+
+typedef struct acx100_cmd_wep_mgmt {
+	u8	MacAddr[ETH_ALEN];
+	u16	Action;
+	u16	KeySize;
+	u8	Key[29]; /* 29*8 == 232bits == WEP256 */
+} ACX_PACKED acx100_cmd_wep_mgmt_t;
+
+typedef struct acx_ie_generic {
+	u16	type;
+	u16	len;
+	union {
+		/* Association ID IE: just a 16bit value: */
+		u16	aid;
+		/* generic member for quick implementation of commands */
+		u8	bytes[32];
+	} ACX_PACKED m;
+} ACX_PACKED acx_ie_generic_t;
+
+#define ACX_SEC_KEYSIZE                     16
+/* Security algorithms. */                
+enum {
+        ACX_SEC_ALG,
+        ACX_SEC_ALGO_NONE = 0, /* unencrypted, as of TX header. */
+        ACX_SEC_ALGO_WEP,
+        ACX_SEC_ALGO_UNKNOWN,
+        ACX_SEC_ALGO_AES,
+        ACX_SEC_ALGO_WEP104,
+        ACX_SEC_ALGO_TKIP,
+};
+/***********************************************************************
+*/
+#define CHECK_SIZEOF(type,size) { \
+	extern void BUG_bad_size_for_##type(void); \
+	if (sizeof(type)!=(size)) BUG_bad_size_for_##type(); \
+}
+
+static inline void
+acx_struct_size_check(void)
+{
+	CHECK_SIZEOF(txdesc_t, 0x30);
+	CHECK_SIZEOF(acx100_ie_memconfigoption_t, 24);
+	CHECK_SIZEOF(acx100_ie_queueconfig_t, 0x20);
+	CHECK_SIZEOF(acx_joinbss_t, 0x30);
+	/* IEs need 4 bytes for (type,len) tuple */
+	CHECK_SIZEOF(acx111_ie_configoption_t, ACX111_IE_CONFIG_OPTIONS_LEN + 4);
+}
+
+
+/***********************************************************************
+** Global data
+*/
+extern const u8 acx_bitpos2ratebyte[];
+extern const u8 acx_bitpos2rate100[];
+
+extern const u8 acx_reg_domain_ids[];
+extern const char * const acx_reg_domain_strings[];
+enum {
+	acx_reg_domain_ids_len = 8
+};
+
+//extern const struct iw_handler_def acx_ioctl_handler_def;
diff -Nurp linux-2.6.23-sabayon.orig/drivers/net/wireless/acx/Changelog linux-2.6.23-sabayon/drivers/net/wireless/acx/Changelog
--- linux-2.6.23-sabayon.orig/drivers/net/wireless/acx/Changelog	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.23-sabayon/drivers/net/wireless/acx/Changelog	2007-10-10 10:51:23.000000000 +0200
@@ -0,0 +1,588 @@
+TODO:
+e100.c: pci_dma_sync_single_for_cpu(nic->pdev, rx->dma_addr, sizeof(struct rfd), PCI_DMA_FROMDEVICE);
+do we need to do something like above for rxhostdescs/rxbufs?
+
+TODO: from Efthym <efthym@gmx.net>:
+13:12:42 wlan0: rx: 31 DUPs in 551 packets received in 10 sec
+13:12:48 wlan0: tx error 0x20, buf 20! (excessive Tx retries
+13:12:48 wlan0: tx error 0x20, buf 21! (excessive Tx retries
+13:12:48 wlan0: several excessive Tx retry errors occurred, a
+13:12:48 wlan0: tx error 0x20, buf 22! (excessive Tx retries
+13:12:48 wlan0: tx error 0x20, buf 23! (excessive Tx retries
+13:12:48 wlan0: tx error 0x20, buf 24! (excessive Tx retries
+13:12:48 wlan0: recalibrating radio
+13:12:48 wlan0: successfully recalibrated radio
+13:12:52 wlan0: tx error 0x20, buf 25! (excessive Tx retries
+13:12:52 wlan0: several excessive Tx retry errors occurred, a
+13:12:52 wlan0: tx error 0x20, buf 26! (excessive Tx retries
+13:12:52 wlan0: tx error 0x20, buf 27! (excessive Tx retries
+13:12:52 wlan0: tx error 0x20, buf 28! (excessive Tx retries
+13:12:52 wlan0: tx error 0x20, buf 29! (excessive Tx retries
+13:12:52 wlan0: several excessive Tx retry errors occurred, a
+13:12:52 wlan0: tx error 0x20, buf 30! (excessive Tx retries
+13:12:52 wlan0: tx error 0x20, buf 31! (excessive Tx retries
+13:12:52 wlan0: tx error 0x20, buf 00! (excessive Tx retries
+13:12:52 wlan0: less than 5 minutes since last radio recalibr
+13:12:58 wlan0: tx error 0x20, buf 01! (excessive Tx retries
+13:12:58 wlan0: several excessive Tx retry errors occurred, a
+13:12:58 wlan0: tx error 0x20, buf 02! (excessive Tx retries
+13:12:58 wlan0: tx error 0x20, buf 03! (excessive Tx retries
+13:12:58 wlan0: tx error 0x20, buf 04! (excessive Tx retries
+13:12:58 wlan0: tx error 0x20, buf 05! (excessive Tx retries
+13:12:58 wlan0: several excessive Tx retry errors occurred, a
+13:12:58 disabling above notification message
+13:12:58 wlan0: tx error 0x20, buf 06! (excessive Tx retries
+13:12:58 wlan0: tx error 0x20, buf 07!
+13:12:58 wlan0: tx error 0x20, buf 08!
+13:12:58 wlan0: less than 5 minutes since last radio recalibr
+13:13:06 wlan0: tx error 0x20, buf 09!
+13:13:06 wlan0: tx error 0x20, buf 10!
+13:13:06 wlan0: tx error 0x20, buf 11!
+13:13:06 wlan0: tx error 0x20, buf 12!
+13:13:06 wlan0: tx error 0x20, buf 13!
+13:13:06 wlan0: tx error 0x20, buf 14!
+13:13:06 wlan0: tx error 0x20, buf 15!
+13:13:06 wlan0: tx error 0x20, buf 16!
+13:13:06 wlan0: less than 5 minutes since last radio recalibr
+13:13:18 wlan0: tx error 0x20, buf 17!
+13:13:18 wlan0: tx error 0x20, buf 18!
+13:13:18 wlan0: tx error 0x20, buf 19!
+13:13:18 wlan0: tx error 0x20, buf 20!
+13:13:18 wlan0: tx error 0x20, buf 21!
+13:13:18 wlan0: tx error 0x20, buf 22!
+13:13:18 wlan0: tx error 0x20, buf 23!
+13:13:18 wlan0: tx error 0x20, buf 24!
+13:13:18 wlan0: less than 5 minutes since last radio recalibr
+13:13:25 wlan0: tx error 0x20, buf 25!
+13:13:25 wlan0: tx error 0x20, buf 26!
+13:13:25 wlan0: tx error 0x20, buf 27!
+13:13:25 wlan0: tx error 0x20, buf 28!
+13:13:25 wlan0: tx error 0x20, buf 29!
+13:13:25 wlan0: tx error 0x20, buf 30!
+13:13:25 wlan0: tx error 0x20, buf 31!
+13:13:25 wlan0: tx error 0x20, buf 00!
+13:13:25 wlan0: less than 5 minutes since last radio recalibr
+13:13:25 disabling above message
+13:13:32 wlan0: tx error 0x20, buf 01!
+13:13:32 wlan0: tx error 0x20, buf 02!
+13:13:32 wlan0: tx error 0x20, buf 03!
+13:13:32 wlan0: tx error 0x20, buf 04!
+13:13:32 wlan0: tx error 0x20, buf 05!
+13:13:32 wlan0: tx error 0x20, buf 06!
+13:13:32 wlan0: tx error 0x20, buf 07!
+13:13:32 wlan0: tx error 0x20, buf 08!
+13:13:41 wlan0: tx error 0x20, buf 09!
+13:13:41 wlan0: tx error 0x20, buf 10!
+13:13:41 wlan0: tx error 0x20, buf 11!
+13:13:41 wlan0: tx error 0x20, buf 12!
+13:13:41 wlan0: tx error 0x20, buf 13!
+13:13:41 wlan0: tx error 0x20, buf 14!
+13:13:41 wlan0: tx error 0x20, buf 15!
+13:13:41 wlan0: tx error 0x20, buf 16!
+13:13:51 wlan0: tx error 0x20, buf 17!
+13:13:51 wlan0: tx error 0x20, buf 18!
+13:13:51 wlan0: tx error 0x20, buf 19!
+13:13:51 wlan0: tx error 0x20, buf 20!
+13:13:51 wlan0: tx error 0x20, buf 21!
+13:13:51 wlan0: tx error 0x20, buf 22!
+13:13:51 wlan0: tx error 0x20, buf 23!
+13:13:51 wlan0: tx error 0x20, buf 24!
+13:14:02 wlan0: tx error 0x20, buf 25!
+13:14:02 wlan0: tx error 0x20, buf 26!
+13:14:02 wlan0: tx error 0x20, buf 27!
+13:14:02 wlan0: tx error 0x20, buf 28!
+13:14:02 wlan0: tx error 0x20, buf 29!
+13:14:02 wlan0: tx error 0x20, buf 30!
+13:14:02 wlan0: tx error 0x20, buf 31!
+13:14:02 wlan0: tx error 0x20, buf 00!
+13:14:13 wlan0: tx error 0x20, buf 01!
+13:14:13 wlan0: tx error 0x20, buf 02!
+13:14:13 wlan0: tx error 0x20, buf 03!
+13:14:13 wlan0: tx error 0x20, buf 04!
+13:14:13 wlan0: tx error 0x20, buf 05!
+13:14:13 wlan0: tx error 0x20, buf 06!
+13:14:13 wlan0: tx error 0x20, buf 07!
+13:14:13 wlan0: tx error 0x20, buf 08!
+[20061217]
+* Sync with acxsm 0.4.9
+ - Moved some #includes (were sitting in the middle of the file)
+ - from Andreas Mohr: ioremap -> ioremap_nocache,
+   more desriptive error message on firmware upload failure
+	
+[20060707]
+* Jeff Williams
+  Fixed Kconfig CONFIG_ACX_MAC80211_* in common.c and acx_struct.h
+
+[20060707]
+* Matthias Meyer
+  Moved GPL license to README
+
+[20060605-20060706]
+* Jeff Williams <jeff@wdwconsulting.net>
+  Added DeviceScape 80211 stack support to PCI
+  Works with wpa_supplicant and hostapd
+  Removed excess homegrown/linux-wlan 80211 stack
+
+[20070101] 0.3.36
+* Andreas Mohr <andi@lisas.de>
+  - cope with *tons* of Linux kernel API changes (via added version checks):
+    - linux/utsrelease.h required in 2.6.18
+    - linux/config.h include removal in 2.6.19
+    - pt_regs interrupt handler arg removal in 2.6.19
+    - INIT_WORK() change in 2.6.20-rc1-git1
+    - "ESSID last char missing" API change in WE-21
+    If anything fails to work for a real non-prerelease mainline kernel version
+    (supported ones, that is: >= 2.6.10), then please yell immediately!
+    Those people *REALLY* want me to concentrate on getting this stuff ready for
+    mainline, it seems...
+  - MAC address change fix (contributed by Carlos Martn Nieto/Luis Padilla)
+  - fix iwlist wlan0 scan output (updated wrong pointer variable --> only one single rate value listed, doh!)
+  - fix buggy hidden ESSID handling (didn't cover all variants in all places)
+  - corrected(?) duration/sequence values in assoc steps handling
+  - use ioremap_nocache() instead of ioremap() (safer)
+  - add another TNETW1450 USB ID
+  - FIX buggy "correction" of medium busy percentage log message
+  - small /proc/driver/acx_wlan0_diag addition
+  - much more verbose firmware image query log message
+  - updated format of main hardware status log message
+  - slightly enhanced Reason Code log messages
+  - minor cleanup
+
+[20060518]
+* Fix warnings about packed structs and printf format mismatches.
+  Fix "implicit declaration of function dma_free_coherent" warning.
+
+[20060212] 0.3.35
+* Carlos Martin <carlos@cmartin.tk>
+  - Fix breakage of "Get rid of circular list of adev's"
+  - Remove .owner = THIS_MODULE
+
+[20060209] 0.3.34
+* Get rid of circular list of adev's
+
+[20060206]
+* Register driver device ids to usb device table
+
+[20060205] 0.3.33
+* Andreas Mohr <andi@rhlx01.fht-esslingen.de>
+  - implement much more flexible firmware statistics parsing
+    (for /proc/driver/acx_wlanX_diag)
+    This has the nice effect that we now get output for both the older
+    TNETW1100 USB and TNETW1450.
+    Since firmware statistics information has non-stable layout depending on
+    firmware version, please report if you suspect any parsing mismatch!
+    This improved version now uses 2kB more driver space, unfortunately.
+  - use "% 8" modulo instead of more complicated "% 5" calculation
+
+[20060202] 0.3.32
+* Andreas Mohr <andim2@users.sourceforge.net>
+  - add initial support for new TNETW1450 USB chip (available on the market since
+    June or so): successful firmware booting, driver initialization working up to
+    a working iwconfig. Any network traffic whatsoever NOT working yet.
+    VERY EXPERIMENTAL! (especially since TNETW1450 sometimes uses enhanced,
+    longer structs for some IEs)
+  - add a ton of different TNETW1450 USB device VID/PID combinations; it's
+    highly likely that there will be many more TNETW1450 devices in the future...
+  - add many more firmware command IEs
+  - firmware upload cleanup (rename variables to better names, unify the various
+    firmware upload implementations, ...)
+  - add FIXME comment to remind about semaphore -> mutex conversion
+  The TNETW1450 firmware image is currently called tiacx111usbcRR, with RR being
+  the currently used radio ID 0x1D ("1D"): tiacx111usbc1D.
+
+[20060126] 0.3.31
+* fix bug uncovered by code added in support for firmware 2.3.1.31
+
+[20060124] 0.3.30
+* fix breakage introduced by vda
+* Bas Vermeulen <bvermeul@blackstar.xs4all.nl>:
+  support for firmware 2.3.1.31
+
+[20060117] 0.3.29
+* Andreas Mohr <andim2@users.sourceforge.net>:
+  - fix OOPS in acx_l_rxmonitor() (wrong ndev->type setting leading to memcpy
+    of negative size) by reworking monitor mode type setup and adding
+    missing sanity checks
+  - rename acx1XX_ie_powermgmt_t to more correct acx1XX_ie_powersave_t
+  - fix format string compile warnings
+  - add <linux/compiler.h> include apparently required for __iomem define
+    around Linux 2.6.8
+  - rework eCPU init by replacing static msleep with faster, more intelligent
+    (hopefully) busy-wait
+* acx_s_set_defaults slightly edited
+* ioctls are changed to have correct prototypes
+
+[20060116] 0.3.28
+* Massive global replaces: priv->adev, netdev_priv->ndev2adev etc.
+  Minimal code changes
+
+[20060113]
+* Andreas Mohr <andim2@users.sourceforge.net>:
+  - add recommended cpu_relax() to busy-wait loops
+  - reorder struct wlandevice_t for better(??) cache use
+  - kill superfluous result variable in conv.c
+  - misc. small cleanup
+* SEPARATE_DRIVER_INSTANCES is a 2.4ism, removed
+
+[20060112] 0.3.27
+* Andreas Mohr <andim2@users.sourceforge.net>:
+  - add support for configopt parsing for ACX100 EEPROM version v5
+  - only start another radio recalibration interval every 5 seconds
+    on ACX111 instead of every second
+
+[20060111]
+* drop compatibility cruft for kernels < 2.6.10
+
+[20060109] 0.3.26
+* From Andreas Mohr <andi@rhlx01.fht-esslingen.de>
+  - revert kzalloc change (too early, only Linux 2.6.14+ has support)
+  - add safe limit checks for probe_delay EEPROM values, log more
+    configopt values
+  - some early parts for packet fragmentation support
+    (I already know how to do it, I think, I just need some time
+    to implement it, and I *really* need this feature here with such
+    a BROKEN 3-wall connection here...)
+  - 802.11 power save mode improvements (not usable by mere mortals yet)
+  - switch fw cmd length structs depending on whether acx100 or acx111
+  - fix log message rate limiting (as a benefit code is now faster, too)
+  - unify acx100/acx111 scanning, saving a couple hundred bytes
+  - set Ctl2_8 to 0 which it most likely should be (please report if
+    this breaks anything - but it shouldn't since it's being initialized
+    to 0 on driver init anyway...)
+
+[20060108] 0.3.25
+* fix scanning breakage
+* fix cmd timeout breakage
+* attempt to fix suspend/resume
+
+[20060104] 0.3.24
+* From Andreas Mohr <andim2@users.sourceforge.net>
+  - activated acx100 configoption readout, unified acx100/acx111 parsing
+  - init NULL data template, required for 802.11 power save mode
+  - return actual, valid txpower levels in range ioctl (from configoption!)
+  fix bugs:
+  - fatal bug in 802.11 powersave structs
+  - some missing endianness conversions
+  - check for sane regulatory domain related settings on both SETting and GETting
+  - random optimizations making this much enhanced code *smaller* than the
+    previous version!
+  - optimized struct layout
+  - merge acx100_s_init_packet_templates and acx111_s_init_packet_templates
+  - use kzalloc instead of kmalloc where useful (yes, this driver is Linux 2.6.x
+    only, with x rather large)
+  - avoid some sprintf() and strlen()
+  - add support for new get_wireless_stats handling (...silence deprecation
+    warning!)
+  - add some unlikely()
+  - lower msleep() value in issue_cmd() in order to speed up card initialization
+    time (almost less than 1 second now, on P3/700!). should this lower msleep()
+    value be made init-only??
+  - disable get sensitivity ioctl for USB (unfortunately not working yet)
+  - make sure to call synchronize_irq(), (semi-)required for SMP
+  - group together some closely related functions
+  - misc cleanups/code maintenance
+  So, configoptions are now working for acx100, too, and unified, and
+  802.11 power save mode actually worked for acx100 when I tested it (large
+  delays during ping which indicate that it must be active, but I guess these
+  delays should be much reduced with a properly tuned implementation), but it's
+  not finished and thus not enabled by default.
+
+[20051228]
+* Global s/acxlog/log/
+
+[20051220] 0.3.23
+* timeout handling fixed for high load case
+  (patch by Andreas Mohr)
+
+[20051219] 0.3.22
+* acx100 active scanning must be working now, thanks to Carlos Martin
+  <carlos@cmartin.tk>.
+
+[20051202]
+* acx_s_update_card_settings cosmetic change
+  (but wasn't run tested)
+
+[20051201] 0.3.21
+* Thanks Carlos Martin
+* Completely serialize USB rx. Tiny speed loss,
+  but even more safe wrt reordering.
+* A few msleeps removed
+
+[20051128] 0.3.20
+* we will use only 2 rx usb buffers now. No apparent speed loss,
+  eliminates usb packet reordering risk.
+* two USB fixes for real bugs and one fix for possible leak
+  of an urb on error path. Thanks Carlos Martin <carlosmn@gmail.com>.
+
+[20051116] 0.3.19
+* a few small fixes accumulated over time, nothing spectacular
+
+[20051031] 0.3.18
+* hopefully a final touch on USB tx autorate
+
+[20051022] 0.3.17
+* PCI command submission made simpler
+
+[20051021] 0.3.16
+* Small changes mostly designed to break USB ;)
+* Auto rate handling for USB is still not confirmed to work.
+  I need USB logs from the users.
+
+[20051020] 0.3.15
+* Auto rate handling for USB is implemented. Untested.
+
+[20051019]
+* first step in proper auto rate handling for USB
+
+[20051018] 0.3.14
+* update for 2.6.14-rc4-mm1
+* Kconfig bug (error if ACX=y, ACX_USB=y, USB=m) fixed
+* PARANOID_LOCKING off by default
+
+[20051016] 0.3.13
+* Revert 20051013 fix, we have one which actually works.
+  Thanks Jacek Jablonski <yacek87@gmail.com> for testing!
+
+[20051013]
+* trying to fix "yet another similar bug"
+* usb fix by Carlos Martin
+
+[20051012] 0.3.12
+* acx_l_clean_tx_desc bug fixed - was stopping tx completely
+  at high load. (It seems there exists yet another similar bug!)
+* "unknown IE" dump was 2 bytes too short - fixed
+* DUP logging made less noisy
+* another usb fix by Carlos Martin <carlosmn@gmail.com>
+
+[20051003]
+* several usb fixes by Carlos Martin <carlosmn@gmail.com> - thanks!
+* unknown IE logging made less noisy
+* few unknown IEs added to the growing collection
+* version bump to 0.3.11
+
+[20050916]
+* fix bogus MTU handling, add ability to change MTU
+* fix WLAN_DATA_MAXLEN: 2312 -> 2304
+* version bump to 0.3.10
+
+[20050915]
+* by popular request default mode is 'managed'
+* empty handler for EID 7 (country info) is added
+* fix 'timer not started - iface is not up'
+* tx[host]desc micro optimizations
+* version bump to 0.3.9
+
+[20050914]
+* tx[host]desc ring workings brought a bit back to two-hostdesc
+  scheme. This is an attempt to fix weird WG311v2 bug.
+  I still fail to understand how same chip with same fw can
+  work for me but do not work for a WG311v2 owner. Mystery.
+* README updated
+* version bump to 0.3.8
+
+[20050913]
+* variable and fields with awful names renamed
+* a few fields dropped (they had constant values)
+* small optimization to acx_l_clean_tx_desc()
+* version bump to 0.3.7
+
+[20050912]
+* stop using 16 byte "private area" in txdesc - fw bug makes it unreliable
+* better logging of DUPs
+* version bump to 0.3.6
+
+[20050911]
+* use alloc_netdev/free_netdev/netdev_priv
+* acx_inline.h incorporated into pci.c
+* helper.c + helper2.c = common.c
+* marking static functions
+* enable IE_DOT11_CURRENT_ANTENNA for acx111
+* version bump to 0.3.5
+
+[20050910]
+* minor fixes, 2.6.13-mm2 integration
+
+[20050905]
+* TIWLAN_DC is dead, ui32ACX[TR]xQueueStart is dead
+* massive mucking with PCI and USB resulting in:
+  acx_pci.o + acx_usb.o = acx.o  ;)
+  Why? Here's why:
+    text    data     bss     dec     hex filename
+  116199     452      40  116691   1c7d3 acx.o
+  103435     244      20  103699   19513 acx_pci.o
+   81732     196      32   81960   14028 acx_usb.o
+* helper.c is PCI/USB independent now. It was the last one.
+* both modular and non-modular builds, PCI, USB, PCI+USB,
+  seem to compile successfully!
+* version bump to 0.3.4
+
+[20050904]
+* acx_stop_queue() locking reviewed and mostly fixed
+* 2.4isms in USB code are officially dead
+* added debug stuff for discovering interrogate/configure IEs
+* version bump to 0.3.3
+
+[20050903]
+* locking bug on error path fixed
+* issue_cmd() logging made more sane
+* issue_cmd() callers may abstain from printing issue_cmd() errors:
+  issue_cmd() itself gives enough info
+* version bump to 0.3.2
+
+[20050902]
+* kill bogus configure() call in acx100_s_create_dma_regions()
+
+[20050901]
+* acx100_s_create_dma_regions: hopefully fixed for USB
+  (problem found with help of Carlos Martin <carlosmn@gmail.com> - thanks!)
+* a load of cleanups:
+* acx_s_create_tx_desc_queue -> acx_create_tx_desc_queue
+  (it doesn't sleep)
+* struct acxp80211_nullframe -> acx_template_nullframe
+* xXBUFFERCOUNT_ACXnn -> xXBUFCNT_ACXnn
+* xXBUFFERCOUNT_USB -> USB_xXBUFCNT: these are _unrelated_ to xXBUFCNT_ACXnn,
+  should have visibly different names
+* TODOs added (we have a few really Pascalish/Windowish names,
+  and some misleading ones)
+* version bump to 0.3.1
+
+[20050830]
+* finally kill warning about acx_s_activate_power_save_mode()
+* struct acx100_ie_memconfigoption: convert pRxHostDesc to acx_ptr type
+* massive move of device-independent code from helper.c to helper2.c
+
+[20050829]
+* dummy handler for NONERP EID (47) added
+
+[20050823]
+* driver submitted for kernel inclusion
+* #defines renamed: CONFIG_ACX_{PCI,USB} -> ACX_{PCI,USB}
+  (needed for correct compilation of two modules from the same source)
+* version bump to 0.3.0
+* sizes:
+   text    data     bss     dec     hex filename
+  78242     264       8   78514   132b2 drivers/net/wireless/acx/acx_pci.o
+  60622     208      20   60850    edb2 drivers/net/wireless/acx/acx_usb.o
+
+[20050822]
+* idma.c is incorporated into helper.c
+* lots of cosmetic work: comments, struct member shuffling,
+  etc. TIWLAN_DC and other PCI data structs are #ifdef'ed
+  to be PCI-only. A few todos added. Extra #include's removed.
+* added sem locking debug printout code (for amd64 debug)
+* beacon tx rate and beacon ratevector is updated according to
+  "iwconfig rate" command immediately (required mode change before).
+
+[20050821]
+* Switch to wrapper functions for dealing with "tx buffers"
+  (memory areas where we create packets for tx. For USB, it's just
+  a part of wlandevice_t, for PCI it's a DMAable buffer pointed to
+  by txhostdesc).
+* Completely hide nature of PCI txdescs under opaque pointer type tx_t*
+* acx_l_ether_to_txdesc -> acx_l_ether_to_txbuf, not using knowledge
+  of PCI txdesc anymore.
+* Massive surgery on usb.c, cutting all paths into PCI code.
+* PCI code moved to pci.c - USB don't need these pieces anymore
+* acx111 and acx100 txhostdesc creation unified into single function
+
+[20050816]
+* PCI code switched to single-txdesc scheme
+* version bump to 0.2.5
+
+[20050815]
+* dev_kfree_skb -> dev_kfree_skb_any
+
+[20050814]
+* Auto rate was reset to lowest rate by scanning code
+  (AP beacons did it every tenth of a second!). Fixed.
+* USB rx no longer uses PCI-style rx descriptor ring.
+  tx ring elimination needs 'single-descriptor' setup
+  to be developed for acx100 (patch exists for acx111).
+* Very strange sem locking problems are reported on amd64.
+  Code which misbehaves looks fine. I do not know what's going on.
+  Workaround: turn off preemption.
+
+[20050812]
+* acx100 was failing to find out radio module #,
+  and wanted to load radio module 00. Must be fixed now.
+* USB: more simplifications
+
+[20050810]
+* USB: simplified command submission code, removed some
+  wlandevice_t fields (now unused)
+
+[20050808]
+* USB changes: nuked global statics, simplified issue_cmd,
+  shortened wlandevice_t. Added some TODOs :)
+
+[20050807]
+* restart scan if AP is not found
+* remove use_eth_name parameter. It was deprecated
+* disable legacy firmware loader for 2.6. Driver printed a warning
+  about need to switch to hotplug.
+* WARNING: new names for firmware images!
+  Driver will try to load the following images:
+  PCI driver:
+    'tiacxNNNcMM' (NNN=100/111, MM=radio module ID (in uppercase hex)):
+    combined firmware for specified chipset and radio.
+    failing that, it will try to load images named
+    'tiacxNNN' (NNN=100/111): main firmware for specified chipset
+    and 'tiacxNNNrMM': corresponding radio module.
+    For example, my firmware is in file named 'tiacx111c16'.
+    Alternatively, I may remove it and use pair of files
+    'tiacx111' and 'tiacx111r16' instead.
+  USB driver: loads image named 'tiacx100usb'
+  Hint: you can keep both old and new image names (via symlinks
+  or just by copying files) if you need to run older driver.
+* fix "Debug: sleeping function called from invalid context..." for USB
+* ACX_{PCI,USB} -> CONFIG_ACX_{PCI,USB} in preparation to 2.6 merge
+* version bump to 0.2.4
+
+[20050804]
+* 'Fixed' deadlock on flush_scheduled_work (need a better fix eventually)
+* We didn't completely disable IRQs on ifdown -> "Disabling IRQ#NN"
+  on second modprobe. Fixed.
+
+[20050802]
+* removed some // comments in order to please Andreas
+* moved a field to PCI-only part of wlandevice_t
+* Random Version Bump (tm) to 0.2.3
+* no code changes
+
+[20050730]
+* Basically just incorporating acx-20050722.acx100fixed.patch
+  This is a bit of a backward step, because instead of figuring out
+  why active scanning doesn't work for acx100, we just disable it.
+  acx100 owners encouraged to try to make it work
+
+[20050729]
+* Added some IE IDs
+
+[20050726]
+* added probe request config to acx100_s_init_packet_templates,
+  maybe acx100 is working now
+
+[20050721]
+* del_timer_sync() sem lockup on SMP maybe fixed
+
+[20050720]
+* lots of amd64 warnings fixed, thanks to Matan Peled <chaosite@gmail.com>
+
+[20050710]
+* {tx,rx}hostdesc->desc_phy removed (was not used)
+* netdev->type of ARPHRD_IEEE80211_PRISM was sticking forever
+  after monitor mode. Fixed
+* monitor mode tx is working again
+* rate reporting added in monitor mode packet header
+
+[20050709]
+* moved PCI specific ioctls to pci.c
+* ioctl.c is PCI/USB independent now
+
+[20050708]
+* Fixed one apparent bug (wlandevice_t had different
+  layout for PCI and USB - conv.c would die horribly)
+* Massive code shuffling with only trivial code changes.
+  Mostly sorting out PCI/USB stuff into relevant files.
+* ihw.c eliminated
+* helper2.c is PCI/USB independent now
diff -Nurp linux-2.6.23-sabayon.orig/drivers/net/wireless/acx/common.c linux-2.6.23-sabayon/drivers/net/wireless/acx/common.c
--- linux-2.6.23-sabayon.orig/drivers/net/wireless/acx/common.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.23-sabayon/drivers/net/wireless/acx/common.c	2007-10-10 10:51:23.000000000 +0200
@@ -0,0 +1,4799 @@
+/**** (legal) claimer in README
+** Copyright (C) 2003  ACX100 Open Source Project
+*/
+
+
+/*
+#if LINUX_VERSION_CODE <= KERNEL_VERSION(2, 6, 18)
+#include <linux/config.h>
+#endif
+*/
+#include <linux/version.h>
+#include <linux/module.h>
+#include <linux/kernel.h>
+#include <linux/sched.h>
+#include <linux/types.h>
+#include <linux/slab.h>
+#include <linux/delay.h>
+#include <linux/proc_fs.h>
+#include <linux/if_arp.h>
+#include <linux/rtnetlink.h>
+#include <linux/netdevice.h>
+#include <linux/etherdevice.h>
+#include <linux/wireless.h>
+#include <linux/pm.h>
+#include <linux/vmalloc.h>
+#include <linux/firmware.h>
+//#include <net/iw_handler.h>
+#include <linux/ethtool.h>
+//#include <linux/utsrelease.h>
+
+#include "acx.h"
+
+
+/***********************************************************************
+*/
+
+static void acx_l_rx(acx_device_t * adev, rxbuffer_t * rxbuf);
+
+
+
+/***********************************************************************
+*/
+#if ACX_DEBUG
+unsigned int acx_debug /* will add __read_mostly later */  = ACX_DEFAULT_MSG;
+/* parameter is 'debug', corresponding var is acx_debug */
+module_param_named(debug, acx_debug, uint, 0);
+MODULE_PARM_DESC(debug, "Debug level mask (see L_xxx constants)");
+#endif
+
+#ifdef MODULE_LICENSE
+MODULE_LICENSE("Dual MPL/GPL");
+#endif
+/* USB had this: MODULE_AUTHOR("Martin Wawro <martin.wawro AT uni-dortmund.de>"); */
+MODULE_AUTHOR("ACX100 Open Source Driver development team");
+MODULE_DESCRIPTION
+    ("Driver for TI ACX1xx based wireless cards (CardBus/PCI/USB)");
+
+
+/***********************************************************************
+*/
+/* Probably a number of acx's intermediate buffers for USB transfers,
+** not to be confused with number of descriptors in tx/rx rings
+** (which are not directly accessible to host in USB devices) */
+#define USB_RX_CNT 10
+#define USB_TX_CNT 10
+
+
+/***********************************************************************
+*/
+
+/* minutes to wait until next radio recalibration: */
+#define RECALIB_PAUSE	5
+
+/* Please keep acx_reg_domain_ids_len in sync... */
+const u8 acx_reg_domain_ids[acx_reg_domain_ids_len] =
+    { 0x10, 0x20, 0x30, 0x31, 0x32, 0x40, 0x41, 0x51 };
+static const u16 reg_domain_channel_masks[acx_reg_domain_ids_len] =
+    { 0x07ff, 0x07ff, 0x1fff, 0x0600, 0x1e00, 0x2000, 0x3fff, 0x01fc };
+const char *const
+ acx_reg_domain_strings[] = {
+	/* 0 */ " 1-11 FCC (USA)",
+	/* 1 */ " 1-11 DOC/IC (Canada)",
+/* BTW: WLAN use in ETSI is regulated by ETSI standard EN 300 328-2 V1.1.2 */
+	/* 2 */ " 1-13 ETSI (Europe)",
+	/* 3 */ "10-11 Spain",
+	/* 4 */ "10-13 France",
+	/* 5 */ "   14 MKK (Japan)",
+	/* 6 */ " 1-14 MKK1",
+	/* 7 */ "  3-9 Israel (not all firmware versions)",
+	NULL			/* needs to remain as last entry */
+};
+
+
+
+/***********************************************************************
+** Debugging support
+*/
+#ifdef PARANOID_LOCKING
+static unsigned max_lock_time;
+static unsigned max_sem_time;
+
+/* Obvious or linux kernel specific derived code follows: */
+
+void acx_lock_unhold()
+{
+	max_lock_time = 0;
+}
+
+void acx_sem_unhold()
+{
+	max_sem_time = 0;
+}
+
+static inline const char *sanitize_str(const char *s)
+{
+	const char *t = strrchr(s, '/');
+	if (t)
+		return t + 1;
+	return s;
+}
+
+void acx_lock_debug(acx_device_t * adev, const char *where)
+{
+	unsigned int count = 100 * 1000 * 1000;
+	where = sanitize_str(where);
+	while (--count) {
+		if (!spin_is_locked(&adev->lock))
+			break;
+		cpu_relax();
+	}
+	if (!count) {
+		printk(KERN_EMERG "LOCKUP: already taken at %s!\n",
+		       adev->last_lock);
+		BUG();
+	}
+	adev->last_lock = where;
+	rdtscl(adev->lock_time);
+}
+void acx_unlock_debug(acx_device_t * adev, const char *where)
+{
+#ifdef SMP
+	if (!spin_is_locked(&adev->lock)) {
+		where = sanitize_str(where);
+		printk(KERN_EMERG "STRAY UNLOCK at %s!\n", where);
+		BUG();
+	}
+#endif
+	if (acx_debug & L_LOCK) {
+		unsigned long diff;
+		rdtscl(diff);
+		diff -= adev->lock_time;
+		if (diff > max_lock_time) {
+			where = sanitize_str(where);
+			printk("max lock hold time %ld CPU ticks from %s "
+			       "to %s\n", diff, adev->last_lock, where);
+			max_lock_time = diff;
+		}
+	}
+}
+#endif /* PARANOID_LOCKING */
+
+
+/***********************************************************************
+*/
+#if ACX_DEBUG > 1
+
+static int acx_debug_func_indent;
+#define DEBUG_TSC 0
+#define FUNC_INDENT_INCREMENT 2
+
+#if DEBUG_TSC
+#define TIMESTAMP(d) unsigned long d; rdtscl(d)
+#else
+#define TIMESTAMP(d) unsigned long d = jiffies
+#endif
+
+static const char spaces[] = "          " "          ";	/* Nx10 spaces */
+
+void log_fn_enter(const char *funcname)
+{
+	int indent;
+	TIMESTAMP(d);
+
+	indent = acx_debug_func_indent;
+	if (indent >= sizeof(spaces))
+		indent = sizeof(spaces) - 1;
+
+	printk("%08ld %s==> %s\n",
+	       d % 100000000, spaces + (sizeof(spaces) - 1) - indent, funcname);
+
+	acx_debug_func_indent += FUNC_INDENT_INCREMENT;
+}
+void log_fn_exit(const char *funcname)
+{
+	int indent;
+	TIMESTAMP(d);
+
+	acx_debug_func_indent -= FUNC_INDENT_INCREMENT;
+
+	indent = acx_debug_func_indent;
+	if (indent >= sizeof(spaces))
+		indent = sizeof(spaces) - 1;
+
+	printk("%08ld %s<== %s\n",
+	       d % 100000000, spaces + (sizeof(spaces) - 1) - indent, funcname);
+}
+void log_fn_exit_v(const char *funcname, int v)
+{
+	int indent;
+	TIMESTAMP(d);
+
+	acx_debug_func_indent -= FUNC_INDENT_INCREMENT;
+
+	indent = acx_debug_func_indent;
+	if (indent >= sizeof(spaces))
+		indent = sizeof(spaces) - 1;
+
+	printk("%08ld %s<== %s: %08X\n",
+	       d % 100000000,
+	       spaces + (sizeof(spaces) - 1) - indent, funcname, v);
+}
+#endif /* ACX_DEBUG > 1 */
+
+
+/***********************************************************************
+** Basically a msleep with logging
+*/
+void acx_s_msleep(int ms)
+{
+	FN_ENTER;
+	msleep(ms);
+	FN_EXIT0;
+}
+
+
+/***********************************************************************
+** Not inlined: it's larger than it seems
+*/
+void acx_print_mac(const char *head, const u8 * mac, const char *tail)
+{
+	printk("%s" MACSTR "%s", head, MAC(mac), tail);
+}
+
+
+
+
+/***********************************************************************
+** acx_cmd_status_str
+*/
+const char *acx_cmd_status_str(unsigned int state)
+{
+	static const char *const cmd_error_strings[] = {
+		"Idle",
+		"Success",
+		"Unknown Command",
+		"Invalid Information Element",
+		"Channel rejected",
+		"Channel invalid in current regulatory domain",
+		"MAC invalid",
+		"Command rejected (read-only information element)",
+		"Command rejected",
+		"Already asleep",
+		"TX in progress",
+		"Already awake",
+		"Write only",
+		"RX in progress",
+		"Invalid parameter",
+		"Scan in progress",
+		"Failed"
+	};
+	return state < ARRAY_SIZE(cmd_error_strings) ?
+	    cmd_error_strings[state] : "?";
+}
+
+/***********************************************************************
+*/
+#if ACX_DEBUG
+void acx_dump_bytes(const void *data, int num)
+{
+	const u8 *ptr = (const u8 *)data;
+
+	if (num <= 0) {
+		printk("\n");
+		return;
+	}
+
+	while (num >= 16) {
+		printk("%02X %02X %02X %02X %02X %02X %02X %02X "
+		       "%02X %02X %02X %02X %02X %02X %02X %02X\n",
+		       ptr[0], ptr[1], ptr[2], ptr[3],
+		       ptr[4], ptr[5], ptr[6], ptr[7],
+		       ptr[8], ptr[9], ptr[10], ptr[11],
+		       ptr[12], ptr[13], ptr[14], ptr[15]);
+		num -= 16;
+		ptr += 16;
+	}
+	if (num > 0) {
+		while (--num > 0)
+			printk("%02X ", *ptr++);
+		printk("%02X\n", *ptr);
+	}
+}
+#endif
+
+
+/***********************************************************************
+** acx_s_get_firmware_version
+** 
+** Obvious
+*/
+void acx_s_get_firmware_version(acx_device_t * adev)
+{
+	fw_ver_t fw;
+	u8 hexarr[4] = { 0, 0, 0, 0 };
+	int hexidx = 0, val = 0;
+	const char *num;
+	char c;
+
+	FN_ENTER;
+
+	memset(fw.fw_id, 'E', FW_ID_SIZE);
+	acx_s_interrogate(adev, &fw, ACX1xx_IE_FWREV);
+	memcpy(adev->firmware_version, fw.fw_id, FW_ID_SIZE);
+	adev->firmware_version[FW_ID_SIZE] = '\0';
+
+	log(L_DEBUG, "fw_ver: fw_id='%s' hw_id=%08X\n",
+	    adev->firmware_version, fw.hw_id);
+
+	if (strncmp(fw.fw_id, "Rev ", 4) != 0) {
+		printk("acx: strange firmware version string "
+		       "'%s', please report\n", adev->firmware_version);
+		adev->firmware_numver = 0x01090407;	/* assume 1.9.4.7 */
+	} else {
+		num = &fw.fw_id[4];
+		while (1) {
+			c = *num++;
+			if ((c == '.') || (c == '\0')) {
+				hexarr[hexidx++] = val;
+				if ((hexidx > 3) || (c == '\0'))	/* end? */
+					break;
+				val = 0;
+				continue;
+			}
+			if ((c >= '0') && (c <= '9'))
+				c -= '0';
+			else
+				c = c - 'a' + (char)10;
+			val = val * 16 + c;
+		}
+
+		adev->firmware_numver = (u32) ((hexarr[0] << 24) |
+					       (hexarr[1] << 16)
+					       | (hexarr[2] << 8) | hexarr[3]);
+		log(L_DEBUG, "firmware_numver 0x%08X\n", adev->firmware_numver);
+	}
+	if (IS_ACX111(adev)) {
+		if (adev->firmware_numver == 0x00010011) {
+			/* This one does not survive floodpinging */
+			printk("acx: firmware '%s' is known to be buggy, "
+			       "please upgrade\n", adev->firmware_version);
+		}
+	}
+
+	adev->firmware_id = le32_to_cpu(fw.hw_id);
+
+	/* we're able to find out more detailed chip names now */
+	switch (adev->firmware_id & 0xffff0000) {
+	case 0x01010000:
+	case 0x01020000:
+		adev->chip_name = "TNETW1100A";
+		break;
+	case 0x01030000:
+		adev->chip_name = "TNETW1100B";
+		break;
+	case 0x03000000:
+	case 0x03010000:
+		adev->chip_name = "TNETW1130";
+		break;
+	case 0x04030000:	/* 0x04030101 is TNETW1450 */
+		adev->chip_name = "TNETW1450";
+		break;
+	default:
+		printk("acx: unknown chip ID 0x%08X, "
+		       "please report\n", adev->firmware_id);
+		break;
+	}
+
+	FN_EXIT0;
+}
+
+
+/***********************************************************************
+** acx_display_hardware_details
+**
+** Displays hw/fw version, radio type etc...
+**
+** Obvious
+*/
+void acx_display_hardware_details(acx_device_t * adev)
+{
+	const char *radio_str, *form_str;
+
+	FN_ENTER;
+
+	switch (adev->radio_type) {
+	case RADIO_MAXIM_0D:
+		radio_str = "Maxim";
+		break;
+	case RADIO_RFMD_11:
+		radio_str = "RFMD";
+		break;
+	case RADIO_RALINK_15:
+		radio_str = "Ralink";
+		break;
+	case RADIO_RADIA_16:
+		radio_str = "Radia";
+		break;
+	case RADIO_UNKNOWN_17:
+		/* TI seems to have a radio which is
+		 * additionally 802.11a capable, too */
+		radio_str = "802.11a/b/g radio?! Please report";
+		break;
+	case RADIO_UNKNOWN_19:
+		radio_str = "A radio used by Safecom cards?! Please report";
+		break;
+	case RADIO_UNKNOWN_1B:
+		radio_str = "An unknown radio used by TNETW1450 USB adapters";
+		break;
+	default:
+		radio_str = "UNKNOWN, please report radio type name!";
+		break;
+	}
+
+	switch (adev->form_factor) {
+	case 0x00:
+		form_str = "unspecified";
+		break;
+	case 0x01:
+		form_str = "(mini-)PCI / CardBus";
+		break;
+	case 0x02:
+		form_str = "USB";
+		break;
+	case 0x03:
+		form_str = "Compact Flash";
+		break;
+	default:
+		form_str = "UNKNOWN, please report";
+		break;
+	}
+
+	printk("acx: chipset %s, radio type 0x%02X (%s), "
+	       "form factor 0x%02X (%s), EEPROM version 0x%02X, "
+	       "uploaded firmware '%s''n",
+	       adev->chip_name, adev->radio_type, radio_str,
+	       adev->form_factor, form_str, adev->eeprom_version,
+	       adev->firmware_version);
+
+	FN_EXIT0;
+}
+
+
+/***********************************************************************
+** acx_e_get_stats, acx_e_get_wireless_stats
+*/
+int
+acx_e_get_stats(struct ieee80211_hw *hw,
+		struct ieee80211_low_level_stats *stats)
+{
+	acx_device_t *adev = ieee2adev(hw);
+	unsigned long flags;
+	acx_lock(adev, flags);
+	memcpy(stats, &adev->ieee_stats, sizeof(*stats));
+	acx_unlock(adev, flags);
+	return 0;
+}
+
+
+/***********************************************************************
+** maps acx111 tx descr rate field to acx100 one
+*/
+const u8 acx_bitpos2rate100[] = {
+	RATE100_1,		/* 0 */
+	RATE100_2,		/* 1 */
+	RATE100_5,		/* 2 */
+	RATE100_2,		/* 3, should not happen */
+	RATE100_2,		/* 4, should not happen */
+	RATE100_11,		/* 5 */
+	RATE100_2,		/* 6, should not happen */
+	RATE100_2,		/* 7, should not happen */
+	RATE100_22,		/* 8 */
+	RATE100_2,		/* 9, should not happen */
+	RATE100_2,		/* 10, should not happen */
+	RATE100_2,		/* 11, should not happen */
+	RATE100_2,		/* 12, should not happen */
+	RATE100_2,		/* 13, should not happen */
+	RATE100_2,		/* 14, should not happen */
+	RATE100_2,		/* 15, should not happen */
+};
+
+u8 acx_rate111to100(u16 r)
+{
+	return acx_bitpos2rate100[highest_bit(r)];
+}
+
+
+/***********************************************************************
+** Calculate level like the feb 2003 windows driver seems to do
+*/
+static u8 acx_signal_to_winlevel(u8 rawlevel)
+{
+	/* u8 winlevel = (u8) (0.5 + 0.625 * rawlevel); */
+	u8 winlevel = ((4 + (rawlevel * 5)) / 8);
+
+	if (winlevel > 100)
+		winlevel = 100;
+	return winlevel;
+}
+
+u8 acx_signal_determine_quality(u8 signal, u8 noise)
+{
+	int qual;
+
+	qual = (((signal - 30) * 100 / 70) + (100 - noise * 4)) / 2;
+
+	if (qual > 100)
+		return 100;
+	if (qual < 0)
+		return 0;
+	return qual;
+}
+
+
+/***********************************************************************
+** Interrogate/configure commands
+*/
+
+/* FIXME: the lengths given here probably aren't always correct.
+ * They should be gradually replaced by proper "sizeof(acx1XX_ie_XXXX)-4",
+ * unless the firmware actually expects a different length than the struct length */
+static const u16 acx100_ie_len[] = {
+	0,
+	ACX100_IE_ACX_TIMER_LEN,
+	sizeof(acx100_ie_powersave_t) - 4,	/* is that 6 or 8??? */
+	ACX1xx_IE_QUEUE_CONFIG_LEN,
+	ACX100_IE_BLOCK_SIZE_LEN,
+	ACX1xx_IE_MEMORY_CONFIG_OPTIONS_LEN,
+	ACX1xx_IE_RATE_FALLBACK_LEN,
+	ACX100_IE_WEP_OPTIONS_LEN,
+	ACX1xx_IE_MEMORY_MAP_LEN,	/*    ACX1xx_IE_SSID_LEN, */
+	0,
+	ACX1xx_IE_ASSOC_ID_LEN,
+	0,
+	ACX111_IE_CONFIG_OPTIONS_LEN,
+	ACX1xx_IE_FWREV_LEN,
+	ACX1xx_IE_FCS_ERROR_COUNT_LEN,
+	ACX1xx_IE_MEDIUM_USAGE_LEN,
+	ACX1xx_IE_RXCONFIG_LEN,
+	0,
+	0,
+	sizeof(fw_stats_t) - 4,
+	0,
+	ACX1xx_IE_FEATURE_CONFIG_LEN,
+	ACX111_IE_KEY_CHOOSE_LEN,
+	ACX1FF_IE_MISC_CONFIG_TABLE_LEN,
+	ACX1FF_IE_WONE_CONFIG_LEN,
+	0,
+	ACX1FF_IE_TID_CONFIG_LEN,
+	0,
+	0,
+	0,
+	ACX1FF_IE_CALIB_ASSESSMENT_LEN,
+	ACX1FF_IE_BEACON_FILTER_OPTIONS_LEN,
+	ACX1FF_IE_LOW_RSSI_THRESH_OPT_LEN,
+	ACX1FF_IE_NOISE_HISTOGRAM_RESULTS_LEN,
+	0,
+	ACX1FF_IE_PACKET_DETECT_THRESH_LEN,
+	ACX1FF_IE_TX_CONFIG_OPTIONS_LEN,
+	ACX1FF_IE_CCA_THRESHOLD_LEN,
+	ACX1FF_IE_EVENT_MASK_LEN,
+	ACX1FF_IE_DTIM_PERIOD_LEN,
+	0,
+	ACX1FF_IE_ACI_CONFIG_SET_LEN,
+	0,
+	0,
+	0,
+	0,
+	0,
+	0,
+	ACX1FF_IE_EEPROM_VER_LEN,
+};
+
+static const u16 acx100_ie_len_dot11[] = {
+	0,
+	ACX1xx_IE_DOT11_STATION_ID_LEN,
+	0,
+	ACX100_IE_DOT11_BEACON_PERIOD_LEN,
+	ACX1xx_IE_DOT11_DTIM_PERIOD_LEN,
+	ACX1xx_IE_DOT11_SHORT_RETRY_LIMIT_LEN,
+	ACX1xx_IE_DOT11_LONG_RETRY_LIMIT_LEN,
+	ACX100_IE_DOT11_WEP_DEFAULT_KEY_WRITE_LEN,
+	ACX1xx_IE_DOT11_MAX_XMIT_MSDU_LIFETIME_LEN,
+	0,
+	ACX1xx_IE_DOT11_CURRENT_REG_DOMAIN_LEN,
+	ACX1xx_IE_DOT11_CURRENT_ANTENNA_LEN,
+	0,
+	ACX1xx_IE_DOT11_TX_POWER_LEVEL_LEN,
+	ACX1xx_IE_DOT11_CURRENT_CCA_MODE_LEN,
+	ACX100_IE_DOT11_ED_THRESHOLD_LEN,
+	ACX1xx_IE_DOT11_WEP_DEFAULT_KEY_SET_LEN,
+	0,
+	0,
+	0,
+};
+
+static const u16 acx111_ie_len[] = {
+	0,
+	ACX100_IE_ACX_TIMER_LEN,
+	sizeof(acx111_ie_powersave_t) - 4,
+	ACX1xx_IE_QUEUE_CONFIG_LEN,
+	ACX100_IE_BLOCK_SIZE_LEN,
+	ACX1xx_IE_MEMORY_CONFIG_OPTIONS_LEN,
+	ACX1xx_IE_RATE_FALLBACK_LEN,
+	ACX100_IE_WEP_OPTIONS_LEN,
+	ACX1xx_IE_MEMORY_MAP_LEN,	/*    ACX1xx_IE_SSID_LEN, */
+	0,
+	ACX1xx_IE_ASSOC_ID_LEN,
+	0,
+	ACX111_IE_CONFIG_OPTIONS_LEN,
+	ACX1xx_IE_FWREV_LEN,
+	ACX1xx_IE_FCS_ERROR_COUNT_LEN,
+	ACX1xx_IE_MEDIUM_USAGE_LEN,
+	ACX1xx_IE_RXCONFIG_LEN,
+	0,
+	0,
+	sizeof(fw_stats_t) - 4,
+	0,
+	ACX1xx_IE_FEATURE_CONFIG_LEN,
+	ACX111_IE_KEY_CHOOSE_LEN,
+	ACX1FF_IE_MISC_CONFIG_TABLE_LEN,
+	ACX1FF_IE_WONE_CONFIG_LEN,
+	0,
+	ACX1FF_IE_TID_CONFIG_LEN,
+	0,
+	0,
+	0,
+	ACX1FF_IE_CALIB_ASSESSMENT_LEN,
+	ACX1FF_IE_BEACON_FILTER_OPTIONS_LEN,
+	ACX1FF_IE_LOW_RSSI_THRESH_OPT_LEN,
+	ACX1FF_IE_NOISE_HISTOGRAM_RESULTS_LEN,
+	0,
+	ACX1FF_IE_PACKET_DETECT_THRESH_LEN,
+	ACX1FF_IE_TX_CONFIG_OPTIONS_LEN,
+	ACX1FF_IE_CCA_THRESHOLD_LEN,
+	ACX1FF_IE_EVENT_MASK_LEN,
+	ACX1FF_IE_DTIM_PERIOD_LEN,
+	0,
+	ACX1FF_IE_ACI_CONFIG_SET_LEN,
+	0,
+	0,
+	0,
+	0,
+	0,
+	0,
+	ACX1FF_IE_EEPROM_VER_LEN,
+};
+
+static const u16 acx111_ie_len_dot11[] = {
+	0,
+	ACX1xx_IE_DOT11_STATION_ID_LEN,
+	0,
+	ACX100_IE_DOT11_BEACON_PERIOD_LEN,
+	ACX1xx_IE_DOT11_DTIM_PERIOD_LEN,
+	ACX1xx_IE_DOT11_SHORT_RETRY_LIMIT_LEN,
+	ACX1xx_IE_DOT11_LONG_RETRY_LIMIT_LEN,
+	ACX100_IE_DOT11_WEP_DEFAULT_KEY_WRITE_LEN,
+	ACX1xx_IE_DOT11_MAX_XMIT_MSDU_LIFETIME_LEN,
+	0,
+	ACX1xx_IE_DOT11_CURRENT_REG_DOMAIN_LEN,
+	ACX1xx_IE_DOT11_CURRENT_ANTENNA_LEN,
+	0,
+	ACX1xx_IE_DOT11_TX_POWER_LEVEL_LEN,
+	ACX1xx_IE_DOT11_CURRENT_CCA_MODE_LEN,
+	ACX100_IE_DOT11_ED_THRESHOLD_LEN,
+	ACX1xx_IE_DOT11_WEP_DEFAULT_KEY_SET_LEN,
+	0,
+	0,
+	0,
+};
+
+
+#undef FUNC
+#define FUNC "configure"
+#if !ACX_DEBUG
+int acx_s_configure(acx_device_t * adev, void *pdr, int type)
+{
+#else
+int
+acx_s_configure_debug(acx_device_t * adev, void *pdr, int type,
+		      const char *typestr)
+{
+#endif
+	u16 len;
+	int res;
+
+	if (type < 0x1000)
+		len = adev->ie_len[type];
+	else
+		len = adev->ie_len_dot11[type - 0x1000];
+
+	log(L_CTL, FUNC "(type:%s,len:%u)\n", typestr, len);
+	if (unlikely(!len)) {
+		log(L_DEBUG, "zero-length type %s?!\n", typestr);
+	}
+
+	((acx_ie_generic_t *) pdr)->type = cpu_to_le16(type);
+	((acx_ie_generic_t *) pdr)->len = cpu_to_le16(len);
+	res = acx_s_issue_cmd(adev, ACX1xx_CMD_CONFIGURE, pdr, len + 4);
+	if (unlikely(OK != res)) {
+#if ACX_DEBUG
+		printk("%s: " FUNC "(type:%s) FAILED\n", wiphy_name(adev->ieee->wiphy),
+		       typestr);
+#else
+		printk("%s: " FUNC "(type:0x%X) FAILED\n", wiphy_name(adev->ieee->wiphy),
+		       type);
+#endif
+		/* dump_stack() is already done in issue_cmd() */
+	}
+	return res;
+}
+
+#undef FUNC
+#define FUNC "interrogate"
+#if !ACX_DEBUG
+int acx_s_interrogate(acx_device_t * adev, void *pdr, int type)
+{
+#else
+int
+acx_s_interrogate_debug(acx_device_t * adev, void *pdr, int type,
+			const char *typestr)
+{
+#endif
+	u16 len;
+	int res;
+
+	/* FIXME: no check whether this exceeds the array yet.
+	 * We should probably remember the number of entries... */
+	if (type < 0x1000)
+		len = adev->ie_len[type];
+	else
+		len = adev->ie_len_dot11[type - 0x1000];
+
+	log(L_CTL, FUNC "(type:%s,len:%u)\n", typestr, len);
+
+	((acx_ie_generic_t *) pdr)->type = cpu_to_le16(type);
+	((acx_ie_generic_t *) pdr)->len = cpu_to_le16(len);
+	res = acx_s_issue_cmd(adev, ACX1xx_CMD_INTERROGATE, pdr, len + 4);
+	if (unlikely(OK != res)) {
+#if ACX_DEBUG
+		printk("%s: " FUNC "(type:%s) FAILED\n", wiphy_name(adev->ieee->wiphy),
+		       typestr);
+#else
+		printk("%s: " FUNC "(type:0x%X) FAILED\n", wiphy_name(adev->ieee->wiphy),
+		       type);
+#endif
+		/* dump_stack() is already done in issue_cmd() */
+	}
+	return res;
+}
+
+#if CMD_DISCOVERY
+void great_inquisitor(acx_device_t * adev)
+{
+	static struct {
+		u16 type;
+		u16 len;
+		/* 0x200 was too large here: */
+		u8 data[0x100 - 4];
+	} ACX_PACKED ie;
+	u16 type;
+
+	FN_ENTER;
+
+	/* 0..0x20, 0x1000..0x1020 */
+	for (type = 0; type <= 0x1020; type++) {
+		if (type == 0x21)
+			type = 0x1000;
+		ie.type = cpu_to_le16(type);
+		ie.len = cpu_to_le16(sizeof(ie) - 4);
+		acx_s_issue_cmd(adev, ACX1xx_CMD_INTERROGATE, &ie, sizeof(ie));
+	}
+	FN_EXIT0;
+}
+#endif
+
+
+#ifdef CONFIG_PROC_FS
+/***********************************************************************
+** /proc files
+*/
+/***********************************************************************
+** acx_l_proc_output
+** Generate content for our /proc entry
+**
+** Arguments:
+**	buf is a pointer to write output to
+**	adev is the usual pointer to our private struct acx_device
+** Returns:
+**	number of bytes actually written to buf
+** Side effects:
+**	none
+*/
+static int acx_l_proc_output(char *buf, acx_device_t * adev)
+{
+	char *p = buf;
+
+	FN_ENTER;
+
+	p += sprintf(p,
+		     "acx driver version:\t\t" ACX_RELEASE "\n"
+		     "Wireless extension version:\t" STRING(WIRELESS_EXT) "\n"
+		     "chip name:\t\t\t%s (0x%08X)\n"
+		     "radio type:\t\t\t0x%02X\n"
+		     "form factor:\t\t\t0x%02X\n"
+		     "EEPROM version:\t\t\t0x%02X\n"
+		     "firmware version:\t\t%s (0x%08X)\n",
+		     adev->chip_name, adev->firmware_id,
+		     adev->radio_type,
+		     adev->form_factor,
+		     adev->eeprom_version,
+		     adev->firmware_version, adev->firmware_numver);
+
+	FN_EXIT1(p - buf);
+	return p - buf;
+}
+
+
+/***********************************************************************
+*/
+static int acx_s_proc_diag_output(char *buf, acx_device_t * adev)
+{
+	char *p = buf;
+	unsigned long flags;
+	unsigned int len = 0, partlen;
+	u32 temp1, temp2;
+	u8 *st, *st_end;
+#ifdef __BIG_ENDIAN
+	u8 *st2;
+#endif
+	fw_stats_t *fw_stats;
+	char *part_str = NULL;
+	fw_stats_tx_t *tx = NULL;
+	fw_stats_rx_t *rx = NULL;
+	fw_stats_dma_t *dma = NULL;
+	fw_stats_irq_t *irq = NULL;
+	fw_stats_wep_t *wep = NULL;
+	fw_stats_pwr_t *pwr = NULL;
+	fw_stats_mic_t *mic = NULL;
+	fw_stats_aes_t *aes = NULL;
+	fw_stats_event_t *evt = NULL;
+
+	FN_ENTER;
+
+	acx_lock(adev, flags);
+
+	if (IS_PCI(adev))
+		p = acxpci_s_proc_diag_output(p, adev);
+
+	p += sprintf(p,
+		     "\n"
+		     "** network status **\n"
+		     "dev_state_mask 0x%04X\n"
+		     "mode %u, channel %u, "
+		     "reg_dom_id 0x%02X, reg_dom_chanmask 0x%04X, ",
+		     adev->dev_state_mask,
+		     adev->mode, adev->channel,
+		     adev->reg_dom_id, adev->reg_dom_chanmask);
+	p += sprintf(p,
+		     "ESSID \"%s\", essid_active %d, essid_len %d, "
+		     "essid_for_assoc \"%s\", nick \"%s\"\n"
+		     "WEP ena %d, restricted %d, idx %d\n",
+		     adev->essid, adev->essid_active, (int)adev->essid_len,
+		     adev->essid_for_assoc, adev->nick,
+		     adev->wep_enabled, adev->wep_restricted,
+		     adev->wep_current_index);
+	p += sprintf(p, "dev_addr  " MACSTR "\n", MAC(adev->dev_addr));
+	p += sprintf(p, "bssid     " MACSTR "\n", MAC(adev->bssid));
+	p += sprintf(p, "ap_filter " MACSTR "\n", MAC(adev->ap));
+
+	p += sprintf(p, "\n" "** PHY status **\n" 
+		     "tx_disabled %d, tx_level_dbm %d\n"	/* "tx_level_val %d, tx_level_auto %d\n" */
+		     "sensitivity %d, antenna 0x%02X, ed_threshold %d, cca %d, preamble_mode %d\n"
+		     "rate_basic 0x%04X, rate_oper 0x%04X\n" 
+		     "rts_threshold %d, frag_threshold %d, short_retry %d, long_retry %d\n" 
+		     "msdu_lifetime %d, listen_interval %d, beacon_interval %d\n", 
+		     adev->tx_disabled, adev->tx_level_dbm,	/* adev->tx_level_val, adev->tx_level_auto, */
+		     adev->sensitivity, adev->antenna, adev->ed_threshold,
+		     adev->cca, adev->preamble_mode, adev->rate_basic, adev->rate_oper, adev->rts_threshold,
+		     adev->frag_threshold, adev->short_retry, adev->long_retry,
+		     adev->msdu_lifetime, adev->listen_interval,
+		     adev->beacon_interval);
+
+	acx_unlock(adev, flags);
+
+	p += sprintf(p,
+		     "\n"
+		     "** Firmware **\n"
+		     "NOTE: version dependent statistics layout, "
+		     "please report if you suspect wrong parsing!\n"
+		     "\n" "version \"%s\"\n", adev->firmware_version);
+
+	/* TODO: may replace kmalloc/memset with kzalloc once
+	 * Linux 2.6.14 is widespread */
+	fw_stats = kmalloc(sizeof(*fw_stats), GFP_KERNEL);
+	if (!fw_stats) {
+		FN_EXIT1(0);
+		return 0;
+	}
+	memset(fw_stats, 0, sizeof(*fw_stats));
+
+	st = (u8 *) fw_stats;
+
+	part_str = "statistics query command";
+
+	if (OK != acx_s_interrogate(adev, st, ACX1xx_IE_FIRMWARE_STATISTICS))
+		goto fw_stats_end;
+
+	st += sizeof(u16);
+	len = *(u16 *) st;
+
+	if (len > sizeof(*fw_stats)) {
+		p += sprintf(p,
+			     "firmware version with bigger fw_stats struct detected\n"
+			     "(%u vs. %u), please report\n", len,
+			     sizeof(fw_stats_t));
+		if (len > sizeof(*fw_stats)) {
+			p += sprintf(p, "struct size exceeded allocation!\n");
+			len = sizeof(*fw_stats);
+		}
+	}
+	st += sizeof(u16);
+	st_end = st - 2 * sizeof(u16) + len;
+
+#ifdef __BIG_ENDIAN
+	/* let's make one bold assumption here:
+	 * (hopefully!) *all* statistics fields are u32 only,
+	 * thus if we need to make endianness corrections
+	 * we can simply do them in one go, in advance */
+	st2 = (u8 *) fw_stats;
+	for (temp1 = 0; temp1 < len; temp1 += 4, st2 += 4)
+		*(u32 *) st2 = le32_to_cpu(*(u32 *) st2);
+#endif
+
+	part_str = "Rx/Tx";
+
+	/* directly at end of a struct part? --> no error! */
+	if (st == st_end)
+		goto fw_stats_end;
+
+	tx = (fw_stats_tx_t *) st;
+	st += sizeof(fw_stats_tx_t);
+	rx = (fw_stats_rx_t *) st;
+	st += sizeof(fw_stats_rx_t);
+	partlen = sizeof(fw_stats_tx_t) + sizeof(fw_stats_rx_t);
+
+	if (IS_ACX100(adev)) {
+		/* at least ACX100 PCI F/W 1.9.8.b
+		 * and ACX100 USB F/W 1.0.7-USB
+		 * don't have those two fields... */
+		st -= 2 * sizeof(u32);
+
+		/* our parsing doesn't quite match this firmware yet,
+		 * log failure */
+		if (st > st_end)
+			goto fw_stats_fail;
+		temp1 = temp2 = 999999999;
+	} else {
+		if (st > st_end)
+			goto fw_stats_fail;
+		temp1 = rx->rx_aci_events;
+		temp2 = rx->rx_aci_resets;
+	}
+
+	p += sprintf(p,
+		     "%s:\n"
+		     "  tx_desc_overfl %u\n"
+		     "  rx_OutOfMem %u, rx_hdr_overfl %u, rx_hw_stuck %u\n"
+		     "  rx_dropped_frame %u, rx_frame_ptr_err %u, rx_xfr_hint_trig %u\n"
+		     "  rx_aci_events %u, rx_aci_resets %u\n",
+		     part_str,
+		     tx->tx_desc_of,
+		     rx->rx_oom,
+		     rx->rx_hdr_of,
+		     rx->rx_hw_stuck,
+		     rx->rx_dropped_frame,
+		     rx->rx_frame_ptr_err, rx->rx_xfr_hint_trig, temp1, temp2);
+
+	part_str = "DMA";
+
+	if (st == st_end)
+		goto fw_stats_end;
+
+	dma = (fw_stats_dma_t *) st;
+	partlen = sizeof(fw_stats_dma_t);
+	st += partlen;
+
+	if (st > st_end)
+		goto fw_stats_fail;
+
+	p += sprintf(p,
+		     "%s:\n"
+		     "  rx_dma_req %u, rx_dma_err %u, tx_dma_req %u, tx_dma_err %u\n",
+		     part_str,
+		     dma->rx_dma_req,
+		     dma->rx_dma_err, dma->tx_dma_req, dma->tx_dma_err);
+
+	part_str = "IRQ";
+
+	if (st == st_end)
+		goto fw_stats_end;
+
+	irq = (fw_stats_irq_t *) st;
+	partlen = sizeof(fw_stats_irq_t);
+	st += partlen;
+
+	if (st > st_end)
+		goto fw_stats_fail;
+
+	p += sprintf(p,
+		     "%s:\n"
+		     "  cmd_cplt %u, fiq %u\n"
+		     "  rx_hdrs %u, rx_cmplt %u, rx_mem_overfl %u, rx_rdys %u\n"
+		     "  irqs %u, tx_procs %u, decrypt_done %u\n"
+		     "  dma_0_done %u, dma_1_done %u, tx_exch_complet %u\n"
+		     "  commands %u, rx_procs %u, hw_pm_mode_changes %u\n"
+		     "  host_acks %u, pci_pm %u, acm_wakeups %u\n",
+		     part_str,
+		     irq->cmd_cplt,
+		     irq->fiq,
+		     irq->rx_hdrs,
+		     irq->rx_cmplt,
+		     irq->rx_mem_of,
+		     irq->rx_rdys,
+		     irq->irqs,
+		     irq->tx_procs,
+		     irq->decrypt_done,
+		     irq->dma_0_done,
+		     irq->dma_1_done,
+		     irq->tx_exch_complet,
+		     irq->commands,
+		     irq->rx_procs,
+		     irq->hw_pm_mode_changes,
+		     irq->host_acks, irq->pci_pm, irq->acm_wakeups);
+
+	part_str = "WEP";
+
+	if (st == st_end)
+		goto fw_stats_end;
+
+	wep = (fw_stats_wep_t *) st;
+	partlen = sizeof(fw_stats_wep_t);
+	st += partlen;
+
+	if ((IS_PCI(adev) && IS_ACX100(adev))
+	    || (IS_USB(adev) && IS_ACX100(adev))
+	    ) {
+		/* at least ACX100 PCI F/W 1.9.8.b
+		 * and ACX100 USB F/W 1.0.7-USB
+		 * don't have those two fields... */
+		st -= 2 * sizeof(u32);
+		if (st > st_end)
+			goto fw_stats_fail;
+		temp1 = temp2 = 999999999;
+	} else {
+		if (st > st_end)
+			goto fw_stats_fail;
+		temp1 = wep->wep_pkt_decrypt;
+		temp2 = wep->wep_decrypt_irqs;
+	}
+
+	p += sprintf(p,
+		     "%s:\n"
+		     "  wep_key_count %u, wep_default_key_count %u, dot11_def_key_mib %u\n"
+		     "  wep_key_not_found %u, wep_decrypt_fail %u\n"
+		     "  wep_pkt_decrypt %u, wep_decrypt_irqs %u\n",
+		     part_str,
+		     wep->wep_key_count,
+		     wep->wep_default_key_count,
+		     wep->dot11_def_key_mib,
+		     wep->wep_key_not_found,
+		     wep->wep_decrypt_fail, temp1, temp2);
+
+	part_str = "power";
+
+	if (st == st_end)
+		goto fw_stats_end;
+
+	pwr = (fw_stats_pwr_t *) st;
+	partlen = sizeof(fw_stats_pwr_t);
+	st += partlen;
+
+	if (st > st_end)
+		goto fw_stats_fail;
+
+	p += sprintf(p,
+		     "%s:\n"
+		     "  tx_start_ctr %u, no_ps_tx_too_short %u\n"
+		     "  rx_start_ctr %u, no_ps_rx_too_short %u\n"
+		     "  lppd_started %u\n"
+		     "  no_lppd_too_noisy %u, no_lppd_too_short %u, no_lppd_matching_frame %u\n",
+		     part_str,
+		     pwr->tx_start_ctr,
+		     pwr->no_ps_tx_too_short,
+		     pwr->rx_start_ctr,
+		     pwr->no_ps_rx_too_short,
+		     pwr->lppd_started,
+		     pwr->no_lppd_too_noisy,
+		     pwr->no_lppd_too_short, pwr->no_lppd_matching_frame);
+
+	part_str = "MIC";
+
+	if (st == st_end)
+		goto fw_stats_end;
+
+	mic = (fw_stats_mic_t *) st;
+	partlen = sizeof(fw_stats_mic_t);
+	st += partlen;
+
+	if (st > st_end)
+		goto fw_stats_fail;
+
+	p += sprintf(p,
+		     "%s:\n"
+		     "  mic_rx_pkts %u, mic_calc_fail %u\n",
+		     part_str, mic->mic_rx_pkts, mic->mic_calc_fail);
+
+	part_str = "AES";
+
+	if (st == st_end)
+		goto fw_stats_end;
+
+	aes = (fw_stats_aes_t *) st;
+	partlen = sizeof(fw_stats_aes_t);
+	st += partlen;
+
+	if (st > st_end)
+		goto fw_stats_fail;
+
+	p += sprintf(p,
+		     "%s:\n"
+		     "  aes_enc_fail %u, aes_dec_fail %u\n"
+		     "  aes_enc_pkts %u, aes_dec_pkts %u\n"
+		     "  aes_enc_irq %u, aes_dec_irq %u\n",
+		     part_str,
+		     aes->aes_enc_fail,
+		     aes->aes_dec_fail,
+		     aes->aes_enc_pkts,
+		     aes->aes_dec_pkts, aes->aes_enc_irq, aes->aes_dec_irq);
+
+	part_str = "event";
+
+	if (st == st_end)
+		goto fw_stats_end;
+
+	evt = (fw_stats_event_t *) st;
+	partlen = sizeof(fw_stats_event_t);
+	st += partlen;
+
+	if (st > st_end)
+		goto fw_stats_fail;
+
+	p += sprintf(p,
+		     "%s:\n"
+		     "  heartbeat %u, calibration %u\n"
+		     "  rx_mismatch %u, rx_mem_empty %u, rx_pool %u\n"
+		     "  oom_late %u\n"
+		     "  phy_tx_err %u, tx_stuck %u\n",
+		     part_str,
+		     evt->heartbeat,
+		     evt->calibration,
+		     evt->rx_mismatch,
+		     evt->rx_mem_empty,
+		     evt->rx_pool,
+		     evt->oom_late, evt->phy_tx_err, evt->tx_stuck);
+
+	if (st < st_end)
+		goto fw_stats_bigger;
+
+	goto fw_stats_end;
+
+      fw_stats_fail:
+	st -= partlen;
+	p += sprintf(p,
+		     "failed at %s part (size %u), offset %u (struct size %u), "
+		     "please report\n", part_str, partlen,
+		     (int)((void *)st - (void *)fw_stats), len);
+
+      fw_stats_bigger:
+	for (; st < st_end; st += 4)
+		p += sprintf(p,
+			     "UNKN%3d: %u\n",
+			     (int)((void *)st - (void *)fw_stats), *(u32 *) st);
+
+      fw_stats_end:
+	kfree(fw_stats);
+
+	FN_EXIT1(p - buf);
+	return p - buf;
+}
+
+
+/***********************************************************************
+*/
+static int acx_s_proc_phy_output(char *buf, acx_device_t * adev)
+{
+	char *p = buf;
+	int i;
+
+	FN_ENTER;
+
+	/*
+	   if (RADIO_RFMD_11 != adev->radio_type) {
+	   printk("sorry, not yet adapted for radio types "
+	   "other than RFMD, please verify "
+	   "PHY size etc. first!\n");
+	   goto end;
+	   }
+	 */
+
+	/* The PHY area is only 0x80 bytes long; further pages after that
+	 * only have some page number registers with altered value,
+	 * all other registers remain the same. */
+	for (i = 0; i < 0x80; i++) {
+		acx_s_read_phy_reg(adev, i, p++);
+	}
+
+	FN_EXIT1(p - buf);
+	return p - buf;
+}
+
+
+/***********************************************************************
+** acx_e_read_proc_XXXX
+** Handle our /proc entry
+**
+** Arguments:
+**	standard kernel read_proc interface
+** Returns:
+**	number of bytes written to buf
+** Side effects:
+**	none
+*/
+static int
+acx_e_read_proc(char *buf, char **start, off_t offset, int count,
+		int *eof, void *data)
+{
+	acx_device_t *adev = (acx_device_t *) data;
+	unsigned long flags;
+	int length;
+
+	FN_ENTER;
+
+	acx_sem_lock(adev);
+	acx_lock(adev, flags);
+	/* fill buf */
+	length = acx_l_proc_output(buf, adev);
+	acx_unlock(adev, flags);
+	acx_sem_unlock(adev);
+
+	/* housekeeping */
+	if (length <= offset + count)
+		*eof = 1;
+	*start = buf + offset;
+	length -= offset;
+	if (length > count)
+		length = count;
+	if (length < 0)
+		length = 0;
+	FN_EXIT1(length);
+	return length;
+}
+
+static int
+acx_e_read_proc_diag(char *buf, char **start, off_t offset, int count,
+		     int *eof, void *data)
+{
+	acx_device_t *adev = (acx_device_t *) data;
+	int length;
+
+	FN_ENTER;
+
+	acx_sem_lock(adev);
+	/* fill buf */
+	length = acx_s_proc_diag_output(buf, adev);
+	acx_sem_unlock(adev);
+
+	/* housekeeping */
+	if (length <= offset + count)
+		*eof = 1;
+	*start = buf + offset;
+	length -= offset;
+	if (length > count)
+		length = count;
+	if (length < 0)
+		length = 0;
+	FN_EXIT1(length);
+	return length;
+}
+
+static int
+acx_e_read_proc_eeprom(char *buf, char **start, off_t offset, int count,
+		       int *eof, void *data)
+{
+	acx_device_t *adev = (acx_device_t *) data;
+	int length;
+
+	FN_ENTER;
+
+	/* fill buf */
+	length = 0;
+	if (IS_PCI(adev)) {
+		acx_sem_lock(adev);
+		length = acxpci_proc_eeprom_output(buf, adev);
+		acx_sem_unlock(adev);
+	}
+
+	/* housekeeping */
+	if (length <= offset + count)
+		*eof = 1;
+	*start = buf + offset;
+	length -= offset;
+	if (length > count)
+		length = count;
+	if (length < 0)
+		length = 0;
+	FN_EXIT1(length);
+	return length;
+}
+
+static int
+acx_e_read_proc_phy(char *buf, char **start, off_t offset, int count,
+		    int *eof, void *data)
+{
+	acx_device_t *adev = (acx_device_t *) data;
+	int length;
+
+	FN_ENTER;
+
+	acx_sem_lock(adev);
+	/* fill buf */
+	length = acx_s_proc_phy_output(buf, adev);
+	acx_sem_unlock(adev);
+
+	/* housekeeping */
+	if (length <= offset + count)
+		*eof = 1;
+	*start = buf + offset;
+	length -= offset;
+	if (length > count)
+		length = count;
+	if (length < 0)
+		length = 0;
+	FN_EXIT1(length);
+	return length;
+}
+
+
+/***********************************************************************
+** /proc files registration
+*/
+static const char *const
+ proc_files[] = { "", "_diag", "_eeprom", "_phy" };
+
+static read_proc_t *const
+ proc_funcs[] = {
+	acx_e_read_proc,
+	acx_e_read_proc_diag,
+	acx_e_read_proc_eeprom,
+	acx_e_read_proc_phy
+};
+
+static int manage_proc_entries(struct ieee80211_hw *hw, int remove)
+{
+	acx_device_t *adev = ieee2adev(hw);
+	char procbuf[80];
+	int i;
+
+	for (i = 0; i < ARRAY_SIZE(proc_files); i++) {
+		snprintf(procbuf, sizeof(procbuf),
+			 "driver/acx_%s", proc_files[i]);
+		log(L_INIT, "%sing /proc entry %s\n",
+		    remove ? "remov" : "creat", procbuf);
+		if (!remove) {
+			if (!create_proc_read_entry
+			    (procbuf, 0, NULL, proc_funcs[i], adev)) {
+				printk("acx: cannot register /proc entry %s\n",
+				       procbuf);
+				return NOT_OK;
+			}
+		} else {
+			remove_proc_entry(procbuf, NULL);
+		}
+	}
+	return OK;
+}
+
+int acx_proc_register_entries(struct ieee80211_hw *ieee)
+{
+	return manage_proc_entries(ieee, 0);
+}
+
+int acx_proc_unregister_entries(struct ieee80211_hw *ieee)
+{
+	return manage_proc_entries(ieee, 1);
+}
+#endif /* CONFIG_PROC_FS */
+
+/****
+** Gathered From rt2x00 and bcm43xx_mac80211 projects
+**/
+void acx_free_modes(acx_device_t * adev)
+{
+
+//        kfree(adev->modes);
+//        adev->modes = NULL;
+}
+
+#define RATETAB_ENT(_rate, _rateid, _flags) \
+	{							\
+		.rate	= (_rate),				\
+		.val	= (_rateid),				\
+		.val2   = (_rateid),				\
+		.flags  = (_flags),				\
+	}
+
+
+static struct ieee80211_rate __acx_ratetable[] = {
+                 RATETAB_ENT(10,  RATE111_1,  IEEE80211_RATE_CCK),
+                 RATETAB_ENT(20,  RATE111_2,  IEEE80211_RATE_CCK_2),
+                 RATETAB_ENT(55,  RATE111_5,  IEEE80211_RATE_CCK_2),
+                 RATETAB_ENT(110, RATE111_11, IEEE80211_RATE_CCK_2),
+                 RATETAB_ENT(60,  RATE111_6,  IEEE80211_RATE_OFDM),
+                 RATETAB_ENT(90,  RATE111_9,  IEEE80211_RATE_OFDM), 
+                 RATETAB_ENT(120, RATE111_12, IEEE80211_RATE_OFDM),
+                 RATETAB_ENT(180, RATE111_18, IEEE80211_RATE_OFDM),
+                 RATETAB_ENT(240, RATE111_24, IEEE80211_RATE_OFDM),
+                 RATETAB_ENT(360, RATE111_36, IEEE80211_RATE_OFDM),
+                 RATETAB_ENT(480, RATE111_48, IEEE80211_RATE_OFDM),
+                 RATETAB_ENT(540, RATE111_54, IEEE80211_RATE_OFDM),
+        };
+
+#define acx_b_ratetable		(__acx_ratetable + 0)
+#define acx_b_ratetable_size	4
+#define acx_g_ratetable		(__acx_ratetable + 0)
+#define acx_g_ratetable_size	12
+
+#define CHANTAB_ENT(_chanid, _freq) \
+        {                                                       \
+                .chan   = (_chanid),                            \
+                .freq   = (_freq),                              \
+                .val    = (_chanid),                            \
+                .flag   = IEEE80211_CHAN_W_SCAN |               \
+                          IEEE80211_CHAN_W_ACTIVE_SCAN |        \
+                          IEEE80211_CHAN_W_IBSS,                \
+                .power_level    = 0xf,                         \
+                .antenna_max    = 0xFF,                         \
+        }
+static struct ieee80211_channel channels[] = {
+                 CHANTAB_ENT(1, 2412),     
+                 CHANTAB_ENT(2, 2417),    
+                 CHANTAB_ENT(3, 2422),
+                 CHANTAB_ENT(4, 2427),               
+                 CHANTAB_ENT(5, 2432),
+                 CHANTAB_ENT(6, 2437),    
+                 CHANTAB_ENT(7, 2442),               
+                 CHANTAB_ENT(8, 2447),     
+                 CHANTAB_ENT(9, 2452),
+                 CHANTAB_ENT(10, 2457),
+                 CHANTAB_ENT(11, 2462),
+                 CHANTAB_ENT(12, 2467),      
+                 CHANTAB_ENT(13, 2472),      
+        };
+
+#define acx_chantable_size ARRAY_SIZE(channels)
+
+static int acx_setup_modes_bphy(acx_device_t * adev)        
+{
+        int err = 0;
+	struct ieee80211_hw *hw = adev->ieee;
+	struct ieee80211_hw_mode *mode;
+
+	mode = &adev->modes[0];
+	mode->mode = MODE_IEEE80211B;
+	mode->num_channels = acx_chantable_size;
+	mode->channels = channels;
+	mode->num_rates = acx_b_ratetable_size;
+	mode->rates = acx_b_ratetable;
+	err = ieee80211_register_hwmode(hw,mode);
+
+        return err;           
+}
+
+static int acx_setup_modes_gphy(acx_device_t * adev)
+{                 
+        int err = 0;
+	struct ieee80211_hw *hw = adev->ieee;
+	struct ieee80211_hw_mode *mode;
+	
+	mode = &adev->modes[1]; 
+	mode->mode = MODE_IEEE80211G;
+	mode->num_channels = acx_chantable_size;
+	mode->channels = channels;
+	mode->num_rates = acx_g_ratetable_size;
+	mode->rates = acx_g_ratetable;
+	err = ieee80211_register_hwmode(hw,mode);
+
+        return err;                  
+}
+
+int acx_setup_modes(acx_device_t * adev)
+{
+        int err = -ENOMEM;
+
+                    
+	if (IS_ACX111(adev)) {
+/*		adev->modes = kzalloc(sizeof(struct ieee80211_hw_mode) * 2, GFP_KERNEL);*/
+        	err = acx_setup_modes_gphy(adev);
+	}/* else {
+		adev->modes = kzalloc(sizeof(struct ieee80211_hw_mode), GFP_KERNEL);
+	}*/
+	err = acx_setup_modes_bphy(adev);
+/*	if (err && adev->modes)
+		kfree(adev->modes);*/
+        return err;                           
+
+}
+
+/***********************************************************************
+** acx_fill_beacon_or_proberesp_template
+**
+** Origin: derived from rt2x00 project
+*/
+static int               
+acx_fill_beacon_or_proberesp_template(acx_device_t *adev,
+                                        struct acx_template_beacon *templ,
+                                        struct sk_buff* skb /* in host order! */)
+{
+        FN_ENTER;
+
+        memcpy(templ,skb->data, skb->len);
+        FN_EXIT1(skb->len);
+        return skb->len;
+}
+
+/***********************************************************************
+** acx_s_set_beacon_template
+**
+**
+*/
+static int
+acx_s_set_beacon_template(acx_device_t *adev, struct sk_buff *skb)
+{
+        struct acx_template_beacon bcn;
+        int len, result;
+
+        FN_ENTER;
+	printk("Size of template: %08X, Size of beacon: %08X\n",sizeof(struct acx_template_beacon),skb->len);
+        len = acx_fill_beacon_or_proberesp_template(adev, &bcn, skb);
+        result = acx_s_issue_cmd(adev, ACX1xx_CMD_CONFIG_BEACON, &bcn, len);
+
+        FN_EXIT1(result);
+        return result;
+}
+
+/***********************************************************************
+** acx_cmd_join_bssid
+**
+** Common code for both acx100 and acx111.
+*/
+/* NB: does NOT match RATE100_nn but matches ACX[111]_SCAN_RATE_n */
+static const u8 bitpos2genframe_txrate[] = {
+	10,			/*  0.  1 Mbit/s */
+	20,			/*  1.  2 Mbit/s */
+	55,			/*  2.  5.5 Mbit/s */
+	0x0B,			/*  3.  6 Mbit/s */
+	0x0F,			/*  4.  9 Mbit/s */
+	110,			/*  5. 11 Mbit/s */
+	0x0A,			/*  6. 12 Mbit/s */
+	0x0E,			/*  7. 18 Mbit/s */
+	220,			/*  8. 22 Mbit/s */
+	0x09,			/*  9. 24 Mbit/s */
+	0x0D,			/* 10. 36 Mbit/s */
+	0x08,			/* 11. 48 Mbit/s */
+	0x0C,			/* 12. 54 Mbit/s */
+	10,			/* 13.  1 Mbit/s, should never happen */
+	10,			/* 14.  1 Mbit/s, should never happen */
+	10,			/* 15.  1 Mbit/s, should never happen */
+};
+
+/* Looks scary, eh?
+** Actually, each one compiled into one AND and one SHIFT,
+** 31 bytes in x86 asm (more if uints are replaced by u16/u8) */
+static inline unsigned int rate111to5bits(unsigned int rate)
+{
+	return (rate & 0x7)
+	    | ((rate & RATE111_11) / (RATE111_11 / JOINBSS_RATES_11))
+	    | ((rate & RATE111_22) / (RATE111_22 / JOINBSS_RATES_22));
+}
+
+
+void acx_s_cmd_join_bssid(acx_device_t *adev, const u8 *bssid)
+{
+        acx_joinbss_t tmp;
+        int dtim_interval;
+        int i;
+
+        if (mac_is_zero(bssid))
+                return;
+
+        FN_ENTER;
+
+        dtim_interval = (ACX_MODE_0_ADHOC == adev->mode) ?
+                        1 : adev->dtim_interval;
+
+        memset(&tmp, 0, sizeof(tmp));
+
+        for (i = 0; i < ETH_ALEN; i++) {
+                tmp.bssid[i] = bssid[ETH_ALEN-1 - i];
+        }
+
+        tmp.beacon_interval = cpu_to_le16(adev->beacon_interval);
+
+        /* Basic rate set. Control frame responses (such as ACK or CTS frames)
+        ** are sent with one of these rates */
+        if (IS_ACX111(adev)) {
+                /* It was experimentally determined that rates_basic
+                ** can take 11g rates as well, not only rates
+                ** defined with JOINBSS_RATES_BASIC111_nnn.
+                ** Just use RATE111_nnn constants... */
+                tmp.u.acx111.dtim_interval = dtim_interval;
+                tmp.u.acx111.rates_basic = cpu_to_le16(adev->rate_basic);
+                log(L_ASSOC, "rates_basic:%04X, rates_supported:%04X\n",
+                        adev->rate_basic, adev->rate_oper);
+        } else {
+                tmp.u.acx100.dtim_interval = dtim_interval;
+                tmp.u.acx100.rates_basic = rate111to5bits(adev->rate_basic);
+                tmp.u.acx100.rates_supported = rate111to5bits(adev->rate_oper);
+                log(L_ASSOC, "rates_basic:%04X->%02X, "
+                        "rates_supported:%04X->%02X\n",
+                        adev->rate_basic, tmp.u.acx100.rates_basic,
+                        adev->rate_oper, tmp.u.acx100.rates_supported);
+        }
+
+        /* Setting up how Beacon, Probe Response, RTS, and PS-Poll frames
+        ** will be sent (rate/modulation/preamble) */
+        tmp.genfrm_txrate = bitpos2genframe_txrate[lowest_bit(adev->rate_basic)];
+        tmp.genfrm_mod_pre = 0; /* FIXME: was = adev->capab_short (which was always 0); */
+        /* we can use short pre *if* all peers can understand it */
+        /* FIXME #2: we need to correctly set PBCC/OFDM bits here too */
+
+        /* we switch fw to STA mode in MONITOR mode, it seems to be
+        ** the only mode where fw does not emit beacons by itself
+        ** but allows us to send anything (we really want to retain
+        ** ability to tx arbitrary frames in MONITOR mode)
+        */
+        tmp.macmode = (adev->mode != ACX_MODE_MONITOR ? adev->mode : ACX_MODE_2_STA);
+        tmp.channel = adev->channel;
+        tmp.essid_len = adev->essid_len;
+
+        memcpy(tmp.essid, adev->essid, tmp.essid_len);
+        acx_s_issue_cmd(adev, ACX1xx_CMD_JOIN, &tmp, tmp.essid_len + 0x11);
+
+        log(L_ASSOC|L_DEBUG, "BSS_Type = %u\n", tmp.macmode);
+        acxlog_mac(L_ASSOC|L_DEBUG, "JoinBSSID MAC:", adev->bssid, "\n");
+
+/*        acx_update_capabilities(adev); */
+        FN_EXIT0;
+}
+
+/***********************************************************************
+** acxpci_i_set_multicast_list
+** FIXME: most likely needs refinement
+*/
+void
+acx_i_set_multicast_list(struct ieee80211_hw *hw,
+                            unsigned short netflags, int mc_count)
+{
+        acx_device_t *adev = ieee2adev(hw);
+        unsigned long flags;
+
+        FN_ENTER;
+
+        acx_lock(adev, flags);
+
+        /* firmwares don't have allmulti capability,
+         * so just use promiscuous mode instead in this case. */
+        if (netflags & (IFF_PROMISC | IFF_ALLMULTI)) {
+                SET_BIT(adev->rx_config_1, RX_CFG1_RCV_PROMISCUOUS);
+                CLEAR_BIT(adev->rx_config_1, RX_CFG1_FILTER_ALL_MULTI);
+                SET_BIT(adev->set_mask, SET_RXCONFIG);
+                /* let kernel know in case *we* needed to set promiscuous */
+        } else {
+                CLEAR_BIT(adev->rx_config_1, RX_CFG1_RCV_PROMISCUOUS);
+                SET_BIT(adev->rx_config_1, RX_CFG1_FILTER_ALL_MULTI);
+                SET_BIT(adev->set_mask, SET_RXCONFIG);              
+        }
+
+        /* cannot update card settings directly here, atomic context */
+        acx_schedule_task(adev, ACX_AFTER_IRQ_UPDATE_CARD_CFG);
+
+        acx_unlock(adev, flags);       
+
+        FN_EXIT0; 
+}
+
+/***********************************************************************
+** acx111 feature config
+**
+** Obvious
+*/
+static int
+acx111_s_get_feature_config(acx_device_t * adev,
+			    u32 * feature_options, u32 * data_flow_options)
+{
+	struct acx111_ie_feature_config feat;
+
+	if (!IS_ACX111(adev)) {
+		return NOT_OK;
+	}
+
+	memset(&feat, 0, sizeof(feat));
+
+	if (OK != acx_s_interrogate(adev, &feat, ACX1xx_IE_FEATURE_CONFIG)) {
+		return NOT_OK;
+	}
+	log(L_DEBUG,
+	    "got Feature option:0x%X, DataFlow option: 0x%X\n",
+	    feat.feature_options, feat.data_flow_options);
+
+	if (feature_options)
+		*feature_options = le32_to_cpu(feat.feature_options);
+	if (data_flow_options)
+		*data_flow_options = le32_to_cpu(feat.data_flow_options);
+
+	return OK;
+}
+
+
+static int
+acx111_s_set_feature_config(acx_device_t * adev,
+			    u32 feature_options, u32 data_flow_options,
+			    unsigned int mode
+			    /* 0 == remove, 1 == add, 2 == set */ )
+{
+	struct acx111_ie_feature_config feat;
+
+	if (!IS_ACX111(adev)) {
+		return NOT_OK;
+	}
+
+	if ((mode < 0) || (mode > 2))
+		return NOT_OK;
+
+	if (mode != 2)
+		/* need to modify old data */
+		acx111_s_get_feature_config(adev, &feat.feature_options,
+					    &feat.data_flow_options);
+	else {
+		/* need to set a completely new value */
+		feat.feature_options = 0;
+		feat.data_flow_options = 0;
+	}
+
+	if (mode == 0) {	/* remove */
+		CLEAR_BIT(feat.feature_options, cpu_to_le32(feature_options));
+		CLEAR_BIT(feat.data_flow_options,
+			  cpu_to_le32(data_flow_options));
+	} else {		/* add or set */
+		SET_BIT(feat.feature_options, cpu_to_le32(feature_options));
+		SET_BIT(feat.data_flow_options, cpu_to_le32(data_flow_options));
+	}
+
+	log(L_DEBUG,
+	    "old: feature 0x%08X dataflow 0x%08X. mode: %u\n"
+	    "new: feature 0x%08X dataflow 0x%08X\n",
+	    feature_options, data_flow_options, mode,
+	    le32_to_cpu(feat.feature_options),
+	    le32_to_cpu(feat.data_flow_options));
+
+	if (OK != acx_s_configure(adev, &feat, ACX1xx_IE_FEATURE_CONFIG)) {
+		return NOT_OK;
+	}
+
+	return OK;
+}
+
+static inline int acx111_s_feature_off(acx_device_t * adev, u32 f, u32 d)
+{
+	return acx111_s_set_feature_config(adev, f, d, 0);
+}
+static inline int acx111_s_feature_on(acx_device_t * adev, u32 f, u32 d)
+{
+	return acx111_s_set_feature_config(adev, f, d, 1);
+}
+static inline int acx111_s_feature_set(acx_device_t * adev, u32 f, u32 d)
+{
+	return acx111_s_set_feature_config(adev, f, d, 2);
+}
+
+
+/***********************************************************************
+** acx100_s_init_memory_pools
+*/
+static int
+acx100_s_init_memory_pools(acx_device_t * adev, const acx_ie_memmap_t * mmt)
+{
+	acx100_ie_memblocksize_t MemoryBlockSize;
+	acx100_ie_memconfigoption_t MemoryConfigOption;
+	int TotalMemoryBlocks;
+	int RxBlockNum;
+	int TotalRxBlockSize;
+	int TxBlockNum;
+	int TotalTxBlockSize;
+
+	FN_ENTER;
+
+	/* Let's see if we can follow this:
+	   first we select our memory block size (which I think is
+	   completely arbitrary) */
+	MemoryBlockSize.size = cpu_to_le16(adev->memblocksize);
+
+	/* Then we alert the card to our decision of block size */
+	if (OK != acx_s_configure(adev, &MemoryBlockSize, ACX100_IE_BLOCK_SIZE)) {
+		goto bad;
+	}
+
+	/* We figure out how many total blocks we can create, using
+	   the block size we chose, and the beginning and ending
+	   memory pointers, i.e.: end-start/size */
+	TotalMemoryBlocks =
+	    (le32_to_cpu(mmt->PoolEnd) -
+	     le32_to_cpu(mmt->PoolStart)) / adev->memblocksize;
+
+	log(L_DEBUG, "TotalMemoryBlocks=%u (%u bytes)\n",
+	    TotalMemoryBlocks, TotalMemoryBlocks * adev->memblocksize);
+
+	/* MemoryConfigOption.DMA_config bitmask:
+	   access to ACX memory is to be done:
+	   0x00080000   using PCI conf space?!
+	   0x00040000   using IO instructions?
+	   0x00000000   using memory access instructions
+	   0x00020000   using local memory block linked list (else what?)
+	   0x00010000   using host indirect descriptors (else host must access ACX memory?)
+	 */
+	if (IS_PCI(adev)) {
+		MemoryConfigOption.DMA_config = cpu_to_le32(0x30000);
+		/* Declare start of the Rx host pool */
+		MemoryConfigOption.pRxHostDesc =
+		    cpu2acx(adev->rxhostdesc_startphy);
+		log(L_DEBUG, "pRxHostDesc 0x%08X, rxhostdesc_startphy 0x%lX\n",
+		    acx2cpu(MemoryConfigOption.pRxHostDesc),
+		    (long)adev->rxhostdesc_startphy);
+	} else {
+		MemoryConfigOption.DMA_config = cpu_to_le32(0x20000);
+	}
+
+	/* 50% of the allotment of memory blocks go to tx descriptors */
+	TxBlockNum = TotalMemoryBlocks / 2;
+	MemoryConfigOption.TxBlockNum = cpu_to_le16(TxBlockNum);
+
+	/* and 50% go to the rx descriptors */
+	RxBlockNum = TotalMemoryBlocks - TxBlockNum;
+	MemoryConfigOption.RxBlockNum = cpu_to_le16(RxBlockNum);
+
+	/* size of the tx and rx descriptor queues */
+	TotalTxBlockSize = TxBlockNum * adev->memblocksize;
+	TotalRxBlockSize = RxBlockNum * adev->memblocksize;
+	log(L_DEBUG, "TxBlockNum %u RxBlockNum %u TotalTxBlockSize %u "
+	    "TotalTxBlockSize %u\n", TxBlockNum, RxBlockNum,
+	    TotalTxBlockSize, TotalRxBlockSize);
+
+
+	/* align the tx descriptor queue to an alignment of 0x20 (32 bytes) */
+	MemoryConfigOption.rx_mem =
+	    cpu_to_le32((le32_to_cpu(mmt->PoolStart) + 0x1f) & ~0x1f);
+
+	/* align the rx descriptor queue to units of 0x20
+	 * and offset it by the tx descriptor queue */
+	MemoryConfigOption.tx_mem =
+	    cpu_to_le32((le32_to_cpu(mmt->PoolStart) + TotalRxBlockSize +
+			 0x1f) & ~0x1f);
+	log(L_DEBUG, "rx_mem %08X rx_mem %08X\n", MemoryConfigOption.tx_mem,
+	    MemoryConfigOption.rx_mem);
+
+	/* alert the device to our decision */
+	if (OK !=
+	    acx_s_configure(adev, &MemoryConfigOption,
+			    ACX1xx_IE_MEMORY_CONFIG_OPTIONS)) {
+		goto bad;
+	}
+
+	/* and tell the device to kick it into gear */
+	if (OK != acx_s_issue_cmd(adev, ACX100_CMD_INIT_MEMORY, NULL, 0)) {
+		goto bad;
+	}
+	FN_EXIT1(OK);
+	return OK;
+      bad:
+	FN_EXIT1(NOT_OK);
+	return NOT_OK;
+}
+
+
+/***********************************************************************
+** acx100_s_create_dma_regions
+**
+** Note that this fn messes up heavily with hardware, but we cannot
+** lock it (we need to sleep). Not a problem since IRQs can't happen
+*/
+static int acx100_s_create_dma_regions(acx_device_t * adev)
+{
+	acx100_ie_queueconfig_t queueconf;
+	acx_ie_memmap_t memmap;
+	int res = NOT_OK;
+	u32 tx_queue_start, rx_queue_start;
+
+	FN_ENTER;
+
+	/* read out the acx100 physical start address for the queues */
+	if (OK != acx_s_interrogate(adev, &memmap, ACX1xx_IE_MEMORY_MAP)) {
+		goto fail;
+	}
+
+	tx_queue_start = le32_to_cpu(memmap.QueueStart);
+	rx_queue_start = tx_queue_start + TX_CNT * sizeof(txdesc_t);
+
+	log(L_DEBUG, "initializing Queue Indicator\n");
+
+	memset(&queueconf, 0, sizeof(queueconf));
+
+	/* Not needed for PCI, so we can avoid setting them altogether */
+	if (IS_USB(adev)) {
+		queueconf.NumTxDesc = USB_TX_CNT;
+		queueconf.NumRxDesc = USB_RX_CNT;
+	}
+
+	/* calculate size of queues */
+	queueconf.AreaSize = cpu_to_le32(TX_CNT * sizeof(txdesc_t) +
+					 RX_CNT * sizeof(rxdesc_t) + 8);
+	queueconf.NumTxQueues = 1;	/* number of tx queues */
+	/* sets the beginning of the tx descriptor queue */
+	queueconf.TxQueueStart = memmap.QueueStart;
+	/* done by memset: queueconf.TxQueuePri = 0; */
+	queueconf.RxQueueStart = cpu_to_le32(rx_queue_start);
+	queueconf.QueueOptions = 1;	/* auto reset descriptor */
+	/* sets the end of the rx descriptor queue */
+	queueconf.QueueEnd =
+	    cpu_to_le32(rx_queue_start + RX_CNT * sizeof(rxdesc_t)
+	    );
+	/* sets the beginning of the next queue */
+	queueconf.HostQueueEnd =
+	    cpu_to_le32(le32_to_cpu(queueconf.QueueEnd) + 8);
+	if (OK != acx_s_configure(adev, &queueconf, ACX1xx_IE_QUEUE_CONFIG)) {
+		goto fail;
+	}
+
+	if (IS_PCI(adev)) {
+		/* sets the beginning of the rx descriptor queue, after the tx descrs */
+		if (OK != acxpci_s_create_hostdesc_queues(adev))
+			goto fail;
+		acxpci_create_desc_queues(adev, tx_queue_start, rx_queue_start);
+	}
+
+	if (OK != acx_s_interrogate(adev, &memmap, ACX1xx_IE_MEMORY_MAP)) {
+		goto fail;
+	}
+
+	memmap.PoolStart = cpu_to_le32((le32_to_cpu(memmap.QueueEnd) + 4 +
+					0x1f) & ~0x1f);
+
+	if (OK != acx_s_configure(adev, &memmap, ACX1xx_IE_MEMORY_MAP)) {
+		goto fail;
+	}
+
+	if (OK != acx100_s_init_memory_pools(adev, &memmap)) {
+		goto fail;
+	}
+
+	res = OK;
+	goto end;
+
+      fail:
+	acx_s_msleep(1000);	/* ? */
+	if (IS_PCI(adev))
+		acxpci_free_desc_queues(adev);
+      end:
+	FN_EXIT1(res);
+	return res;
+}
+
+
+/***********************************************************************
+** acx111_s_create_dma_regions
+**
+** Note that this fn messes heavily with hardware, but we cannot
+** lock it (we need to sleep). Not a problem since IRQs can't happen
+*/
+#define ACX111_PERCENT(percent) ((percent)/5)
+
+static int acx111_s_create_dma_regions(acx_device_t * adev)
+{
+	struct acx111_ie_memoryconfig memconf;
+	struct acx111_ie_queueconfig queueconf;
+	u32 tx_queue_start, rx_queue_start;
+
+	FN_ENTER;
+
+	/* Calculate memory positions and queue sizes */
+
+	/* Set up our host descriptor pool + data pool */
+	if (IS_PCI(adev)) {
+		if (OK != acxpci_s_create_hostdesc_queues(adev))
+			goto fail;
+	}
+
+	memset(&memconf, 0, sizeof(memconf));
+	/* the number of STAs (STA contexts) to support
+	 ** NB: was set to 1 and everything seemed to work nevertheless... */
+	memconf.no_of_stations = 1;	//cpu_to_le16(VEC_SIZE(adev->sta_list));
+	/* specify the memory block size. Default is 256 */
+	memconf.memory_block_size = cpu_to_le16(adev->memblocksize);
+	/* let's use 50%/50% for tx/rx (specify percentage, units of 5%) */
+	memconf.tx_rx_memory_block_allocation = ACX111_PERCENT(50);
+	/* set the count of our queues
+	 ** NB: struct acx111_ie_memoryconfig shall be modified
+	 ** if we ever will switch to more than one rx and/or tx queue */
+	memconf.count_rx_queues = 1;
+	memconf.count_tx_queues = 1;
+	/* 0 == Busmaster Indirect Memory Organization, which is what we want
+	 * (using linked host descs with their allocated mem).
+	 * 2 == Generic Bus Slave */
+	/* done by memset: memconf.options = 0; */
+	/* let's use 25% for fragmentations and 75% for frame transfers
+	 * (specified in units of 5%) */
+	memconf.fragmentation = ACX111_PERCENT(75);
+	/* Rx descriptor queue config */
+	memconf.rx_queue1_count_descs = RX_CNT;
+	memconf.rx_queue1_type = 7;	/* must be set to 7 */
+	/* done by memset: memconf.rx_queue1_prio = 0; low prio */
+	if (IS_PCI(adev)) {
+		memconf.rx_queue1_host_rx_start =
+		    cpu2acx(adev->rxhostdesc_startphy);
+	}
+	/* Tx descriptor queue config */
+	memconf.tx_queue1_count_descs = TX_CNT;
+	/* done by memset: memconf.tx_queue1_attributes = 0; lowest priority */
+
+	/* NB1: this looks wrong: (memconf,ACX1xx_IE_QUEUE_CONFIG),
+	 ** (queueconf,ACX1xx_IE_MEMORY_CONFIG_OPTIONS) look swapped, eh?
+	 ** But it is actually correct wrt IE numbers.
+	 ** NB2: sizeof(memconf) == 28 == 0x1c but configure(ACX1xx_IE_QUEUE_CONFIG)
+	 ** writes 0x20 bytes (because same IE for acx100 uses struct acx100_ie_queueconfig
+	 ** which is 4 bytes larger. what a mess. TODO: clean it up) */
+	if (OK != acx_s_configure(adev, &memconf, ACX1xx_IE_QUEUE_CONFIG)) {
+		goto fail;
+	}
+
+	acx_s_interrogate(adev, &queueconf, ACX1xx_IE_MEMORY_CONFIG_OPTIONS);
+
+	tx_queue_start = le32_to_cpu(queueconf.tx1_queue_address);
+	rx_queue_start = le32_to_cpu(queueconf.rx1_queue_address);
+
+	log(L_INIT, "dump queue head (from card):\n"
+	    "len: %u\n"
+	    "tx_memory_block_address: %X\n"
+	    "rx_memory_block_address: %X\n"
+	    "tx1_queue address: %X\n"
+	    "rx1_queue address: %X\n",
+	    le16_to_cpu(queueconf.len),
+	    le32_to_cpu(queueconf.tx_memory_block_address),
+	    le32_to_cpu(queueconf.rx_memory_block_address),
+	    tx_queue_start, rx_queue_start);
+
+	if (IS_PCI(adev))
+		acxpci_create_desc_queues(adev, tx_queue_start, rx_queue_start);
+
+	FN_EXIT1(OK);
+	return OK;
+      fail:
+	if (IS_PCI(adev))
+		acxpci_free_desc_queues(adev);
+
+	FN_EXIT1(NOT_OK);
+	return NOT_OK;
+}
+
+
+/***********************************************************************
+*/
+static void acx_s_initialize_rx_config(acx_device_t * adev)
+{
+	struct {
+		u16 id;
+		u16 len;
+		u16 rx_cfg1;
+		u16 rx_cfg2;
+	} ACX_PACKED cfg;
+	switch (adev->mode) {
+	case ACX_MODE_MONITOR:
+		adev->rx_config_1 = (u16) (0
+					   /* | RX_CFG1_INCLUDE_RXBUF_HDR  */
+					   /* | RX_CFG1_FILTER_SSID        */
+					   /* | RX_CFG1_FILTER_BCAST       */
+					   /* | RX_CFG1_RCV_MC_ADDR1       */
+					   /* | RX_CFG1_RCV_MC_ADDR0       */
+					   /* | RX_CFG1_FILTER_ALL_MULTI   */
+					   /* | RX_CFG1_FILTER_BSSID       */
+					   /* | RX_CFG1_FILTER_MAC         */
+					   | RX_CFG1_RCV_PROMISCUOUS
+					   | RX_CFG1_INCLUDE_FCS
+					   /* | RX_CFG1_INCLUDE_PHY_HDR    */
+		    );
+		adev->rx_config_2 = (u16) (0
+					   | RX_CFG2_RCV_ASSOC_REQ
+					   | RX_CFG2_RCV_AUTH_FRAMES
+					   | RX_CFG2_RCV_BEACON_FRAMES
+					   | RX_CFG2_RCV_CONTENTION_FREE
+					   | RX_CFG2_RCV_CTRL_FRAMES
+					   | RX_CFG2_RCV_DATA_FRAMES
+					   | RX_CFG2_RCV_BROKEN_FRAMES
+					   | RX_CFG2_RCV_MGMT_FRAMES
+					   | RX_CFG2_RCV_PROBE_REQ
+					   | RX_CFG2_RCV_PROBE_RESP
+					   | RX_CFG2_RCV_ACK_FRAMES
+					   | RX_CFG2_RCV_OTHER);
+		break;
+	default:
+		adev->rx_config_1 = (u16) (0
+					   /* | RX_CFG1_INCLUDE_RXBUF_HDR  */
+					   /* | RX_CFG1_FILTER_SSID        */
+					   /* | RX_CFG1_FILTER_BCAST       */
+					   /* | RX_CFG1_RCV_MC_ADDR1       */
+					   /* | RX_CFG1_RCV_MC_ADDR0       */
+					   /* | RX_CFG1_FILTER_ALL_MULTI   */
+					   /* | RX_CFG1_FILTER_BSSID       */
+					   /* | RX_CFG1_FILTER_MAC         */
+					    | RX_CFG1_RCV_PROMISCUOUS    
+					   /* | RX_CFG1_INCLUDE_FCS */        
+					   /* | RX_CFG1_INCLUDE_PHY_HDR   */
+		    );
+		adev->rx_config_2 = (u16) (0
+					   | RX_CFG2_RCV_ASSOC_REQ
+					   | RX_CFG2_RCV_AUTH_FRAMES
+					   | RX_CFG2_RCV_BEACON_FRAMES
+					   | RX_CFG2_RCV_CONTENTION_FREE
+					   | RX_CFG2_RCV_CTRL_FRAMES
+					   | RX_CFG2_RCV_DATA_FRAMES
+					   /*| RX_CFG2_RCV_BROKEN_FRAMES   */
+					   | RX_CFG2_RCV_MGMT_FRAMES
+					   | RX_CFG2_RCV_PROBE_REQ
+					   | RX_CFG2_RCV_PROBE_RESP
+					   | RX_CFG2_RCV_ACK_FRAMES
+					   | RX_CFG2_RCV_OTHER);
+		break;
+	}
+	adev->rx_config_1 |= RX_CFG1_INCLUDE_RXBUF_HDR;
+
+	if ((adev->rx_config_1 & RX_CFG1_INCLUDE_PHY_HDR)
+	    || (adev->firmware_numver >= 0x02000000))
+		adev->phy_header_len = IS_ACX111(adev) ? 8 : 4;
+	else
+		adev->phy_header_len = 0;
+
+	log(L_INIT, "setting RXconfig to %04X:%04X\n",
+	    adev->rx_config_1, adev->rx_config_2);
+	cfg.rx_cfg1 = cpu_to_le16(adev->rx_config_1);
+	cfg.rx_cfg2 = cpu_to_le16(adev->rx_config_2);
+	acx_s_configure(adev, &cfg, ACX1xx_IE_RXCONFIG);
+}
+
+
+/***********************************************************************
+** acx_s_set_defaults
+*/
+void acx_s_set_defaults(acx_device_t * adev)
+{
+	unsigned long flags;
+
+	FN_ENTER;
+
+	acx_lock(adev, flags);
+	/* do it before getting settings, prevent bogus channel 0 warning */
+	adev->channel = 1;
+
+	/* query some settings from the card.
+	 * NOTE: for some settings, e.g. CCA and ED (ACX100!), an initial
+	 * query is REQUIRED, otherwise the card won't work correctly! */
+	adev->get_mask =
+	    GETSET_ANTENNA | GETSET_SENSITIVITY | GETSET_STATION_ID |
+	    GETSET_REG_DOMAIN;
+	/* Only ACX100 supports ED and CCA */
+	if (IS_ACX100(adev))
+		adev->get_mask |= GETSET_CCA | GETSET_ED_THRESH;
+
+	acx_s_update_card_settings(adev);
+
+
+	/* set our global interrupt mask */
+	if (IS_PCI(adev))
+		acxpci_set_interrupt_mask(adev);
+
+	adev->led_power = 1;	/* LED is active on startup */
+	adev->brange_max_quality = 60;	/* LED blink max quality is 60 */
+	adev->brange_time_last_state_change = jiffies;
+
+	/* copy the MAC address we just got from the card
+	 * into our MAC address used during current 802.11 session */
+	SET_IEEE80211_PERM_ADDR(adev->ieee,adev->dev_addr);
+	MAC_BCAST(adev->ap);
+
+	adev->essid_len =
+	    snprintf(adev->essid, sizeof(adev->essid), "STA%02X%02X%02X",
+		     adev->dev_addr[3], adev->dev_addr[4], adev->dev_addr[5]);
+	adev->essid_active = 1;
+
+	/* we have a nick field to waste, so why not abuse it
+	 * to announce the driver version? ;-) */
+	strncpy(adev->nick, "acx " ACX_RELEASE, IW_ESSID_MAX_SIZE);
+
+	if (IS_PCI(adev)) {	/* FIXME: this should be made to apply to USB, too! */
+		/* first regulatory domain entry in EEPROM == default reg. domain */
+		adev->reg_dom_id = adev->cfgopt_domains.list[0];
+	}
+
+	/* 0xffff would be better, but then we won't get a "scan complete"
+	 * interrupt, so our current infrastructure will fail: */
+	adev->scan_count = 1;
+	adev->scan_mode = ACX_SCAN_OPT_ACTIVE;
+	adev->scan_duration = 100;
+	adev->scan_probe_delay = 200;
+	/* reported to break scanning: adev->scan_probe_delay = adev->cfgopt_probe_delay; */
+	adev->scan_rate = ACX_SCAN_RATE_1;
+
+
+	adev->mode = ACX_MODE_2_STA;
+	adev->listen_interval = 100;
+	adev->beacon_interval = DEFAULT_BEACON_INTERVAL;
+	adev->dtim_interval = DEFAULT_DTIM_INTERVAL;
+
+	adev->msdu_lifetime = DEFAULT_MSDU_LIFETIME;
+
+	adev->rts_threshold = DEFAULT_RTS_THRESHOLD;
+	adev->frag_threshold = 2346;
+
+	/* use standard default values for retry limits */
+	adev->short_retry = 7;	/* max. retries for (short) non-RTS packets */
+	adev->long_retry = 4;	/* max. retries for long (RTS) packets */
+
+	adev->preamble_mode = 2;	/* auto */
+	adev->fallback_threshold = 3;
+	adev->stepup_threshold = 10;
+	adev->rate_bcast = RATE111_1;
+	adev->rate_bcast100 = RATE100_1;
+	adev->rate_basic = RATE111_1 | RATE111_2;
+	adev->rate_auto = 1;
+	if (IS_ACX111(adev)) {
+		adev->rate_oper = RATE111_ALL;
+	} else {
+		adev->rate_oper = RATE111_ACX100_COMPAT;
+	}
+
+	/* Supported Rates element - the rates here are given in units of
+	 * 500 kbit/s, plus 0x80 added. See 802.11-1999.pdf item 7.3.2.2 */
+	acx_l_update_ratevector(adev);
+
+	/* set some more defaults */
+	if (IS_ACX111(adev)) {
+		/* 30mW (15dBm) is default, at least in my acx111 card: */
+		adev->tx_level_dbm = 15;
+	} else {
+		/* don't use max. level, since it might be dangerous
+		 * (e.g. WRT54G people experience
+		 * excessive Tx power damage!) */
+		adev->tx_level_dbm = 18;
+	}
+	/* adev->tx_level_auto = 1; */
+	if (IS_ACX111(adev)) {
+		/* start with sensitivity level 1 out of 3: */
+		adev->sensitivity = 1;
+	}
+
+/* #define ENABLE_POWER_SAVE */
+#ifdef ENABLE_POWER_SAVE
+	adev->ps_wakeup_cfg = PS_CFG_ENABLE | PS_CFG_WAKEUP_ALL_BEAC;
+	adev->ps_listen_interval = 1;
+	adev->ps_options =
+	    PS_OPT_ENA_ENHANCED_PS | PS_OPT_TX_PSPOLL | PS_OPT_STILL_RCV_BCASTS;
+	adev->ps_hangover_period = 30;
+	adev->ps_enhanced_transition_time = 0;
+#else
+	adev->ps_wakeup_cfg = 0;
+	adev->ps_listen_interval = 0;
+	adev->ps_options = 0;
+	adev->ps_hangover_period = 0;
+	adev->ps_enhanced_transition_time = 0;
+#endif
+
+	/* These settings will be set in fw on ifup */
+	adev->set_mask = 0 | GETSET_RETRY | SET_MSDU_LIFETIME
+	    /* configure card to do rate fallback when in auto rate mode */
+	    | SET_RATE_FALLBACK | SET_RXCONFIG | GETSET_TXPOWER
+	    /* better re-init the antenna value we got above */
+	    | GETSET_ANTENNA
+#if POWER_SAVE_80211
+	    | GETSET_POWER_80211
+#endif
+	    ;
+
+	acx_unlock(adev, flags);
+	acx_lock_unhold();	/* hold time 844814 CPU ticks @2GHz */
+
+	acx_s_initialize_rx_config(adev);
+
+	FN_EXIT0;
+}
+
+
+/***********************************************************************
+** FIXME: this should be solved in a general way for all radio types
+** by decoding the radio firmware module,
+** since it probably has some standard structure describing how to
+** set the power level of the radio module which it controls.
+** Or maybe not, since the radio module probably has a function interface
+** instead which then manages Tx level programming :-\
+**
+** Obvious
+*/
+static int acx111_s_set_tx_level(acx_device_t * adev, u8 level_dbm)
+{
+	struct acx111_ie_tx_level tx_level;
+
+	/* my acx111 card has two power levels in its configoptions (== EEPROM):
+	 * 1 (30mW) [15dBm]
+	 * 2 (10mW) [10dBm]
+	 * For now, just assume all other acx111 cards have the same.
+	 * FIXME: Ideally we would query it here, but we first need a
+	 * standard way to query individual configoptions easily.
+	 * Well, now we have proper cfgopt txpower variables, but this still
+	 * hasn't been done yet, since it also requires dBm <-> mW conversion here... */
+	if (level_dbm <= 12) {
+		tx_level.level = 2;	/* 10 dBm */
+		adev->tx_level_dbm = 10;
+	} else {
+		tx_level.level = 1;	/* 15 dBm */
+		adev->tx_level_dbm = 15;
+	}
+/*	if (level_dbm != adev->tx_level_dbm)
+		log(L_INIT, "acx111 firmware has specific "
+		    "power levels only: adjusted %d dBm to %d dBm!\n",
+		    level_dbm, adev->tx_level_dbm);
+*/
+	return acx_s_configure(adev, &tx_level, ACX1xx_IE_DOT11_TX_POWER_LEVEL);
+}
+
+static int acx_s_set_tx_level(acx_device_t * adev, u8 level_dbm)
+{
+	if (IS_ACX111(adev)) {
+		return acx111_s_set_tx_level(adev, level_dbm);
+	}
+	if (IS_PCI(adev)) {
+		return acx100pci_s_set_tx_level(adev, level_dbm);
+	}
+	return OK;
+}
+
+/***********************************************************************
+** acx_l_process_rxbuf
+**
+** NB: used by USB code also
+*/
+void acx_l_process_rxbuf(acx_device_t * adev, rxbuffer_t * rxbuf)
+{
+	struct ieee80211_hdr *hdr;
+	u16 fc, buf_len;
+	hdr = acx_get_wlan_hdr(adev, rxbuf);
+	fc = le16_to_cpu(hdr->frame_control);
+	/* length of frame from control field to first byte of FCS */
+	buf_len = RXBUF_BYTES_RCVD(adev, rxbuf);
+
+	if (unlikely(acx_debug & L_DATA)) {
+		printk("rx: 802.11 buf[%u]: ", buf_len);
+		acx_dump_bytes(hdr, buf_len);
+	}
+
+
+	acx_l_rx(adev, rxbuf);
+	/* Now check Rx quality level, AFTER processing packet.
+	 * I tried to figure out how to map these levels to dBm
+	 * values, but for the life of me I really didn't
+	 * manage to get it. Either these values are not meant to
+	 * be expressed in dBm, or it's some pretty complicated
+	 * calculation. */
+
+#ifdef FROM_SCAN_SOURCE_ONLY
+	/* only consider packets originating from the MAC
+	 * address of the device that's managing our BSSID.
+	 * Disable it for now, since it removes information (levels
+	 * from different peers) and slows the Rx path. *//*
+	if (adev->ap_client && mac_is_equal(hdr->a2, adev->ap_client->address)) {
+*/
+#endif
+}
+
+
+/***********************************************************************
+** acx_l_handle_txrate_auto
+**
+** Theory of operation:
+** client->rate_cap is a bitmask of rates client is capable of.
+** client->rate_cfg is a bitmask of allowed (configured) rates.
+** It is set as a result of iwconfig rate N [auto]
+** or iwpriv set_rates "N,N,N N,N,N" commands.
+** It can be fixed (e.g. 0x0080 == 18Mbit only),
+** auto (0x00ff == 18Mbit or any lower value),
+** and code handles any bitmask (0x1081 == try 54Mbit,18Mbit,1Mbit _only_).
+**
+** client->rate_cur is a value for rate111 field in tx descriptor.
+** It is always set to txrate_cfg sans zero or more most significant
+** bits. This routine handles selection of new rate_cur value depending on
+** outcome of last tx event.
+**
+** client->rate_100 is a precalculated rate value for acx100
+** (we can do without it, but will need to calculate it on each tx).
+**
+** You cannot configure mixed usage of 5.5 and/or 11Mbit rate
+** with PBCC and CCK modulation. Either both at CCK or both at PBCC.
+** In theory you can implement it, but so far it is considered not worth doing.
+**
+** 22Mbit, of course, is PBCC always. */
+
+/* maps acx100 tx descr rate field to acx111 one */
+/*
+static u16 rate100to111(u8 r)
+{
+	switch (r) {
+	case RATE100_1:
+		return RATE111_1;
+	case RATE100_2:
+		return RATE111_2;
+	case RATE100_5:
+	case (RATE100_5 | RATE100_PBCC511):
+		return RATE111_5;
+	case RATE100_11:
+	case (RATE100_11 | RATE100_PBCC511):
+		return RATE111_11;
+	case RATE100_22:
+		return RATE111_22;
+	default:
+		printk("acx: unexpected acx100 txrate: %u! "
+		       "Please report\n", r);
+		return RATE111_1;
+	}
+}
+
+*/
+
+int
+acx_i_start_xmit(struct ieee80211_hw *hw,
+                 struct sk_buff *skb, struct ieee80211_tx_control *ctl)
+{
+        acx_device_t *adev = ieee2adev(hw);
+        tx_t *tx;
+        void *txbuf;
+        unsigned long flags;
+
+        int txresult = NOT_OK;
+
+        FN_ENTER;
+
+        if (unlikely(!skb)) {
+                /* indicate success */
+                txresult = OK;
+                goto end_no_unlock;
+        }
+
+        if (unlikely(!adev)) {
+                goto end_no_unlock;
+        }
+
+
+        acx_lock(adev, flags);             
+
+        if (unlikely(!(adev->dev_state_mask & ACX_STATE_IFACE_UP))) {
+                goto end;
+        }
+        if (unlikely(!adev->initialized)) {
+                goto end;
+        }
+
+        tx = acx_l_alloc_tx(adev);
+
+        if (unlikely(!tx)) {             
+                printk_ratelimited("%s: start_xmit: txdesc ring is full, "
+                                   "dropping tx\n", wiphy_name(adev->ieee->wiphy));
+                txresult = NOT_OK;           
+                goto end;
+        }           
+
+        txbuf = acx_l_get_txbuf(adev, tx);
+
+        if (unlikely(!txbuf)) {
+                /* Card was removed */
+                txresult = NOT_OK;
+                acx_l_dealloc_tx(adev, tx);
+                goto end;    
+        }
+        memcpy(txbuf, skb->data, skb->len);
+
+        acx_l_tx_data(adev, tx, skb->len, ctl,skb);
+
+        txresult = OK;
+        adev->stats.tx_packets++;               
+        adev->stats.tx_bytes += skb->len;
+
+      end:
+        acx_unlock(adev, flags);
+
+      end_no_unlock:
+
+        FN_EXIT1(txresult);             
+        return txresult; 
+}   
+/***********************************************************************
+** acx_l_update_ratevector
+**
+** Updates adev->rate_supported[_len] according to rate_{basic,oper}
+*/
+const u8 acx_bitpos2ratebyte[] = {
+	DOT11RATEBYTE_1,
+	DOT11RATEBYTE_2,
+	DOT11RATEBYTE_5_5,
+	DOT11RATEBYTE_6_G,
+	DOT11RATEBYTE_9_G,
+	DOT11RATEBYTE_11,
+	DOT11RATEBYTE_12_G,
+	DOT11RATEBYTE_18_G,
+	DOT11RATEBYTE_22,
+	DOT11RATEBYTE_24_G,
+	DOT11RATEBYTE_36_G,
+	DOT11RATEBYTE_48_G,
+	DOT11RATEBYTE_54_G,
+};
+
+void acx_l_update_ratevector(acx_device_t * adev)
+{
+	u16 bcfg = adev->rate_basic;
+	u16 ocfg = adev->rate_oper;
+	u8 *supp = adev->rate_supported;
+	const u8 *dot11 = acx_bitpos2ratebyte;
+
+	FN_ENTER;
+
+	while (ocfg) {
+		if (ocfg & 1) {
+			*supp = *dot11;
+			if (bcfg & 1) {
+				*supp |= 0x80;
+			}
+			supp++;
+		}
+		dot11++;
+		ocfg >>= 1;
+		bcfg >>= 1;
+	}
+	adev->rate_supported_len = supp - adev->rate_supported;
+	if (acx_debug & L_ASSOC) {
+		printk("new ratevector: ");
+		acx_dump_bytes(adev->rate_supported, adev->rate_supported_len);
+	}
+	FN_EXIT0;
+}
+
+/***********************************************************************
+** acx_i_timer
+**
+** Fires up periodically. Used to kick scan/auth/assoc if something goes wrong
+**
+** Obvious
+*/
+void acx_i_timer(unsigned long address)
+{
+	unsigned long flags;
+	acx_device_t *adev = (acx_device_t *) address;
+
+	FN_ENTER;
+
+	acx_lock(adev, flags);
+
+	FIXME();
+	/* We need calibration and stats gather tasks to perform here */
+
+	acx_unlock(adev, flags);
+
+	FN_EXIT0;
+}
+
+
+/***********************************************************************
+** acx_set_timer
+**
+** Sets the 802.11 state management timer's timeout.
+**
+** Linux derived
+*/
+void acx_set_timer(acx_device_t * adev, int timeout_us)
+{
+	FN_ENTER;
+
+	log(L_DEBUG | L_IRQ, "%s(%u ms)\n", __func__, timeout_us / 1000);
+	if (!(adev->dev_state_mask & ACX_STATE_IFACE_UP)) {
+		printk("attempt to set the timer "
+		       "when the card interface is not up!\n");
+		goto end;
+	}
+
+	/* first check if the timer was already initialized, THEN modify it */
+	if (adev->mgmt_timer.function) {
+		mod_timer(&adev->mgmt_timer,
+			  jiffies + (timeout_us * HZ / 1000000));
+	}
+      end:
+	FN_EXIT0;
+}
+
+/** acx_plcp_get_bitrate_cck
+ **
+ ** Obvious
+*/
+static u8 acx_plcp_get_bitrate_cck(u8 plcp)
+{
+        switch (plcp) {
+        case 0x0A:
+                return ACX_CCK_RATE_1MB;
+        case 0x14:
+                return ACX_CCK_RATE_2MB;
+        case 0x37:
+                return ACX_CCK_RATE_5MB;
+        case 0x6E:
+                return ACX_CCK_RATE_11MB;
+        }
+        return 0;
+}
+
+/* Extract the bitrate out of an OFDM PLCP header. */
+/** Obvious **/
+static u8 acx_plcp_get_bitrate_ofdm(u8 plcp)
+{
+        switch (plcp & 0xF) {
+        case 0xB:
+                return ACX_OFDM_RATE_6MB;
+        case 0xF:
+                return ACX_OFDM_RATE_9MB;
+        case 0xA:
+                return ACX_OFDM_RATE_12MB;
+        case 0xE:
+                return ACX_OFDM_RATE_18MB;
+        case 0x9:
+                return ACX_OFDM_RATE_24MB;
+        case 0xD:
+                return ACX_OFDM_RATE_36MB;
+        case 0x8:
+                return ACX_OFDM_RATE_48MB;
+        case 0xC:
+                return ACX_OFDM_RATE_54MB;
+        }
+        return 0;
+}
+
+
+/***********************************************************************
+** acx_l_rx
+**
+** The end of the Rx path. Pulls data from a rxhostdesc into a socket
+** buffer and feeds it to the network stack via netif_rx().
+** 
+** Look to bcm43xx or p54
+*/
+static void acx_l_rx(acx_device_t * adev, rxbuffer_t * rxbuf)
+{
+
+	struct ieee80211_rx_status* status = &adev->rx_status;
+	struct ieee80211_hdr *w_hdr;
+	int buflen;
+	FN_ENTER;
+
+	if (likely(adev->dev_state_mask & ACX_STATE_IFACE_UP)) {
+		struct sk_buff *skb;
+		w_hdr = acx_get_wlan_hdr(adev, rxbuf);
+		buflen = RXBUF_BYTES_USED(rxbuf) - ((u8*)w_hdr - (u8*)rxbuf);
+		skb = dev_alloc_skb(buflen + 2);
+		skb_reserve(skb, 2);
+		skb_put(skb, buflen);
+		memcpy(skb->data, w_hdr, buflen);
+
+//		memset(&status, 0, sizeof(status));
+
+		if (likely(skb)) {
+			adev->acx_stats.last_rx = jiffies;
+			status->mactime = rxbuf->time;
+			status->signal = acx_signal_to_winlevel(rxbuf->phy_level);
+			status->noise = acx_signal_to_winlevel(rxbuf->phy_snr);
+			status->flag = 0;
+			status->rate = rxbuf->phy_plcp_signal;
+			status->antenna = 1;
+/*
+#ifndef OLD_QUALITY
+		qual = acx_signal_determine_quality(adev->wstats.qual.level,
+						    adev->wstats.qual.noise);
+#else
+		qual = (adev->wstats.qual.noise <= 100) ?
+		    100 - adev->wstats.qual.noise : 0;
+#endif
+		adev->wstats.qual.qual = qual;
+		adev->wstats.qual.updated = 7;	*//* all 3 indicators updated */
+/*
+#ifdef FROM_SCAN_SOURCE_ONLY
+	}
+#endif
+*/
+			if (rxbuf->phy_stat_baseband & (1 << 3)) /* Uses OFDM */
+			{
+				status->rate = acx_plcp_get_bitrate_ofdm(rxbuf->phy_plcp_signal);
+			} else
+			{
+				status->rate = acx_plcp_get_bitrate_cck(rxbuf->phy_plcp_signal);
+			}
+			ieee80211_rx_irqsafe(adev->ieee, skb, status);
+			adev->stats.rx_packets++;
+			adev->stats.rx_bytes += skb->len;
+		}
+	}
+	FN_EXIT0;
+}
+
+
+
+/***********************************************************************
+** acx_s_read_fw
+**
+** Loads a firmware image
+**
+** Returns:
+**  0				unable to load file
+**  pointer to firmware		success
+*/
+firmware_image_t *acx_s_read_fw(struct device *dev, const char *file,
+				u32 * size)
+{
+	firmware_image_t *res;
+	const struct firmware *fw_entry;
+
+	res = NULL;
+	log(L_INIT, "requesting firmware image '%s'\n", file);
+	if (!request_firmware(&fw_entry, file, dev)) {
+		*size = 8;
+		if (fw_entry->size >= 8)
+			*size = 8 + le32_to_cpu(*(u32 *) (fw_entry->data + 4));
+		if (fw_entry->size != *size) {
+			printk("acx: firmware size does not match "
+			       "firmware header: %d != %d, "
+			       "aborting fw upload\n",
+			       (int)fw_entry->size, (int)*size);
+			goto release_ret;
+		}
+		res = vmalloc(*size);
+		if (!res) {
+			printk("acx: no memory for firmware "
+			       "(%u bytes)\n", *size);
+			goto release_ret;
+		}
+		memcpy(res, fw_entry->data, fw_entry->size);
+	      release_ret:
+		release_firmware(fw_entry);
+		return res;
+	}
+	printk("acx: firmware image '%s' was not provided. "
+	       "Check your hotplug scripts\n", file);
+
+	/* checksum will be verified in write_fw, so don't bother here */
+	return res;
+}
+
+
+/***********************************************************************
+** acx_s_set_wepkey
+*/
+static void acx100_s_set_wepkey(acx_device_t * adev)
+{
+	ie_dot11WEPDefaultKey_t dk;
+	int i;
+
+	for (i = 0; i < DOT11_MAX_DEFAULT_WEP_KEYS; i++) {
+		if (adev->wep_keys[i].size != 0) {
+			log(L_INIT, "setting WEP key: %d with "
+			    "total size: %d\n", i, (int)adev->wep_keys[i].size);
+			dk.action = 1;
+			dk.keySize = adev->wep_keys[i].size;
+			dk.defaultKeyNum = i;
+			memcpy(dk.key, adev->wep_keys[i].key, dk.keySize);
+			acx_s_configure(adev, &dk,
+					ACX100_IE_DOT11_WEP_DEFAULT_KEY_WRITE);
+		}
+	}
+}
+
+static void acx111_s_set_wepkey(acx_device_t * adev)
+{
+	acx111WEPDefaultKey_t dk;
+	int i;
+
+	for (i = 0; i < DOT11_MAX_DEFAULT_WEP_KEYS; i++) {
+		if (adev->wep_keys[i].size != 0) {
+			log(L_INIT, "setting WEP key: %d with "
+			    "total size: %d\n", i, (int)adev->wep_keys[i].size);
+			memset(&dk, 0, sizeof(dk));
+			dk.action = cpu_to_le16(1);	/* "add key"; yes, that's a 16bit value */
+			dk.keySize = adev->wep_keys[i].size;
+
+			/* are these two lines necessary? */
+			dk.type = 0;	/* default WEP key */
+			dk.index = 0;	/* ignored when setting default key */
+
+			dk.defaultKeyNum = i;
+			memcpy(dk.key, adev->wep_keys[i].key, dk.keySize);
+			acx_s_issue_cmd(adev, ACX1xx_CMD_WEP_MGMT, &dk,
+					sizeof(dk));
+		}
+	}
+}
+/* Obvious */
+static void acx_s_set_wepkey(acx_device_t * adev)
+{
+	if (IS_ACX111(adev))
+		acx111_s_set_wepkey(adev);
+	else
+		acx100_s_set_wepkey(adev);
+}
+
+
+/***********************************************************************
+** acx100_s_init_wep
+**
+** FIXME: this should probably be moved into the new card settings
+** management, but since we're also modifying the memory map layout here
+** due to the WEP key space we want, we should take care...
+*/
+static int acx100_s_init_wep(acx_device_t * adev)
+{
+	acx100_ie_wep_options_t options;
+	ie_dot11WEPDefaultKeyID_t dk;
+	acx_ie_memmap_t pt;
+	int res = NOT_OK;
+
+	FN_ENTER;
+
+	if (OK != acx_s_interrogate(adev, &pt, ACX1xx_IE_MEMORY_MAP)) {
+		goto fail;
+	}
+
+	log(L_DEBUG, "CodeEnd:%X\n", pt.CodeEnd);
+
+	pt.WEPCacheStart = cpu_to_le32(le32_to_cpu(pt.CodeEnd) + 0x4);
+	pt.WEPCacheEnd = cpu_to_le32(le32_to_cpu(pt.CodeEnd) + 0x4);
+
+	if (OK != acx_s_configure(adev, &pt, ACX1xx_IE_MEMORY_MAP)) {
+		goto fail;
+	}
+
+	/* let's choose maximum setting: 4 default keys, plus 10 other keys: */
+	options.NumKeys = cpu_to_le16(DOT11_MAX_DEFAULT_WEP_KEYS + 10);
+	options.WEPOption = 0x00;
+
+	log(L_ASSOC, "writing WEP options\n");
+	acx_s_configure(adev, &options, ACX100_IE_WEP_OPTIONS);
+
+	acx100_s_set_wepkey(adev);
+
+	if (adev->wep_keys[adev->wep_current_index].size != 0) {
+		log(L_ASSOC, "setting active default WEP key number: %d\n",
+		    adev->wep_current_index);
+		dk.KeyID = adev->wep_current_index;
+		acx_s_configure(adev, &dk, ACX1xx_IE_DOT11_WEP_DEFAULT_KEY_SET);	/* 0x1010 */
+	}
+	/* FIXME!!! wep_key_struct is filled nowhere! But adev
+	 * is initialized to 0, and we don't REALLY need those keys either */
+/*		for (i = 0; i < 10; i++) {
+		if (adev->wep_key_struct[i].len != 0) {
+			MAC_COPY(wep_mgmt.MacAddr, adev->wep_key_struct[i].addr);
+			wep_mgmt.KeySize = cpu_to_le16(adev->wep_key_struct[i].len);
+			memcpy(&wep_mgmt.Key, adev->wep_key_struct[i].key, le16_to_cpu(wep_mgmt.KeySize));
+			wep_mgmt.Action = cpu_to_le16(1);
+			log(L_ASSOC, "writing WEP key %d (len %d)\n", i, le16_to_cpu(wep_mgmt.KeySize));
+			if (OK == acx_s_issue_cmd(adev, ACX1xx_CMD_WEP_MGMT, &wep_mgmt, sizeof(wep_mgmt))) {
+				adev->wep_key_struct[i].index = i;
+			}
+		}
+	}
+*/
+
+	/* now retrieve the updated WEPCacheEnd pointer... */
+	if (OK != acx_s_interrogate(adev, &pt, ACX1xx_IE_MEMORY_MAP)) {
+		printk("%s: ACX1xx_IE_MEMORY_MAP read #2 FAILED\n",
+		       wiphy_name(adev->ieee->wiphy));
+		goto fail;
+	}
+	/* ...and tell it to start allocating templates at that location */
+	/* (no endianness conversion needed) */
+	pt.PacketTemplateStart = pt.WEPCacheEnd;
+
+	if (OK != acx_s_configure(adev, &pt, ACX1xx_IE_MEMORY_MAP)) {
+		printk("%s: ACX1xx_IE_MEMORY_MAP write #2 FAILED\n",
+		       wiphy_name(adev->ieee->wiphy));
+		goto fail;
+	}
+	res = OK;
+
+      fail:
+	FN_EXIT1(res);
+	return res;
+}
+
+
+static int
+acx_s_init_max_template_generic(acx_device_t * adev, unsigned int len,
+				unsigned int cmd)
+{
+	int res;
+	union {
+		acx_template_nullframe_t null;
+		acx_template_beacon_t b;
+		acx_template_tim_t tim;
+		acx_template_probereq_t preq;
+		acx_template_proberesp_t presp;
+	} templ;
+
+	memset(&templ, 0, len);
+	templ.null.size = cpu_to_le16(len - 2);
+	res = acx_s_issue_cmd(adev, cmd, &templ, len);
+	return res;
+}
+
+static inline int acx_s_init_max_null_data_template(acx_device_t * adev)
+{
+	return acx_s_init_max_template_generic(adev,
+					       sizeof(acx_template_nullframe_t),
+					       ACX1xx_CMD_CONFIG_NULL_DATA);
+}
+
+static inline int acx_s_init_max_beacon_template(acx_device_t * adev)
+{
+	return acx_s_init_max_template_generic(adev,
+					       sizeof(acx_template_beacon_t),
+					       ACX1xx_CMD_CONFIG_BEACON);
+}
+
+static inline int acx_s_init_max_tim_template(acx_device_t * adev)
+{
+	return acx_s_init_max_template_generic(adev, sizeof(acx_template_tim_t),
+					       ACX1xx_CMD_CONFIG_TIM);
+}
+
+static inline int acx_s_init_max_probe_response_template(acx_device_t * adev)
+{
+	return acx_s_init_max_template_generic(adev,
+					       sizeof(acx_template_proberesp_t),
+					       ACX1xx_CMD_CONFIG_PROBE_RESPONSE);
+}
+
+static inline int acx_s_init_max_probe_request_template(acx_device_t * adev)
+{
+	return acx_s_init_max_template_generic(adev,
+					       sizeof(acx_template_probereq_t),
+					       ACX1xx_CMD_CONFIG_PROBE_REQUEST);
+}
+
+/***********************************************************************
+** acx_s_set_tim_template
+**
+** FIXME: In full blown driver we will regularly update partial virtual bitmap
+** by calling this function
+** (it can be done by irq handler on each DTIM irq or by timer...)
+
+[802.11 7.3.2.6] TIM information element:
+- 1 EID
+- 1 Length
+1 1 DTIM Count
+    indicates how many beacons (including this) appear before next DTIM
+    (0=this one is a DTIM)
+2 1 DTIM Period
+    number of beacons between successive DTIMs
+    (0=reserved, 1=all TIMs are DTIMs, 2=every other, etc)
+3 1 Bitmap Control
+    bit0: Traffic Indicator bit associated with Assoc ID 0 (Bcast AID?)
+    set to 1 in TIM elements with a value of 0 in the DTIM Count field
+    when one or more broadcast or multicast frames are buffered at the AP.
+    bit1-7: Bitmap Offset (logically Bitmap_Offset = Bitmap_Control & 0xFE).
+4 n Partial Virtual Bitmap
+    Visible part of traffic-indication bitmap.
+    Full bitmap consists of 2008 bits (251 octets) such that bit number N
+    (0<=N<=2007) in the bitmap corresponds to bit number (N mod 8)
+    in octet number N/8 where the low-order bit of each octet is bit0,
+    and the high order bit is bit7.
+    Each set bit in virtual bitmap corresponds to traffic buffered by AP
+    for a specific station (with corresponding AID?).
+    Partial Virtual Bitmap shows a part of bitmap which has non-zero.
+    Bitmap Offset is a number of skipped zero octets (see above).
+    'Missing' octets at the tail are also assumed to be zero.
+    Example: Length=6, Bitmap_Offset=2, Partial_Virtual_Bitmap=55 55 55
+    This means that traffic-indication bitmap is:
+    00000000 00000000 01010101 01010101 01010101 00000000 00000000...
+    (is bit0 in the map is always 0 and real value is in Bitmap Control bit0?)
+*/
+static int acx_s_set_tim_template(acx_device_t * adev)
+{
+/* For now, configure smallish test bitmap, all zero ("no pending data") */
+	enum { bitmap_size = 5 };
+
+	acx_template_tim_t t;
+	int result;
+
+	FN_ENTER;
+
+	memset(&t, 0, sizeof(t));
+	t.size = 5 + bitmap_size;	/* eid+len+count+period+bmap_ctrl + bmap */
+	t.tim_eid = WLAN_EID_TIM;
+	t.len = 3 + bitmap_size;	/* count+period+bmap_ctrl + bmap */
+	result = acx_s_issue_cmd(adev, ACX1xx_CMD_CONFIG_TIM, &t, sizeof(t));
+	FN_EXIT1(result);
+	return result;
+}
+
+
+
+
+#if POWER_SAVE_80211
+/***********************************************************************
+** acx_s_set_null_data_template
+*/
+static int acx_s_set_null_data_template(acx_device_t * adev)
+{
+	struct acx_template_nullframe b;
+	int result;
+
+	FN_ENTER;
+
+	/* memset(&b, 0, sizeof(b)); not needed, setting all members */
+
+	b.size = cpu_to_le16(sizeof(b) - 2);
+	b.hdr.fc = WF_FTYPE_MGMTi | WF_FSTYPE_NULLi;
+	b.hdr.dur = 0;
+	MAC_BCAST(b.hdr.a1);
+	MAC_COPY(b.hdr.a2, adev->dev_addr);
+	MAC_COPY(b.hdr.a3, adev->bssid);
+	b.hdr.seq = 0;
+
+	result =
+	    acx_s_issue_cmd(adev, ACX1xx_CMD_CONFIG_NULL_DATA, &b, sizeof(b));
+
+	FN_EXIT1(result);
+	return result;
+}
+#endif
+
+
+
+
+
+
+/***********************************************************************
+** acx_s_init_packet_templates()
+**
+** NOTE: order is very important here, to have a correct memory layout!
+** init templates: max Probe Request (station mode), max NULL data,
+** max Beacon, max TIM, max Probe Response.
+*/
+static int acx_s_init_packet_templates(acx_device_t * adev)
+{
+	acx_ie_memmap_t mm;	/* ACX100 only */
+	int result = NOT_OK;
+
+	FN_ENTER;
+
+	log(L_DEBUG | L_INIT, "initializing max packet templates\n");
+
+	if (OK != acx_s_init_max_probe_request_template(adev))
+		goto failed;
+
+	if (OK != acx_s_init_max_null_data_template(adev))
+		goto failed;
+
+	if (OK != acx_s_init_max_beacon_template(adev))
+		goto failed;
+
+	if (OK != acx_s_init_max_tim_template(adev))
+		goto failed;
+
+	if (OK != acx_s_init_max_probe_response_template(adev))
+		goto failed;
+
+	if (IS_ACX111(adev)) {
+		/* ACX111 doesn't need the memory map magic below,
+		 * and the other templates will be set later (acx_start) */
+		result = OK;
+		goto success;
+	}
+
+	/* ACX100 will have its TIM template set,
+	 * and we also need to update the memory map */
+
+	if (OK != acx_s_set_tim_template(adev))
+		goto failed_acx100;
+
+	log(L_DEBUG, "sizeof(memmap)=%d bytes\n", (int)sizeof(mm));
+
+	if (OK != acx_s_interrogate(adev, &mm, ACX1xx_IE_MEMORY_MAP))
+		goto failed_acx100;
+
+	mm.QueueStart = cpu_to_le32(le32_to_cpu(mm.PacketTemplateEnd) + 4);
+	if (OK != acx_s_configure(adev, &mm, ACX1xx_IE_MEMORY_MAP))
+		goto failed_acx100;
+
+	result = OK;
+	goto success;
+
+      failed_acx100:
+	log(L_DEBUG | L_INIT,
+	    /* "cb=0x%X\n" */
+	    "ACXMemoryMap:\n"
+	    ".CodeStart=0x%X\n"
+	    ".CodeEnd=0x%X\n"
+	    ".WEPCacheStart=0x%X\n"
+	    ".WEPCacheEnd=0x%X\n"
+	    ".PacketTemplateStart=0x%X\n" ".PacketTemplateEnd=0x%X\n",
+	    /* len, */
+	    le32_to_cpu(mm.CodeStart),
+	    le32_to_cpu(mm.CodeEnd),
+	    le32_to_cpu(mm.WEPCacheStart),
+	    le32_to_cpu(mm.WEPCacheEnd),
+	    le32_to_cpu(mm.PacketTemplateStart),
+	    le32_to_cpu(mm.PacketTemplateEnd));
+
+      failed:
+	printk("%s: %s() FAILED\n", wiphy_name(adev->ieee->wiphy), __func__);
+
+      success:
+	FN_EXIT1(result);
+	return result;
+}
+
+
+
+/***********************************************************************
+** acx_s_init_mac
+*/
+int acx_s_init_mac(acx_device_t * adev)
+{
+	int result = NOT_OK;
+
+	FN_ENTER;
+
+	if (IS_ACX111(adev)) {
+		adev->ie_len = acx111_ie_len;
+		adev->ie_len_dot11 = acx111_ie_len_dot11;
+	} else {
+		adev->ie_len = acx100_ie_len;
+		adev->ie_len_dot11 = acx100_ie_len_dot11;
+	}
+
+	if (IS_PCI(adev)) {
+		adev->memblocksize = 256;	/* 256 is default */
+		/* try to load radio for both ACX100 and ACX111, since both
+		 * chips have at least some firmware versions making use of an
+		 * external radio module */
+		acxpci_s_upload_radio(adev);
+	} else {
+		adev->memblocksize = 128;
+	}
+
+	if (IS_ACX111(adev)) {
+		/* for ACX111, the order is different from ACX100
+		   1. init packet templates
+		   2. create station context and create dma regions
+		   3. init wep default keys
+		 */
+		if (OK != acx_s_init_packet_templates(adev))
+			goto fail;
+		if (OK != acx111_s_create_dma_regions(adev)) {
+			printk("%s: acx111_create_dma_regions FAILED\n",
+			       wiphy_name(adev->ieee->wiphy));
+			goto fail;
+		}
+	} else {
+		if (OK != acx100_s_init_wep(adev))
+			goto fail;
+		if (OK != acx_s_init_packet_templates(adev))
+			goto fail;
+		if (OK != acx100_s_create_dma_regions(adev)) {
+			printk("%s: acx100_create_dma_regions FAILED\n",
+			       wiphy_name(adev->ieee->wiphy));
+			goto fail;
+		}
+	}
+
+	SET_IEEE80211_PERM_ADDR(adev->ieee, adev->dev_addr);
+	result = OK;
+
+      fail:
+	if (result)
+		printk("acx: init_mac() FAILED\n");
+	FN_EXIT1(result);
+	return result;
+}
+
+
+
+#if POWER_SAVE_80211
+static void acx_s_update_80211_powersave_mode(acx_device_t * adev)
+{
+	/* merge both structs in a union to be able to have common code */
+	union {
+		acx111_ie_powersave_t acx111;
+		acx100_ie_powersave_t acx100;
+	} pm;
+
+	/* change 802.11 power save mode settings */
+	log(L_INIT, "updating 802.11 power save mode settings: "
+	    "wakeup_cfg 0x%02X, listen interval %u, "
+	    "options 0x%02X, hangover period %u, "
+	    "enhanced_ps_transition_time %u\n",
+	    adev->ps_wakeup_cfg, adev->ps_listen_interval,
+	    adev->ps_options, adev->ps_hangover_period,
+	    adev->ps_enhanced_transition_time);
+	acx_s_interrogate(adev, &pm, ACX1xx_IE_POWER_MGMT);
+	log(L_INIT, "Previous PS mode settings: wakeup_cfg 0x%02X, "
+	    "listen interval %u, options 0x%02X, "
+	    "hangover period %u, "
+	    "enhanced_ps_transition_time %u, beacon_rx_time %u\n",
+	    pm.acx111.wakeup_cfg,
+	    pm.acx111.listen_interval,
+	    pm.acx111.options,
+	    pm.acx111.hangover_period,
+	    IS_ACX111(adev) ?
+	    pm.acx111.enhanced_ps_transition_time
+	    : pm.acx100.enhanced_ps_transition_time,
+	    IS_ACX111(adev) ? pm.acx111.beacon_rx_time : (u32) - 1);
+	pm.acx111.wakeup_cfg = adev->ps_wakeup_cfg;
+	pm.acx111.listen_interval = adev->ps_listen_interval;
+	pm.acx111.options = adev->ps_options;
+	pm.acx111.hangover_period = adev->ps_hangover_period;
+	if (IS_ACX111(adev)) {
+		pm.acx111.beacon_rx_time = cpu_to_le32(adev->ps_beacon_rx_time);
+		pm.acx111.enhanced_ps_transition_time =
+		    cpu_to_le32(adev->ps_enhanced_transition_time);
+	} else {
+		pm.acx100.enhanced_ps_transition_time =
+		    cpu_to_le16(adev->ps_enhanced_transition_time);
+	}
+	acx_s_configure(adev, &pm, ACX1xx_IE_POWER_MGMT);
+	acx_s_interrogate(adev, &pm, ACX1xx_IE_POWER_MGMT);
+	log(L_INIT, "wakeup_cfg: 0x%02X\n", pm.acx111.wakeup_cfg);
+	acx_s_msleep(40);
+	acx_s_interrogate(adev, &pm, ACX1xx_IE_POWER_MGMT);
+	log(L_INIT, "wakeup_cfg: 0x%02X\n", pm.acx111.wakeup_cfg);
+	log(L_INIT, "power save mode change %s\n",
+	    (pm.acx111.
+	     wakeup_cfg & PS_CFG_PENDING) ? "FAILED" : "was successful");
+	/* FIXME: maybe verify via PS_CFG_PENDING bit here
+	 * that power save mode change was successful. */
+	/* FIXME: we shouldn't trigger a scan immediately after
+	 * fiddling with power save mode (since the firmware is sending
+	 * a NULL frame then). */
+}
+#endif
+
+
+/***********************************************************************
+** acx_s_update_card_settings
+**
+** Applies accumulated changes in various adev->xxxx members
+** Called by ioctl commit handler, acx_start, acx_set_defaults,
+** acx_s_after_interrupt_task (if IRQ_CMD_UPDATE_CARD_CFG),
+*/
+void acx_s_set_sane_reg_domain(acx_device_t * adev, int do_set)
+{
+
+	FIXME();
+	if (do_set) {
+		acx_ie_generic_t dom;
+		dom.m.bytes[0] = adev->reg_dom_id;
+		acx_s_configure(adev, &dom, ACX1xx_IE_DOT11_CURRENT_REG_DOMAIN);
+	}
+
+}
+
+static void acx111_s_sens_radio_16_17(acx_device_t * adev)
+{
+	u32 feature1, feature2;
+
+	if ((adev->sensitivity < 1) || (adev->sensitivity > 3)) {
+		printk("%s: invalid sensitivity setting (1..3), "
+		       "setting to 1\n", wiphy_name(adev->ieee->wiphy));
+		adev->sensitivity = 1;
+	}
+	acx111_s_get_feature_config(adev, &feature1, &feature2);
+	CLEAR_BIT(feature1, FEATURE1_LOW_RX | FEATURE1_EXTRA_LOW_RX);
+	if (adev->sensitivity > 1)
+		SET_BIT(feature1, FEATURE1_LOW_RX);
+	if (adev->sensitivity > 2)
+		SET_BIT(feature1, FEATURE1_EXTRA_LOW_RX);
+	acx111_s_feature_set(adev, feature1, feature2);
+}
+
+
+void acx_s_update_card_settings(acx_device_t * adev)
+{
+	unsigned long flags;
+	unsigned int start_scan = 0;
+	int i;
+
+	FN_ENTER;
+
+	log(L_INIT, "get_mask 0x%08X, set_mask 0x%08X\n",
+	    adev->get_mask, adev->set_mask);
+
+	/* Track dependencies betweed various settings */
+
+	if (adev->set_mask & (GETSET_MODE | GETSET_RESCAN | GETSET_WEP)) {
+		log(L_INIT, "important setting has been changed. "
+		    "Need to update packet templates, too\n");
+		SET_BIT(adev->set_mask, SET_TEMPLATES);
+	}
+	if (adev->set_mask & GETSET_CHANNEL) {
+		/* This will actually tune RX/TX to the channel */
+		SET_BIT(adev->set_mask, GETSET_RX | GETSET_TX);
+		switch (adev->mode) {
+		case ACX_MODE_0_ADHOC:
+		case ACX_MODE_3_AP:
+			/* Beacons contain channel# - update them */
+			SET_BIT(adev->set_mask, SET_TEMPLATES);
+		}
+
+		switch (adev->mode) {
+		case ACX_MODE_0_ADHOC:
+		case ACX_MODE_2_STA:
+			start_scan = 1;
+		}
+	}
+
+	/* Apply settings */
+
+
+	if (adev->get_mask & GETSET_STATION_ID) {
+		u8 stationID[4 + ACX1xx_IE_DOT11_STATION_ID_LEN];
+		const u8 *paddr;
+
+		acx_s_interrogate(adev, &stationID, ACX1xx_IE_DOT11_STATION_ID);
+		paddr = &stationID[4];
+//		memcpy(adev->dev_addr, adev->ndev->dev_addr, ETH_ALEN);
+		for (i = 0; i < ETH_ALEN; i++) {
+			/* we copy the MAC address (reversed in
+			 * the card) to the netdevice's MAC
+			 * address, and on ifup it will be
+			 * copied into iwadev->dev_addr */
+			adev->dev_addr[ETH_ALEN - 1 - i] = paddr[i];
+		}
+		SET_IEEE80211_PERM_ADDR(adev->ieee,adev->dev_addr);
+		CLEAR_BIT(adev->get_mask, GETSET_STATION_ID);
+	}
+
+	if (adev->get_mask & GETSET_SENSITIVITY) {
+		if ((RADIO_RFMD_11 == adev->radio_type)
+		    || (RADIO_MAXIM_0D == adev->radio_type)
+		    || (RADIO_RALINK_15 == adev->radio_type)) {
+			acx_s_read_phy_reg(adev, 0x30, &adev->sensitivity);
+		} else {
+			log(L_INIT, "don't know how to get sensitivity "
+			    "for radio type 0x%02X\n", adev->radio_type);
+			adev->sensitivity = 0;
+		}
+		log(L_INIT, "got sensitivity value %u\n", adev->sensitivity);
+
+		CLEAR_BIT(adev->get_mask, GETSET_SENSITIVITY);
+	}
+
+	if (adev->get_mask & GETSET_ANTENNA) {
+		u8 antenna[4 + ACX1xx_IE_DOT11_CURRENT_ANTENNA_LEN];
+
+		memset(antenna, 0, sizeof(antenna));
+		acx_s_interrogate(adev, antenna,
+				  ACX1xx_IE_DOT11_CURRENT_ANTENNA);
+		adev->antenna = antenna[4];
+		log(L_INIT, "got antenna value 0x%02X\n", adev->antenna);
+		CLEAR_BIT(adev->get_mask, GETSET_ANTENNA);
+	}
+
+	if (adev->get_mask & GETSET_ED_THRESH) {
+		if (IS_ACX100(adev)) {
+			u8 ed_threshold[4 + ACX100_IE_DOT11_ED_THRESHOLD_LEN];
+
+			memset(ed_threshold, 0, sizeof(ed_threshold));
+			acx_s_interrogate(adev, ed_threshold,
+					  ACX100_IE_DOT11_ED_THRESHOLD);
+			adev->ed_threshold = ed_threshold[4];
+		} else {
+			log(L_INIT, "acx111 doesn't support ED\n");
+			adev->ed_threshold = 0;
+		}
+		log(L_INIT, "got Energy Detect (ED) threshold %u\n",
+		    adev->ed_threshold);
+		CLEAR_BIT(adev->get_mask, GETSET_ED_THRESH);
+	}
+
+	if (adev->get_mask & GETSET_CCA) {
+		if (IS_ACX100(adev)) {
+			u8 cca[4 + ACX1xx_IE_DOT11_CURRENT_CCA_MODE_LEN];
+
+			memset(cca, 0, sizeof(adev->cca));
+			acx_s_interrogate(adev, cca,
+					  ACX1xx_IE_DOT11_CURRENT_CCA_MODE);
+			adev->cca = cca[4];
+		} else {
+			log(L_INIT, "acx111 doesn't support CCA\n");
+			adev->cca = 0;
+		}
+		log(L_INIT, "got Channel Clear Assessment (CCA) value %u\n",
+		    adev->cca);
+		CLEAR_BIT(adev->get_mask, GETSET_CCA);
+	}
+
+	if (adev->get_mask & GETSET_REG_DOMAIN) {
+		acx_ie_generic_t dom;
+
+		acx_s_interrogate(adev, &dom,
+				  ACX1xx_IE_DOT11_CURRENT_REG_DOMAIN);
+		adev->reg_dom_id = dom.m.bytes[0];
+		acx_s_set_sane_reg_domain(adev, 0);
+		log(L_INIT, "got regulatory domain 0x%02X\n", adev->reg_dom_id);
+		CLEAR_BIT(adev->get_mask, GETSET_REG_DOMAIN);
+	}
+
+	if (adev->set_mask & GETSET_STATION_ID) {
+		u8 stationID[4 + ACX1xx_IE_DOT11_STATION_ID_LEN];
+		u8 *paddr;
+
+		paddr = &stationID[4];
+		MAC_COPY(adev->dev_addr, adev->ieee->wiphy->perm_addr);
+		for (i = 0; i < ETH_ALEN; i++) {
+			/* copy the MAC address we obtained when we noticed
+			 * that the ethernet iface's MAC changed
+			 * to the card (reversed in
+			 * the card!) */
+			paddr[i] = adev->dev_addr[ETH_ALEN - 1 - i];
+		}
+		acx_s_configure(adev, &stationID, ACX1xx_IE_DOT11_STATION_ID);
+		CLEAR_BIT(adev->set_mask, GETSET_STATION_ID);
+	}
+
+	if (adev->set_mask & SET_STA_LIST) {
+		acx_lock(adev, flags);
+		CLEAR_BIT(adev->set_mask, SET_STA_LIST);
+		acx_unlock(adev, flags);
+	}
+	if (adev->set_mask & SET_RATE_FALLBACK) {
+		u8 rate[4 + ACX1xx_IE_RATE_FALLBACK_LEN];
+
+		/* configure to not do fallbacks when not in auto rate mode */
+		rate[4] =
+		    (adev->
+		     rate_auto) ? /* adev->txrate_fallback_retries */ 1 : 0;
+		log(L_INIT, "updating Tx fallback to %u retries\n", rate[4]);
+		acx_s_configure(adev, &rate, ACX1xx_IE_RATE_FALLBACK);
+		CLEAR_BIT(adev->set_mask, SET_RATE_FALLBACK);
+	}
+	if (adev->set_mask & GETSET_TXPOWER) {
+		log(L_INIT, "updating transmit power: %u dBm\n",
+		    adev->tx_level_dbm);
+		acx_s_set_tx_level(adev, adev->tx_level_dbm);
+		CLEAR_BIT(adev->set_mask, GETSET_TXPOWER);
+	}
+
+	if (adev->set_mask & GETSET_SENSITIVITY) {
+		log(L_INIT, "updating sensitivity value: %u\n",
+		    adev->sensitivity);
+		switch (adev->radio_type) {
+		case RADIO_RFMD_11:
+		case RADIO_MAXIM_0D:
+		case RADIO_RALINK_15:
+			acx_s_write_phy_reg(adev, 0x30, adev->sensitivity);
+			break;
+		case RADIO_RADIA_16:
+		case RADIO_UNKNOWN_17:
+			acx111_s_sens_radio_16_17(adev);
+			break;
+		default:
+			log(L_INIT, "don't know how to modify sensitivity "
+			    "for radio type 0x%02X\n", adev->radio_type);
+		}
+		CLEAR_BIT(adev->set_mask, GETSET_SENSITIVITY);
+	}
+
+	if (adev->set_mask & GETSET_ANTENNA) {
+		/* antenna */
+		u8 antenna[4 + ACX1xx_IE_DOT11_CURRENT_ANTENNA_LEN];
+
+		memset(antenna, 0, sizeof(antenna));
+		antenna[4] = adev->antenna;
+		log(L_INIT, "updating antenna value: 0x%02X\n", adev->antenna);
+		acx_s_configure(adev, &antenna,
+				ACX1xx_IE_DOT11_CURRENT_ANTENNA);
+		CLEAR_BIT(adev->set_mask, GETSET_ANTENNA);
+	}
+
+	if (adev->set_mask & GETSET_ED_THRESH) {
+		/* ed_threshold */
+		log(L_INIT, "updating Energy Detect (ED) threshold: %u\n",
+		    adev->ed_threshold);
+		if (IS_ACX100(adev)) {
+			u8 ed_threshold[4 + ACX100_IE_DOT11_ED_THRESHOLD_LEN];
+
+			memset(ed_threshold, 0, sizeof(ed_threshold));
+			ed_threshold[4] = adev->ed_threshold;
+			acx_s_configure(adev, &ed_threshold,
+					ACX100_IE_DOT11_ED_THRESHOLD);
+		} else
+			log(L_INIT, "acx111 doesn't support ED!\n");
+		CLEAR_BIT(adev->set_mask, GETSET_ED_THRESH);
+	}
+
+	if (adev->set_mask & GETSET_CCA) {
+		/* CCA value */
+		log(L_INIT, "updating Channel Clear Assessment "
+		    "(CCA) value: 0x%02X\n", adev->cca);
+		if (IS_ACX100(adev)) {
+			u8 cca[4 + ACX1xx_IE_DOT11_CURRENT_CCA_MODE_LEN];
+
+			memset(cca, 0, sizeof(cca));
+			cca[4] = adev->cca;
+			acx_s_configure(adev, &cca,
+					ACX1xx_IE_DOT11_CURRENT_CCA_MODE);
+		} else
+			log(L_INIT, "acx111 doesn't support CCA!\n");
+		CLEAR_BIT(adev->set_mask, GETSET_CCA);
+	}
+
+	if (adev->set_mask & GETSET_LED_POWER) {
+		/* Enable Tx */
+		log(L_INIT, "updating power LED status: %u\n", adev->led_power);
+
+		acx_lock(adev, flags);
+		if (IS_PCI(adev))
+			acxpci_l_power_led(adev, adev->led_power);
+		CLEAR_BIT(adev->set_mask, GETSET_LED_POWER);
+		acx_unlock(adev, flags);
+	}
+
+	if (adev->set_mask & GETSET_POWER_80211) {
+#if POWER_SAVE_80211
+		acx_s_update_80211_powersave_mode(adev);
+#endif
+		CLEAR_BIT(adev->set_mask, GETSET_POWER_80211);
+	}
+
+	if (adev->set_mask & GETSET_CHANNEL) {
+		/* channel */
+		log(L_INIT, "updating channel to: %u\n", adev->channel);
+		CLEAR_BIT(adev->set_mask, GETSET_CHANNEL);
+	}
+
+	if (adev->set_mask & GETSET_TX) {
+		/* set Tx */
+		log(L_INIT, "updating: %s Tx\n",
+		    adev->tx_disabled ? "disable" : "enable");
+		if (adev->tx_disabled)
+			acx_s_issue_cmd(adev, ACX1xx_CMD_DISABLE_TX, NULL, 0);
+		else {
+			acx_s_issue_cmd(adev, ACX1xx_CMD_ENABLE_TX,
+					&adev->channel, 1);
+			FIXME();
+			/* This needs to be keyed on WEP? */
+//			acx111_s_feature_on(adev, 0,
+//					    FEATURE2_NO_TXCRYPT |
+//					    FEATURE2_SNIFFER);
+		}
+		CLEAR_BIT(adev->set_mask, GETSET_TX);
+	}
+
+	if (adev->set_mask & GETSET_RX) {
+		/* Enable Rx */
+		log(L_INIT, "updating: enable Rx on channel: %u\n",
+		    adev->channel);
+		acx_s_issue_cmd(adev, ACX1xx_CMD_ENABLE_RX, &adev->channel, 1);
+		CLEAR_BIT(adev->set_mask, GETSET_RX);
+	}
+
+	if (adev->set_mask & GETSET_RETRY) {
+		u8 short_retry[4 + ACX1xx_IE_DOT11_SHORT_RETRY_LIMIT_LEN];
+		u8 long_retry[4 + ACX1xx_IE_DOT11_LONG_RETRY_LIMIT_LEN];
+
+		log(L_INIT,
+		    "updating short retry limit: %u, long retry limit: %u\n",
+		    adev->short_retry, adev->long_retry);
+		short_retry[0x4] = adev->short_retry;
+		long_retry[0x4] = adev->long_retry;
+		acx_s_configure(adev, &short_retry,
+				ACX1xx_IE_DOT11_SHORT_RETRY_LIMIT);
+		acx_s_configure(adev, &long_retry,
+				ACX1xx_IE_DOT11_LONG_RETRY_LIMIT);
+		CLEAR_BIT(adev->set_mask, GETSET_RETRY);
+	}
+
+	if (adev->set_mask & SET_MSDU_LIFETIME) {
+		u8 xmt_msdu_lifetime[4 +
+				     ACX1xx_IE_DOT11_MAX_XMIT_MSDU_LIFETIME_LEN];
+
+		log(L_INIT, "updating tx MSDU lifetime: %u\n",
+		    adev->msdu_lifetime);
+		*(u32 *) & xmt_msdu_lifetime[4] =
+		    cpu_to_le32((u32) adev->msdu_lifetime);
+		acx_s_configure(adev, &xmt_msdu_lifetime,
+				ACX1xx_IE_DOT11_MAX_XMIT_MSDU_LIFETIME);
+		CLEAR_BIT(adev->set_mask, SET_MSDU_LIFETIME);
+	}
+
+	if (adev->set_mask & GETSET_REG_DOMAIN) {
+		log(L_INIT, "updating regulatory domain: 0x%02X\n",
+		    adev->reg_dom_id);
+		acx_s_set_sane_reg_domain(adev, 1);
+		CLEAR_BIT(adev->set_mask, GETSET_REG_DOMAIN);
+	}
+	if (adev->set_mask & GETSET_MODE ) {
+		acx111_s_feature_on(adev, 0,
+				    FEATURE2_NO_TXCRYPT | FEATURE2_SNIFFER);
+		switch (adev->mode) {
+		case ACX_MODE_3_AP:
+			adev->aid = 0;
+			//acx111_s_feature_off(adev, 0,
+			//	    FEATURE2_NO_TXCRYPT | FEATURE2_SNIFFER);
+			MAC_COPY(adev->bssid,adev->dev_addr);
+			acx_s_cmd_join_bssid(adev,adev->dev_addr);
+			break;
+		case ACX_MODE_MONITOR:
+			SET_BIT(adev->set_mask, SET_RXCONFIG | SET_WEP_OPTIONS);
+			break;
+		case ACX_MODE_0_ADHOC:
+		case ACX_MODE_2_STA:
+                	acx111_s_feature_on(adev, 0, FEATURE2_NO_TXCRYPT | FEATURE2_SNIFFER);
+			break;
+		default:
+			break;
+		}
+		CLEAR_BIT(adev->set_mask, GETSET_MODE);
+	}
+	if (adev->set_mask & SET_TEMPLATES) {
+		switch (adev->mode)
+		{
+			case ACX_MODE_3_AP:
+				acx_s_set_tim_template(adev);
+				break;
+			default:
+				break;
+		}
+		if (adev->beacon_cache)
+		{
+			acx_s_set_beacon_template(adev, adev->beacon_cache);
+			dev_kfree_skb(adev->beacon_cache);
+			adev->beacon_cache = NULL;
+		}
+		CLEAR_BIT(adev->set_mask, SET_TEMPLATES);
+	}
+
+	if (adev->set_mask & SET_RXCONFIG) {
+		acx_s_initialize_rx_config(adev);
+		CLEAR_BIT(adev->set_mask, SET_RXCONFIG);
+	}
+
+	if (adev->set_mask & GETSET_RESCAN) {
+/*		switch (adev->mode) {
+		case ACX_MODE_0_ADHOC:
+		case ACX_MODE_2_STA:
+			start_scan = 1;
+			break;
+		}
+*/ CLEAR_BIT(adev->set_mask, GETSET_RESCAN);
+	}
+
+	if (adev->set_mask & GETSET_WEP) {
+		/* encode */
+
+		ie_dot11WEPDefaultKeyID_t dkey;
+#ifdef DEBUG_WEP
+		struct {
+			u16 type;
+			u16 len;
+			u8 val;
+		} ACX_PACKED keyindic;
+#endif
+		log(L_INIT, "updating WEP key settings\n");
+
+		acx_s_set_wepkey(adev);
+		if (adev->wep_enabled) {
+			dkey.KeyID = adev->wep_current_index;
+			log(L_INIT, "setting WEP key %u as default\n",
+			    dkey.KeyID);
+			acx_s_configure(adev, &dkey,
+					ACX1xx_IE_DOT11_WEP_DEFAULT_KEY_SET);
+#ifdef DEBUG_WEP
+			keyindic.val = 3;
+			acx_s_configure(adev, &keyindic, ACX111_IE_KEY_CHOOSE);
+#endif
+		}
+
+//		start_scan = 1;
+		CLEAR_BIT(adev->set_mask, GETSET_WEP);
+	}
+
+	if (adev->set_mask & SET_WEP_OPTIONS) {
+		acx100_ie_wep_options_t options;
+
+		if (IS_ACX111(adev)) {
+			log(L_DEBUG,
+			    "setting WEP Options for acx111 is not supported\n");
+		} else {
+			log(L_INIT, "setting WEP Options\n");
+
+			/* let's choose maximum setting: 4 default keys,
+			 * plus 10 other keys: */
+			options.NumKeys =
+			    cpu_to_le16(DOT11_MAX_DEFAULT_WEP_KEYS + 10);
+			/* don't decrypt default key only,
+			 * don't override decryption: */
+			options.WEPOption = 0;
+			if (adev->mode == ACX_MODE_3_AP) {
+				/* don't decrypt default key only,
+				 * override decryption mechanism: */
+				options.WEPOption = 2;
+			}
+
+			acx_s_configure(adev, &options, ACX100_IE_WEP_OPTIONS);
+		}
+		CLEAR_BIT(adev->set_mask, SET_WEP_OPTIONS);
+	}
+
+
+	/* debug, rate, and nick don't need any handling */
+	/* what about sniffing mode?? */
+
+/*	log(L_INIT, "get_mask 0x%08X, set_mask 0x%08X - after update\n",
+	    adev->get_mask, adev->set_mask);
+*/
+/* end: */
+	FN_EXIT0;
+}
+
+#if 0
+/***********************************************************************
+** acx_e_after_interrupt_task
+*/
+static int acx_s_recalib_radio(acx_device_t * adev)
+{
+	if (IS_ACX111(adev)) {
+		acx111_cmd_radiocalib_t cal;
+
+		/* automatic recalibration, choose all methods: */
+		cal.methods = cpu_to_le32(0x8000000f);
+		/* automatic recalibration every 60 seconds (value in TUs)
+		 * I wonder what the firmware default here is? */
+		cal.interval = cpu_to_le32(58594);
+		return acx_s_issue_cmd_timeo(adev, ACX111_CMD_RADIOCALIB,
+					     &cal, sizeof(cal),
+					     CMD_TIMEOUT_MS(100));
+	} else {
+		/* On ACX100, we need to recalibrate the radio
+		 * by issuing a GETSET_TX|GETSET_RX */
+		if (		/* (OK == acx_s_issue_cmd(adev, ACX1xx_CMD_DISABLE_TX, NULL, 0)) &&
+				   (OK == acx_s_issue_cmd(adev, ACX1xx_CMD_DISABLE_RX, NULL, 0)) && */
+			   (OK ==
+			    acx_s_issue_cmd(adev, ACX1xx_CMD_ENABLE_TX,
+					    &adev->channel, 1))
+			   && (OK ==
+			       acx_s_issue_cmd(adev, ACX1xx_CMD_ENABLE_RX,
+					       &adev->channel, 1)))
+			return OK;
+		return NOT_OK;
+	}
+}
+#endif // if 0
+#if 0
+static void acx_s_after_interrupt_recalib(acx_device_t * adev)
+{
+	int res;
+
+	/* this helps with ACX100 at least;
+	 * hopefully ACX111 also does a
+	 * recalibration here */
+
+	/* clear flag beforehand, since we want to make sure
+	 * it's cleared; then only set it again on specific circumstances */
+	CLEAR_BIT(adev->after_interrupt_jobs, ACX_AFTER_IRQ_CMD_RADIO_RECALIB);
+
+	/* better wait a bit between recalibrations to
+	 * prevent overheating due to torturing the card
+	 * into working too long despite high temperature
+	 * (just a safety measure) */
+	if (adev->recalib_time_last_success
+	    && time_before(jiffies, adev->recalib_time_last_success
+			   + RECALIB_PAUSE * 60 * HZ)) {
+		if (adev->recalib_msg_ratelimit <= 4) {
+			printk("%s: less than " STRING(RECALIB_PAUSE)
+			       " minutes since last radio recalibration, "
+			       "not recalibrating (maybe card is too hot?)\n",
+			       wiphy_name(adev->ieee->wiphy));
+			adev->recalib_msg_ratelimit++;
+			if (adev->recalib_msg_ratelimit == 5)
+				printk("disabling above message until next recalib\n");
+		}
+		return;
+	}
+
+	adev->recalib_msg_ratelimit = 0;
+
+	/* note that commands sometimes fail (card busy),
+	 * so only clear flag if we were fully successful */
+	res = acx_s_recalib_radio(adev);
+	if (res == OK) {
+		printk("%s: successfully recalibrated radio\n",
+		       wiphy_name(adev->ieee->wiphy));
+		adev->recalib_time_last_success = jiffies;
+		adev->recalib_failure_count = 0;
+	} else {
+		/* failed: resubmit, but only limited
+		 * amount of times within some time range
+		 * to prevent endless loop */
+
+		adev->recalib_time_last_success = 0;	/* we failed */
+
+		/* if some time passed between last
+		 * attempts, then reset failure retry counter
+		 * to be able to do next recalib attempt */
+		if (time_after
+		    (jiffies, adev->recalib_time_last_attempt + 5 * HZ))
+			adev->recalib_failure_count = 0;
+
+		if (adev->recalib_failure_count < 5) {
+			/* increment inside only, for speedup of outside path */
+			adev->recalib_failure_count++;
+			adev->recalib_time_last_attempt = jiffies;
+			acx_schedule_task(adev,
+					  ACX_AFTER_IRQ_CMD_RADIO_RECALIB);
+		}
+	}
+}
+#endif // if 0
+
+void acx_e_after_interrupt_task(struct work_struct *work)
+{
+       acx_device_t *adev = container_of(work, acx_device_t, after_interrupt_task);
+	unsigned int flags;
+	FN_ENTER;
+	acx_lock(adev, flags);
+	if (!adev->after_interrupt_jobs || !adev->initialized) 
+		goto end;	/* no jobs to do */
+
+	/* we see lotsa tx errors */
+	if (adev->after_interrupt_jobs & ACX_AFTER_IRQ_CMD_RADIO_RECALIB) {
+//		acx_s_after_interrupt_recalib(adev);
+	}
+
+	/* a poor interrupt code wanted to do update_card_settings() */
+	if (adev->after_interrupt_jobs & ACX_AFTER_IRQ_UPDATE_CARD_CFG) {
+		if (ACX_STATE_IFACE_UP & adev->dev_state_mask)
+			acx_s_update_card_settings(adev);
+		CLEAR_BIT(adev->after_interrupt_jobs,
+			  ACX_AFTER_IRQ_UPDATE_CARD_CFG);
+	}
+	/* 1) we detected that no Scan_Complete IRQ came from fw, or
+	 ** 2) we found too many STAs */
+	if (adev->after_interrupt_jobs & ACX_AFTER_IRQ_CMD_STOP_SCAN) {
+		log(L_IRQ, "sending a stop scan cmd...\n");
+		acx_s_issue_cmd(adev, ACX1xx_CMD_STOP_SCAN, NULL, 0);
+		/* HACK: set the IRQ bit, since we won't get a
+		 * scan complete IRQ any more on ACX111 (works on ACX100!),
+		 * since _we_, not a fw, have stopped the scan */
+		SET_BIT(adev->irq_status, HOST_INT_SCAN_COMPLETE);
+		CLEAR_BIT(adev->after_interrupt_jobs,
+			  ACX_AFTER_IRQ_CMD_STOP_SCAN);
+	}
+
+	/* either fw sent Scan_Complete or we detected that
+	 ** no Scan_Complete IRQ came from fw. Finish scanning,
+	 ** pick join partner if any */
+	if (adev->after_interrupt_jobs & ACX_AFTER_IRQ_COMPLETE_SCAN) {
+		/* + scan kills current join status - restore it
+		 **   (do we need it for STA?) */
+		/* + does it happen only with active scans?
+		 **   active and passive scans? ALL scans including
+		 **   background one? */
+		/* + was not verified that everything is restored
+		 **   (but at least we start to emit beacons again) */
+		CLEAR_BIT(adev->after_interrupt_jobs,
+			  ACX_AFTER_IRQ_COMPLETE_SCAN);
+	}
+
+	/* STA auth or assoc timed out, start over again */
+
+	if (adev->after_interrupt_jobs & ACX_AFTER_IRQ_RESTART_SCAN) {
+		log(L_IRQ, "sending a start_scan cmd...\n");
+		CLEAR_BIT(adev->after_interrupt_jobs,
+			  ACX_AFTER_IRQ_RESTART_SCAN);
+	}
+
+	/* whee, we got positive assoc response! 8) */
+	if (adev->after_interrupt_jobs & ACX_AFTER_IRQ_CMD_ASSOCIATE) {
+		CLEAR_BIT(adev->after_interrupt_jobs,
+			  ACX_AFTER_IRQ_CMD_ASSOCIATE);
+	}
+      end:
+	if(adev->after_interrupt_jobs)
+	{
+		printk("Jobs still to be run: %x\n",adev->after_interrupt_jobs);
+		adev->after_interrupt_jobs = 0;
+	}
+	acx_unlock(adev, flags);
+//      acx_sem_unlock(adev);
+	FN_EXIT0;
+}
+
+
+/***********************************************************************
+** acx_schedule_task
+**
+** Schedule the call of the after_interrupt method after leaving
+** the interrupt context.
+*/
+void acx_schedule_task(acx_device_t * adev, unsigned int set_flag)
+{
+	if (!adev->after_interrupt_jobs)
+	{
+		SET_BIT(adev->after_interrupt_jobs, set_flag);
+		schedule_work(&adev->after_interrupt_task);
+	}
+}
+
+
+/***********************************************************************
+*/
+void acx_init_task_scheduler(acx_device_t * adev)
+{
+	/* configure task scheduler */
+	INIT_WORK(&adev->after_interrupt_task, acx_interrupt_tasklet);
+}
+
+
+/***********************************************************************
+** acx_s_start
+*/
+void acx_s_start(acx_device_t * adev)
+{
+	FN_ENTER;
+
+	/*
+	 * Ok, now we do everything that can possibly be done with ioctl
+	 * calls to make sure that when it was called before the card
+	 * was up we get the changes asked for
+	 */
+
+	SET_BIT(adev->set_mask, SET_TEMPLATES | SET_STA_LIST | GETSET_WEP
+		| GETSET_TXPOWER | GETSET_ANTENNA | GETSET_ED_THRESH |
+		GETSET_CCA | GETSET_REG_DOMAIN | GETSET_MODE | GETSET_CHANNEL |
+		GETSET_TX | GETSET_RX | GETSET_STATION_ID);
+
+	log(L_INIT, "updating initial settings on iface activation\n");
+	acx_s_update_card_settings(adev);
+
+	FN_EXIT0;
+}
+
+
+/***********************************************************************
+** acx_update_capabilities
+*//*
+void acx_update_capabilities(acx_device_t * adev)
+{
+	u16 cap = 0;
+
+	switch (adev->mode) {
+	case ACX_MODE_3_AP:
+		SET_BIT(cap, WF_MGMT_CAP_ESS);
+		break;
+	case ACX_MODE_0_ADHOC:
+		SET_BIT(cap, WF_MGMT_CAP_IBSS);
+		break;
+*/		/* other types of stations do not emit beacons */
+/*	}
+
+	if (adev->wep_restricted) {
+		SET_BIT(cap, WF_MGMT_CAP_PRIVACY);
+	}
+	if (adev->cfgopt_dot11ShortPreambleOption) {
+		SET_BIT(cap, WF_MGMT_CAP_SHORT);
+	}
+	if (adev->cfgopt_dot11PBCCOption) {
+		SET_BIT(cap, WF_MGMT_CAP_PBCC);
+	}
+	if (adev->cfgopt_dot11ChannelAgility) {
+		SET_BIT(cap, WF_MGMT_CAP_AGILITY);
+	}
+	log(L_DEBUG, "caps updated from 0x%04X to 0x%04X\n",
+	    adev->capabilities, cap);
+	adev->capabilities = cap;
+}
+*/
+/**
+** Derived from mac80211 code, p54, bcm43xx_mac80211
+**
+*/
+static void acx_select_opmode(acx_device_t * adev)
+{
+	int changed = 0;
+	if (adev->interface.operating) {
+		switch (adev->interface.type) {
+			case IEEE80211_IF_TYPE_AP:
+				if (adev->mode != ACX_MODE_3_AP)
+				{
+					adev->mode = ACX_MODE_3_AP;
+					changed = 1;
+				}
+				break;
+			case IEEE80211_IF_TYPE_IBSS:
+				if (adev->mode != ACX_MODE_0_ADHOC)
+				{
+					adev->mode = ACX_MODE_0_ADHOC;
+					changed = 1;
+				}
+				break;
+			case IEEE80211_IF_TYPE_STA:
+				if (adev->mode != ACX_MODE_2_STA)
+				{
+					adev->mode = ACX_MODE_2_STA;
+					changed = 1;
+				}
+				break;
+			case IEEE80211_IF_TYPE_WDS:
+			default:
+				if (adev->mode != ACX_MODE_OFF)
+				{
+					adev->mode = ACX_MODE_OFF;
+					changed = 1;
+				}
+			break;
+		}
+	} else {
+		if (adev->interface.type == IEEE80211_IF_TYPE_MNTR)
+		{
+			if (adev->mode != ACX_MODE_MONITOR)
+			{
+				adev->mode = ACX_MODE_MONITOR;
+				changed = 1;
+			}
+		}
+		else
+		{
+			if (adev->mode != ACX_MODE_OFF)
+			{
+				adev->mode = ACX_MODE_OFF;
+				changed = 1;
+			}
+		}
+	}
+	if (changed)
+	{
+		SET_BIT(adev->set_mask, GETSET_MODE);
+		acx_s_update_card_settings(adev);
+//	acx_schedule_task(adev,	ACX_AFTER_IRQ_UPDATE_CARD_CFG);
+	}
+}
+
+/**
+** Derived from mac80211 code, p54, bcm43xx_mac80211
+**
+*/
+
+int acx_add_interface(struct ieee80211_hw *ieee,
+		      struct ieee80211_if_init_conf *conf)
+{
+	acx_device_t *adev = ieee2adev(ieee);
+	unsigned long flags;
+	int err = -EOPNOTSUPP;
+
+	FN_ENTER;
+	acx_lock(adev, flags);
+
+	if (conf->type == IEEE80211_IF_TYPE_MNTR) {
+		adev->interface.monitor++;
+	} else {
+		if (adev->interface.operating)
+			goto out_unlock;
+		adev->interface.operating = 1;
+		adev->interface.if_id = conf->if_id;
+		adev->interface.mac_addr = conf->mac_addr;
+		adev->interface.type = conf->type;
+	}
+//	adev->mode = conf->type;
+	if (adev->initialized)
+		acx_select_opmode(adev);
+	err = 0;
+
+	printk(KERN_INFO "Virtual interface added "
+	       "(type: 0x%08X, ID: %d, MAC: "
+	       MAC_FMT ")\n",
+	       conf->type, conf->if_id, MAC_ARG(conf->mac_addr));
+
+      out_unlock:
+	acx_unlock(adev, flags);
+
+	FN_EXIT0;
+	return err;
+}
+/**
+** Derived from mac80211 code, p54, bcm43xx_mac80211
+**
+*/
+
+void acx_remove_interface(struct ieee80211_hw *hw,
+			  struct ieee80211_if_init_conf *conf)
+{
+	acx_device_t *adev = ieee2adev(hw);
+	unsigned long flags;
+	FN_ENTER;
+
+	acx_lock(adev, flags);
+	if (conf->type == IEEE80211_IF_TYPE_MNTR) {
+		adev->interface.monitor--;
+//                assert(bcm->interface.monitor >= 0);
+	} else
+		adev->interface.operating = 0;
+	printk("Removing interface: %d %d\n", adev->interface.operating, conf->type);
+	if (adev->initialized)
+		acx_select_opmode(adev);
+	flush_scheduled_work();
+	acx_unlock(adev, flags);
+
+	printk(KERN_INFO "Virtual interface removed "
+	       "(type: 0x%08X, ID: %d, MAC: "
+	       MAC_FMT ")\n",
+	       conf->type, conf->if_id, MAC_ARG(conf->mac_addr));
+	FN_EXIT0;
+}
+/**
+** Derived from mac80211 code, p54, bcm43xx_mac80211
+**
+*/
+
+int acx_net_reset(struct ieee80211_hw *ieee)
+{
+	acx_device_t *adev = ieee2adev(ieee);
+	FN_ENTER;
+	if (IS_PCI(adev))
+		acxpci_s_reset_dev(adev);
+	else
+		TODO();
+
+	FN_EXIT0;
+	return 0;
+}
+
+/**
+** Derived from mac80211 code, p54, bcm43xx_mac80211
+**
+*/
+int acx_selectchannel(acx_device_t * adev, u8 channel, int freq)
+{
+	int result;
+	acx_sem_lock(adev);
+	adev->rx_status.channel = channel;
+	adev->rx_status.freq = freq;
+	
+	adev->channel = channel;
+	/* hmm, the following code part is strange, but this is how
+	 * it was being done before... */
+	log(L_IOCTL, "Changing to channel %d\n", channel);
+	SET_BIT(adev->set_mask, GETSET_CHANNEL);
+	result = -EINPROGRESS;	/* need to call commit handler */
+
+	acx_sem_unlock(adev);
+	FN_EXIT1(result);
+	return result;
+}
+
+/**
+** Derived from mac80211 code, p54, bcm43xx_mac80211
+**
+*/
+int acx_net_config(struct ieee80211_hw *hw, struct ieee80211_conf *conf)
+{
+	acx_device_t *adev = ieee2adev(hw);
+	unsigned long flags;
+	int change =0;
+	FN_ENTER;
+
+	acx_lock(adev, flags);
+//FIXME();
+	if (!adev->initialized) {
+		acx_unlock(adev,flags);
+		return 0;
+	}
+	if (conf->beacon_int != adev->beacon_interval)
+		adev->beacon_interval = conf->beacon_int;
+	if (conf->channel != adev->channel) {
+		acx_selectchannel(adev, conf->channel,conf->freq);
+/*		acx_schedule_task(adev,
+				  ACX_AFTER_IRQ_UPDATE_CARD_CFG
+*/				  /*+ ACX_AFTER_IRQ_RESTART_SCAN */ /*);*/
+	}
+/*
+        if (conf->short_slot_time != adev->short_slot) {
+//                assert(phy->type == BCM43xx_PHYTYPE_G);      
+                if (conf->short_slot_time)
+                        acx_short_slot_timing_enable(adev);
+                else
+                        acx_short_slot_timing_disable(adev);
+		acx_schedule_task(adev, ACX_AFTER_IRQ_UPDATE_CARD_CFG);
+        }
+*/
+	adev->tx_disabled = !conf->radio_enabled;
+	if (conf->power_level != 0 && adev->tx_level_dbm > 15){
+		adev->tx_level_dbm =  conf->power_level;
+		SET_BIT(adev->set_mask,GETSET_TXPOWER);
+		//acx_schedule_task(adev, ACX_AFTER_IRQ_UPDATE_CARD_CFG);
+	} 
+
+//FIXME: This does not seem to wake up:
+#if 0
+	if (conf->power_level == 0) {
+		if (radio->enabled)
+			bcm43xx_radio_turn_off(bcm);
+	} else {
+		if (!radio->enabled)
+			bcm43xx_radio_turn_on(bcm);
+	}
+#endif
+
+	//TODO: phymode
+	//TODO: antennas
+	if (adev->set_mask > 0)
+		acx_s_update_card_settings(adev);
+	acx_unlock(adev, flags);
+
+	FN_EXIT0;
+	return 0;
+}
+
+/**
+** Derived from mac80211 code, p54, bcm43xx_mac80211
+**
+*/
+
+int acx_config_interface(struct ieee80211_hw *ieee, int if_id,
+			 struct ieee80211_if_conf *conf)
+{
+	acx_device_t *adev = ieee2adev(ieee);
+	unsigned long flags;
+	int err = -ENODEV;
+	FN_ENTER;
+	if (!adev->interface.operating)
+		goto err_out;
+	acx_lock(adev, flags);
+
+	if (adev->initialized)
+		acx_select_opmode(adev);
+
+	if ((conf->type != IEEE80211_IF_TYPE_MNTR)
+	    && (adev->interface.if_id == if_id)) {
+		if (conf->bssid)
+		{
+			adev->interface.bssid = conf->bssid;
+ 	             	MAC_COPY(adev->bssid,conf->bssid);
+		}
+	}
+	if ((conf->type == IEEE80211_IF_TYPE_AP)
+	    && (adev->interface.if_id == if_id)) {
+		if ((conf->ssid_len > 0) && conf->ssid)
+		{
+			adev->essid_len = conf->ssid_len;
+			memcpy(adev->essid, conf->ssid, conf->ssid_len);
+			SET_BIT(adev->set_mask, SET_TEMPLATES);
+		}
+	}
+	if (conf->beacon != 0)
+	{
+		adev->beacon_interval = DEFAULT_BEACON_INTERVAL;
+		adev->beacon_cache = conf->beacon;
+		SET_BIT(adev->set_mask, SET_TEMPLATES);
+	}
+	if (adev->set_mask != 0)
+		acx_s_update_card_settings(adev);
+//		acx_schedule_task(adev, ACX_AFTER_IRQ_UPDATE_CARD_CFG);
+	acx_unlock(adev, flags);
+	err = 0;
+err_out:
+	FN_EXIT0;
+	return err;
+}
+
+/**
+** Derived from mac80211 code, p54, bcm43xx_mac80211
+**
+*/
+
+int acx_net_get_tx_stats(struct ieee80211_hw *hw,
+			 struct ieee80211_tx_queue_stats *stats)
+{
+//        acx_device_t *adev = ndev2adev(net_dev);
+	struct ieee80211_tx_queue_stats_data *data;
+	int err = -ENODEV;
+
+	FN_ENTER;
+
+//        acx_lock(adev, flags);
+	data = &(stats->data[0]);
+	data->len = 0;
+	data->limit = TX_CNT;
+	data->count = 0;
+//        acx_unlock(adev, flags);
+
+	FN_EXIT0;
+	return err;
+}
+/**
+** Derived from mac80211 code, p54, bcm43xx_mac80211
+**
+*/
+
+int acx_net_conf_tx(struct ieee80211_hw *hw,
+		    int queue, const struct ieee80211_tx_queue_params *params)
+{
+	FN_ENTER;
+//      TODO();
+	FN_EXIT0;
+	return 0;
+}
+
+static void keymac_write(acx_device_t * adev, u8 index, const u32 * addr)
+{
+	/* for keys 0-3 there is no associated mac address */
+	if (index < 4)
+		return;
+
+	index -= 4;
+	if (1) {
+		TODO();
+/*
+                bcm43xx_shm_write32(bcm,
+                                    BCM43xx_SHM_HWMAC,
+                                    index * 2,
+                                    cpu_to_be32(*addr));
+                bcm43xx_shm_write16(bcm,   
+                                    BCM43xx_SHM_HWMAC,   
+                                    (index * 2) + 1,
+                                    cpu_to_be16(*((u16 *)(addr + 1))));
+*/
+	} else {
+		if (index < 8) {
+			TODO();	/* Put them in the macaddress filter */
+		} else {
+			TODO();
+			/* Put them BCM43xx_SHM_SHARED, stating index 0x0120.
+			   Keep in mind to update the count of keymacs in 0x003 */
+		}
+	}
+}
+
+/**
+** Derived from mac80211 code, p54, bcm43xx_mac80211
+**
+*/
+
+int acx_clear_keys(acx_device_t * adev)
+{
+	static const u32 zero_mac[2] = { 0 };
+	unsigned int i, j, nr_keys = 54;
+	u16 offset;
+
+	/* FixMe:Check for Number of Keys available */
+
+//        assert(nr_keys <= ARRAY_SIZE(adev->key));
+
+	for (i = 0; i < nr_keys; i++) {
+		adev->key[i].enabled = 0;
+		/* returns for i < 4 immediately */
+		keymac_write(adev, i, zero_mac);
+/*
+                bcm43xx_shm_write16(adev, BCM43xx_SHM_SHARED,
+                                    0x100 + (i * 2), 0x0000);
+*/
+		for (j = 0; j < 8; j++) {
+			offset =
+			    adev->security_offset + (j * 4) +
+			    (i * ACX_SEC_KEYSIZE);
+/*
+                        bcm43xx_shm_write16(bcm, BCM43xx_SHM_SHARED,
+                                            offset, 0x0000);
+*/
+		}
+	}
+	return 1;
+}
+
+/**
+** Derived from mac80211 code, p54, bcm43xx_mac80211
+**
+*/
+
+int acx_key_write(acx_device_t * adev,
+		  u8 index,
+		  u8 algorithm,
+		  const u8 * _key, int key_len, const u8 * mac_addr)
+{
+// struct iw_point *dwrq = &wrqu->encoding;
+//        acx_device_t *adev = ndev2adev(ndev);
+	int result;
+
+	FN_ENTER;
+/*
+        log(L_IOCTL, "set encoding flags=0x%04X, size=%d, key: %s\n",
+                        dwrq->flags, dwrq->length, extra ? "set" : "No key");
+*/
+	acx_sem_lock(adev);
+
+//        index = (dwrq->flags & IW_ENCODE_INDEX) - 1;
+	if (key_len > 0) {
+		/* if index is 0 or invalid, use default key */
+		if (index > 3)
+			index = (int)adev->wep_current_index;
+		if ((algorithm == ACX_SEC_ALGO_WEP)
+		    || (algorithm == ACX_SEC_ALGO_WEP104)) {
+			if (key_len > 29)
+				key_len = 29;	/* restrict it */
+
+			if (key_len > 13) {
+				/* 29*8 == 232, WEP256 */
+				adev->wep_keys[index].size = 29;
+			} else if (key_len > 5) {
+				/* 13*8 == 104bit, WEP128 */
+				adev->wep_keys[index].size = 13;
+			} else if (key_len > 0) {
+				/* 5*8 == 40bit, WEP64 */
+				adev->wep_keys[index].size = 5;
+			} else {
+				/* disable key */
+				adev->wep_keys[index].size = 0;
+			}
+
+			memset(adev->wep_keys[index].key, 0,
+			       sizeof(adev->wep_keys[index].key));
+			memcpy(adev->wep_keys[index].key, _key, key_len);
+		}
+	} else {
+		/* set transmit key */
+		if (index <= 3)
+			adev->wep_current_index = index;
+		//               else if (0 == (dwrq->flags & IW_ENCODE_MODE)) {
+		/* complain if we were not just setting
+		 * the key mode */
+//                        result = -EINVAL;
+//                        goto end_unlock;
+//                }
+	}
+
+	adev->wep_enabled = (algorithm == ALG_WEP);
+/*
+        adev->wep_enabled = !(dwrq->flags & IW_ENCODE_DISABLED);
+
+        if (algorithm & IW_ENCODE_OPEN) {
+                adev->auth_alg = WLAN_AUTH_ALG_OPENSYSTEM;
+                adev->wep_restricted = 0;
+
+        } else if (algorithm & IW_ENCODE_RESTRICTED) {
+                adev->auth_alg = WLAN_AUTH_ALG_SHAREDKEY;
+                adev->wep_restricted = 1;
+        }
+*/
+//	adev->auth_alg = algorithm;
+	/* set flag to make sure the card WEP settings get updated */
+	if (adev->wep_enabled) {
+		SET_BIT(adev->set_mask, GETSET_WEP);
+		acx_s_update_card_settings(adev);
+//		acx_schedule_task(adev, ACX_AFTER_IRQ_UPDATE_CARD_CFG);
+	}
+/*
+        log(L_IOCTL, "len=%d, key at 0x%p, flags=0x%X\n",
+                dwrq->length, extra, dwrq->flags);
+        for (index = 0; index <= 3; index++) {
+                if (adev->wep_keys[index].size) {
+                        log(L_IOCTL,    "index=%d, size=%d, key at 0x%p\n",
+                                adev->wep_keys[index].index,
+                                (int) adev->wep_keys[index].size,
+                                adev->wep_keys[index].key);
+                }
+        }
+*/
+	result = -EINPROGRESS;
+	acx_sem_unlock(adev);
+
+	FN_EXIT1(result);
+	return result;
+
+
+}
+
+/**
+** Derived from mac80211 code, p54, bcm43xx_mac80211
+**
+*/
+
+int acx_net_set_key(struct ieee80211_hw *ieee,
+		    set_key_cmd cmd,
+		    u8 * addr, struct ieee80211_key_conf *key, int aid)
+{
+//      return 0;
+	struct acx_device *adev = ieee2adev(ieee);
+	unsigned long flags;
+	u8 algorithm;
+	u8 index;
+	int err = -EINVAL;
+	FN_ENTER;
+//	TODO();
+	switch (key->alg) {
+	default:
+	case ALG_NONE:
+	case ALG_NULL:
+		algorithm = ACX_SEC_ALGO_NONE;
+		break;
+	case ALG_WEP:
+		if (key->keylen == 5)
+			algorithm = ACX_SEC_ALGO_WEP;
+		else
+			algorithm = ACX_SEC_ALGO_WEP104;
+		break;
+	case ALG_TKIP:
+		algorithm = ACX_SEC_ALGO_TKIP;
+		break;
+	case ALG_CCMP:
+		algorithm = ACX_SEC_ALGO_AES;
+		break;
+	}
+
+	index = (u8) (key->keyidx);
+	if (index >= ARRAY_SIZE(adev->key))
+		goto out;
+	acx_lock(adev, flags);
+	switch (cmd) {
+	case SET_KEY:
+		err = acx_key_write(adev, index, algorithm,
+				    key->key, key->keylen, addr);
+		if (err)
+			goto out_unlock;
+		key->hw_key_idx = index;
+		CLEAR_BIT(key->flags, IEEE80211_KEY_FORCE_SW_ENCRYPT);
+		if (CHECK_BIT(key->flags, IEEE80211_KEY_DEFAULT_TX_KEY))
+			adev->default_key_idx = index;
+		adev->key[index].enabled = 1;
+		break;
+	case DISABLE_KEY:
+		adev->key[index].enabled = 0;
+		err = 0;
+		break;
+	case REMOVE_ALL_KEYS:
+		acx_clear_keys(adev);
+		err = 0;
+		break;
+     /* case ENABLE_COMPRESSION:
+	case DISABLE_COMPRESSION:
+		err = 0;
+		break; */
+	}
+      out_unlock:
+	acx_unlock(adev, flags);
+      out:
+	FN_EXIT0;
+	return err;
+}
+
+
+
+/***********************************************************************
+** Common function to parse ALL configoption struct formats
+** (ACX100 and ACX111; FIXME: how to make it work with ACX100 USB!?!?).
+** FIXME: logging should be removed here and added to a /proc file instead
+**
+** Look into bcm43xx
+*/
+void
+acx_s_parse_configoption(acx_device_t * adev,
+			 const acx111_ie_configoption_t * pcfg)
+{
+	const u8 *pEle;
+	int i;
+	int is_acx111 = IS_ACX111(adev);
+
+	if (acx_debug & L_DEBUG) {
+		printk("configoption struct content:\n");
+		acx_dump_bytes(pcfg, sizeof(*pcfg));
+	}
+
+	if ((is_acx111 && (adev->eeprom_version == 5))
+	    || (!is_acx111 && (adev->eeprom_version == 4))
+	    || (!is_acx111 && (adev->eeprom_version == 5))) {
+		/* these versions are known to be supported */
+	} else {
+		printk("unknown chip and EEPROM version combination (%s, v%d), "
+		       "don't know how to parse config options yet. "
+		       "Please report\n", is_acx111 ? "ACX111" : "ACX100",
+		       adev->eeprom_version);
+		return;
+	}
+
+	/* first custom-parse the first part which has chip-specific layout */
+
+	pEle = (const u8 *)pcfg;
+
+	pEle += 4;		/* skip (type,len) header */
+
+	memcpy(adev->cfgopt_NVSv, pEle, sizeof(adev->cfgopt_NVSv));
+	pEle += sizeof(adev->cfgopt_NVSv);
+
+	if (is_acx111) {
+		adev->cfgopt_NVS_vendor_offs = le16_to_cpu(*(u16 *) pEle);
+		pEle += sizeof(adev->cfgopt_NVS_vendor_offs);
+
+		adev->cfgopt_probe_delay = 200;	/* good default value? */
+		pEle += 2;	/* FIXME: unknown, value 0x0001 */
+	} else {
+		memcpy(adev->cfgopt_MAC, pEle, sizeof(adev->cfgopt_MAC));
+		pEle += sizeof(adev->cfgopt_MAC);
+
+		adev->cfgopt_probe_delay = le16_to_cpu(*(u16 *) pEle);
+		pEle += sizeof(adev->cfgopt_probe_delay);
+		if ((adev->cfgopt_probe_delay < 100)
+		    || (adev->cfgopt_probe_delay > 500)) {
+			printk("strange probe_delay value %d, "
+			       "tweaking to 200\n", adev->cfgopt_probe_delay);
+			adev->cfgopt_probe_delay = 200;
+		}
+	}
+
+	adev->cfgopt_eof_memory = le32_to_cpu(*(u32 *) pEle);
+	pEle += sizeof(adev->cfgopt_eof_memory);
+
+	printk("NVS_vendor_offs:%04X probe_delay:%d eof_memory:%d\n",
+	       adev->cfgopt_NVS_vendor_offs,
+	       adev->cfgopt_probe_delay, adev->cfgopt_eof_memory);
+
+	adev->cfgopt_dot11CCAModes = *pEle++;
+	adev->cfgopt_dot11Diversity = *pEle++;
+	adev->cfgopt_dot11ShortPreambleOption = *pEle++;
+	adev->cfgopt_dot11PBCCOption = *pEle++;
+	adev->cfgopt_dot11ChannelAgility = *pEle++;
+	adev->cfgopt_dot11PhyType = *pEle++;
+	adev->cfgopt_dot11TempType = *pEle++;
+	printk("CCAModes:%02X Diversity:%02X ShortPreOpt:%02X "
+	       "PBCC:%02X ChanAgil:%02X PHY:%02X Temp:%02X\n",
+	       adev->cfgopt_dot11CCAModes,
+	       adev->cfgopt_dot11Diversity,
+	       adev->cfgopt_dot11ShortPreambleOption,
+	       adev->cfgopt_dot11PBCCOption,
+	       adev->cfgopt_dot11ChannelAgility,
+	       adev->cfgopt_dot11PhyType, adev->cfgopt_dot11TempType);
+
+	/* then use common parsing for next part which has common layout */
+
+	pEle++;			/* skip table_count (6) */
+
+	adev->cfgopt_antennas.type = pEle[0];
+	adev->cfgopt_antennas.len = pEle[1];
+	printk("AntennaID:%02X Len:%02X Data:",
+	       adev->cfgopt_antennas.type, adev->cfgopt_antennas.len);
+	for (i = 0; i < pEle[1]; i++) {
+		adev->cfgopt_antennas.list[i] = pEle[i + 2];
+		printk("%02X ", pEle[i + 2]);
+	}
+	printk("\n");
+
+	pEle += pEle[1] + 2;
+	adev->cfgopt_power_levels.type = pEle[0];
+	adev->cfgopt_power_levels.len = pEle[1];
+	printk("PowerLevelID:%02X Len:%02X Data:",
+	       adev->cfgopt_power_levels.type, adev->cfgopt_power_levels.len);
+	for (i = 0; i < pEle[1]; i++) {
+		adev->cfgopt_power_levels.list[i] =
+		    le16_to_cpu(*(u16 *) & pEle[i * 2 + 2]);
+		printk("%04X ", adev->cfgopt_power_levels.list[i]);
+	}
+	printk("\n");
+
+	pEle += pEle[1] * 2 + 2;
+	adev->cfgopt_data_rates.type = pEle[0];
+	adev->cfgopt_data_rates.len = pEle[1];
+	printk("DataRatesID:%02X Len:%02X Data:",
+	       adev->cfgopt_data_rates.type, adev->cfgopt_data_rates.len);
+	for (i = 0; i < pEle[1]; i++) {
+		adev->cfgopt_data_rates.list[i] = pEle[i + 2];
+		printk("%02X ", pEle[i + 2]);
+	}
+	printk("\n");
+
+	pEle += pEle[1] + 2;
+	adev->cfgopt_domains.type = pEle[0];
+	adev->cfgopt_domains.len = pEle[1];
+	printk("DomainID:%02X Len:%02X Data:",
+	       adev->cfgopt_domains.type, adev->cfgopt_domains.len);
+	for (i = 0; i < pEle[1]; i++) {
+		adev->cfgopt_domains.list[i] = pEle[i + 2];
+		printk("%02X ", pEle[i + 2]);
+	}
+	printk("\n");
+
+	pEle += pEle[1] + 2;
+	adev->cfgopt_product_id.type = pEle[0];
+	adev->cfgopt_product_id.len = pEle[1];
+	for (i = 0; i < pEle[1]; i++) {
+		adev->cfgopt_product_id.list[i] = pEle[i + 2];
+	}
+	printk("ProductID:%02X Len:%02X Data:%.*s\n",
+	       adev->cfgopt_product_id.type, adev->cfgopt_product_id.len,
+	       adev->cfgopt_product_id.len,
+	       (char *)adev->cfgopt_product_id.list);
+
+	pEle += pEle[1] + 2;
+	adev->cfgopt_manufacturer.type = pEle[0];
+	adev->cfgopt_manufacturer.len = pEle[1];
+	for (i = 0; i < pEle[1]; i++) {
+		adev->cfgopt_manufacturer.list[i] = pEle[i + 2];
+	}
+	printk("ManufacturerID:%02X Len:%02X Data:%.*s\n",
+	       adev->cfgopt_manufacturer.type, adev->cfgopt_manufacturer.len,
+	       adev->cfgopt_manufacturer.len,
+	       (char *)adev->cfgopt_manufacturer.list);
+/*
+	printk("EEPROM part:\n");
+	for (i=0; i<58; i++) {
+		printk("%02X =======>  0x%02X\n",
+			i, (u8 *)adev->cfgopt_NVSv[i-2]);
+	}
+*/
+}
+
+
+/***********************************************************************
+** Linux Kernel Specific
+*/
+static int __init acx_e_init_module(void)
+{
+	int r1, r2;
+
+	acx_struct_size_check();
+
+	printk("acx: this driver is still EXPERIMENTAL\n"
+	       "acx: reading README file and/or Craig's HOWTO is "
+	       "recommended, visit http://acx100.sourceforge.net/wiki in case "
+	       "of further questions/discussion\n");
+
+#if defined(CONFIG_ACX_MAC80211_PCI)
+	r1 = acxpci_e_init_module();
+#else
+	r1 = -EINVAL;
+#endif
+#if defined(CONFIG_ACX_MAC80211_USB)
+	r2 = acxusb_e_init_module();
+#else
+	r2 = -EINVAL;
+#endif
+	if (r2 && r1)		/* both failed! */
+		return r2 ? r2 : r1;
+	/* return success if at least one succeeded */
+	return 0;
+}
+
+static void __exit acx_e_cleanup_module(void)
+{
+#if defined(CONFIG_ACX_MAC80211_PCI)
+	acxpci_e_cleanup_module();
+#endif
+#if defined(CONFIG_ACX_MAC80211_USB)
+	acxusb_e_cleanup_module();
+#endif
+}
+
+module_init(acx_e_init_module)
+    module_exit(acx_e_cleanup_module)
diff -Nurp linux-2.6.23-sabayon.orig/drivers/net/wireless/acx/Kconfig linux-2.6.23-sabayon/drivers/net/wireless/acx/Kconfig
--- linux-2.6.23-sabayon.orig/drivers/net/wireless/acx/Kconfig	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.23-sabayon/drivers/net/wireless/acx/Kconfig	2007-10-10 10:51:23.000000000 +0200
@@ -0,0 +1,63 @@
+config ACX_MAC80211
+	tristate "TI acx100/acx111 802.11b/g wireless chipsets"
+	depends on WLAN_80211 && MAC80211 && EXPERIMENTAL && (USB || PCI)
+	select FW_LOADER
+	---help---
+	A driver for 802.11b/g wireless cards based on
+	Texas Instruments acx100 and acx111 chipsets.
+
+	This driver supports Host AP mode that allows
+	your computer to act as an IEEE 802.11 access point.
+	This driver is new and experimental.
+
+	Texas Instruments did not take part in development of this driver
+	in any way, shape or form.
+
+	The driver can be compiled as a module and will be named "acx".
+
+config ACX_MAC80211_PCI
+	bool "TI acx100/acx111 802.11b/g PCI"
+	depends on ACX_MAC80211 && PCI
+	---help---
+	Include PCI and CardBus support in acx.
+
+	acx chipsets need their firmware loaded at startup.
+	You will need to provide a firmware image via hotplug.
+
+	Firmware may be in a form of single image 40-100kb in size
+	(a 'combined' firmware) or two images - main image
+	(again 40-100kb) and radio image (~10kb or less).
+
+	Firmware images are requested from hotplug using following names:
+
+	tiacx100 - main firmware image for acx100 chipset
+	tiacx100rNN - radio acx100 firmware for radio type NN
+	tiacx100cNN - combined acx100 firmware for radio type NN
+	tiacx111 - main acx111 firmware
+	tiacx111rNN - radio acx111 firmware for radio type NN
+	tiacx111cNN - combined acx111 firmware for radio type NN
+
+	Driver will attempt to load combined image first.
+	If no such image is found, it will try to load main image
+	and radio image instead.
+
+	Firmware files are not covered by GPL and are not distributed
+	with this driver for legal reasons.
+
+config ACX_MAC80211_USB
+	bool "TI acx100/acx111 802.11b/g USB"
+	depends on ACX_MAC80211 && (USB=y || USB=ACX_MAC80211)
+	---help---
+	Include USB support in acx.
+
+	There is only one currently known device in this category,
+	D-Link DWL-120+, but newer devices seem to be on the horizon.
+
+	acx chipsets need their firmware loaded at startup.
+	You will need to provide a firmware image via hotplug.
+
+	Firmware for USB device is requested from hotplug
+	by the 'tiacx1NNusbcNN' name.
+
+	Firmware files are not covered by GPL and are not distributed
+	with this driver for legal reasons.
diff -Nurp linux-2.6.23-sabayon.orig/drivers/net/wireless/acx/Makefile linux-2.6.23-sabayon/drivers/net/wireless/acx/Makefile
--- linux-2.6.23-sabayon.orig/drivers/net/wireless/acx/Makefile	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.23-sabayon/drivers/net/wireless/acx/Makefile	2007-10-10 10:51:23.000000000 +0200
@@ -0,0 +1,16 @@
+obj-$(CONFIG_ACX_MAC80211) += acx-mac80211.o
+
+acx-mac80211-obj-$(CONFIG_ACX_MAC80211_PCI) += pci.o
+acx-mac80211-obj-$(CONFIG_ACX_MAC80211_USB) += usb.o
+
+#acx-mac80211-objs := wlan.o conv.o ioctl.o common.o $(acx-mac80211-obj-y)
+acx-mac80211-objs :=  common.o $(acx-mac80211-obj-y)
+
+# Use this if you have proper Kconfig integration:
+
+#obj-$(CONFIG_ACX) += acx.o
+#
+#acx-obj-$(CONFIG_ACX_PCI) += pci.o
+#acx-obj-$(CONFIG_ACX_USB) += usb.o
+#
+#acx-objs := wlan.o conv.o ioctl.o common.o $(acx-obj-y)
diff -Nurp linux-2.6.23-sabayon.orig/drivers/net/wireless/acx/pci.c linux-2.6.23-sabayon/drivers/net/wireless/acx/pci.c
--- linux-2.6.23-sabayon.orig/drivers/net/wireless/acx/pci.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.23-sabayon/drivers/net/wireless/acx/pci.c	2007-10-10 10:51:23.000000000 +0200
@@ -0,0 +1,4497 @@
+/**** (legal) claimer in README
+** Copyright (C) 2003  ACX100 Open Source Project
+*/
+#define ACX_MAC80211_PCI 1
+
+#include <linux/version.h>
+#if LINUX_VERSION_CODE <= KERNEL_VERSION(2, 6, 18)
+#include <linux/config.h>     
+#endif        
+
+/* Linux 2.6.18+ uses <linux/utsrelease.h> */      
+#ifndef UTS_RELEASE
+#include <linux/utsrelease.h>
+#endif
+
+#include <linux/compiler.h>	/* required for Lx 2.6.8 ?? */
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/moduleparam.h>
+#include <linux/sched.h>
+#include <linux/types.h>
+#include <linux/skbuff.h>
+#include <linux/slab.h>
+#include <linux/if_arp.h>
+#include <linux/rtnetlink.h>
+#include <linux/wireless.h>
+#include <net/iw_handler.h>
+#include <linux/netdevice.h>
+#include <linux/ioport.h>
+#include <linux/pci.h>
+#include <linux/pm.h>
+#include <linux/vmalloc.h>
+#include <linux/ethtool.h>
+#include <linux/dma-mapping.h>
+#include <linux/workqueue.h>
+#ifdef CONFIG_VLYNQ
+#include <linux/vlynq.h>
+#endif
+
+#include "acx.h"
+
+/***********************************************************************
+*/
+#ifdef CONFIG_PCI
+#define PCI_TYPE		(PCI_USES_MEM | PCI_ADDR0 | PCI_NO_ACPI_WAKE)
+#define PCI_ACX100_REGION1		0x01
+#define PCI_ACX100_REGION1_SIZE		0x1000	/* Memory size - 4K bytes */
+#define PCI_ACX100_REGION2		0x02
+#define PCI_ACX100_REGION2_SIZE		0x10000	/* Memory size - 64K bytes */
+
+#define PCI_ACX111_REGION1		0x00
+#define PCI_ACX111_REGION1_SIZE		0x2000	/* Memory size - 8K bytes */
+#define PCI_ACX111_REGION2		0x01
+#define PCI_ACX111_REGION2_SIZE		0x20000	/* Memory size - 128K bytes */
+
+/* Texas Instruments Vendor ID */
+#define PCI_VENDOR_ID_TI		0x104c
+
+/* ACX100 22Mb/s WLAN controller */
+#define PCI_DEVICE_ID_TI_TNETW1100A	0x8400
+#define PCI_DEVICE_ID_TI_TNETW1100B	0x8401
+
+/* ACX111 54Mb/s WLAN controller */
+#define PCI_DEVICE_ID_TI_TNETW1130	0x9066
+
+/* PCI Class & Sub-Class code, Network-'Other controller' */
+#define PCI_CLASS_NETWORK_OTHERS	0x0280
+
+#define CARD_EEPROM_ID_SIZE 6
+
+#ifndef PCI_D0
+/* From include/linux/pci.h */
+#define PCI_D0		0
+#define PCI_D1		1
+#define PCI_D2		2
+#define PCI_D3hot	3
+#define PCI_D3cold	4
+#define PCI_UNKNOWN	5
+#define PCI_POWER_ERROR	-1
+#endif
+#endif /* CONFIG_PCI */
+/***********************************************************************
+*/
+
+static irqreturn_t acxpci_i_interrupt(int irq, void *dev_id);
+
+static void disable_acx_irq(acx_device_t * adev);
+
+static int acxpci_e_open(struct ieee80211_hw *hw);
+static int acxpci_e_close(struct ieee80211_hw *hw);
+static void acxpci_s_up(struct ieee80211_hw *hw);
+static void acxpci_s_down(struct ieee80211_hw *hw);
+
+/***********************************************************************
+** Register access
+**
+** 
+*/
+
+/* OS I/O routines *always* be endianness-clean but having them doesn't hurt */
+#define acx_readl(v)	le32_to_cpu(readl((v)))
+#define acx_readw(v)	le16_to_cpu(readw((v)))
+#define acx_writew(v,r)	writew(le16_to_cpu((v)), r)
+#define acx_writel(v,r)	writel(le32_to_cpu((v)), r)
+
+/* Pick one */
+/* #define INLINE_IO static */
+#define INLINE_IO static inline
+
+INLINE_IO u32 read_reg32(acx_device_t * adev, unsigned int offset)
+{
+#if ACX_IO_WIDTH == 32
+	return acx_readl((u8 *) adev->iobase + adev->io[offset]);
+#else
+	return acx_readw((u8 *) adev->iobase + adev->io[offset])
+	    + (acx_readw((u8 *) adev->iobase + adev->io[offset] + 2) << 16);
+#endif
+}
+
+INLINE_IO u16 read_reg16(acx_device_t * adev, unsigned int offset)
+{
+	return acx_readw((u8 *) adev->iobase + adev->io[offset]);
+}
+
+INLINE_IO u8 read_reg8(acx_device_t * adev, unsigned int offset)
+{
+	return readb((u8 *) adev->iobase + adev->io[offset]);
+}
+
+INLINE_IO void write_reg32(acx_device_t * adev, unsigned int offset, u32 val)
+{
+#if ACX_IO_WIDTH == 32
+	acx_writel(val, (u8 *) adev->iobase + adev->io[offset]);
+#else
+	acx_writew(val & 0xffff, (u8 *) adev->iobase + adev->io[offset]);
+	acx_writew(val >> 16, (u8 *) adev->iobase + adev->io[offset] + 2);
+#endif
+}
+
+INLINE_IO void write_reg16(acx_device_t * adev, unsigned int offset, u16 val)
+{
+	acx_writew(val, (u8 *) adev->iobase + adev->io[offset]);
+}
+
+INLINE_IO void write_reg8(acx_device_t * adev, unsigned int offset, u8 val)
+{
+	writeb(val, (u8 *) adev->iobase + adev->io[offset]);
+}
+
+/* Handle PCI posting properly:
+ * Make sure that writes reach the adapter in case they require to be executed
+ * *before* the next write, by reading a random (and safely accessible) register.
+ * This call has to be made if there is no read following (which would flush the data
+ * to the adapter), yet the written data has to reach the adapter immediately. */
+INLINE_IO void write_flush(acx_device_t * adev)
+{
+	/* readb(adev->iobase + adev->io[IO_ACX_INFO_MAILBOX_OFFS]); */
+	/* faster version (accesses the first register, IO_ACX_SOFT_RESET,
+	 * which should also be safe): */
+	readb(adev->iobase);
+}
+
+INLINE_IO int adev_present(acx_device_t * adev)
+{
+	/* fast version (accesses the first register, IO_ACX_SOFT_RESET,
+	 * which should be safe): */
+	return acx_readl(adev->iobase) != 0xffffffff;
+}
+
+
+/***********************************************************************
+*/
+static inline txdesc_t *get_txdesc(acx_device_t * adev, int index)
+{
+	return (txdesc_t *) (((u8 *) adev->txdesc_start) +
+			     index * adev->txdesc_size);
+}
+
+static inline txdesc_t *advance_txdesc(acx_device_t * adev, txdesc_t * txdesc,
+				       int inc)
+{
+	return (txdesc_t *) (((u8 *) txdesc) + inc * adev->txdesc_size);
+}
+
+static txhostdesc_t *get_txhostdesc(acx_device_t * adev, txdesc_t * txdesc)
+{
+	int index = (u8 *) txdesc - (u8 *) adev->txdesc_start;
+	if (unlikely(ACX_DEBUG && (index % adev->txdesc_size))) {
+		printk("bad txdesc ptr %p\n", txdesc);
+		return NULL;
+	}
+	index /= adev->txdesc_size;
+	if (unlikely(ACX_DEBUG && (index >= TX_CNT))) {
+		printk("bad txdesc ptr %p\n", txdesc);
+		return NULL;
+	}
+	return &adev->txhostdesc_start[index * 2];
+}
+
+
+
+
+
+/***********************************************************************
+** EEPROM and PHY read/write helpers
+*/
+/***********************************************************************
+** acxpci_read_eeprom_byte
+**
+** Function called to read an octet in the EEPROM.
+**
+** This function is used by acxpci_e_probe to check if the
+** connected card is a legal one or not.
+**
+** Arguments:
+**	adev		ptr to acx_device structure
+**	addr		address to read in the EEPROM
+**	charbuf		ptr to a char. This is where the read octet
+**			will be stored
+*/
+
+int acxpci_read_eeprom_byte(acx_device_t * adev, u32 addr, u8 * charbuf)
+{
+	int result;
+	int count;
+
+	write_reg32(adev, IO_ACX_EEPROM_CFG, 0);
+	write_reg32(adev, IO_ACX_EEPROM_ADDR, addr);
+	write_flush(adev);
+	write_reg32(adev, IO_ACX_EEPROM_CTL, 2);
+
+	count = 0xffff;
+	while (read_reg16(adev, IO_ACX_EEPROM_CTL)) {
+		/* scheduling away instead of CPU burning loop
+		 * doesn't seem to work here at all:
+		 * awful delay, sometimes also failure.
+		 * Doesn't matter anyway (only small delay). */
+		if (unlikely(!--count)) {
+			printk("%s: timeout waiting for EEPROM read\n",
+			       wiphy_name(adev->ieee->wiphy));
+			result = NOT_OK;
+			goto fail;
+		}
+		cpu_relax();
+	}
+
+	*charbuf = read_reg8(adev, IO_ACX_EEPROM_DATA);
+	log(L_DEBUG, "EEPROM at 0x%04X = 0x%02X\n", addr, *charbuf);
+	result = OK;
+
+      fail:
+	return result;
+}
+
+
+/***********************************************************************
+** We don't lock hw accesses here since we never r/w eeprom in IRQ
+** Note: this function sleeps only because of GFP_KERNEL alloc
+*/
+#ifdef UNUSED
+int
+acxpci_s_write_eeprom(acx_device_t * adev, u32 addr, u32 len,
+		      const u8 * charbuf)
+{
+	u8 *data_verify = NULL;
+	unsigned long flags;
+	int count, i;
+	int result = NOT_OK;
+	u16 gpio_orig;
+
+	printk("acx: WARNING! I would write to EEPROM now. "
+	       "Since I really DON'T want to unless you know "
+	       "what you're doing (THIS CODE WILL PROBABLY "
+	       "NOT WORK YET!), I will abort that now. And "
+	       "definitely make sure to make a "
+	       "/proc/driver/acx_wlan0_eeprom backup copy first!!! "
+	       "(the EEPROM content includes the PCI config header!! "
+	       "If you kill important stuff, then you WILL "
+	       "get in trouble and people DID get in trouble already)\n");
+	return OK;
+
+	FN_ENTER;
+
+	data_verify = kmalloc(len, GFP_KERNEL);
+	if (!data_verify) {
+		goto end;
+	}
+
+	/* first we need to enable the OE (EEPROM Output Enable) GPIO line
+	 * to be able to write to the EEPROM.
+	 * NOTE: an EEPROM writing success has been reported,
+	 * but you probably have to modify GPIO_OUT, too,
+	 * and you probably need to activate a different GPIO
+	 * line instead! */
+	gpio_orig = read_reg16(adev, IO_ACX_GPIO_OE);
+	write_reg16(adev, IO_ACX_GPIO_OE, gpio_orig & ~1);
+	write_flush(adev);
+
+	/* ok, now start writing the data out */
+	for (i = 0; i < len; i++) {
+		write_reg32(adev, IO_ACX_EEPROM_CFG, 0);
+		write_reg32(adev, IO_ACX_EEPROM_ADDR, addr + i);
+		write_reg32(adev, IO_ACX_EEPROM_DATA, *(charbuf + i));
+		write_flush(adev);
+		write_reg32(adev, IO_ACX_EEPROM_CTL, 1);
+
+		count = 0xffff;
+		while (read_reg16(adev, IO_ACX_EEPROM_CTL)) {
+			if (unlikely(!--count)) {
+				printk("WARNING, DANGER!!! "
+				       "Timeout waiting for EEPROM write\n");
+				goto end;
+			}
+			cpu_relax();
+		}
+	}
+
+	/* disable EEPROM writing */
+	write_reg16(adev, IO_ACX_GPIO_OE, gpio_orig);
+	write_flush(adev);
+
+	/* now start a verification run */
+	for (i = 0; i < len; i++) {
+		write_reg32(adev, IO_ACX_EEPROM_CFG, 0);
+		write_reg32(adev, IO_ACX_EEPROM_ADDR, addr + i);
+		write_flush(adev);
+		write_reg32(adev, IO_ACX_EEPROM_CTL, 2);
+
+		count = 0xffff;
+		while (read_reg16(adev, IO_ACX_EEPROM_CTL)) {
+			if (unlikely(!--count)) {
+				printk("timeout waiting for EEPROM read\n");
+				goto end;
+			}
+			cpu_relax();
+		}
+
+		data_verify[i] = read_reg16(adev, IO_ACX_EEPROM_DATA);
+	}
+
+	if (0 == memcmp(charbuf, data_verify, len))
+		result = OK;	/* read data matches, success */
+
+      end:
+	kfree(data_verify);
+	FN_EXIT1(result);
+	return result;
+}
+#endif /* UNUSED */
+
+
+/***********************************************************************
+** acxpci_s_read_phy_reg
+**
+** Messing with rx/tx disabling and enabling here
+** (write_reg32(adev, IO_ACX_ENABLE, 0b000000xx)) kills traffic
+*/
+int acxpci_s_read_phy_reg(acx_device_t * adev, u32 reg, u8 * charbuf)
+{
+	int result = NOT_OK;
+	int count;
+
+	FN_ENTER;
+
+	write_reg32(adev, IO_ACX_PHY_ADDR, reg);
+	write_flush(adev);
+	write_reg32(adev, IO_ACX_PHY_CTL, 2);
+
+	count = 0xffff;
+	while (read_reg32(adev, IO_ACX_PHY_CTL)) {
+		/* scheduling away instead of CPU burning loop
+		 * doesn't seem to work here at all:
+		 * awful delay, sometimes also failure.
+		 * Doesn't matter anyway (only small delay). */
+		if (unlikely(!--count)) {
+			printk("%s: timeout waiting for phy read\n",
+			       wiphy_name(adev->ieee->wiphy));
+			*charbuf = 0;
+			goto fail;
+		}
+		cpu_relax();
+	}
+
+	log(L_DEBUG, "count was %u\n", count);
+	*charbuf = read_reg8(adev, IO_ACX_PHY_DATA);
+
+	log(L_DEBUG, "radio PHY at 0x%04X = 0x%02X\n", *charbuf, reg);
+	result = OK;
+	goto fail;		/* silence compiler warning */
+      fail:
+	FN_EXIT1(result);
+	return result;
+}
+
+
+/***********************************************************************
+*/
+int acxpci_s_write_phy_reg(acx_device_t * adev, u32 reg, u8 value)
+{
+	FN_ENTER;
+
+	/* mprusko said that 32bit accesses result in distorted sensitivity
+	 * on his card. Unconfirmed, looks like it's not true (most likely since we
+	 * now properly flush writes). */
+	write_reg32(adev, IO_ACX_PHY_DATA, value);
+	write_reg32(adev, IO_ACX_PHY_ADDR, reg);
+	write_flush(adev);
+	write_reg32(adev, IO_ACX_PHY_CTL, 1);
+	write_flush(adev);
+	log(L_DEBUG, "radio PHY write 0x%02X at 0x%04X\n", value, reg);
+
+	FN_EXIT1(OK);
+	return OK;
+}
+
+
+#define NO_AUTO_INCREMENT	1
+
+/***********************************************************************
+** acxpci_s_write_fw
+**
+** Write the firmware image into the card.
+**
+** Arguments:
+**	adev		wlan device structure
+**	fw_image	firmware image.
+**
+** Returns:
+**	1	firmware image corrupted
+**	0	success
+**
+** Standard csum implementation + write to IO
+*/
+static int
+acxpci_s_write_fw(acx_device_t * adev, const firmware_image_t *fw_image,
+		  u32 offset)
+{
+	int len, size;
+	u32 sum, v32;
+	/* we skip the first four bytes which contain the control sum */
+
+	const u8 *p = (u8 *) fw_image + 4;
+
+	/* start the image checksum by adding the image size value */
+	sum = p[0] + p[1] + p[2] + p[3];
+	p += 4;
+
+	write_reg32(adev, IO_ACX_SLV_END_CTL, 0);
+
+#if NO_AUTO_INCREMENT
+	write_reg32(adev, IO_ACX_SLV_MEM_CTL, 0);	/* use basic mode */
+#else
+	write_reg32(adev, IO_ACX_SLV_MEM_CTL, 1);	/* use autoincrement mode */
+	write_reg32(adev, IO_ACX_SLV_MEM_ADDR, offset);	/* configure start address */
+	write_flush(adev);
+#endif
+
+	len = 0;
+	size = le32_to_cpu(fw_image->size) & (~3);
+
+	while (likely(len < size)) {
+		v32 = be32_to_cpu(*(u32 *) p);
+		sum += p[0] + p[1] + p[2] + p[3];
+		p += 4;
+		len += 4;
+
+#if NO_AUTO_INCREMENT
+		write_reg32(adev, IO_ACX_SLV_MEM_ADDR, offset + len - 4);
+		write_flush(adev);
+#endif
+		write_reg32(adev, IO_ACX_SLV_MEM_DATA, v32);
+	}
+
+	log(L_DEBUG, "firmware written, size:%d sum1:%x sum2:%x\n",
+	    size, sum, le32_to_cpu(fw_image->chksum));
+
+	/* compare our checksum with the stored image checksum */
+	return (sum != le32_to_cpu(fw_image->chksum));
+}
+
+
+/***********************************************************************
+** acxpci_s_validate_fw
+**
+** Compare the firmware image given with
+** the firmware image written into the card.
+**
+** Arguments:
+**	adev		wlan device structure
+**   fw_image  firmware image.
+**
+** Returns:
+**	NOT_OK	firmware image corrupted or not correctly written
+**	OK	success
+**
+** Origin: Standard csum + Read IO
+*/
+static int
+acxpci_s_validate_fw(acx_device_t * adev, const firmware_image_t *fw_image,
+		     u32 offset)
+{
+	u32 sum, v32, w32;
+	int len, size;
+	int result = OK;
+	/* we skip the first four bytes which contain the control sum */
+	const u8 *p = (u8 *) fw_image + 4;
+
+	/* start the image checksum by adding the image size value */
+	sum = p[0] + p[1] + p[2] + p[3];
+	p += 4;
+
+	write_reg32(adev, IO_ACX_SLV_END_CTL, 0);
+
+#if NO_AUTO_INCREMENT
+	write_reg32(adev, IO_ACX_SLV_MEM_CTL, 0);	/* use basic mode */
+#else
+	write_reg32(adev, IO_ACX_SLV_MEM_CTL, 1);	/* use autoincrement mode */
+	write_reg32(adev, IO_ACX_SLV_MEM_ADDR, offset);	/* configure start address */
+#endif
+
+	len = 0;
+	size = le32_to_cpu(fw_image->size) & (~3);
+
+	while (likely(len < size)) {
+		v32 = be32_to_cpu(*(u32 *) p);
+		p += 4;
+		len += 4;
+
+#if NO_AUTO_INCREMENT
+		write_reg32(adev, IO_ACX_SLV_MEM_ADDR, offset + len - 4);
+#endif
+		w32 = read_reg32(adev, IO_ACX_SLV_MEM_DATA);
+
+		if (unlikely(w32 != v32)) {
+			printk("acx: FATAL: firmware upload: "
+			       "data parts at offset %d don't match (0x%08X vs. 0x%08X)! "
+			       "I/O timing issues or defective memory, with DWL-xx0+? "
+			       "ACX_IO_WIDTH=16 may help. Please report\n",
+			       len, v32, w32);
+			result = NOT_OK;
+			break;
+		}
+
+		sum +=
+		    (u8) w32 + (u8) (w32 >> 8) + (u8) (w32 >> 16) +
+		    (u8) (w32 >> 24);
+	}
+
+	/* sum control verification */
+	if (result != NOT_OK) {
+		if (sum != le32_to_cpu(fw_image->chksum)) {
+			printk("acx: FATAL: firmware upload: "
+			       "checksums don't match!\n");
+			result = NOT_OK;
+		}
+	}
+
+	return result;
+}
+
+
+/***********************************************************************
+** acxpci_s_upload_fw
+**
+** Called from acx_reset_dev
+**
+** Origin: Derived from FW dissection
+*/
+static int acxpci_s_upload_fw(acx_device_t * adev)
+{
+	firmware_image_t *fw_image = NULL;
+	int res = NOT_OK;
+	int try;
+	u32 file_size;
+	char filename[sizeof("tiacx1NNcNN")];
+
+	FN_ENTER;
+
+	/* print exact chipset and radio ID to make sure people
+	 * really get a clue on which files exactly they need to provide.
+	 * Firmware loading is a frequent end-user PITA with these chipsets.
+	 */
+	printk( "acx: need firmware for acx1%02d chipset with radio ID %02X\n"
+		"Please provide via firmware hotplug:\n"
+		"either combined firmware (single file named 'tiacx1%02dc%02X')\n"
+		"or two files (base firmware file 'tiacx1%02d' "
+		"+ radio fw 'tiacx1%02dr%02X')\n",
+		IS_ACX111(adev)*11, adev->radio_type,
+		IS_ACX111(adev)*11, adev->radio_type,
+		IS_ACX111(adev)*11,
+		IS_ACX111(adev)*11, adev->radio_type
+		);
+
+	/* print exact chipset and radio ID to make sure people really get a clue on which files exactly they are supposed to provide,
+	 * since firmware loading is the biggest enduser PITA with these chipsets.
+	 * Not printing radio ID in 0xHEX in order to not confuse them into wrong file naming */
+	printk(	"acx: need to load firmware for acx1%02d chipset with radio ID %02x, please provide via firmware hotplug:\n"
+		"acx: either one file only (<c>ombined firmware image file, radio-specific) or two files (radio-less base image file *plus* separate <r>adio-specific extension file)\n",
+		IS_ACX111(adev)*11, adev->radio_type);
+
+	/* Try combined, then main image */
+	adev->need_radio_fw = 0;
+	snprintf(filename, sizeof(filename), "tiacx1%02dc%02X",
+		 IS_ACX111(adev) * 11, adev->radio_type);
+
+	fw_image = acx_s_read_fw(adev->bus_dev, filename, &file_size);
+	if (!fw_image) {
+		adev->need_radio_fw = 1;
+		filename[sizeof("tiacx1NN") - 1] = '\0';
+		fw_image =
+		    acx_s_read_fw(adev->bus_dev, filename, &file_size);
+		if (!fw_image) {
+			FN_EXIT1(NOT_OK);
+			return NOT_OK;
+		}
+	}
+
+	for (try = 1; try <= 5; try++) {
+		res = acxpci_s_write_fw(adev, fw_image, 0);
+		log(L_DEBUG | L_INIT, "acx_write_fw (main/combined): %d\n", res);
+		if (OK == res) {
+			res = acxpci_s_validate_fw(adev, fw_image, 0);
+			log(L_DEBUG | L_INIT, "acx_validate_fw "
+			    		"(main/combined): %d\n", res);
+		}
+
+		if (OK == res) {
+			SET_BIT(adev->dev_state_mask, ACX_STATE_FW_LOADED);
+			break;
+		}
+		printk("acx: firmware upload attempt #%d FAILED, "
+		       "retrying...\n", try);
+		acx_s_msleep(1000);	/* better wait for a while... */
+	}
+
+	vfree(fw_image);
+
+	FN_EXIT1(res);
+	return res;
+}
+
+
+/***********************************************************************
+** acxpci_s_upload_radio
+**
+** Uploads the appropriate radio module firmware into the card.
+**
+** Origin: Standard Read/Write to IO
+*/
+int acxpci_s_upload_radio(acx_device_t * adev)
+{
+	acx_ie_memmap_t mm;
+	firmware_image_t *radio_image;
+	acx_cmd_radioinit_t radioinit;
+	int res = NOT_OK;
+	int try;
+	u32 offset;
+	u32 size;
+	char filename[sizeof("tiacx1NNrNN")];
+
+	if (!adev->need_radio_fw)
+		return OK;
+
+	FN_ENTER;
+
+	acx_s_interrogate(adev, &mm, ACX1xx_IE_MEMORY_MAP);
+	offset = le32_to_cpu(mm.CodeEnd);
+
+	snprintf(filename, sizeof(filename), "tiacx1%02dr%02X",
+		 IS_ACX111(adev) * 11, adev->radio_type);
+	radio_image = acx_s_read_fw(adev->bus_dev, filename, &size);
+	if (!radio_image) {
+		printk("acx: can't load radio module '%s'\n", filename);
+		goto fail;
+	}
+
+	acx_s_issue_cmd(adev, ACX1xx_CMD_SLEEP, NULL, 0);
+
+	for (try = 1; try <= 5; try++) {
+		res = acxpci_s_write_fw(adev, radio_image, offset);
+		log(L_DEBUG | L_INIT, "acx_write_fw (radio): %d\n", res);
+		if (OK == res) {
+			res = acxpci_s_validate_fw(adev, radio_image, offset);
+			log(L_DEBUG | L_INIT, "acx_validate_fw (radio): %d\n",
+			    res);
+		}
+
+		if (OK == res)
+			break;
+		printk("acx: radio firmware upload attempt #%d FAILED, "
+		       "retrying...\n", try);
+		acx_s_msleep(1000);	/* better wait for a while... */
+	}
+
+	acx_s_issue_cmd(adev, ACX1xx_CMD_WAKE, NULL, 0);
+	radioinit.offset = cpu_to_le32(offset);
+	/* no endian conversion needed, remains in card CPU area: */
+	radioinit.len = radio_image->size;
+
+	vfree(radio_image);
+
+	if (OK != res)
+		goto fail;
+
+	/* will take a moment so let's have a big timeout */
+	acx_s_issue_cmd_timeo(adev, ACX1xx_CMD_RADIOINIT,
+			      &radioinit, sizeof(radioinit),
+			      CMD_TIMEOUT_MS(1000));
+
+	res = acx_s_interrogate(adev, &mm, ACX1xx_IE_MEMORY_MAP);
+      fail:
+	FN_EXIT1(res);
+	return res;
+}
+
+
+/***********************************************************************
+** acxpci_l_reset_mac
+**
+** MAC will be reset
+** Call context: reset_dev
+**
+** Origin: Standard Read/Write to IO
+*/
+static void acxpci_l_reset_mac(acx_device_t * adev)
+{
+	u16 temp;
+
+	FN_ENTER;
+
+	/* halt eCPU */
+	temp = read_reg16(adev, IO_ACX_ECPU_CTRL) | 0x1;
+	write_reg16(adev, IO_ACX_ECPU_CTRL, temp);
+
+	/* now do soft reset of eCPU, set bit */
+	temp = read_reg16(adev, IO_ACX_SOFT_RESET) | 0x1;
+	log(L_DEBUG, "enable soft reset\n");
+	write_reg16(adev, IO_ACX_SOFT_RESET, temp);
+	write_flush(adev);
+
+	/* now clear bit again: deassert eCPU reset */
+	log(L_DEBUG, "disable soft reset and go to init mode");
+	write_reg16(adev, IO_ACX_SOFT_RESET, temp & ~0x1);
+
+	/* now start a burst read from initial EEPROM */
+	temp = read_reg16(adev, IO_ACX_EE_START) | 0x1;
+	write_reg16(adev, IO_ACX_EE_START, temp);
+	write_flush(adev);
+
+	FN_EXIT0;
+}
+
+
+/***********************************************************************
+** acxpci_s_verify_init
+*/
+static int acxpci_s_verify_init(acx_device_t * adev)
+{
+	int result = NOT_OK;
+	unsigned long timeout;
+
+	FN_ENTER;
+
+	timeout = jiffies + 2 * HZ;
+	for (;;) {
+		u16 irqstat = read_reg16(adev, IO_ACX_IRQ_STATUS_NON_DES);
+		if (irqstat & HOST_INT_FCS_THRESHOLD) {
+			result = OK;
+			write_reg16(adev, IO_ACX_IRQ_ACK,
+				    HOST_INT_FCS_THRESHOLD);
+			break;
+		}
+		if (time_after(jiffies, timeout))
+			break;
+		/* Init may take up to ~0.5 sec total */
+		acx_s_msleep(50);
+	}
+
+	FN_EXIT1(result);
+	return result;
+}
+
+
+/***********************************************************************
+** A few low-level helpers
+**
+** Note: these functions are not protected by lock
+** and thus are never allowed to be called from IRQ.
+** Also they must not race with fw upload which uses same hw regs
+*/
+
+/***********************************************************************
+** acxpci_write_cmd_type_status
+**
+** Origin: Common linux implementation
+*/
+
+static inline void
+acxpci_write_cmd_type_status(acx_device_t * adev, u16 type, u16 status)
+{
+	acx_writel(type | (status << 16), adev->cmd_area);
+	write_flush(adev);
+}
+
+
+/***********************************************************************
+** acxpci_read_cmd_type_status
+**
+** Origin: Common linux implementation
+*/
+static u32 acxpci_read_cmd_type_status(acx_device_t * adev)
+{
+	u32 cmd_type, cmd_status;
+
+	cmd_type = acx_readl(adev->cmd_area);
+	cmd_status = (cmd_type >> 16);
+	cmd_type = (u16) cmd_type;
+
+	log(L_CTL, "cmd_type:%04X cmd_status:%04X [%s]\n",
+	    cmd_type, cmd_status, acx_cmd_status_str(cmd_status));
+
+	return cmd_status;
+}
+
+
+/***********************************************************************
+** acxpci_s_reset_dev
+**
+** Arguments:
+**	netdevice that contains the adev variable
+** Returns:
+**	NOT_OK on fail
+**	OK on success
+** Side effects:
+**	device is hard reset
+** Call context:
+**	acxpci_e_probe
+** Comment:
+**	This resets the device using low level hardware calls
+**	as well as uploads and verifies the firmware to the card
+*/
+
+static inline void init_mboxes(acx_device_t * adev)
+{
+	u32 cmd_offs, info_offs;
+
+	cmd_offs = read_reg32(adev, IO_ACX_CMD_MAILBOX_OFFS);
+	info_offs = read_reg32(adev, IO_ACX_INFO_MAILBOX_OFFS);
+	adev->cmd_area = (u8 *) adev->iobase2 + cmd_offs;
+	adev->info_area = (u8 *) adev->iobase2 + info_offs;
+	log(L_DEBUG, "iobase2=%p\n"
+	    "cmd_mbox_offset=%X cmd_area=%p\n"
+	    "info_mbox_offset=%X info_area=%p\n",
+	    adev->iobase2,
+	    cmd_offs, adev->cmd_area, info_offs, adev->info_area);
+}
+
+
+static inline void read_eeprom_area(acx_device_t * adev)
+{
+#if ACX_DEBUG > 1
+	int offs;
+	u8 tmp;
+
+	for (offs = 0x8c; offs < 0xb9; offs++)
+		acxpci_read_eeprom_byte(adev, offs, &tmp);
+#endif
+}
+
+
+int acxpci_s_reset_dev(acx_device_t * adev)
+{
+	const char *msg = "";
+	unsigned long flags;
+	int result = NOT_OK;
+	u16 hardware_info;
+	u16 ecpu_ctrl;
+	int count;
+
+	FN_ENTER;
+
+	/* reset the device to make sure the eCPU is stopped
+	 * to upload the firmware correctly */
+
+	acx_lock(adev, flags);
+
+#ifdef CONFIG_PCI
+	acxpci_l_reset_mac(adev);
+#endif
+
+	ecpu_ctrl = read_reg16(adev, IO_ACX_ECPU_CTRL) & 1;
+	if (!ecpu_ctrl) {
+		msg = "eCPU is already running. ";
+		goto end_unlock;
+	}
+#ifdef WE_DONT_NEED_THAT_DO_WE
+	if (read_reg16(adev, IO_ACX_SOR_CFG) & 2) {
+		/* eCPU most likely means "embedded CPU" */
+		msg = "eCPU did not start after boot from flash. ";
+		goto end_unlock;
+	}
+
+	/* check sense on reset flags */
+	if (read_reg16(adev, IO_ACX_SOR_CFG) & 0x10) {
+		printk("%s: eCPU did not start after boot (SOR), "
+		       "is this fatal?\n", wiphy_name(adev->ieee->wiphy));
+	}
+#endif
+	/* scan, if any, is stopped now, setting corresponding IRQ bit */
+	adev->irq_status |= HOST_INT_SCAN_COMPLETE;
+
+	acx_unlock(adev, flags);
+
+	/* need to know radio type before fw load */
+	/* Need to wait for arrival of this information in a loop,
+	 * most probably since eCPU runs some init code from EEPROM
+	 * (started burst read in reset_mac()) which also
+	 * sets the radio type ID */
+
+	count = 0xffff;
+	do {
+		hardware_info = read_reg16(adev, IO_ACX_EEPROM_INFORMATION);
+		if (!--count) {
+			msg = "eCPU didn't indicate radio type";
+			goto end_fail;
+		}
+		cpu_relax();
+	} while (!(hardware_info & 0xff00));	/* radio type still zero? */
+
+	/* printk("DEBUG: count %d\n", count); */
+	adev->form_factor = hardware_info & 0xff;
+	adev->radio_type = hardware_info >> 8;
+
+	/* load the firmware */
+	if (OK != acxpci_s_upload_fw(adev))
+		goto end_fail;
+
+	/* acx_s_msleep(10);    this one really shouldn't be required */
+
+	/* now start eCPU by clearing bit */
+	write_reg16(adev, IO_ACX_ECPU_CTRL, ecpu_ctrl & ~0x1);
+	log(L_DEBUG, "booted eCPU up and waiting for completion...\n");
+
+	/* wait for eCPU bootup */
+	if (OK != acxpci_s_verify_init(adev)) {
+		msg = "timeout waiting for eCPU. ";
+		goto end_fail;
+	}
+	log(L_DEBUG, "eCPU has woken up, card is ready to be configured\n");
+
+	init_mboxes(adev);
+	acxpci_write_cmd_type_status(adev, 0, 0);
+
+	/* test that EEPROM is readable */
+	read_eeprom_area(adev);
+
+	result = OK;
+	goto end;
+
+/* Finish error message. Indicate which function failed */
+      end_unlock:
+	acx_unlock(adev, flags);
+      end_fail:
+	printk("acx: %sreset_dev() FAILED\n", msg);
+      end:
+	FN_EXIT1(result);
+	return result;
+}
+
+
+/***********************************************************************
+** acxpci_s_issue_cmd_timeo
+**
+** Sends command to fw, extract result
+**
+** NB: we do _not_ take lock inside, so be sure to not touch anything
+** which may interfere with IRQ handler operation
+**
+** TODO: busy wait is a bit silly, so:
+** 1) stop doing many iters - go to sleep after first
+** 2) go to waitqueue based approach: wait, not poll!
+*/
+#undef FUNC
+#define FUNC "issue_cmd"
+
+#if !ACX_DEBUG
+int
+acxpci_s_issue_cmd_timeo(acx_device_t * adev,
+			 unsigned int cmd,
+			 void *buffer, unsigned buflen, unsigned cmd_timeout)
+{
+#else
+int
+acxpci_s_issue_cmd_timeo_debug(acx_device_t * adev,
+			       unsigned cmd,
+			       void *buffer,
+			       unsigned buflen,
+			       unsigned cmd_timeout, const char *cmdstr)
+{
+	unsigned long start = jiffies;
+#endif
+	const char *devname;
+	unsigned counter;
+	u16 irqtype;
+	u16 cmd_status;
+	unsigned long timeout;
+
+	FN_ENTER;
+
+
+	devname = wiphy_name(adev->ieee->wiphy);
+	if (!devname || !devname[0] || devname[4] == '%')
+		devname = "acx";
+
+	log(L_CTL, FUNC "(cmd:%s,buflen:%u,timeout:%ums,type:0x%04X)\n",
+	    cmdstr, buflen, cmd_timeout,
+	    buffer ? le16_to_cpu(((acx_ie_generic_t *) buffer)->type) : -1);
+
+	if (!(adev->dev_state_mask & ACX_STATE_FW_LOADED)) {
+		printk("%s: " FUNC "(): firmware is not loaded yet, "
+		       "cannot execute commands!\n", devname);
+		goto bad;
+	}
+
+	if ((acx_debug & L_DEBUG) && (cmd != ACX1xx_CMD_INTERROGATE)) {
+		printk("input buffer (len=%u):\n", buflen);
+		acx_dump_bytes(buffer, buflen);
+	}
+
+	/* wait for firmware to become idle for our command submission */
+	timeout = HZ / 5;
+	counter = (timeout * 1000 / HZ) - 1;	/* in ms */
+	timeout += jiffies;
+	do {
+		cmd_status = acxpci_read_cmd_type_status(adev);
+		/* Test for IDLE state */
+		if (!cmd_status)
+			break;
+		if (counter % 8 == 0) {
+			if (time_after(jiffies, timeout)) {
+				counter = 0;
+				break;
+			}
+			/* we waited 8 iterations, no luck. Sleep 8 ms */
+			acx_s_msleep(8);
+		}
+	} while (likely(--counter));
+
+	if (!counter) {
+		/* the card doesn't get idle, we're in trouble */
+		printk("%s: " FUNC "(): cmd_status is not IDLE: 0x%04X!=0\n",
+		       devname, cmd_status);
+		goto bad;
+	} else if (counter < 190) {	/* if waited >10ms... */
+		log(L_CTL | L_DEBUG, FUNC "(): waited for IDLE %dms. "
+		    "Please report\n", 199 - counter);
+	}
+
+	/* now write the parameters of the command if needed */
+	if (buffer && buflen) {
+		/* if it's an INTERROGATE command, just pass the length
+		 * of parameters to read, as data */
+#if CMD_DISCOVERY
+		if (cmd == ACX1xx_CMD_INTERROGATE)
+			memset_io(adev->cmd_area + 4, 0xAA, buflen);
+#endif
+		/* adev->cmd_area points to PCI device's memory, not to RAM! */
+		memcpy_toio(adev->cmd_area + 4, buffer,
+			    (cmd == ACX1xx_CMD_INTERROGATE) ? 4 : buflen);
+	}
+	/* now write the actual command type */
+	acxpci_write_cmd_type_status(adev, cmd, 0);
+	/* execute command */
+	write_reg16(adev, IO_ACX_INT_TRIG, INT_TRIG_CMD);
+	write_flush(adev);
+
+	/* wait for firmware to process command */
+
+	/* Ensure nonzero and not too large timeout.
+	 ** Also converts e.g. 100->99, 200->199
+	 ** which is nice but not essential */
+	cmd_timeout = (cmd_timeout - 1) | 1;
+	if (unlikely(cmd_timeout > 1199))
+		cmd_timeout = 1199;
+	/* clear CMD_COMPLETE bit. can be set only by IRQ handler: */
+	adev->irq_status &= ~HOST_INT_CMD_COMPLETE;
+
+	/* we schedule away sometimes (timeout can be large) */
+	counter = cmd_timeout;
+	timeout = jiffies + cmd_timeout * HZ / 1000;
+	do {
+		if (!adev->irqs_active) {	/* IRQ disabled: poll */
+			irqtype = read_reg16(adev, IO_ACX_IRQ_STATUS_NON_DES);
+			if (irqtype & HOST_INT_CMD_COMPLETE) {
+				write_reg16(adev, IO_ACX_IRQ_ACK,
+					    HOST_INT_CMD_COMPLETE);
+				break;
+			}
+		} else {	/* Wait when IRQ will set the bit */
+			irqtype = adev->irq_status;
+			if (irqtype & HOST_INT_CMD_COMPLETE)
+				break;
+		}
+
+		if (counter % 8 == 0) {
+			if (time_after(jiffies, timeout)) {
+				counter = 0;
+				break;
+			}
+			/* we waited 8 iterations, no luck. Sleep 8 ms */
+			acx_s_msleep(8);
+		}
+	} while (likely(--counter));
+
+	/* save state for debugging */
+	cmd_status = acxpci_read_cmd_type_status(adev);
+
+	/* put the card in IDLE state */
+	acxpci_write_cmd_type_status(adev, 0, 0);
+
+	if (!counter) {		/* timed out! */
+		printk("%s: " FUNC "(): timed out %s for CMD_COMPLETE. "
+		       "irq bits:0x%04X irq_status:0x%04X timeout:%dms "
+		       "cmd_status:%d (%s)\n",
+		       devname, (adev->irqs_active) ? "waiting" : "polling",
+		       irqtype, adev->irq_status, cmd_timeout,
+		       cmd_status, acx_cmd_status_str(cmd_status));
+		goto bad;
+	} else if (cmd_timeout - counter > 30) {	/* if waited >30ms... */
+		log(L_CTL | L_DEBUG, FUNC "(): %s for CMD_COMPLETE %dms. "
+		    "count:%d. Please report\n",
+		    (adev->irqs_active) ? "waited" : "polled",
+		    cmd_timeout - counter, counter);
+	}
+
+	if (1 != cmd_status) {	/* it is not a 'Success' */
+		printk("%s: " FUNC "(): cmd_status is not SUCCESS: %d (%s). "
+		       "Took %dms of %d\n",
+		       devname, cmd_status, acx_cmd_status_str(cmd_status),
+		       cmd_timeout - counter, cmd_timeout);
+		/* zero out result buffer
+		 * WARNING: this will trash stack in case of illegally large input
+		 * length! */
+		if (buffer && buflen)
+			memset(buffer, 0, buflen);
+		goto bad;
+	}
+
+	/* read in result parameters if needed */
+	if (buffer && buflen && (cmd == ACX1xx_CMD_INTERROGATE)) {
+		/* adev->cmd_area points to PCI device's memory, not to RAM! */
+		memcpy_fromio(buffer, adev->cmd_area + 4, buflen);
+		if (acx_debug & L_DEBUG) {
+			printk("output buffer (len=%u): ", buflen);
+			acx_dump_bytes(buffer, buflen);
+		}
+	}
+/* ok: */
+	log(L_CTL, FUNC "(%s): took %ld jiffies to complete\n",
+	    cmdstr, jiffies - start);
+	FN_EXIT1(OK);
+	return OK;
+
+      bad:
+	/* Give enough info so that callers can avoid
+	 ** printing their own diagnostic messages */
+#if ACX_DEBUG
+	printk("%s: " FUNC "(cmd:%s) FAILED\n", devname, cmdstr);
+#else
+	printk("%s: " FUNC "(cmd:0x%04X) FAILED\n", devname, cmd);
+#endif
+	dump_stack();
+	FN_EXIT1(NOT_OK);
+	return NOT_OK;
+}
+
+
+/***********************************************************************
+*/
+#ifdef NONESSENTIAL_FEATURES
+typedef struct device_id {
+	unsigned char id[6];
+	char *descr;
+	char *type;
+} device_id_t;
+
+static const device_id_t device_ids[] = {
+	{
+	 {'G', 'l', 'o', 'b', 'a', 'l'},
+	 NULL,
+	 NULL,
+	 },
+	{
+	 {0xff, 0xff, 0xff, 0xff, 0xff, 0xff},
+	 "uninitialized",
+	 "SpeedStream SS1021 or Gigafast WF721-AEX"},
+	{
+	 {0x80, 0x81, 0x82, 0x83, 0x84, 0x85},
+	 "non-standard",
+	 "DrayTek Vigor 520"},
+	{
+	 {'?', '?', '?', '?', '?', '?'},
+	 "non-standard",
+	 "Level One WPC-0200"},
+	{
+	 {0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
+	 "empty",
+	 "DWL-650+ variant"}
+};
+
+static void acx_show_card_eeprom_id(acx_device_t * adev)
+{
+	unsigned char buffer[CARD_EEPROM_ID_SIZE];
+	int i;
+
+	memset(&buffer, 0, CARD_EEPROM_ID_SIZE);
+	/* use direct EEPROM access */
+	for (i = 0; i < CARD_EEPROM_ID_SIZE; i++) {
+		if (OK != acxpci_read_eeprom_byte(adev,
+						  ACX100_EEPROM_ID_OFFSET + i,
+						  &buffer[i])) {
+			printk("acx: reading EEPROM FAILED\n");
+			break;
+		}
+	}
+
+	for (i = 0; i < ARRAY_SIZE(device_ids); i++) {
+		if (!memcmp(&buffer, device_ids[i].id, CARD_EEPROM_ID_SIZE)) {
+			if (device_ids[i].descr) {
+				printk("acx: EEPROM card ID string check "
+				       "found %s card ID: is this %s?\n",
+				       device_ids[i].descr, device_ids[i].type);
+			}
+			break;
+		}
+	}
+	if (i == ARRAY_SIZE(device_ids)) {
+		printk("acx: EEPROM card ID string check found "
+		       "unknown card: expected 'Global', got '%.*s\'. "
+		       "Please report\n", CARD_EEPROM_ID_SIZE, buffer);
+	}
+}
+#endif /* NONESSENTIAL_FEATURES */
+
+
+/***********************************************************************
+** acxpci_free_desc_queues
+**
+** Releases the queues that have been allocated, the
+** others have been initialised to NULL so this
+** function can be used if only part of the queues were allocated.
+*/
+
+static inline void
+free_coherent(struct pci_dev *hwdev, size_t size,
+	      void *vaddr, dma_addr_t dma_handle)
+{
+	dma_free_coherent(hwdev == NULL ? NULL : &hwdev->dev,
+			  size, vaddr, dma_handle);
+}
+
+
+void acxpci_free_desc_queues(acx_device_t * adev)
+{
+#define ACX_FREE_QUEUE(size, ptr, phyaddr) \
+	if (ptr) { \
+		free_coherent(NULL, size, ptr, phyaddr); \
+		ptr = NULL; \
+		size = 0; \
+	}
+
+	FN_ENTER;
+
+	ACX_FREE_QUEUE(adev->txhostdesc_area_size, adev->txhostdesc_start,
+		       adev->txhostdesc_startphy);
+	ACX_FREE_QUEUE(adev->txbuf_area_size, adev->txbuf_start,
+		       adev->txbuf_startphy);
+
+	adev->txdesc_start = NULL;
+
+	ACX_FREE_QUEUE(adev->rxhostdesc_area_size, adev->rxhostdesc_start,
+		       adev->rxhostdesc_startphy);
+	ACX_FREE_QUEUE(adev->rxbuf_area_size, adev->rxbuf_start,
+		       adev->rxbuf_startphy);
+
+	adev->rxdesc_start = NULL;
+
+	FN_EXIT0;
+}
+
+
+/***********************************************************************
+** acxpci_s_delete_dma_regions
+*/
+static void acxpci_s_delete_dma_regions(acx_device_t * adev)
+{
+	unsigned long flags;
+
+	FN_ENTER;
+	/* disable radio Tx/Rx. Shouldn't we use the firmware commands
+	 * here instead? Or are we that much down the road that it's no
+	 * longer possible here? */
+	write_reg16(adev, IO_ACX_ENABLE, 0);
+
+	acx_s_msleep(100);
+
+	acx_lock(adev, flags);
+	acxpci_free_desc_queues(adev);
+	acx_unlock(adev, flags);
+
+	FN_EXIT0;
+}
+
+
+/***********************************************************************
+** acxpci_e_probe
+**
+** Probe routine called when a PCI device w/ matching ID is found.
+** Here's the sequence:
+**   - Allocate the PCI resources.
+**   - Read the PCMCIA attribute memory to make sure we have a WLAN card
+**   - Reset the MAC
+**   - Initialize the dev and wlan data
+**   - Initialize the MAC
+**
+** pdev	- ptr to pci device structure containing info about pci configuration
+** id	- ptr to the device id entry that matched this device
+*/
+static const u16 IO_ACX100[] = {
+	0x0000,			/* IO_ACX_SOFT_RESET */
+
+	0x0014,			/* IO_ACX_SLV_MEM_ADDR */
+	0x0018,			/* IO_ACX_SLV_MEM_DATA */
+	0x001c,			/* IO_ACX_SLV_MEM_CTL */
+	0x0020,			/* IO_ACX_SLV_END_CTL */
+
+	0x0034,			/* IO_ACX_FEMR */
+
+	0x007c,			/* IO_ACX_INT_TRIG */
+	0x0098,			/* IO_ACX_IRQ_MASK */
+	0x00a4,			/* IO_ACX_IRQ_STATUS_NON_DES */
+	0x00a8,			/* IO_ACX_IRQ_STATUS_CLEAR */
+	0x00ac,			/* IO_ACX_IRQ_ACK */
+	0x00b0,			/* IO_ACX_HINT_TRIG */
+
+	0x0104,			/* IO_ACX_ENABLE */
+
+	0x0250,			/* IO_ACX_EEPROM_CTL */
+	0x0254,			/* IO_ACX_EEPROM_ADDR */
+	0x0258,			/* IO_ACX_EEPROM_DATA */
+	0x025c,			/* IO_ACX_EEPROM_CFG */
+
+	0x0268,			/* IO_ACX_PHY_ADDR */
+	0x026c,			/* IO_ACX_PHY_DATA */
+	0x0270,			/* IO_ACX_PHY_CTL */
+
+	0x0290,			/* IO_ACX_GPIO_OE */
+
+	0x0298,			/* IO_ACX_GPIO_OUT */
+
+	0x02a4,			/* IO_ACX_CMD_MAILBOX_OFFS */
+	0x02a8,			/* IO_ACX_INFO_MAILBOX_OFFS */
+	0x02ac,			/* IO_ACX_EEPROM_INFORMATION */
+
+	0x02d0,			/* IO_ACX_EE_START */
+	0x02d4,			/* IO_ACX_SOR_CFG */
+	0x02d8			/* IO_ACX_ECPU_CTRL */
+};
+
+static const u16 IO_ACX111[] = {
+	0x0000,			/* IO_ACX_SOFT_RESET */
+
+	0x0014,			/* IO_ACX_SLV_MEM_ADDR */
+	0x0018,			/* IO_ACX_SLV_MEM_DATA */
+	0x001c,			/* IO_ACX_SLV_MEM_CTL */
+	0x0020,			/* IO_ACX_SLV_END_CTL */
+
+	0x0034,			/* IO_ACX_FEMR */
+
+	0x00b4,			/* IO_ACX_INT_TRIG */
+	0x00d4,			/* IO_ACX_IRQ_MASK */
+	/* we do mean NON_DES (0xf0), not NON_DES_MASK which is at 0xe0: */
+	0x00f0,			/* IO_ACX_IRQ_STATUS_NON_DES */
+	0x00e4,			/* IO_ACX_IRQ_STATUS_CLEAR */
+	0x00e8,			/* IO_ACX_IRQ_ACK */
+	0x00ec,			/* IO_ACX_HINT_TRIG */
+
+	0x01d0,			/* IO_ACX_ENABLE */
+
+	0x0338,			/* IO_ACX_EEPROM_CTL */
+	0x033c,			/* IO_ACX_EEPROM_ADDR */
+	0x0340,			/* IO_ACX_EEPROM_DATA */
+	0x0344,			/* IO_ACX_EEPROM_CFG */
+
+	0x0350,			/* IO_ACX_PHY_ADDR */
+	0x0354,			/* IO_ACX_PHY_DATA */
+	0x0358,			/* IO_ACX_PHY_CTL */
+
+	0x0374,			/* IO_ACX_GPIO_OE */
+
+	0x037c,			/* IO_ACX_GPIO_OUT */
+
+	0x0388,			/* IO_ACX_CMD_MAILBOX_OFFS */
+	0x038c,			/* IO_ACX_INFO_MAILBOX_OFFS */
+	0x0390,			/* IO_ACX_EEPROM_INFORMATION */
+
+	0x0100,			/* IO_ACX_EE_START */
+	0x0104,			/* IO_ACX_SOR_CFG */
+	0x0108,			/* IO_ACX_ECPU_CTRL */
+};
+
+static const struct ieee80211_ops acxpci_hw_ops = {
+        .tx = acx_i_start_xmit,
+        .conf_tx = acx_net_conf_tx,
+        .add_interface = acx_add_interface,
+        .remove_interface = acx_remove_interface,
+	.open = acxpci_e_open,
+	.stop = acxpci_e_close,
+        .reset = acx_net_reset,
+        .config = acx_net_config,
+        .config_interface = acx_config_interface,
+        .set_multicast_list = acx_i_set_multicast_list,
+        .set_key = acx_net_set_key,
+        .get_stats = acx_e_get_stats,
+        .get_tx_stats = acx_net_get_tx_stats,
+};
+
+
+#ifdef CONFIG_PCI
+static int __devinit
+acxpci_e_probe(struct pci_dev *pdev, const struct pci_device_id *id)
+{
+	acx111_ie_configoption_t co;
+	unsigned long mem_region1 = 0;
+	unsigned long mem_region2 = 0;
+	unsigned long mem_region1_size;
+	unsigned long mem_region2_size;
+	unsigned long phymem1;
+	unsigned long phymem2;
+	void *mem1 = NULL;
+	void *mem2 = NULL;
+	acx_device_t *adev = NULL;
+	const char *chip_name;
+	int result = -EIO;
+	int err;
+	u8 chip_type;
+	struct ieee80211_hw *ieee;
+
+	FN_ENTER;
+
+	ieee = ieee80211_alloc_hw(sizeof(struct acx_device), &acxpci_hw_ops);
+	if (!ieee) {
+		printk("acx: could not allocate ieee80211 structure %s\n",
+		       pci_name(pdev));
+		goto fail_alloc_netdev;
+	}
+	ieee->flags &=	 ~IEEE80211_HW_RX_INCLUDES_FCS &
+			 ~IEEE80211_HW_MONITOR_DURING_OPER |
+			 IEEE80211_HW_WEP_INCLUDE_IV;
+	ieee->queues = 1;
+
+	/* (NB: memsets to 0 entire area) */
+	if (!ieee) {
+		printk("acx: could not allocate ieee structure %s\n",
+		       pci_name(pdev));
+		goto fail_alloc_netdev;
+	}
+
+	adev = ieee2adev(ieee);
+
+	memset(adev, 0, sizeof(*adev));
+	/** Set up our private interface **/
+	spin_lock_init(&adev->lock);	/* initial state: unlocked */
+	/* We do not start with downed sem: we want PARANOID_LOCKING to work */
+	mutex_init(&adev->mutex);
+	/* since nobody can see new netdev yet, we can as well
+	 ** just _presume_ that we're under sem (instead of actually taking it): */
+	/* acx_sem_lock(adev); */
+	adev->ieee = ieee;
+	adev->pdev = pdev;
+	adev->bus_dev = &pdev->dev;
+	adev->dev_type = DEVTYPE_PCI;
+
+/** Finished with private interface **/
+
+/** begin board specific inits **/
+	pci_set_drvdata(pdev, ieee);
+
+	/* Enable the PCI device */
+	if (pci_enable_device(pdev)) {
+		printk("acx: pci_enable_device() FAILED\n");
+		result = -ENODEV;
+		goto fail_pci_enable_device;
+	}
+
+	/* enable busmastering (required for CardBus) */
+	pci_set_master(pdev);
+
+
+	/* chiptype is u8 but id->driver_data is ulong
+	 ** Works for now (possible values are 1 and 2) */
+	chip_type = (u8) id->driver_data;
+	/* acx100 and acx111 have different PCI memory regions */
+	if (chip_type == CHIPTYPE_ACX100) {
+		chip_name = "ACX100";
+		mem_region1 = PCI_ACX100_REGION1;
+		mem_region1_size = PCI_ACX100_REGION1_SIZE;
+
+		mem_region2 = PCI_ACX100_REGION2;
+		mem_region2_size = PCI_ACX100_REGION2_SIZE;
+	} else if (chip_type == CHIPTYPE_ACX111) {
+		chip_name = "ACX111";
+		mem_region1 = PCI_ACX111_REGION1;
+		mem_region1_size = PCI_ACX111_REGION1_SIZE;
+
+		mem_region2 = PCI_ACX111_REGION2;
+		mem_region2_size = PCI_ACX111_REGION2_SIZE;
+	} else {
+		printk("acx: unknown chip type 0x%04X\n", chip_type);
+		goto fail_unknown_chiptype;
+	}
+
+	/* Figure out our resources */
+	phymem1 = pci_resource_start(pdev, mem_region1);
+	phymem2 = pci_resource_start(pdev, mem_region2);
+	if (!request_mem_region
+	    (phymem1, pci_resource_len(pdev, mem_region1), "acx_1")) {
+		printk("acx: cannot reserve PCI memory region 1 (are you sure "
+		       "you have CardBus support in kernel?)\n");
+		goto fail_request_mem_region1;
+	}
+	if (!request_mem_region
+	    (phymem2, pci_resource_len(pdev, mem_region2), "acx_2")) {
+		printk("acx: cannot reserve PCI memory region 2\n");
+		goto fail_request_mem_region2;
+	}
+	/* this used to be ioremap(), but ioremap_nocache()
+	 * is much less risky, right? (and slower?)
+	 * FIXME: we may want to go back to cached variant if it's
+	 * certain that our code really properly handles
+	 * cached operation (memory barriers, volatile?, ...)
+	 * (but always keep this comment here regardless!)
+	 * Possibly make this a driver config setting?
+	 */
+	
+	mem1 = ioremap_nocache(phymem1, mem_region1_size);
+	if (!mem1) {
+		printk("acx: ioremap() FAILED\n");
+		goto fail_ioremap1;
+	}
+	mem2 = ioremap_nocache(phymem2, mem_region2_size);
+	if (!mem2) {
+		printk("acx: ioremap() #2 FAILED\n");
+		goto fail_ioremap2;
+	}
+
+	printk("acx: found %s-based wireless network card at %s, irq:%d, "
+	       "phymem1:0x%lX, phymem2:0x%lX, mem1:0x%p, mem1_size:%ld, "
+	       "mem2:0x%p, mem2_size:%ld\n",
+	       chip_name, pci_name(pdev), pdev->irq, phymem1, phymem2,
+	       mem1, mem_region1_size, mem2, mem_region2_size);
+	log(L_ANY, "initial debug setting is 0x%04X\n", acx_debug);
+	adev->chip_type = chip_type;
+	adev->chip_name = chip_name;
+	adev->io = (CHIPTYPE_ACX100 == chip_type) ? IO_ACX100 : IO_ACX111;
+	adev->membase = phymem1;
+	adev->iobase = mem1;
+	adev->membase2 = phymem2;
+	adev->iobase2 = mem2;
+	adev->irq = pdev->irq;
+
+
+	if (0 == pdev->irq) {
+		printk("acx: can't use IRQ 0\n");
+		goto fail_irq;
+	}
+	SET_IEEE80211_DEV(ieee, &pdev->dev);
+
+
+	/* to find crashes due to weird driver access
+	 * to unconfigured interface (ifup) */
+	adev->mgmt_timer.function = (void (*)(unsigned long))0x0000dead;
+
+
+#ifdef NONESSENTIAL_FEATURES
+	acx_show_card_eeprom_id(adev);
+#endif /* NONESSENTIAL_FEATURES */
+
+
+	/* ok, pci setup is finished, now start initializing the card */
+
+	/* NB: read_reg() reads may return bogus data before reset_dev(),
+	 * since the firmware which directly controls large parts of the I/O
+	 * registers isn't initialized yet.
+	 * acx100 seems to be more affected than acx111 */
+	if (OK != acxpci_s_reset_dev(adev))
+		goto fail_reset;
+
+	if (IS_ACX100(adev)) {
+		/* ACX100: configopt struct in cmd mailbox - directly after reset */
+		memcpy_fromio(&co, adev->cmd_area, sizeof(co));
+	}
+
+	if (OK != acx_s_init_mac(adev))
+		goto fail_init_mac;
+
+	if (IS_ACX111(adev)) {
+		/* ACX111: configopt struct needs to be queried after full init */
+		acx_s_interrogate(adev, &co, ACX111_IE_CONFIG_OPTIONS);
+	}
+/* TODO: merge them into one function, they are called just once and are the same for pci & usb */
+	if (OK != acxpci_read_eeprom_byte(adev, 0x05, &adev->eeprom_version))
+		goto fail_read_eeprom_version;
+
+	acx_s_parse_configoption(adev, &co);
+	acx_s_set_defaults(adev);
+	acx_s_get_firmware_version(adev);	/* needs to be after acx_s_init_mac() */
+	acx_display_hardware_details(adev);
+
+	/* Register the card, AFTER everything else has been set up,
+	 * since otherwise an ioctl could step on our feet due to
+	 * firmware operations happening in parallel or uninitialized data */
+
+
+	acx_proc_register_entries(ieee);
+
+	/* Now we have our device, so make sure the kernel doesn't try
+	 * to send packets even though we're not associated to a network yet */
+
+	/* after register_netdev() userspace may start working with dev
+	 * (in particular, on other CPUs), we only need to up the sem */
+	/* acx_sem_unlock(adev); */
+
+	printk("acx " ACX_RELEASE ": net device %s, driver compiled "
+	       "against wireless extensions %d and Linux %s\n",
+	       wiphy_name(adev->ieee->wiphy), WIRELESS_EXT, UTS_RELEASE);
+
+	MAC_COPY(adev->ieee->wiphy->perm_addr, adev->dev_addr);
+
+	log(L_IRQ | L_INIT, "using IRQ %d\n", pdev->irq);
+
+/** done with board specific setup **/
+
+	/* need to be able to restore PCI state after a suspend */
+#ifdef CONFIG_PM
+	pci_save_state(pdev);
+#endif
+
+
+	acx_init_task_scheduler(adev);
+	err = ieee80211_register_hw(adev->ieee);
+	if (OK != err) {
+		printk("acx: ieee80211_register_hw() FAILED: %d\n", err);
+		goto fail_register_netdev;
+	}
+#if CMD_DISCOVERY
+	great_inquisitor(adev);
+#endif
+
+	result = OK;
+	goto done;
+
+	/* error paths: undo everything in reverse order... */
+
+
+	acxpci_s_delete_dma_regions(adev);
+	pci_set_drvdata(pdev, NULL);
+
+      fail_init_mac:
+      fail_read_eeprom_version:
+      fail_reset:
+
+      fail_alloc_netdev:
+      fail_irq:
+
+	iounmap(mem2);
+      fail_ioremap2:
+
+	iounmap(mem1);
+      fail_ioremap1:
+
+	release_mem_region(pci_resource_start(pdev, mem_region2),
+			   pci_resource_len(pdev, mem_region2));
+      fail_request_mem_region2:
+
+	release_mem_region(pci_resource_start(pdev, mem_region1),
+			   pci_resource_len(pdev, mem_region1));
+      fail_request_mem_region1:
+      fail_unknown_chiptype:
+
+	pci_disable_device(pdev);
+      fail_pci_enable_device:
+
+#ifdef CONFIG_PM
+	pci_set_power_state(pdev, PCI_D3hot);
+#endif
+      fail_register_netdev:
+	ieee80211_free_hw(ieee);
+      done:
+	FN_EXIT1(result);
+	return result;
+}
+
+
+/***********************************************************************
+** acxpci_e_remove
+**
+** Shut device down (if not hot unplugged)
+** and deallocate PCI resources for the acx chip.
+**
+** pdev - ptr to PCI device structure containing info about pci configuration
+*/
+static void __devexit acxpci_e_remove(struct pci_dev *pdev)
+{
+	struct ieee80211_hw *hw = (struct ieee80211_hw *)pci_get_drvdata(pdev);
+	acx_device_t *adev = ieee2adev(hw);
+	unsigned long mem_region1, mem_region2;
+	unsigned long flags;
+	FN_ENTER;
+
+	if (!hw) {
+		log(L_DEBUG, "%s: card is unused. Skipping any release code\n",
+		    __func__);
+		goto end;
+	}
+
+
+	acx_lock(adev, flags);
+	acx_unlock(adev, flags);
+	adev->initialized = 0;
+
+	/* If device wasn't hot unplugged... */
+	if (adev_present(adev)) {
+
+		acx_sem_lock(adev);
+
+		/* disable both Tx and Rx to shut radio down properly */
+		if (adev->initialized) {
+			acx_s_issue_cmd(adev, ACX1xx_CMD_DISABLE_TX, NULL, 0);
+			acx_s_issue_cmd(adev, ACX1xx_CMD_DISABLE_RX, NULL, 0);
+		}
+#ifdef REDUNDANT
+		/* put the eCPU to sleep to save power
+		 * Halting is not possible currently,
+		 * since not supported by all firmware versions */
+		acx_s_issue_cmd(adev, ACX100_CMD_SLEEP, NULL, 0);
+#endif
+		acx_lock(adev, flags);
+		/* disable power LED to save power :-) */
+		log(L_INIT, "switching off power LED to save power\n");
+		acxpci_l_power_led(adev, 0);
+		/* stop our eCPU */
+		if (IS_ACX111(adev)) {
+			/* FIXME: does this actually keep halting the eCPU?
+			 * I don't think so...
+			 */
+			acxpci_l_reset_mac(adev);
+		} else {
+			u16 temp;
+			/* halt eCPU */
+			temp = read_reg16(adev, IO_ACX_ECPU_CTRL) | 0x1;
+			write_reg16(adev, IO_ACX_ECPU_CTRL, temp);
+			write_flush(adev);
+		}
+		acx_unlock(adev, flags);
+
+		acx_sem_unlock(adev);
+	}
+
+	/* unregister the device to not let the kernel
+	 * (e.g. ioctls) access a half-deconfigured device
+	 * NB: this will cause acxpci_e_close() to be called,
+	 * thus we shouldn't call it under sem!
+	 * Well, netdev did, but ieee80211 stack does not, so we
+	 * have to do so manually...
+	 */
+	acxpci_e_close(hw);
+	log(L_INIT, "removing device %s\n", wiphy_name(adev->ieee->wiphy));
+	ieee80211_unregister_hw(adev->ieee);
+
+	/* unregister_netdev ensures that no references to us left.
+	 * For paranoid reasons we continue to follow the rules */
+	acx_sem_lock(adev);
+
+	if (adev->dev_state_mask & ACX_STATE_IFACE_UP) {
+		acxpci_s_down(hw);
+		CLEAR_BIT(adev->dev_state_mask, ACX_STATE_IFACE_UP);
+	}
+
+	acx_proc_unregister_entries(adev->ieee);
+
+	if (IS_ACX100(adev)) {
+		mem_region1 = PCI_ACX100_REGION1;
+		mem_region2 = PCI_ACX100_REGION2;
+	} else {
+		mem_region1 = PCI_ACX111_REGION1;
+		mem_region2 = PCI_ACX111_REGION2;
+	}
+
+	/* finally, clean up PCI bus state */
+	acxpci_s_delete_dma_regions(adev);
+	if (adev->iobase)
+		iounmap(adev->iobase);
+	if (adev->iobase2)
+		iounmap(adev->iobase2);
+	release_mem_region(pci_resource_start(pdev, mem_region1),
+			   pci_resource_len(pdev, mem_region1));
+	release_mem_region(pci_resource_start(pdev, mem_region2),
+			   pci_resource_len(pdev, mem_region2));
+	pci_disable_device(pdev);
+
+	/* remove dev registration */
+
+	free_irq(adev->irq, adev);
+	acx_sem_unlock(adev);
+
+	/* Free netdev (quite late,
+	 * since otherwise we might get caught off-guard
+	 * by a netdev timeout handler execution
+	 * expecting to see a working dev...) */
+	ieee80211_free_hw(adev->ieee);
+
+	/* put device into ACPI D3 mode (shutdown) */
+#ifdef CONFIG_PM
+	pci_set_power_state(pdev, PCI_D3hot);
+#endif
+      end:
+	FN_EXIT0;
+}
+
+
+/***********************************************************************
+** TODO: PM code needs to be fixed / debugged / tested.
+*/
+#ifdef CONFIG_PM
+static int
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 11)
+acxpci_e_suspend(struct pci_dev *pdev, pm_message_t state)
+#else
+acxpci_e_suspend(struct pci_dev *pdev, u32 state)
+#endif
+{
+	struct ieee80211_hw *hw = pci_get_drvdata(pdev);
+	acx_device_t *adev;
+
+	FN_ENTER;
+	printk("acx: suspend handler is experimental!\n");
+	printk("sus: dev %p\n", hw);
+
+/*	if (!netif_running(ndev))
+		goto end;
+*/
+	adev = ieee2adev(hw);
+	printk("sus: adev %p\n", adev);
+
+	acx_sem_lock(adev);
+
+	ieee80211_unregister_hw(hw);	/* this one cannot sleep */
+	acxpci_s_down(hw);
+	/* down() does not set it to 0xffff, but here we really want that */
+	write_reg16(adev, IO_ACX_IRQ_MASK, 0xffff);
+	write_reg16(adev, IO_ACX_FEMR, 0x0);
+	acxpci_s_delete_dma_regions(adev);
+	pci_save_state(pdev);
+	pci_set_power_state(pdev, PCI_D3hot);
+
+	acx_sem_unlock(adev);
+	FN_EXIT0;
+	return OK;
+}
+
+
+static int acxpci_e_resume(struct pci_dev *pdev)
+{
+	struct ieee80211_hw *hw = pci_get_drvdata(pdev);
+	acx_device_t *adev;
+
+	FN_ENTER;
+
+	printk("acx: resume handler is experimental!\n");
+	printk("rsm: got dev %p\n", hw);
+
+
+	adev = ieee2adev(hw);
+	printk("rsm: got adev %p\n", adev);
+
+	acx_sem_lock(adev);
+
+	pci_set_power_state(pdev, PCI_D0);
+	printk("rsm: power state PCI_D0 set\n");
+	pci_restore_state(pdev);
+	printk("rsm: PCI state restored\n");
+
+	if (OK != acxpci_s_reset_dev(adev))
+		goto end_unlock;
+	printk("rsm: device reset done\n");
+	if (OK != acx_s_init_mac(adev))
+		goto end_unlock;
+	printk("rsm: init MAC done\n");
+
+	acxpci_s_up(hw);
+	printk("rsm: acx up done\n");
+
+	/* now even reload all card parameters as they were before suspend,
+	 * and possibly be back in the network again already :-) */
+	if (ACX_STATE_IFACE_UP & adev->dev_state_mask) {
+		adev->set_mask = GETSET_ALL;
+		acx_s_update_card_settings(adev);
+		printk("rsm: settings updated\n");
+	}
+	ieee80211_register_hw(hw);
+	printk("rsm: device attached\n");
+
+      end_unlock:
+	acx_sem_unlock(adev);
+	/* we need to return OK here anyway, right? */
+	FN_EXIT0;
+	return OK;
+}
+#endif /* CONFIG_PM */
+#endif /* CONFIG_PCI */
+
+/***********************************************************************
+** acxpci_s_up
+**
+** This function is called by acxpci_e_open (when ifconfig sets the device as up)
+**
+** Side effects:
+** - Enables on-card interrupt requests
+** - calls acx_s_start
+*/
+
+static void enable_acx_irq(acx_device_t * adev)
+{
+	FN_ENTER;
+	write_reg16(adev, IO_ACX_IRQ_MASK, adev->irq_mask);
+	write_reg16(adev, IO_ACX_FEMR, 0x8000);
+	adev->irqs_active = 1;
+	FN_EXIT0;
+}
+
+static void acxpci_s_up(struct ieee80211_hw *hw)
+{
+	acx_device_t *adev = ieee2adev(hw);
+	unsigned long flags;
+
+	FN_ENTER;
+
+	acx_lock(adev, flags);
+	enable_acx_irq(adev);
+	acx_unlock(adev, flags);
+
+	/* acx fw < 1.9.3.e has a hardware timer, and older drivers
+	 ** used to use it. But we don't do that anymore, our OS
+	 ** has reliable software timers */
+	init_timer(&adev->mgmt_timer);
+	adev->mgmt_timer.function = acx_i_timer;
+	adev->mgmt_timer.data = (unsigned long)adev;
+
+	/* Need to set ACX_STATE_IFACE_UP first, or else
+	 ** timer won't be started by acx_set_status() */
+	SET_BIT(adev->dev_state_mask, ACX_STATE_IFACE_UP);
+
+	acx_s_start(adev);
+
+	FN_EXIT0;
+}
+
+
+/***********************************************************************
+** acxpci_s_down
+**
+** NB: device may be already hot unplugged if called from acxpci_e_remove()
+**
+** Disables on-card interrupt request, stops softirq and timer, stops queue,
+** sets status == STOPPED
+*/
+
+static void disable_acx_irq(acx_device_t * adev)
+{
+	FN_ENTER;
+
+	/* I guess mask is not 0xffff because acx100 won't signal
+	 ** cmd completion then (needed for ifup).
+	 ** Someone with acx100 please confirm */
+	write_reg16(adev, IO_ACX_IRQ_MASK, adev->irq_mask_off);
+	write_reg16(adev, IO_ACX_FEMR, 0x0);
+	adev->irqs_active = 0;
+	FN_EXIT0;
+}
+
+static void acxpci_s_down(struct ieee80211_hw *hw)
+{
+	acx_device_t *adev = ieee2adev(hw);
+	unsigned long flags;
+
+	FN_ENTER;
+
+	/* Disable IRQs first, so that IRQs cannot race with us */
+	/* then wait until interrupts have finished executing on other CPUs */
+	acx_lock(adev, flags);
+	disable_acx_irq(adev);
+        synchronize_irq(adev->irq);
+	acx_unlock(adev, flags);
+
+	/* we really don't want to have an asynchronous tasklet disturb us
+	 ** after something vital for its job has been shut down, so
+	 ** end all remaining work now.
+	 **
+	 ** NB: carrier_off (done by set_status below) would lead to
+	 ** not yet fully understood deadlock in flush_scheduled_work().
+	 ** That's why we do FLUSH first.
+	 **
+	 ** NB2: we have a bad locking bug here: flush_scheduled_work()
+	 ** waits for acx_e_after_interrupt_task to complete if it is running
+	 ** on another CPU, but acx_e_after_interrupt_task
+	 ** will sleep on sem forever, because it is taken by us!
+	 ** Work around that by temporary sem unlock.
+	 ** This will fail miserably if we'll be hit by concurrent
+	 ** iwconfig or something in between. TODO! */
+	flush_scheduled_work();
+
+	/* This is possible:
+	 ** flush_scheduled_work -> acx_e_after_interrupt_task ->
+	 ** -> set_status(ASSOCIATED) -> wake_queue()
+	 ** That's why we stop queue _after_ flush_scheduled_work
+	 ** lock/unlock is just paranoia, maybe not needed */
+
+	/* kernel/timer.c says it's illegal to del_timer_sync()
+	 ** a timer which restarts itself. We guarantee this cannot
+	 ** ever happen because acx_i_timer() never does this if
+	 ** status is ACX_STATUS_0_STOPPED */
+	del_timer_sync(&adev->mgmt_timer);
+
+	FN_EXIT0;
+}
+/*
+#ifdef CONFIG_NET_POLL_CONTROLLER
+void acxpci_net_poll_controller(struct net_device *net_dev)   
+{     
+        acx_device_t *adev = ndev2adev(net_dev);
+        unsigned long flags;
+
+        local_irq_save(flags);              
+        acxpci_i_interrupt(adev->irq, adev);
+        local_irq_restore(flags);           
+}
+#endif*/ /* CONFIG_NET_POLL_CONTROLLER */
+
+/***********************************************************************
+** acxpci_e_open
+**
+** Called as a result of SIOCSIFFLAGS ioctl changing the flags bit IFF_UP
+** from clear to set. In other words: ifconfig up.
+**
+** Returns:
+**	0	success
+**	>0	f/w reported error
+**	<0	driver reported error
+*/
+static int acxpci_e_open(struct ieee80211_hw *hw)
+{
+	acx_device_t *adev = ieee2adev(hw);
+	int result = OK;
+
+	FN_ENTER;
+
+	acx_sem_lock(adev);
+
+	adev->initialized = 0;
+
+/* TODO: pci_set_power_state(pdev, PCI_D0); ? */
+
+	/* request shared IRQ handler */
+	if (request_irq
+	    (adev->irq, acxpci_i_interrupt, IRQF_SHARED, KBUILD_MODNAME, adev)) {
+		printk("%s: request_irq FAILED\n", wiphy_name(adev->ieee->wiphy));
+		result = -EAGAIN;
+		goto done;
+	}
+	log(L_DEBUG | L_IRQ, "request_irq %d successful\n", adev->irq);
+
+	/* ifup device */
+	acxpci_s_up(hw);
+
+	/* We don't currently have to do anything else.
+	 * The setup of the MAC should be subsequently completed via
+	 * the mlme commands.
+	 * Higher layers know we're ready from dev->start==1 and
+	 * dev->tbusy==0.  Our rx path knows to pass up received/
+	 * frames because of dev->flags&IFF_UP is true.
+	 */
+	acx_setup_modes(adev);
+	ieee80211_start_queues(adev->ieee);
+
+	adev->initialized = 1;
+      done:
+	acx_sem_unlock(adev);
+
+	FN_EXIT1(result);
+	return result;
+}
+
+
+/***********************************************************************
+** acxpci_e_close
+**
+** Called as a result of SIOCSIIFFLAGS ioctl changing the flags bit IFF_UP
+** from set to clear. I.e. called by "ifconfig DEV down"
+**
+** Returns:
+**	0	success
+**	>0	f/w reported error
+**	<0	driver reported error
+*/
+static int acxpci_e_close(struct ieee80211_hw *hw)
+{
+	acx_device_t *adev = ieee2adev(hw);
+	unsigned long flags;
+	FN_ENTER;
+	acx_lock(adev,flags);
+	/* ifdown device */
+	CLEAR_BIT(adev->dev_state_mask, ACX_STATE_IFACE_UP);
+	if (adev->initialized) {
+              acxpci_s_down(hw);
+	}
+
+	if (adev->modes)
+		acx_free_modes(adev);
+	/* disable all IRQs, release shared IRQ handler */
+	write_reg16(adev, IO_ACX_IRQ_MASK, 0xffff);
+	write_reg16(adev, IO_ACX_FEMR, 0x0);
+
+/* TODO: pci_set_power_state(pdev, PCI_D3hot); ? */
+
+	/* We currently don't have to do anything else.
+	 * Higher layers know we're not ready from dev->start==0 and
+	 * dev->tbusy==1.  Our rx path knows to not pass up received
+	 * frames because of dev->flags&IFF_UP is false.
+	 */
+	acx_unlock(adev,flags);
+
+	log(L_INIT, "closed device\n");
+	FN_EXIT0;
+	return OK;
+}
+
+
+
+
+/***************************************************************
+** acxpci_l_process_rxdesc
+**
+** Called directly and only from the IRQ handler
+*/
+
+#if !ACX_DEBUG
+static inline void log_rxbuffer(const acx_device_t * adev)
+{
+}
+#else
+static void log_rxbuffer(const acx_device_t * adev)
+{
+	register const struct rxhostdesc *rxhostdesc;
+	int i;
+
+	/* no FN_ENTER here, we don't want that */
+
+	rxhostdesc = adev->rxhostdesc_start;
+	if (unlikely(!rxhostdesc))
+		return;
+	for (i = 0; i < RX_CNT; i++) {
+		if ((rxhostdesc->Ctl_16 & cpu_to_le16(DESC_CTL_HOSTOWN))
+		    && (rxhostdesc->Status & cpu_to_le32(DESC_STATUS_FULL)))
+			printk("rx: buf %d full\n", i);
+		rxhostdesc++;
+	}
+}
+#endif
+
+static void acxpci_l_process_rxdesc(acx_device_t * adev)
+{
+	register rxhostdesc_t *hostdesc;
+	unsigned count, tail;
+
+	FN_ENTER;
+
+	if (unlikely(acx_debug & L_BUFR))
+		log_rxbuffer(adev);
+
+	/* First, have a loop to determine the first descriptor that's
+	 * full, just in case there's a mismatch between our current
+	 * rx_tail and the full descriptor we're supposed to handle. */
+	tail = adev->rx_tail;
+	count = RX_CNT;
+	while (1) {
+		hostdesc = &adev->rxhostdesc_start[tail];
+		/* advance tail regardless of outcome of the below test */
+		tail = (tail + 1) % RX_CNT;
+
+		if ((hostdesc->Ctl_16 & cpu_to_le16(DESC_CTL_HOSTOWN))
+		    && (hostdesc->Status & cpu_to_le32(DESC_STATUS_FULL)))
+			break;	/* found it! */
+
+		if (unlikely(!--count))	/* hmm, no luck: all descs empty, bail out */
+			goto end;
+	}
+
+	/* now process descriptors, starting with the first we figured out */
+	while (1) {
+		log(L_BUFR, "rx: tail=%u Ctl_16=%04X Status=%08X\n",
+		    tail, hostdesc->Ctl_16, hostdesc->Status);
+
+		acx_l_process_rxbuf(adev, hostdesc->data);
+		hostdesc->Status = 0;
+		/* flush all writes before adapter sees CTL_HOSTOWN change */
+		wmb();
+		/* Host no longer owns this, needs to be LAST */
+		CLEAR_BIT(hostdesc->Ctl_16, cpu_to_le16(DESC_CTL_HOSTOWN));
+
+		/* ok, descriptor is handled, now check the next descriptor */
+		hostdesc = &adev->rxhostdesc_start[tail];
+
+		/* if next descriptor is empty, then bail out */
+		if (!(hostdesc->Ctl_16 & cpu_to_le16(DESC_CTL_HOSTOWN))
+		    || !(hostdesc->Status & cpu_to_le32(DESC_STATUS_FULL)))
+			break;
+
+		tail = (tail + 1) % RX_CNT;
+	}
+      end:
+	adev->rx_tail = tail;
+	FN_EXIT0;
+}
+
+
+
+/***********************************************************************
+** acxpci_i_interrupt
+**
+** IRQ handler (atomic context, must not sleep, blah, blah)
+*/
+
+/* scan is complete. all frames now on the receive queue are valid */
+#define INFO_SCAN_COMPLETE      0x0001
+#define INFO_WEP_KEY_NOT_FOUND  0x0002
+/* hw has been reset as the result of a watchdog timer timeout */
+#define INFO_WATCH_DOG_RESET    0x0003
+/* failed to send out NULL frame from PS mode notification to AP */
+/* recommended action: try entering 802.11 PS mode again */
+#define INFO_PS_FAIL            0x0004
+/* encryption/decryption process on a packet failed */
+#define INFO_IV_ICV_FAILURE     0x0005
+
+/* Info mailbox format:
+2 bytes: type
+2 bytes: status
+more bytes may follow
+    rumors say about status:
+	0x0000 info available (set by hw)
+	0x0001 information received (must be set by host)
+	0x1000 info available, mailbox overflowed (messages lost) (set by hw)
+    but in practice we've seen:
+	0x9000 when we did not set status to 0x0001 on prev message
+	0x1001 when we did set it
+	0x0000 was never seen
+    conclusion: this is really a bitfield:
+    0x1000 is 'info available' bit
+    'mailbox overflowed' bit is 0x8000, not 0x1000
+    value of 0x0000 probably means that there are no messages at all
+    P.S. I dunno how in hell hw is supposed to notice that messages are lost -
+    it does NOT clear bit 0x0001, and this bit will probably stay forever set
+    after we set it once. Let's hope this will be fixed in firmware someday
+*/
+
+static void handle_info_irq(acx_device_t * adev)
+{
+#if ACX_DEBUG
+	static const char *const info_type_msg[] = {
+		"(unknown)",
+		"scan complete",
+		"WEP key not found",
+		"internal watchdog reset was done",
+		"failed to send powersave (NULL frame) notification to AP",
+		"encrypt/decrypt on a packet has failed",
+		"TKIP tx keys disabled",
+		"TKIP rx keys disabled",
+		"TKIP rx: key ID not found",
+		"???",
+		"???",
+		"???",
+		"???",
+		"???",
+		"???",
+		"???",
+		"TKIP IV value exceeds thresh"
+	};
+#endif
+	u32 info_type, info_status;
+
+	info_type = acx_readl(adev->info_area);
+	info_status = (info_type >> 16);
+	info_type = (u16) info_type;
+
+	/* inform fw that we have read this info message */
+	acx_writel(info_type | 0x00010000, adev->info_area);
+	write_reg16(adev, IO_ACX_INT_TRIG, INT_TRIG_INFOACK);
+	write_flush(adev);
+
+	log(L_CTL, "info_type:%04X info_status:%04X\n", info_type, info_status);
+
+	log(L_IRQ, "got Info IRQ: status %04X type %04X: %s\n",
+	    info_status, info_type,
+	    info_type_msg[(info_type >= ARRAY_SIZE(info_type_msg)) ?
+			  0 : info_type]
+	    );
+}
+
+
+static void log_unusual_irq(u16 irqtype)
+{
+	/*
+	   if (!printk_ratelimit())
+	   return;
+	 */
+
+	printk("acx: got");
+	if (irqtype & HOST_INT_RX_DATA) {
+		printk(" Rx_Data");
+	}
+	/* HOST_INT_TX_COMPLETE   */
+	if (irqtype & HOST_INT_TX_XFER) {
+		printk(" Tx_Xfer");
+	}
+	/* HOST_INT_RX_COMPLETE   */
+	if (irqtype & HOST_INT_DTIM) {
+		printk(" DTIM");
+	}
+	if (irqtype & HOST_INT_BEACON) {
+		printk(" Beacon");
+	}
+	if (irqtype & HOST_INT_TIMER) {
+		log(L_IRQ, " Timer");
+	}
+	if (irqtype & HOST_INT_KEY_NOT_FOUND) {
+		printk(" Key_Not_Found");
+	}
+	if (irqtype & HOST_INT_IV_ICV_FAILURE) {
+		printk(" IV_ICV_Failure (crypto)");
+	}
+	/* HOST_INT_CMD_COMPLETE  */
+	/* HOST_INT_INFO          */
+	if (irqtype & HOST_INT_OVERFLOW) {
+		printk(" Overflow");
+	}
+	if (irqtype & HOST_INT_PROCESS_ERROR) {
+		printk(" Process_Error");
+	}
+	/* HOST_INT_SCAN_COMPLETE */
+	if (irqtype & HOST_INT_FCS_THRESHOLD) {
+		printk(" FCS_Threshold");
+	}
+	if (irqtype & HOST_INT_UNKNOWN) {
+		printk(" Unknown");
+	}
+	printk(" IRQ(s)\n");
+}
+
+
+static void update_link_quality_led(acx_device_t * adev)
+{
+/*	int qual; */
+
+/*	qual =
+	    acx_signal_determine_quality(adev->wstats.qual.level,
+					 adev->wstats.qual.noise);
+	if (qual > adev->brange_max_quality)
+		qual = adev->brange_max_quality;
+*/
+
+/*	if (time_after(jiffies, adev->brange_time_last_state_change +
+		       (HZ / 2 -
+			HZ / 2 * (unsigned long)qual /
+			adev->brange_max_quality))) {
+		acxpci_l_power_led(adev, (adev->brange_last_state == 0));
+		adev->brange_last_state ^= 1;	*//* toggle */
+/*		adev->brange_time_last_state_change = jiffies;
+	}
+*/
+}
+
+#define MAX_IRQLOOPS_PER_JIFFY  (20000/HZ)	/* a la orinoco.c */
+
+/* Interrupt handler bottom-half */
+void acx_interrupt_tasklet(struct work_struct *work)
+{
+
+#ifdef CONFIG_ACX_MAC80211_DEBUG
+	u32 _handled = 0x00000000;
+# define acxirq_handled(irq)    do { _handled |= (irq); } while (0)
+#else
+# define acxirq_handled(irq)    do { /* nothing */ } while (0)
+#endif /* CONFIG_ACX_MAC80211_DEBUG */
+	acx_device_t *adev = container_of(work,struct acx_device, after_interrupt_task);
+//	unsigned int irqcount = MAX_IRQLOOPS_PER_JIFFY;
+	int irqtype;
+
+	/* LOCKING: can just spin_lock() since IRQs are disabled anyway.
+	 * I am paranoid */
+	acx_sem_lock(adev);
+
+
+	FN_ENTER;
+	irqtype = adev->irq_reason;
+	adev->irq_reason = 0;
+
+#define IRQ_ITERATE 0
+#if IRQ_ITERATE
+	if (jiffies != adev->irq_last_jiffies) {
+		adev->irq_loops_this_jiffy = 0;
+		adev->irq_last_jiffies = jiffies;
+	}
+
+/* safety condition; we'll normally abort loop below
+ * in case no IRQ type occurred */
+	while (likely(--irqcount)) {
+#endif
+		/* ACK all IRQs ASAP */
+
+
+		/* Handle most important IRQ types first */
+		if (irqtype & HOST_INT_RX_COMPLETE) {
+			log(L_IRQ, "got Rx_Complete IRQ\n");
+			acxpci_l_process_rxdesc(adev);
+		}
+		if (irqtype & HOST_INT_TX_COMPLETE) {
+			log(L_IRQ, "got Tx_Complete IRQ\n");
+			/* don't clean up on each Tx complete, wait a bit
+			 * unless we're going towards full, in which case
+			 * we do it immediately, too (otherwise we might lockup
+			 * with a full Tx buffer if we go into
+			 * acxpci_l_clean_txdesc() at a time when we won't wakeup
+			 * the net queue in there for some reason...) */
+//			if (adev->tx_free <= TX_START_CLEAN) {
+				acxpci_l_clean_txdesc(adev);
+//			}
+		}
+
+		/* Less frequent ones */
+		if (irqtype & (0
+			       | HOST_INT_CMD_COMPLETE
+			       | HOST_INT_INFO | HOST_INT_SCAN_COMPLETE)) {
+			if (irqtype & HOST_INT_INFO) {
+				handle_info_irq(adev);
+			}
+			if (irqtype & HOST_INT_SCAN_COMPLETE) {
+				log(L_IRQ, "got Scan_Complete IRQ\n");
+				/* need to do that in process context */
+				/* remember that fw is not scanning anymore */
+				SET_BIT(adev->irq_status,
+					HOST_INT_SCAN_COMPLETE);
+			}
+		}
+
+		/* These we just log, but either they happen rarely
+		 * or we keep them masked out */
+		if (irqtype & (0 | HOST_INT_RX_DATA
+			       /* | HOST_INT_TX_COMPLETE   */
+			       | HOST_INT_TX_XFER
+			       /* | HOST_INT_RX_COMPLETE   */
+			       | HOST_INT_DTIM
+			       | HOST_INT_BEACON
+			       | HOST_INT_TIMER
+			       | HOST_INT_KEY_NOT_FOUND
+			       | HOST_INT_IV_ICV_FAILURE
+			       /* | HOST_INT_CMD_COMPLETE  */
+			       /* | HOST_INT_INFO          */
+			       | HOST_INT_OVERFLOW | HOST_INT_PROCESS_ERROR
+			       /* | HOST_INT_SCAN_COMPLETE */
+			       | HOST_INT_FCS_THRESHOLD | HOST_INT_UNKNOWN)) {
+			log_unusual_irq(irqtype);
+		}
+#if IRQ_ITERATE
+		unmasked = read_reg16(adev, IO_ACX_IRQ_STATUS_CLEAR);
+		irqtype = unmasked & ~adev->irq_mask;
+		/* Bail out if no new IRQ bits or if all are masked out */
+		if (!irqtype)
+			break;
+
+		if (unlikely
+		    (++adev->irq_loops_this_jiffy > MAX_IRQLOOPS_PER_JIFFY)) {
+			printk(KERN_ERR
+			       "acx: too many interrupts per jiffy!\n");
+			/* Looks like card floods us with IRQs! Try to stop that */
+			write_reg16(adev, IO_ACX_IRQ_MASK, 0xffff);
+			/* This will short-circuit all future attempts to handle IRQ.
+			 * We cant do much more... */
+			adev->irq_mask = 0;
+			break;
+		}
+	}
+#endif
+	/* Routine to perform blink with range */
+	if (unlikely(adev->led_power == 2))
+		update_link_quality_led(adev);
+
+/* handled: */
+	if (adev->after_interrupt_jobs)
+		acx_e_after_interrupt_task(&adev->after_interrupt_task);
+
+	/* write_flush(adev); - not needed, last op was read anyway */
+	acx_sem_unlock(adev);
+	FN_EXIT0;
+	return;			
+
+}
+
+
+static irqreturn_t
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 19)
+acxpci_i_interrupt(int irq, void *dev_id)
+#else
+acxpci_i_interrupt(int irq, void *dev_id, struct pt_regs *regs)
+#endif
+{
+
+	acx_device_t *adev = dev_id;
+	unsigned long flags;
+	register u16 irqtype;
+	u16 unmasked;
+
+	if (!adev)
+		return IRQ_NONE;
+	/* LOCKING: can just spin_lock() since IRQs are disabled anyway.
+	 * I am paranoid */
+
+	acx_lock(adev, flags);
+
+	unmasked = read_reg16(adev, IO_ACX_IRQ_STATUS_CLEAR);
+
+	if (unlikely(0xffff == unmasked)) {
+		/* 0xffff value hints at missing hardware,
+		 * so don't do anything.
+		 * Not very clean, but other drivers do the same... */
+		log(L_IRQ, "IRQ type:FFFF - device removed? IRQ_NONE\n");
+		goto none;
+	}
+
+	/* We will check only "interesting" IRQ types */
+	irqtype = unmasked & ~adev->irq_mask;
+	if (!irqtype) {
+		/* We are on a shared IRQ line and it wasn't our IRQ */
+		log(L_IRQ,
+		    "IRQ type:%04X, mask:%04X - all are masked, IRQ_NONE\n",
+		    unmasked, adev->irq_mask);
+		goto none;
+	}
+
+	/* Go ahead and ACK our interrupt */
+	write_reg16(adev, IO_ACX_IRQ_ACK, 0xffff);
+	if (irqtype & HOST_INT_CMD_COMPLETE) {
+		log(L_IRQ, "got Command_Complete IRQ\n");
+		/* save the state for the running issue_cmd() */
+		SET_BIT(adev->irq_status, HOST_INT_CMD_COMPLETE);
+	}
+
+	/* Only accept IRQs, if we are initialized properly.
+	 * This avoids an RX race while initializing.
+	 * We should probably not enable IRQs before we are initialized
+	 * completely, but some careful work is needed to fix this. I think it
+	 * is best to stay with this cheap workaround for now... .
+	 */
+	if (likely(adev->initialized)) {
+		/* disable all IRQs. They are enabled again in the bottom half. */
+		/* save the reason code and call our bottom half. */
+		adev->irq_reason = irqtype;
+
+		if ((irqtype & HOST_INT_RX_COMPLETE) || (irqtype & HOST_INT_TX_COMPLETE))
+			acx_schedule_task(adev, 0);
+	}
+	acx_unlock(adev, flags);
+	return IRQ_HANDLED;
+      none:
+	acx_unlock(adev, flags);
+	return IRQ_NONE;
+
+}
+
+
+/***********************************************************************
+** acxpci_l_power_led
+*/
+void acxpci_l_power_led(acx_device_t * adev, int enable)
+{
+	u16 gpio_pled = IS_ACX111(adev) ? 0x0040 : 0x0800;
+
+	/* A hack. Not moving message rate limiting to adev->xxx
+	 * (it's only a debug message after all) */
+	static int rate_limit = 0;
+
+	if (rate_limit++ < 3)
+		log(L_IOCTL, "Please report in case toggling the power "
+		    "LED doesn't work for your card!\n");
+	if (enable)
+		write_reg16(adev, IO_ACX_GPIO_OUT,
+			    read_reg16(adev, IO_ACX_GPIO_OUT) & ~gpio_pled);
+	else
+		write_reg16(adev, IO_ACX_GPIO_OUT,
+			    read_reg16(adev, IO_ACX_GPIO_OUT) | gpio_pled);
+}
+
+
+/***********************************************************************
+** Ioctls
+*/
+
+/***********************************************************************
+*/
+#if 0
+int
+acx111pci_ioctl_info(struct net_device *ndev,
+		     struct iw_request_info *info,
+		     struct iw_param *vwrq, char *extra)
+{
+#if ACX_DEBUG > 1
+	acx_device_t *adev = ndev2adev(ndev);
+	rxdesc_t *rxdesc;
+	txdesc_t *txdesc;
+	rxhostdesc_t *rxhostdesc;
+	txhostdesc_t *txhostdesc;
+	struct acx111_ie_memoryconfig memconf;
+	struct acx111_ie_queueconfig queueconf;
+	unsigned long flags;
+	int i;
+	char memmap[0x34];
+	char rxconfig[0x8];
+	char fcserror[0x8];
+	char ratefallback[0x5];
+
+	if (!(acx_debug & (L_IOCTL | L_DEBUG)))
+		return OK;
+	/* using printk() since we checked debug flag already */
+
+	acx_sem_lock(adev);
+
+	if (!IS_ACX111(adev)) {
+		printk("acx111-specific function called "
+		       "with non-acx111 chip, aborting\n");
+		goto end_ok;
+	}
+
+	/* get Acx111 Memory Configuration */
+	memset(&memconf, 0, sizeof(memconf));
+	/* BTW, fails with 12 (Write only) error code.
+	 ** Retained for easy testing of issue_cmd error handling :) */
+	acx_s_interrogate(adev, &memconf, ACX1xx_IE_QUEUE_CONFIG);
+
+	/* get Acx111 Queue Configuration */
+	memset(&queueconf, 0, sizeof(queueconf));
+	acx_s_interrogate(adev, &queueconf, ACX1xx_IE_MEMORY_CONFIG_OPTIONS);
+
+	/* get Acx111 Memory Map */
+	memset(memmap, 0, sizeof(memmap));
+	acx_s_interrogate(adev, &memmap, ACX1xx_IE_MEMORY_MAP);
+
+	/* get Acx111 Rx Config */
+	memset(rxconfig, 0, sizeof(rxconfig));
+	acx_s_interrogate(adev, &rxconfig, ACX1xx_IE_RXCONFIG);
+
+	/* get Acx111 fcs error count */
+	memset(fcserror, 0, sizeof(fcserror));
+	acx_s_interrogate(adev, &fcserror, ACX1xx_IE_FCS_ERROR_COUNT);
+
+	/* get Acx111 rate fallback */
+	memset(ratefallback, 0, sizeof(ratefallback));
+	acx_s_interrogate(adev, &ratefallback, ACX1xx_IE_RATE_FALLBACK);
+
+	/* force occurrence of a beacon interrupt */
+	/* TODO: comment why is this necessary */
+	write_reg16(adev, IO_ACX_HINT_TRIG, HOST_INT_BEACON);
+
+	/* dump Acx111 Mem Configuration */
+	printk("dump mem config:\n"
+	       "data read: %d, struct size: %d\n"
+	       "Number of stations: %1X\n"
+	       "Memory block size: %1X\n"
+	       "tx/rx memory block allocation: %1X\n"
+	       "count rx: %X / tx: %X queues\n"
+	       "options %1X\n"
+	       "fragmentation %1X\n"
+	       "Rx Queue 1 Count Descriptors: %X\n"
+	       "Rx Queue 1 Host Memory Start: %X\n"
+	       "Tx Queue 1 Count Descriptors: %X\n"
+	       "Tx Queue 1 Attributes: %X\n",
+	       memconf.len, (int)sizeof(memconf),
+	       memconf.no_of_stations,
+	       memconf.memory_block_size,
+	       memconf.tx_rx_memory_block_allocation,
+	       memconf.count_rx_queues, memconf.count_tx_queues,
+	       memconf.options,
+	       memconf.fragmentation,
+	       memconf.rx_queue1_count_descs,
+	       acx2cpu(memconf.rx_queue1_host_rx_start),
+	       memconf.tx_queue1_count_descs, memconf.tx_queue1_attributes);
+
+	/* dump Acx111 Queue Configuration */
+	printk("dump queue head:\n"
+	       "data read: %d, struct size: %d\n"
+	       "tx_memory_block_address (from card): %X\n"
+	       "rx_memory_block_address (from card): %X\n"
+	       "rx1_queue address (from card): %X\n"
+	       "tx1_queue address (from card): %X\n"
+	       "tx1_queue attributes (from card): %X\n",
+	       queueconf.len, (int)sizeof(queueconf),
+	       queueconf.tx_memory_block_address,
+	       queueconf.rx_memory_block_address,
+	       queueconf.rx1_queue_address,
+	       queueconf.tx1_queue_address, queueconf.tx1_attributes);
+
+	/* dump Acx111 Mem Map */
+	printk("dump mem map:\n"
+	       "data read: %d, struct size: %d\n"
+	       "Code start: %X\n"
+	       "Code end: %X\n"
+	       "WEP default key start: %X\n"
+	       "WEP default key end: %X\n"
+	       "STA table start: %X\n"
+	       "STA table end: %X\n"
+	       "Packet template start: %X\n"
+	       "Packet template end: %X\n"
+	       "Queue memory start: %X\n"
+	       "Queue memory end: %X\n"
+	       "Packet memory pool start: %X\n"
+	       "Packet memory pool end: %X\n"
+	       "iobase: %p\n"
+	       "iobase2: %p\n",
+	       *((u16 *) & memmap[0x02]), (int)sizeof(memmap),
+	       *((u32 *) & memmap[0x04]),
+	       *((u32 *) & memmap[0x08]),
+	       *((u32 *) & memmap[0x0C]),
+	       *((u32 *) & memmap[0x10]),
+	       *((u32 *) & memmap[0x14]),
+	       *((u32 *) & memmap[0x18]),
+	       *((u32 *) & memmap[0x1C]),
+	       *((u32 *) & memmap[0x20]),
+	       *((u32 *) & memmap[0x24]),
+	       *((u32 *) & memmap[0x28]),
+	       *((u32 *) & memmap[0x2C]),
+	       *((u32 *) & memmap[0x30]), adev->iobase, adev->iobase2);
+
+	/* dump Acx111 Rx Config */
+	printk("dump rx config:\n"
+	       "data read: %d, struct size: %d\n"
+	       "rx config: %X\n"
+	       "rx filter config: %X\n",
+	       *((u16 *) & rxconfig[0x02]), (int)sizeof(rxconfig),
+	       *((u16 *) & rxconfig[0x04]), *((u16 *) & rxconfig[0x06]));
+
+	/* dump Acx111 fcs error */
+	printk("dump fcserror:\n"
+	       "data read: %d, struct size: %d\n"
+	       "fcserrors: %X\n",
+	       *((u16 *) & fcserror[0x02]), (int)sizeof(fcserror),
+	       *((u32 *) & fcserror[0x04]));
+
+	/* dump Acx111 rate fallback */
+	printk("dump rate fallback:\n"
+	       "data read: %d, struct size: %d\n"
+	       "ratefallback: %X\n",
+	       *((u16 *) & ratefallback[0x02]), (int)sizeof(ratefallback),
+	       *((u8 *) & ratefallback[0x04]));
+
+	/* protect against IRQ */
+	acx_lock(adev, flags);
+
+	/* dump acx111 internal rx descriptor ring buffer */
+	rxdesc = adev->rxdesc_start;
+
+	/* loop over complete receive pool */
+	if (rxdesc)
+		for (i = 0; i < RX_CNT; i++) {
+			printk("\ndump internal rxdesc %d:\n"
+			       "mem pos %p\n"
+			       "next 0x%X\n"
+			       "acx mem pointer (dynamic) 0x%X\n"
+			       "CTL (dynamic) 0x%X\n"
+			       "Rate (dynamic) 0x%X\n"
+			       "RxStatus (dynamic) 0x%X\n"
+			       "Mod/Pre (dynamic) 0x%X\n",
+			       i,
+			       rxdesc,
+			       acx2cpu(rxdesc->pNextDesc),
+			       acx2cpu(rxdesc->ACXMemPtr),
+			       rxdesc->Ctl_8,
+			       rxdesc->rate, rxdesc->error, rxdesc->SNR);
+			rxdesc++;
+		}
+
+	/* dump host rx descriptor ring buffer */
+
+	rxhostdesc = adev->rxhostdesc_start;
+
+	/* loop over complete receive pool */
+	if (rxhostdesc)
+		for (i = 0; i < RX_CNT; i++) {
+			printk("\ndump host rxdesc %d:\n"
+			       "mem pos %p\n"
+			       "buffer mem pos 0x%X\n"
+			       "buffer mem offset 0x%X\n"
+			       "CTL 0x%X\n"
+			       "Length 0x%X\n"
+			       "next 0x%X\n"
+			       "Status 0x%X\n",
+			       i,
+			       rxhostdesc,
+			       acx2cpu(rxhostdesc->data_phy),
+			       rxhostdesc->data_offset,
+			       le16_to_cpu(rxhostdesc->Ctl_16),
+			       le16_to_cpu(rxhostdesc->length),
+			       acx2cpu(rxhostdesc->desc_phy_next),
+			       rxhostdesc->Status);
+			rxhostdesc++;
+		}
+
+	/* dump acx111 internal tx descriptor ring buffer */
+	txdesc = adev->txdesc_start;
+
+	/* loop over complete transmit pool */
+	if (txdesc)
+		for (i = 0; i < TX_CNT; i++) {
+			printk("\ndump internal txdesc %d:\n"
+			       "size 0x%X\n"
+			       "mem pos %p\n"
+			       "next 0x%X\n"
+			       "acx mem pointer (dynamic) 0x%X\n"
+			       "host mem pointer (dynamic) 0x%X\n"
+			       "length (dynamic) 0x%X\n"
+			       "CTL (dynamic) 0x%X\n"
+			       "CTL2 (dynamic) 0x%X\n"
+			       "Status (dynamic) 0x%X\n"
+			       "Rate (dynamic) 0x%X\n",
+			       i,
+			       (int)sizeof(struct txdesc),
+			       txdesc,
+			       acx2cpu(txdesc->pNextDesc),
+			       acx2cpu(txdesc->AcxMemPtr),
+			       acx2cpu(txdesc->HostMemPtr),
+			       le16_to_cpu(txdesc->total_length),
+			       txdesc->Ctl_8,
+			       txdesc->Ctl2_8, txdesc->error,
+			       txdesc->u.r1.rate);
+			txdesc = advance_txdesc(adev, txdesc, 1);
+		}
+
+	/* dump host tx descriptor ring buffer */
+
+	txhostdesc = adev->txhostdesc_start;
+
+	/* loop over complete host send pool */
+	if (txhostdesc)
+		for (i = 0; i < TX_CNT * 2; i++) {
+			printk("\ndump host txdesc %d:\n"
+			       "mem pos %p\n"
+			       "buffer mem pos 0x%X\n"
+			       "buffer mem offset 0x%X\n"
+			       "CTL 0x%X\n"
+			       "Length 0x%X\n"
+			       "next 0x%X\n"
+			       "Status 0x%X\n",
+			       i,
+			       txhostdesc,
+			       acx2cpu(txhostdesc->data_phy),
+			       txhostdesc->data_offset,
+			       le16_to_cpu(txhostdesc->Ctl_16),
+			       le16_to_cpu(txhostdesc->length),
+			       acx2cpu(txhostdesc->desc_phy_next),
+			       le32_to_cpu(txhostdesc->Status));
+			txhostdesc++;
+		}
+
+	/* write_reg16(adev, 0xb4, 0x4); */
+
+	acx_unlock(adev, flags);
+      end_ok:
+
+	acx_sem_unlock(adev);
+#endif /* ACX_DEBUG */
+	return OK;
+}
+
+
+/***********************************************************************
+*/
+int
+acx100pci_ioctl_set_phy_amp_bias(struct net_device *ndev,
+				 struct iw_request_info *info,
+				 struct iw_param *vwrq, char *extra)
+{
+	acx_device_t *adev = ndev2adev(ndev);
+	unsigned long flags;
+	u16 gpio_old;
+
+	if (!IS_ACX100(adev)) {
+		/* WARNING!!!
+		 * Removing this check *might* damage
+		 * hardware, since we're tweaking GPIOs here after all!!!
+		 * You've been warned...
+		 * WARNING!!! */
+		printk("acx: sorry, setting bias level for non-acx100 "
+		       "is not supported yet\n");
+		return OK;
+	}
+
+	if (*extra > 7) {
+		printk("acx: invalid bias parameter, range is 0-7\n");
+		return -EINVAL;
+	}
+
+	acx_sem_lock(adev);
+
+	/* Need to lock accesses to [IO_ACX_GPIO_OUT]:
+	 * IRQ handler uses it to update LED */
+	acx_lock(adev, flags);
+	gpio_old = read_reg16(adev, IO_ACX_GPIO_OUT);
+	write_reg16(adev, IO_ACX_GPIO_OUT,
+		    (gpio_old & 0xf8ff) | ((u16) * extra << 8));
+	acx_unlock(adev, flags);
+
+	log(L_DEBUG, "gpio_old: 0x%04X\n", gpio_old);
+	printk("%s: PHY power amplifier bias: old:%d, new:%d\n",
+	       ndev->name, (gpio_old & 0x0700) >> 8, (unsigned char)*extra);
+
+	acx_sem_unlock(adev);
+
+	return OK;
+}
+#endif 
+
+/***************************************************************
+** acxpci_l_alloc_tx
+** Actually returns a txdesc_t* ptr
+**
+** FIXME: in case of fragments, should allocate multiple descrs
+** after figuring out how many we need and whether we still have
+** sufficiently many.
+*/
+tx_t *acxpci_l_alloc_tx(acx_device_t * adev)
+{
+	struct txdesc *txdesc;
+	unsigned head;
+	u8 ctl8;
+
+	FN_ENTER;
+
+	if (unlikely(!adev->tx_free)) {
+		printk("acx: BUG: no free txdesc left\n");
+		txdesc = NULL;
+		goto end;
+	}
+
+	head = adev->tx_head;
+	txdesc = get_txdesc(adev, head);
+	ctl8 = txdesc->Ctl_8;
+
+	/* 2005-10-11: there were several bug reports on this happening
+	 ** but now cause seems to be understood & fixed */
+	if (unlikely(DESC_CTL_HOSTOWN != (ctl8 & DESC_CTL_ACXDONE_HOSTOWN))) {
+		/* whoops, descr at current index is not free, so probably
+		 * ring buffer already full */
+		printk("acx: BUG: tx_head:%d Ctl8:0x%02X - failed to find "
+		       "free txdesc\n", head, ctl8);
+		txdesc = NULL;
+		goto end;
+	}
+
+	/* Needed in case txdesc won't be eventually submitted for tx */
+	txdesc->Ctl_8 = DESC_CTL_ACXDONE_HOSTOWN;
+
+	adev->tx_free--;
+	log(L_BUFT, "tx: got desc %u, %u remain\n", head, adev->tx_free);
+	/* Keep a few free descs between head and tail of tx ring.
+	 ** It is not absolutely needed, just feels safer */
+	if (adev->tx_free < TX_STOP_QUEUE) {
+		log(L_BUF, "stop queue (%u tx desc left)\n", adev->tx_free);
+		acx_stop_queue(adev->ieee, NULL);
+	}
+
+	/* returning current descriptor, so advance to next free one */
+	adev->tx_head = (head + 1) % TX_CNT;
+      end:
+	FN_EXIT0;
+
+	return (tx_t *) txdesc;
+}
+
+
+/***********************************************************************
+*/
+void *acxpci_l_get_txbuf(acx_device_t * adev, tx_t * tx_opaque)
+{
+	return get_txhostdesc(adev, (txdesc_t *) tx_opaque)->data;
+}
+
+
+/***********************************************************************
+** acxpci_l_tx_data
+**
+** Can be called from IRQ (rx -> (AP bridging or mgmt response) -> tx).
+** Can be called from acx_i_start_xmit (data frames from net core).
+**
+** FIXME: in case of fragments, should loop over the number of
+** pre-allocated tx descrs, properly setting up transfer data and
+** CTL_xxx flags according to fragment number.
+*/
+void
+acxpci_l_tx_data(acx_device_t * adev, tx_t * tx_opaque, int len,
+		 struct ieee80211_tx_control *ieeectl,struct sk_buff* skb)
+{
+	txdesc_t *txdesc = (txdesc_t *) tx_opaque;
+	struct ieee80211_hdr *wireless_header;
+	txhostdesc_t *hostdesc1, *hostdesc2;
+	int rate_cur;
+	u8 Ctl_8, Ctl2_8;
+	int wlhdr_len;
+
+	FN_ENTER;
+
+	/* fw doesn't tx such packets anyhow */
+/*	if (unlikely(len < WLAN_HDR_A3_LEN))
+		goto end;
+*/
+	hostdesc1 = get_txhostdesc(adev, txdesc);
+	wireless_header = (struct ieee80211_hdr *)hostdesc1->data;
+	/* modify flag status in separate variable to be able to write it back
+	 * in one big swoop later (also in order to have less device memory
+	 * accesses) */
+	Ctl_8 = txdesc->Ctl_8;
+	Ctl2_8 = 0;		/* really need to init it to 0, not txdesc->Ctl2_8, it seems */
+
+	hostdesc2 = hostdesc1 + 1;
+
+	/* DON'T simply set Ctl field to 0 here globally,
+	 * it needs to maintain a consistent flag status (those are state flags!!),
+	 * otherwise it may lead to severe disruption. Only set or reset particular
+	 * flags at the exact moment this is needed... */
+
+	/* let chip do RTS/CTS handshaking before sending
+	 * in case packet size exceeds threshold */
+	if (ieeectl->flags & IEEE80211_TXCTL_USE_RTS_CTS)
+		SET_BIT(Ctl2_8, DESC_CTL2_RTS);
+	else
+		CLEAR_BIT(Ctl2_8, DESC_CTL2_RTS);
+
+	rate_cur = ieeectl->tx_rate;
+	if (unlikely(!rate_cur)) {
+		printk("acx: driver bug! bad ratemask\n");
+		goto end;
+	}
+
+	/* used in tx cleanup routine for auto rate and accounting: */
+/*	put_txcr(adev, txdesc, clt, rate_cur);  deprecated by mac80211 */
+
+	txdesc->total_length = cpu_to_le16(len);
+	wlhdr_len = ieee80211_get_hdrlen(le16_to_cpu(wireless_header->frame_control));
+	hostdesc2->length = cpu_to_le16(len - wlhdr_len);
+/*
+	if (!ieeectl->do_not_encrypt && ieeectl->key_idx>= 0)
+	{
+		u16 key_idx = (u16)(ieeectl->key_idx);
+		struct acx_key* key = &(adev->key[key_idx]);
+		int wlhdr_len;
+		if (key->enabled)
+		{
+			memcpy(ieeehdr->wep_iv, ((u8*)wireless_header) + wlhdr_len, 4);
+		}
+	}
+*/
+	if (IS_ACX111(adev)) {
+		/* note that if !txdesc->do_auto, txrate->cur
+		 ** has only one nonzero bit */
+		txdesc->u.r2.rate111 = cpu_to_le16(rate_cur
+						   /* WARNING: I was never able to make it work with prism54 AP.
+						    ** It was falling down to 1Mbit where shortpre is not applicable,
+						    ** and not working at all at "5,11 basic rates only" setting.
+						    ** I even didn't see tx packets in radio packet capture.
+						    ** Disabled for now --vda */
+						   /*| ((clt->shortpre && clt->cur!=RATE111_1) ? RATE111_SHORTPRE : 0) */
+		    );
+#ifdef TODO_FIGURE_OUT_WHEN_TO_SET_THIS
+		/* should add this to rate111 above as necessary */
+		|(clt->pbcc511 ? RATE111_PBCC511 : 0)
+#endif
+		    hostdesc1->length = cpu_to_le16(len);
+	} else {		/* ACX100 */
+		u8 rate_100 = ieeectl->tx_rate;
+		txdesc->u.r1.rate = rate_100;
+#ifdef TODO_FIGURE_OUT_WHEN_TO_SET_THIS
+		if (clt->pbcc511) {
+			if (n == RATE100_5 || n == RATE100_11)
+				n |= RATE100_PBCC511;
+		}
+
+		if (clt->shortpre && (clt->cur != RATE111_1))
+			SET_BIT(Ctl_8, DESC_CTL_SHORT_PREAMBLE);	/* set Short Preamble */
+#endif
+		/* set autodma and reclaim and 1st mpdu */
+		SET_BIT(Ctl_8,
+			DESC_CTL_AUTODMA | DESC_CTL_RECLAIM |
+			DESC_CTL_FIRSTFRAG);
+#if ACX_FRAGMENTATION
+		/* SET_BIT(Ctl2_8, DESC_CTL2_MORE_FRAG); cannot set it unconditionally, needs to be set for all non-last fragments */
+#endif
+		hostdesc1->length = cpu_to_le16(wlhdr_len);
+	}
+	/* don't need to clean ack/rts statistics here, already
+	 * done on descr cleanup */
+
+	/* clears HOSTOWN and ACXDONE bits, thus telling that the descriptors
+	 * are now owned by the acx100; do this as LAST operation */
+	CLEAR_BIT(Ctl_8, DESC_CTL_ACXDONE_HOSTOWN);
+	/* flush writes before we release hostdesc to the adapter here */
+	wmb();
+	CLEAR_BIT(hostdesc1->Ctl_16, cpu_to_le16(DESC_CTL_HOSTOWN));
+	CLEAR_BIT(hostdesc2->Ctl_16, cpu_to_le16(DESC_CTL_HOSTOWN));
+
+	/* write back modified flags */
+	CLEAR_BIT(Ctl2_8, DESC_CTL2_WEP);
+	txdesc->Ctl2_8 = Ctl2_8;
+	txdesc->Ctl_8 = Ctl_8;
+	/* unused: txdesc->tx_time = cpu_to_le32(jiffies); */
+
+	/* flush writes before we tell the adapter that it's its turn now */
+	mmiowb();
+	write_reg16(adev, IO_ACX_INT_TRIG, INT_TRIG_TXPRC);
+	write_flush(adev);
+	/* log the packet content AFTER sending it,
+	 * in order to not delay sending any further than absolutely needed
+	 * Do separate logs for acx100/111 to have human-readable rates */
+        memcpy(&(hostdesc1->txstatus.control),ieeectl,sizeof(struct ieee80211_tx_control));
+        hostdesc1->skb = skb;
+      end:
+	FN_EXIT0;
+}
+
+
+/***********************************************************************
+** acxpci_l_clean_txdesc
+**
+** This function resets the txdescs' status when the ACX100
+** signals the TX done IRQ (txdescs have been processed), starting with
+** the pool index of the descriptor which we would use next,
+** in order to make sure that we can be as fast as possible
+** in filling new txdescs.
+** Everytime we get called we know where the next packet to be cleaned is.
+*/
+
+#if !ACX_DEBUG
+static inline void log_txbuffer(const acx_device_t * adev)
+{
+}
+#else
+static void log_txbuffer(acx_device_t * adev)
+{
+	txdesc_t *txdesc;
+	int i;
+
+	/* no FN_ENTER here, we don't want that */
+	/* no locks here, since it's entirely non-critical code */
+	txdesc = adev->txdesc_start;
+	if (unlikely(!txdesc))
+		return;
+	printk("tx: desc->Ctl8's:");
+	for (i = 0; i < TX_CNT; i++) {
+		printk(" %02X", txdesc->Ctl_8);
+		txdesc = advance_txdesc(adev, txdesc, 1);
+	}
+	printk("\n");
+}
+#endif
+
+
+static void handle_tx_error(acx_device_t * adev, u8 error, unsigned int finger,
+		struct ieee80211_tx_status *status)
+{
+	const char *err = "unknown error";
+
+	/* hmm, should we handle this as a mask
+	 * of *several* bits?
+	 * For now I think only caring about
+	 * individual bits is ok... */
+	switch (error) {
+	case 0x01:
+		err = "no Tx due to error in other fragment";
+/*		adev->wstats.discard.fragment++; */
+		break;
+	case 0x02:
+		err = "Tx aborted";
+		adev->stats.tx_aborted_errors++;
+		break;
+	case 0x04:
+		err = "Tx desc wrong parameters";
+/*		adev->wstats.discard.misc++; */
+		break;
+	case 0x08:
+		err = "WEP key not found";
+/*		adev->wstats.discard.misc++; */
+		break;
+	case 0x10:
+		err = "MSDU lifetime timeout? - try changing "
+		    "'iwconfig retry lifetime XXX'";
+/*		adev->wstats.discard.misc++; */
+		break;
+	case 0x20:
+		err = "excessive Tx retries due to either distance "
+		    "too high or unable to Tx or Tx frame error - "
+		    "try changing 'iwconfig txpower XXX' or "
+		    "'sens'itivity or 'retry'";
+/*		adev->wstats.discard.retries++; */
+		/* Tx error 0x20 also seems to occur on
+		 * overheating, so I'm not sure whether we
+		 * actually want to do aggressive radio recalibration,
+		 * since people maybe won't notice then that their hardware
+		 * is slowly getting cooked...
+		 * Or is it still a safe long distance from utter
+		 * radio non-functionality despite many radio recalibs
+		 * to final destructive overheating of the hardware?
+		 * In this case we really should do recalib here...
+		 * I guess the only way to find out is to do a
+		 * potentially fatal self-experiment :-\
+		 * Or maybe only recalib in case we're using Tx
+		 * rate auto (on errors switching to lower speed
+		 * --> less heat?) or 802.11 power save mode?
+		 *
+		 * ok, just do it. */
+		if (++adev->retry_errors_msg_ratelimit % 4 == 0) {
+			if (adev->retry_errors_msg_ratelimit <= 20) {
+				printk("%s: several excessive Tx "
+				       "retry errors occurred, attempting "
+				       "to recalibrate radio. Radio "
+				       "drift might be caused by increasing "
+				       "card temperature, please check the card "
+				       "before it's too late!\n",
+				       wiphy_name(adev->ieee->wiphy));
+				if (adev->retry_errors_msg_ratelimit == 20)
+					printk("disabling above message\n");
+			}
+
+			acx_schedule_task(adev,
+					  ACX_AFTER_IRQ_CMD_RADIO_RECALIB);
+		}
+		status->excessive_retries++;
+		break;
+	case 0x40:
+		err = "Tx buffer overflow";
+		adev->stats.tx_fifo_errors++;
+		break;
+	case 0x80:
+		/* possibly ACPI C-state powersaving related!!!
+		 * (DMA timeout due to excessively high wakeup
+		 * latency after C-state activation!?)
+		 * Disable C-State powersaving and try again,
+		 * then PLEASE REPORT, I'm VERY interested in
+		 * whether my theory is correct that this is
+		 * actually the problem here.
+		 * In that case, use new Linux idle wakeup latency
+		 * requirements kernel API to prevent this issue. */
+		err = "DMA error";
+/*		adev->wstats.discard.misc++; */
+		break;
+	}
+	adev->stats.tx_errors++;
+	if (adev->stats.tx_errors <= 20)
+		printk("%s: tx error 0x%02X, buf %02u! (%s)\n",
+		       wiphy_name(adev->ieee->wiphy), error, finger, err);
+	else
+		printk("%s: tx error 0x%02X, buf %02u!\n",
+		       wiphy_name(adev->ieee->wiphy), error, finger);
+}
+
+
+unsigned int acxpci_l_clean_txdesc(acx_device_t * adev)
+{
+	txdesc_t *txdesc;
+	txhostdesc_t *hostdesc;
+	unsigned finger;
+	int num_cleaned;
+	u16 r111;
+	u8 error, ack_failures, rts_failures, rts_ok, r100;
+
+	FN_ENTER;
+
+	if (unlikely(acx_debug & L_DEBUG))
+		log_txbuffer(adev);
+
+	log(L_BUFT, "tx: cleaning up bufs from %u\n", adev->tx_tail);
+
+	/* We know first descr which is not free yet. We advance it as far
+	 ** as we see correct bits set in following descs (if next desc
+	 ** is NOT free, we shouldn't advance at all). We know that in
+	 ** front of tx_tail may be "holes" with isolated free descs.
+	 ** We will catch up when all intermediate descs will be freed also */
+
+	finger = adev->tx_tail;
+	num_cleaned = 0;
+	while (likely(finger != adev->tx_head)) {
+		txdesc = get_txdesc(adev, finger);
+
+		/* If we allocated txdesc on tx path but then decided
+		 ** to NOT use it, then it will be left as a free "bubble"
+		 ** in the "allocated for tx" part of the ring.
+		 ** We may meet it on the next ring pass here. */
+
+		/* stop if not marked as "tx finished" and "host owned" */
+		if ((txdesc->Ctl_8 & DESC_CTL_ACXDONE_HOSTOWN)
+		    != DESC_CTL_ACXDONE_HOSTOWN) {
+			if (unlikely(!num_cleaned)) {	/* maybe remove completely */
+				log(L_BUFT, "clean_txdesc: tail isn't free. "
+				    "tail:%d head:%d\n",
+				    adev->tx_tail, adev->tx_head);
+			}
+			break;
+		}
+
+		/* remember desc values... */
+		error = txdesc->error;
+		ack_failures = txdesc->ack_failures;
+		rts_failures = txdesc->rts_failures;
+		rts_ok = txdesc->rts_ok;
+		r100 = txdesc->u.r1.rate;
+		r111 = le16_to_cpu(txdesc->u.r2.rate111);
+
+		/* need to check for certain error conditions before we
+		 * clean the descriptor: we still need valid descr data here */
+		hostdesc = get_txhostdesc(adev, txdesc);
+
+		hostdesc->txstatus.flags |= IEEE80211_TX_STATUS_ACK; 
+		if (unlikely(0x30 & error)) {
+			/* only send IWEVTXDROP in case of retry or lifetime exceeded;
+			 * all other errors mean we screwed up locally */
+/*			union iwreq_data wrqu;
+			struct ieee80211_hdr_3addr *hdr;
+			hdr = (struct ieee80211_hdr_3addr *) hostdesc->data;
+			MAC_COPY(wrqu.addr.sa_data, hdr->addr1);
+*/
+			hostdesc->txstatus.flags &= ~IEEE80211_TX_STATUS_ACK; 
+		}
+
+		/* ...and free the desc */
+		txdesc->error = 0;
+		txdesc->ack_failures = 0;
+		txdesc->rts_failures = 0;
+		txdesc->rts_ok = 0;
+		/* signal host owning it LAST, since ACX already knows that this
+		 ** descriptor is finished since it set Ctl_8 accordingly. */
+		txdesc->Ctl_8 = DESC_CTL_HOSTOWN;
+
+		adev->tx_free++;
+		num_cleaned++;
+
+		if ((adev->tx_free >= TX_START_QUEUE)
+/*		    && (adev->status == ACX_STATUS_4_ASSOCIATED) */
+		    /*&& (acx_queue_stopped(adev->ieee))*/
+		    ) {
+			log(L_BUF, "tx: wake queue (avail. Tx desc %u)\n",
+			    adev->tx_free);
+			acx_wake_queue(adev->ieee, NULL);
+		}
+
+		/* do error checking, rate handling and logging
+		 * AFTER having done the work, it's faster */
+
+		/* Rate handling is done in mac80211 */
+/*		if (adev->rate_auto) {
+			struct client *clt = get_txc(adev, txdesc);
+			if (clt) {
+				u16 cur = get_txr(adev, txdesc);
+				if (clt->rate_cur == cur) {
+					acx_l_handle_txrate_auto(adev, clt, cur,*/	/* intended rate */
+								 /*r100, r111,*/	/* actually used rate */
+								 /*(error & 0x30),*/	/* was there an error? */
+/*								 TX_CNT +
+								 TX_CLEAN_BACKLOG
+								 -
+								 adev->tx_free);
+				}
+			}
+		}
+*/
+		if (unlikely(error))
+			handle_tx_error(adev, error, finger,  &hostdesc->txstatus);
+
+		if (IS_ACX111(adev))
+			log(L_BUFT,
+			    "tx: cleaned %u: !ACK=%u !RTS=%u RTS=%u r111=%04X tx_free=%u\n",
+			    finger, ack_failures, rts_failures, rts_ok, r111, adev->tx_free);
+		else
+			log(L_BUFT,
+			    "tx: cleaned %u: !ACK=%u !RTS=%u RTS=%u rate=%u\n",
+			    finger, ack_failures, rts_failures, rts_ok, r100);
+
+		/* And finally report upstream */
+		if (hostdesc)
+		{
+			hostdesc->txstatus.excessive_retries = rts_failures ;
+			hostdesc->txstatus.retry_count = ack_failures;
+			ieee80211_tx_status(adev->ieee,hostdesc->skb,&hostdesc->txstatus);
+			memset(&hostdesc->txstatus, 0, sizeof(struct ieee80211_tx_status));
+		}
+		/* update pointer for descr to be cleaned next */
+		finger = (finger + 1) % TX_CNT;
+	}
+	/* remember last position */
+	adev->tx_tail = finger;
+/* end: */
+	FN_EXIT1(num_cleaned);
+	return num_cleaned;
+}
+
+/* clean *all* Tx descriptors, and regardless of their previous state.
+ * Used for brute-force reset handling. */
+void acxpci_l_clean_txdesc_emergency(acx_device_t * adev)
+{
+	txdesc_t *txdesc;
+	int i;
+
+	FN_ENTER;
+
+	for (i = 0; i < TX_CNT; i++) {
+		txdesc = get_txdesc(adev, i);
+
+		/* free it */
+		txdesc->ack_failures = 0;
+		txdesc->rts_failures = 0;
+		txdesc->rts_ok = 0;
+		txdesc->error = 0;
+		txdesc->Ctl_8 = DESC_CTL_HOSTOWN;
+	}
+
+	adev->tx_free = TX_CNT;
+
+	FN_EXIT0;
+}
+
+
+/***********************************************************************
+** acxpci_s_create_tx_host_desc_queue
+*/
+
+static void *allocate(acx_device_t * adev, size_t size, dma_addr_t * phy,
+		      const char *msg)
+{
+	void *ptr;
+
+	ptr = dma_alloc_coherent(adev->bus_dev, size, phy, GFP_KERNEL);
+
+	if (ptr) {
+		log(L_DEBUG, "%s sz=%d adr=0x%p phy=0x%08llx\n",
+		    msg, (int)size, ptr, (unsigned long long)*phy);
+		memset(ptr, 0, size);
+		return ptr;
+	}
+	printk(KERN_ERR "acx: %s allocation FAILED (%d bytes)\n",
+	       msg, (int)size);
+	return NULL;
+}
+
+
+static int acxpci_s_create_tx_host_desc_queue(acx_device_t * adev)
+{
+	txhostdesc_t *hostdesc;
+	u8 *txbuf;
+	dma_addr_t hostdesc_phy;
+	dma_addr_t txbuf_phy;
+	int i;
+
+	FN_ENTER;
+
+	/* allocate TX buffer */
+	adev->txbuf_area_size = TX_CNT * /*WLAN_A4FR_MAXLEN_WEP_FCS*/ (30 + 2312 + 4);
+	adev->txbuf_start = allocate(adev, adev->txbuf_area_size,
+				     &adev->txbuf_startphy, "txbuf_start");
+	if (!adev->txbuf_start)
+		goto fail;
+
+	/* allocate the TX host descriptor queue pool */
+	adev->txhostdesc_area_size = TX_CNT * 2 * sizeof(*hostdesc);
+	adev->txhostdesc_start = allocate(adev, adev->txhostdesc_area_size,
+					  &adev->txhostdesc_startphy,
+					  "txhostdesc_start");
+	if (!adev->txhostdesc_start)
+		goto fail;
+	/* check for proper alignment of TX host descriptor pool */
+	if ((long)adev->txhostdesc_start & 3) {
+		printk
+		    ("acx: driver bug: dma alloc returns unaligned address\n");
+		goto fail;
+	}
+
+	hostdesc = adev->txhostdesc_start;
+	hostdesc_phy = adev->txhostdesc_startphy;
+	txbuf = adev->txbuf_start;
+	txbuf_phy = adev->txbuf_startphy;
+
+#if 0
+/* Each tx buffer is accessed by hardware via
+** txdesc -> txhostdesc(s) -> txbuffer(s).
+** We use only one txhostdesc per txdesc, but it looks like
+** acx111 is buggy: it accesses second txhostdesc
+** (via hostdesc.desc_phy_next field) even if
+** txdesc->length == hostdesc->length and thus
+** entire packet was placed into first txhostdesc.
+** Due to this bug acx111 hangs unless second txhostdesc
+** has le16_to_cpu(hostdesc.length) = 3 (or larger)
+** Storing NULL into hostdesc.desc_phy_next
+** doesn't seem to help.
+**
+** Update: although it worked on Xterasys XN-2522g
+** with len=3 trick, WG311v2 is even more bogus, doesn't work.
+** Keeping this code (#ifdef'ed out) for documentational purposes.
+*/
+	for (i = 0; i < TX_CNT * 2; i++) {
+		hostdesc_phy += sizeof(*hostdesc);
+		if (!(i & 1)) {
+			hostdesc->data_phy = cpu2acx(txbuf_phy);
+			/* hostdesc->data_offset = ... */
+			/* hostdesc->reserved = ... */
+			hostdesc->Ctl_16 = cpu_to_le16(DESC_CTL_HOSTOWN);
+			/* hostdesc->length = ... */
+			hostdesc->desc_phy_next = cpu2acx(hostdesc_phy);
+			hostdesc->pNext = ptr2acx(NULL);
+			/* hostdesc->Status = ... */
+			/* below: non-hardware fields */
+			hostdesc->data = txbuf;
+
+			txbuf += WLAN_A4FR_MAXLEN_WEP_FCS;
+			txbuf_phy += WLAN_A4FR_MAXLEN_WEP_FCS;
+		} else {
+			/* hostdesc->data_phy = ... */
+			/* hostdesc->data_offset = ... */
+			/* hostdesc->reserved = ... */
+			/* hostdesc->Ctl_16 = ... */
+			hostdesc->length = cpu_to_le16(3);	/* bug workaround */
+			/* hostdesc->desc_phy_next = ... */
+			/* hostdesc->pNext = ... */
+			/* hostdesc->Status = ... */
+			/* below: non-hardware fields */
+			/* hostdesc->data = ... */
+		}
+		hostdesc++;
+	}
+#endif
+/* We initialize two hostdescs so that they point to adjacent
+** memory areas. Thus txbuf is really just a contiguous memory area */
+	for (i = 0; i < TX_CNT * 2; i++) {
+		hostdesc_phy += sizeof(*hostdesc);
+
+		hostdesc->data_phy = cpu2acx(txbuf_phy);
+		/* done by memset(0): hostdesc->data_offset = 0; */
+		/* hostdesc->reserved = ... */
+		hostdesc->Ctl_16 = cpu_to_le16(DESC_CTL_HOSTOWN);
+		/* hostdesc->length = ... */
+		hostdesc->desc_phy_next = cpu2acx(hostdesc_phy);
+		/* done by memset(0): hostdesc->pNext = ptr2acx(NULL); */
+		/* hostdesc->Status = ... */
+		/* ->data is a non-hardware field: */
+		hostdesc->data = txbuf;
+
+		if (!(i & 1)) {
+			txbuf += 24 /*WLAN_HDR_A3_LEN*/;
+			txbuf_phy += 24 /*WLAN_HDR_A3_LEN*/;
+		} else {
+			txbuf +=  30 + 2132 + 4 - 24/*WLAN_A4FR_MAXLEN_WEP_FCS - WLAN_HDR_A3_LEN*/;
+			txbuf_phy += 30 + 2132 +4  - 24/*WLAN_A4FR_MAXLEN_WEP_FCS - WLAN_HDR_A3_LEN*/;
+		}
+		hostdesc++;
+	}
+	hostdesc--;
+	hostdesc->desc_phy_next = cpu2acx(adev->txhostdesc_startphy);
+
+	FN_EXIT1(OK);
+	return OK;
+      fail:
+	printk("acx: create_tx_host_desc_queue FAILED\n");
+	/* dealloc will be done by free function on error case */
+	FN_EXIT1(NOT_OK);
+	return NOT_OK;
+}
+
+
+/***************************************************************
+** acxpci_s_create_rx_host_desc_queue
+*/
+/* the whole size of a data buffer (header plus data body)
+ * plus 32 bytes safety offset at the end */
+#define RX_BUFFER_SIZE (sizeof(rxbuffer_t) + 32)
+
+static int acxpci_s_create_rx_host_desc_queue(acx_device_t * adev)
+{
+	rxhostdesc_t *hostdesc;
+	rxbuffer_t *rxbuf;
+	dma_addr_t hostdesc_phy;
+	dma_addr_t rxbuf_phy;
+	int i;
+
+	FN_ENTER;
+
+	/* allocate the RX host descriptor queue pool */
+	adev->rxhostdesc_area_size = RX_CNT * sizeof(*hostdesc);
+	adev->rxhostdesc_start = allocate(adev, adev->rxhostdesc_area_size,
+					  &adev->rxhostdesc_startphy,
+					  "rxhostdesc_start");
+	if (!adev->rxhostdesc_start)
+		goto fail;
+	/* check for proper alignment of RX host descriptor pool */
+	if ((long)adev->rxhostdesc_start & 3) {
+		printk
+		    ("acx: driver bug: dma alloc returns unaligned address\n");
+		goto fail;
+	}
+
+	/* allocate Rx buffer pool which will be used by the acx
+	 * to store the whole content of the received frames in it */
+	adev->rxbuf_area_size = RX_CNT * RX_BUFFER_SIZE;
+	adev->rxbuf_start = allocate(adev, adev->rxbuf_area_size,
+				     &adev->rxbuf_startphy, "rxbuf_start");
+	if (!adev->rxbuf_start)
+		goto fail;
+
+	rxbuf = adev->rxbuf_start;
+	rxbuf_phy = adev->rxbuf_startphy;
+	hostdesc = adev->rxhostdesc_start;
+	hostdesc_phy = adev->rxhostdesc_startphy;
+
+	/* don't make any popular C programming pointer arithmetic mistakes
+	 * here, otherwise I'll kill you...
+	 * (and don't dare asking me why I'm warning you about that...) */
+	for (i = 0; i < RX_CNT; i++) {
+		hostdesc->data = rxbuf;
+		hostdesc->data_phy = cpu2acx(rxbuf_phy);
+		hostdesc->length = cpu_to_le16(RX_BUFFER_SIZE);
+		CLEAR_BIT(hostdesc->Ctl_16, cpu_to_le16(DESC_CTL_HOSTOWN));
+		rxbuf++;
+		rxbuf_phy += sizeof(*rxbuf);
+		hostdesc_phy += sizeof(*hostdesc);
+		hostdesc->desc_phy_next = cpu2acx(hostdesc_phy);
+		hostdesc++;
+	}
+	hostdesc--;
+	hostdesc->desc_phy_next = cpu2acx(adev->rxhostdesc_startphy);
+	FN_EXIT1(OK);
+	return OK;
+      fail:
+	printk("acx: create_rx_host_desc_queue FAILED\n");
+	/* dealloc will be done by free function on error case */
+	FN_EXIT1(NOT_OK);
+	return NOT_OK;
+}
+
+
+/***************************************************************
+** acxpci_s_create_hostdesc_queues
+*/
+int acxpci_s_create_hostdesc_queues(acx_device_t * adev)
+{
+	int result;
+	result = acxpci_s_create_tx_host_desc_queue(adev);
+	if (OK != result)
+		return result;
+	result = acxpci_s_create_rx_host_desc_queue(adev);
+	return result;
+}
+
+
+/***************************************************************
+** acxpci_create_tx_desc_queue
+*/
+static void acxpci_create_tx_desc_queue(acx_device_t * adev, u32 tx_queue_start)
+{
+	txdesc_t *txdesc;
+	txhostdesc_t *hostdesc;
+	dma_addr_t hostmemptr;
+	u32 mem_offs;
+	int i;
+
+	FN_ENTER;
+
+	if (IS_ACX100(adev))
+		adev->txdesc_size = sizeof(*txdesc);
+	else
+		/* the acx111 txdesc is 4 bytes larger */
+		adev->txdesc_size = sizeof(*txdesc) + 4;
+
+	adev->txdesc_start = (txdesc_t *) (adev->iobase2 + tx_queue_start);
+
+	log(L_DEBUG, "adev->iobase2=%p\n"
+	    "tx_queue_start=%08X\n"
+	    "adev->txdesc_start=%p\n",
+	    adev->iobase2, tx_queue_start, adev->txdesc_start);
+
+	adev->tx_free = TX_CNT;
+	/* done by memset: adev->tx_head = 0; */
+	/* done by memset: adev->tx_tail = 0; */
+	txdesc = adev->txdesc_start;
+	mem_offs = tx_queue_start;
+	hostmemptr = adev->txhostdesc_startphy;
+	hostdesc = adev->txhostdesc_start;
+
+	if (IS_ACX111(adev)) {
+		/* ACX111 has a preinitialized Tx buffer! */
+		/* loop over whole send pool */
+		/* FIXME: do we have to do the hostmemptr stuff here?? */
+		for (i = 0; i < TX_CNT; i++) {
+			txdesc->HostMemPtr = ptr2acx(hostmemptr);
+			txdesc->Ctl_8 = DESC_CTL_HOSTOWN;
+			/* reserve two (hdr desc and payload desc) */
+			hostdesc += 2;
+			hostmemptr += 2 * sizeof(*hostdesc);
+			txdesc = advance_txdesc(adev, txdesc, 1);
+		}
+	} else {
+		/* ACX100 Tx buffer needs to be initialized by us */
+		/* clear whole send pool. sizeof is safe here (we are acx100) */
+		memset(adev->txdesc_start, 0, TX_CNT * sizeof(*txdesc));
+
+		/* loop over whole send pool */
+		for (i = 0; i < TX_CNT; i++) {
+			log(L_DEBUG, "configure card tx descriptor: 0x%p, "
+			    "size: 0x%X\n", txdesc, adev->txdesc_size);
+
+			/* pointer to hostdesc memory */
+			txdesc->HostMemPtr = ptr2acx(hostmemptr);
+			/* initialise ctl */
+			txdesc->Ctl_8 = (DESC_CTL_HOSTOWN | DESC_CTL_RECLAIM
+					 | DESC_CTL_AUTODMA |
+					 DESC_CTL_FIRSTFRAG);
+			/* done by memset(0): txdesc->Ctl2_8 = 0; */
+			/* point to next txdesc */
+			txdesc->pNextDesc =
+			    cpu2acx(mem_offs + adev->txdesc_size);
+			/* reserve two (hdr desc and payload desc) */
+			hostdesc += 2;
+			hostmemptr += 2 * sizeof(*hostdesc);
+			/* go to the next one */
+			mem_offs += adev->txdesc_size;
+			/* ++ is safe here (we are acx100) */
+			txdesc++;
+		}
+		/* go back to the last one */
+		txdesc--;
+		/* and point to the first making it a ring buffer */
+		txdesc->pNextDesc = cpu2acx(tx_queue_start);
+	}
+	FN_EXIT0;
+}
+
+
+/***************************************************************
+** acxpci_create_rx_desc_queue
+*/
+static void acxpci_create_rx_desc_queue(acx_device_t * adev, u32 rx_queue_start)
+{
+	rxdesc_t *rxdesc;
+	u32 mem_offs;
+	int i;
+
+	FN_ENTER;
+
+	/* done by memset: adev->rx_tail = 0; */
+
+	/* ACX111 doesn't need any further config: preconfigures itself.
+	 * Simply print ring buffer for debugging */
+	if (IS_ACX111(adev)) {
+		/* rxdesc_start already set here */
+
+		adev->rxdesc_start =
+		    (rxdesc_t *) ((u8 *) adev->iobase2 + rx_queue_start);
+
+		rxdesc = adev->rxdesc_start;
+		for (i = 0; i < RX_CNT; i++) {
+			log(L_DEBUG, "rx descriptor %d @ 0x%p\n", i, rxdesc);
+			rxdesc = adev->rxdesc_start = (rxdesc_t *)
+			    (adev->iobase2 + acx2cpu(rxdesc->pNextDesc));
+		}
+	} else {
+		/* we didn't pre-calculate rxdesc_start in case of ACX100 */
+		/* rxdesc_start should be right AFTER Tx pool */
+		adev->rxdesc_start = (rxdesc_t *)
+		    ((u8 *) adev->txdesc_start + (TX_CNT * sizeof(txdesc_t)));
+		/* NB: sizeof(txdesc_t) above is valid because we know
+		 ** we are in if (acx100) block. Beware of cut-n-pasting elsewhere!
+		 ** acx111's txdesc is larger! */
+
+		memset(adev->rxdesc_start, 0, RX_CNT * sizeof(*rxdesc));
+
+		/* loop over whole receive pool */
+		rxdesc = adev->rxdesc_start;
+		mem_offs = rx_queue_start;
+		for (i = 0; i < RX_CNT; i++) {
+			log(L_DEBUG, "rx descriptor @ 0x%p\n", rxdesc);
+			rxdesc->Ctl_8 = DESC_CTL_RECLAIM | DESC_CTL_AUTODMA;
+			/* point to next rxdesc */
+			rxdesc->pNextDesc = cpu2acx(mem_offs + sizeof(*rxdesc));
+			/* go to the next one */
+			mem_offs += sizeof(*rxdesc);
+			rxdesc++;
+		}
+		/* go to the last one */
+		rxdesc--;
+
+		/* and point to the first making it a ring buffer */
+		rxdesc->pNextDesc = cpu2acx(rx_queue_start);
+	}
+	FN_EXIT0;
+}
+
+
+/***************************************************************
+** acxpci_create_desc_queues
+*/
+void
+acxpci_create_desc_queues(acx_device_t * adev, u32 tx_queue_start,
+			  u32 rx_queue_start)
+{
+	acxpci_create_tx_desc_queue(adev, tx_queue_start);
+	acxpci_create_rx_desc_queue(adev, rx_queue_start);
+}
+
+
+/***************************************************************
+** acxpci_s_proc_diag_output
+*/
+char *acxpci_s_proc_diag_output(char *p, acx_device_t * adev)
+{
+	const char *rtl, *thd, *ttl;
+	rxhostdesc_t *rxhostdesc;
+	txdesc_t *txdesc;
+	int i;
+
+	FN_ENTER;
+
+	p += sprintf(p, "** Rx buf **\n");
+	rxhostdesc = adev->rxhostdesc_start;
+	if (rxhostdesc)
+		for (i = 0; i < RX_CNT; i++) {
+			rtl = (i == adev->rx_tail) ? " [tail]" : "";
+			if ((rxhostdesc->Ctl_16 & cpu_to_le16(DESC_CTL_HOSTOWN))
+			    && (rxhostdesc->
+				Status & cpu_to_le32(DESC_STATUS_FULL)))
+				p += sprintf(p, "%02u FULL%s\n", i, rtl);
+			else
+				p += sprintf(p, "%02u empty%s\n", i, rtl);
+			rxhostdesc++;
+		}
+/*	p += sprintf(p, "** Tx buf (free %d, Linux netqueue %s) **\n",
+		     adev->tx_free,
+		     acx_queue_stopped(adev->ieee) ? "STOPPED" : "running");*/
+	txdesc = adev->txdesc_start;
+	if (txdesc)
+		for (i = 0; i < TX_CNT; i++) {
+			thd = (i == adev->tx_head) ? " [head]" : "";
+			ttl = (i == adev->tx_tail) ? " [tail]" : "";
+			if (txdesc->Ctl_8 & DESC_CTL_ACXDONE)
+				p += sprintf(p, "%02u free (%02X)%s%s\n", i,
+					     txdesc->Ctl_8, thd, ttl);
+			else
+				p += sprintf(p, "%02u tx   (%02X)%s%s\n", i,
+					     txdesc->Ctl_8, thd, ttl);
+			txdesc = advance_txdesc(adev, txdesc, 1);
+		}
+	p += sprintf(p,
+		     "\n"
+		     "** PCI data **\n"
+		     "txbuf_start %p, txbuf_area_size %u, txbuf_startphy %08llx\n"
+		     "txdesc_size %u, txdesc_start %p\n"
+		     "txhostdesc_start %p, txhostdesc_area_size %u, txhostdesc_startphy %08llx\n"
+		     "rxdesc_start %p\n"
+		     "rxhostdesc_start %p, rxhostdesc_area_size %u, rxhostdesc_startphy %08llx\n"
+		     "rxbuf_start %p, rxbuf_area_size %u, rxbuf_startphy %08llx\n",
+		     adev->txbuf_start, adev->txbuf_area_size,
+		     (unsigned long long)adev->txbuf_startphy,
+		     adev->txdesc_size, adev->txdesc_start,
+		     adev->txhostdesc_start, adev->txhostdesc_area_size,
+		     (unsigned long long)adev->txhostdesc_startphy,
+		     adev->rxdesc_start,
+		     adev->rxhostdesc_start, adev->rxhostdesc_area_size,
+		     (unsigned long long)adev->rxhostdesc_startphy,
+		     adev->rxbuf_start, adev->rxbuf_area_size,
+		     (unsigned long long)adev->rxbuf_startphy);
+
+	FN_EXIT0;
+	return p;
+}
+
+
+/***********************************************************************
+*/
+int acxpci_proc_eeprom_output(char *buf, acx_device_t * adev)
+{
+	char *p = buf;
+	int i;
+
+	FN_ENTER;
+
+	for (i = 0; i < 0x400; i++) {
+		acxpci_read_eeprom_byte(adev, i, p++);
+	}
+
+	FN_EXIT1(p - buf);
+	return p - buf;
+}
+
+
+/***********************************************************************
+** Obvious
+*/
+void acxpci_set_interrupt_mask(acx_device_t * adev)
+{
+	if (IS_ACX111(adev)) {
+		adev->irq_mask = (u16) ~ (0
+					  /* | HOST_INT_RX_DATA        */
+					  | HOST_INT_TX_COMPLETE
+					  /* | HOST_INT_TX_XFER        */
+					  | HOST_INT_RX_COMPLETE
+					  /* | HOST_INT_DTIM           */
+					  /* | HOST_INT_BEACON         */
+					  /* | HOST_INT_TIMER          */
+					  /* | HOST_INT_KEY_NOT_FOUND  */
+					  | HOST_INT_IV_ICV_FAILURE
+					  | HOST_INT_CMD_COMPLETE
+					  | HOST_INT_INFO
+					  /* | HOST_INT_OVERFLOW       */
+					  /* | HOST_INT_PROCESS_ERROR  */
+					  | HOST_INT_SCAN_COMPLETE
+					  | HOST_INT_FCS_THRESHOLD
+					  /* | HOST_INT_UNKNOWN        */
+		    );
+		/* Or else acx100 won't signal cmd completion, right? */
+		adev->irq_mask_off = (u16) ~ (HOST_INT_CMD_COMPLETE);	/* 0xfdff */
+	} else {
+		adev->irq_mask = (u16) ~ (0
+					  /* | HOST_INT_RX_DATA        */
+					  | HOST_INT_TX_COMPLETE
+					  /* | HOST_INT_TX_XFER        */
+					  | HOST_INT_RX_COMPLETE
+					  /* | HOST_INT_DTIM           */
+					  /* | HOST_INT_BEACON         */
+					  /* | HOST_INT_TIMER          */
+					  /* | HOST_INT_KEY_NOT_FOUND  */
+					  /* | HOST_INT_IV_ICV_FAILURE */
+					  | HOST_INT_CMD_COMPLETE
+					  | HOST_INT_INFO
+					  /* | HOST_INT_OVERFLOW       */
+					  /* | HOST_INT_PROCESS_ERROR  */
+					  | HOST_INT_SCAN_COMPLETE
+					  /* | HOST_INT_FCS_THRESHOLD  */
+					  /* | HOST_INT_UNKNOWN        */
+		    );
+		adev->irq_mask_off = (u16) ~ (HOST_INT_UNKNOWN);	/* 0x7fff */
+	}
+}
+
+
+/***********************************************************************
+*/
+int acx100pci_s_set_tx_level(acx_device_t * adev, u8 level_dbm)
+{
+	/* since it can be assumed that at least the Maxim radio has a
+	 * maximum power output of 20dBm and since it also can be
+	 * assumed that these values drive the DAC responsible for
+	 * setting the linear Tx level, I'd guess that these values
+	 * should be the corresponding linear values for a dBm value,
+	 * in other words: calculate the values from that formula:
+	 * Y [dBm] = 10 * log (X [mW])
+	 * then scale the 0..63 value range onto the 1..100mW range (0..20 dBm)
+	 * and you're done...
+	 * Hopefully that's ok, but you never know if we're actually
+	 * right... (especially since Windows XP doesn't seem to show
+	 * actual Tx dBm values :-P) */
+
+	/* NOTE: on Maxim, value 30 IS 30mW, and value 10 IS 10mW - so the
+	 * values are EXACTLY mW!!! Not sure about RFMD and others,
+	 * though... */
+	static const u8 dbm2val_maxim[21] = {
+		63, 63, 63, 62,
+		61, 61, 60, 60,
+		59, 58, 57, 55,
+		53, 50, 47, 43,
+		38, 31, 23, 13,
+		0
+	};
+	static const u8 dbm2val_rfmd[21] = {
+		0, 0, 0, 1,
+		2, 2, 3, 3,
+		4, 5, 6, 8,
+		10, 13, 16, 20,
+		25, 32, 41, 50,
+		63
+	};
+	const u8 *table;
+
+	switch (adev->radio_type) {
+	case RADIO_MAXIM_0D:
+		table = &dbm2val_maxim[0];
+		break;
+	case RADIO_RFMD_11:
+	case RADIO_RALINK_15:
+		table = &dbm2val_rfmd[0];
+		break;
+	default:
+		printk("%s: unknown/unsupported radio type, "
+		       "cannot modify tx power level yet!\n", wiphy_name(adev->ieee->wiphy));
+		return NOT_OK;
+	}
+	printk("%s: changing radio power level to %u dBm (%u)\n",
+	       wiphy_name(adev->ieee->wiphy), level_dbm, table[level_dbm]);
+	acxpci_s_write_phy_reg(adev, 0x11, table[level_dbm]);
+	return OK;
+}
+
+#ifdef CONFIG_VLYNQ
+struct vlynq_reg_config {
+	u32 offset;
+	u32 value;
+};
+
+struct vlynq_known {
+	u32 chip_id;
+	char name[32];
+	struct vlynq_mapping rx_mapping[4];
+	int irq;
+	int irq_type;
+	int num_regs;
+	struct vlynq_reg_config regs[10];
+};
+
+#define CHIP_TNETW1130 0x00000009
+#define CHIP_TNETW1350 0x00000029
+
+static struct vlynq_known known_devices[] = {
+	{
+		.chip_id = CHIP_TNETW1130, .name = "TI TNETW1130",
+		.rx_mapping = {
+			{ .size = 0x22000, .offset = 0xf0000000 },
+			{ .size = 0x40000, .offset = 0xc0000000 },
+			{ .size = 0x0, .offset = 0x0 },
+			{ .size = 0x0, .offset = 0x0 },
+		},
+		.irq = 0,
+		.irq_type = IRQ_TYPE_EDGE_RISING,
+		.num_regs = 5,
+		.regs = {
+			{
+				.offset = 0x790,
+				.value = (0xd0000000 - PHYS_OFFSET)
+			},
+			{
+				.offset = 0x794,
+				.value = (0xd0000000 - PHYS_OFFSET)
+			},
+			{ .offset = 0x740, .value = 0 },
+			{ .offset = 0x744, .value = 0x00010000 },
+			{ .offset = 0x764, .value = 0x00010000 },
+		},
+	},
+	{
+		.chip_id = CHIP_TNETW1350, .name = "TI TNETW1350",
+		.rx_mapping = {
+			{ .size = 0x100000, .offset = 0x00300000 },
+			{ .size = 0x80000, .offset = 0x00000000 },
+			{ .size = 0x0, .offset = 0x0 },
+			{ .size = 0x0, .offset = 0x0 },
+		},
+		.irq = 0,
+		.irq_type = IRQ_TYPE_EDGE_RISING,
+		.num_regs = 5,
+		.regs = {
+			{
+				.offset = 0x790,
+				.value = (0x60000000 - PHYS_OFFSET)
+			},
+			{
+				.offset = 0x794,
+				.value = (0x60000000 - PHYS_OFFSET)
+			},
+			{ .offset = 0x740, .value = 0 },
+			{ .offset = 0x744, .value = 0x00010000 },
+			{ .offset = 0x764, .value = 0x00010000 },
+		},
+	},
+};
+
+static struct vlynq_device_id acx_vlynq_id[] = {
+	{ CHIP_TNETW1130, vlynq_div_auto, 0 },
+	{ CHIP_TNETW1350, vlynq_div_auto, 1 },
+	{ 0, 0, 0 },
+};
+
+static __devinit int vlynq_probe(struct vlynq_device *vdev,
+				 struct vlynq_device_id *id)
+{
+	int result = -EIO, i;
+	u32 addr;
+	struct ieee80211_hw *ieee;
+	acx_device_t *adev = NULL;
+	acx111_ie_configoption_t co;
+	struct vlynq_mapping mapping[4] = { { 0, }, };
+	struct vlynq_known *match = NULL;
+
+	FN_ENTER;
+	result = vlynq_enable_device(vdev);
+	if (result)
+		return result;
+
+	match = &known_devices[id->driver_data];
+
+	if (!match) {
+		result = -ENODEV;
+		goto fail;
+	}
+
+	mapping[0].offset = ARCH_PFN_OFFSET << PAGE_SHIFT;
+	mapping[0].size = 0x02000000;
+	vlynq_set_local_mapping(vdev, vdev->mem_start, mapping);
+	vlynq_set_remote_mapping(vdev, 0, match->rx_mapping);
+
+	set_irq_type(vlynq_virq_to_irq(vdev, match->irq), match->irq_type);
+
+	addr = (u32)ioremap(vdev->mem_start, 0x1000);
+	if (!addr) {
+		printk(KERN_ERR "%s: failed to remap io memory\n",
+		       vdev->dev.bus_id);
+		result = -ENXIO;
+		goto fail;
+	}
+
+	for (i = 0; i < match->num_regs; i++)
+		iowrite32(match->regs[i].value,
+			  (u32 *)(addr + match->regs[i].offset));
+
+	iounmap((void *)addr);
+
+	ieee = ieee80211_alloc_hw(sizeof(struct acx_device), &acxpci_hw_ops);
+	if (!ieee) {
+		printk("acx: could not allocate ieee80211 structure %s\n",
+		       vdev->dev.bus_id);
+		goto fail_alloc_netdev;
+	}
+	ieee->flags &=	 (~IEEE80211_HW_RX_INCLUDES_FCS &
+			  ~IEEE80211_HW_MONITOR_DURING_OPER) |
+			 IEEE80211_HW_WEP_INCLUDE_IV;
+	ieee->queues = 1;
+
+	adev = ieee2adev(ieee);
+
+	memset(adev, 0, sizeof(*adev));
+	/** Set up our private interface **/
+	spin_lock_init(&adev->lock);	/* initial state: unlocked */
+	/* We do not start with downed sem: we want PARANOID_LOCKING to work */
+	mutex_init(&adev->mutex);
+	/* since nobody can see new netdev yet, we can as well
+	 ** just _presume_ that we're under sem (instead of actually taking it): */
+	/* acx_sem_lock(adev); */
+	adev->ieee = ieee;
+	adev->vdev = vdev;
+	adev->bus_dev = &vdev->dev;
+	adev->dev_type = DEVTYPE_PCI;
+
+/** Finished with private interface **/
+
+	vlynq_set_drvdata(vdev, ieee);
+	if (!request_mem_region(vdev->mem_start, vdev->mem_end - vdev->mem_start, "acx")) {
+		printk("acx: cannot reserve VLYNQ memory region\n");
+		goto fail_request_mem_region;
+	}
+	adev->iobase = ioremap(vdev->mem_start, vdev->mem_end - vdev->mem_start);
+	if (!adev->iobase) {
+		printk("acx: ioremap() FAILED\n");
+		goto fail_ioremap;
+	}
+	adev->iobase2 = adev->iobase + match->rx_mapping[0].size;
+	adev->chip_type = CHIPTYPE_ACX111;
+	adev->chip_name = match->name;
+	adev->io = IO_ACX111;
+	adev->irq = vlynq_virq_to_irq(vdev, match->irq);
+
+	printk("acx: found %s-based wireless network card at %s, irq:%d, "
+	       "phymem:0x%x, mem:0x%p\n",
+	       match->name, vdev->dev.bus_id, adev->irq,
+	       vdev->mem_start, adev->iobase);
+	log(L_ANY, "initial debug setting is 0x%04X\n", acx_debug);
+
+	if (0 == adev->irq) {
+		printk("acx: can't use IRQ 0\n");
+		goto fail_irq;
+	}
+	SET_IEEE80211_DEV(ieee, &vdev->dev);
+
+
+	/* to find crashes due to weird driver access
+	 * to unconfigured interface (ifup) */
+	adev->mgmt_timer.function = (void (*)(unsigned long))0x0000dead;
+
+
+	/* ok, pci setup is finished, now start initializing the card */
+
+	/* NB: read_reg() reads may return bogus data before reset_dev(),
+	 * since the firmware which directly controls large parts of the I/O
+	 * registers isn't initialized yet.
+	 * acx100 seems to be more affected than acx111 */
+	if (OK != acxpci_s_reset_dev(adev))
+		goto fail_reset;
+
+	if (OK != acx_s_init_mac(adev))
+		goto fail_init_mac;
+
+	acx_s_interrogate(adev, &co, ACX111_IE_CONFIG_OPTIONS);
+/* TODO: merge them into one function, they are called just once and are the same for pci & usb */
+	if (OK != acxpci_read_eeprom_byte(adev, 0x05, &adev->eeprom_version))
+		goto fail_read_eeprom_version;
+
+	acx_s_parse_configoption(adev, &co);
+	acx_s_set_defaults(adev);
+	acx_s_get_firmware_version(adev);	/* needs to be after acx_s_init_mac() */
+	acx_display_hardware_details(adev);
+
+	/* Register the card, AFTER everything else has been set up,
+	 * since otherwise an ioctl could step on our feet due to
+	 * firmware operations happening in parallel or uninitialized data */
+
+
+	acx_proc_register_entries(ieee);
+
+	/* Now we have our device, so make sure the kernel doesn't try
+	 * to send packets even though we're not associated to a network yet */
+
+	/* after register_netdev() userspace may start working with dev
+	 * (in particular, on other CPUs), we only need to up the sem */
+	/* acx_sem_unlock(adev); */
+
+	printk("acx " ACX_RELEASE ": net device %s, driver compiled "
+	       "against wireless extensions %d and Linux %s\n",
+	       wiphy_name(adev->ieee->wiphy), WIRELESS_EXT, UTS_RELEASE);
+
+	MAC_COPY(adev->ieee->wiphy->perm_addr, adev->dev_addr);
+
+	log(L_IRQ | L_INIT, "using IRQ %d\n", adev->irq);
+
+/** done with board specific setup **/
+
+	acx_init_task_scheduler(adev);
+	result = ieee80211_register_hw(adev->ieee);
+	if (OK != result) {
+		printk("acx: ieee80211_register_hw() FAILED: %d\n", result);
+		goto fail_register_netdev;
+	}
+#if CMD_DISCOVERY
+	great_inquisitor(adev);
+#endif
+
+	result = OK;
+	goto done;
+
+	/* error paths: undo everything in reverse order... */
+
+
+	acxpci_s_delete_dma_regions(adev);
+
+      fail_init_mac:
+      fail_read_eeprom_version:
+      fail_reset:
+
+      fail_alloc_netdev:
+      fail_irq:
+
+	iounmap(adev->iobase);
+      fail_ioremap:
+
+	release_mem_region(vdev->mem_start, vdev->mem_end - vdev->mem_start);
+      fail_request_mem_region:
+      fail_register_netdev:
+	ieee80211_free_hw(ieee);
+      fail:
+	vlynq_disable_device(vdev);
+      done:
+	FN_EXIT1(result);
+	return result;
+}
+
+static void vlynq_remove(struct vlynq_device *vdev)
+{
+	struct ieee80211_hw *hw = vlynq_get_drvdata(vdev);
+	acx_device_t *adev = ieee2adev(hw);
+	unsigned long flags;
+	FN_ENTER;
+
+	if (!hw) {
+		log(L_DEBUG, "%s: card is unused. Skipping any release code\n",
+		    __func__);
+		goto end;
+	}
+
+
+	acx_lock(adev, flags);
+	acx_unlock(adev, flags);
+	adev->initialized = 0;
+
+	/* If device wasn't hot unplugged... */
+	if (adev_present(adev)) {
+
+		acx_sem_lock(adev);
+
+		/* disable both Tx and Rx to shut radio down properly */
+		if (adev->initialized) {
+			acx_s_issue_cmd(adev, ACX1xx_CMD_DISABLE_TX, NULL, 0);
+			acx_s_issue_cmd(adev, ACX1xx_CMD_DISABLE_RX, NULL, 0);
+		}
+		acx_lock(adev, flags);
+		/* disable power LED to save power :-) */
+		log(L_INIT, "switching off power LED to save power\n");
+		acxpci_l_power_led(adev, 0);
+		/* stop our eCPU */
+		acx_unlock(adev, flags);
+
+		acx_sem_unlock(adev);
+	}
+
+	/* unregister the device to not let the kernel
+	 * (e.g. ioctls) access a half-deconfigured device
+	 * NB: this will cause acxpci_e_close() to be called,
+	 * thus we shouldn't call it under sem!
+	 * Well, netdev did, but ieee80211 stack does not, so we
+	 * have to do so manually...
+	 */
+	acxpci_e_close(hw);
+	log(L_INIT, "removing device %s\n", wiphy_name(adev->ieee->wiphy));
+	ieee80211_unregister_hw(adev->ieee);
+
+	/* unregister_netdev ensures that no references to us left.
+	 * For paranoid reasons we continue to follow the rules */
+	acx_sem_lock(adev);
+
+	if (adev->dev_state_mask & ACX_STATE_IFACE_UP) {
+		acxpci_s_down(hw);
+		CLEAR_BIT(adev->dev_state_mask, ACX_STATE_IFACE_UP);
+	}
+
+	acx_proc_unregister_entries(adev->ieee);
+
+	/* finally, clean up PCI bus state */
+	acxpci_s_delete_dma_regions(adev);
+	if (adev->iobase)
+		iounmap(adev->iobase);
+	if (adev->iobase2)
+		iounmap(adev->iobase2);
+	release_mem_region(vdev->mem_start, vdev->mem_end - vdev->mem_start);
+
+	/* remove dev registration */
+
+	free_irq(adev->irq, adev);
+	acx_sem_unlock(adev);
+	vlynq_disable_device(vdev);
+
+	/* Free netdev (quite late,
+	 * since otherwise we might get caught off-guard
+	 * by a netdev timeout handler execution
+	 * expecting to see a working dev...) */
+	ieee80211_free_hw(adev->ieee);
+
+      end:
+	FN_EXIT0;
+}
+
+static struct vlynq_driver vlynq_acx = {
+	.name = "acx_vlynq",
+	.id_table = acx_vlynq_id,
+	.probe = vlynq_probe,
+	.remove = __devexit_p(vlynq_remove),
+};
+#endif
+
+/***********************************************************************
+** Data for init_module/cleanup_module
+*/
+#ifdef CONFIG_PCI
+static const struct pci_device_id acxpci_id_tbl[] __devinitdata = {
+	{
+	 .vendor = PCI_VENDOR_ID_TI,
+	 .device = PCI_DEVICE_ID_TI_TNETW1100A,
+	 .subvendor = PCI_ANY_ID,
+	 .subdevice = PCI_ANY_ID,
+	 .driver_data = CHIPTYPE_ACX100,
+	 },
+	{
+	 .vendor = PCI_VENDOR_ID_TI,
+	 .device = PCI_DEVICE_ID_TI_TNETW1100B,
+	 .subvendor = PCI_ANY_ID,
+	 .subdevice = PCI_ANY_ID,
+	 .driver_data = CHIPTYPE_ACX100,
+	 },
+	{
+	 .vendor = PCI_VENDOR_ID_TI,
+	 .device = PCI_DEVICE_ID_TI_TNETW1130,
+	 .subvendor = PCI_ANY_ID,
+	 .subdevice = PCI_ANY_ID,
+	 .driver_data = CHIPTYPE_ACX111,
+	 },
+	{
+	 .vendor = 0,
+	 .device = 0,
+	 .subvendor = 0,
+	 .subdevice = 0,
+	 .driver_data = 0,
+	 }
+};
+
+MODULE_DEVICE_TABLE(pci, acxpci_id_tbl);
+
+/* FIXME: checks should be removed once driver is included in the kernel */
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2, 6, 11)
+/* pci_name() got introduced at start of 2.6.x,
+ * got mandatory (slot_name member removed) in 2.6.11-bk1 */
+#define pci_name(x) x->slot_name
+#endif
+
+static struct pci_driver
+ acxpci_drv_id = {
+	.name = "acx_pci",
+	.id_table = acxpci_id_tbl,
+	.probe = acxpci_e_probe,
+	.remove = __devexit_p(acxpci_e_remove),
+#ifdef CONFIG_PM
+	.suspend = acxpci_e_suspend,
+	.resume = acxpci_e_resume
+#endif /* CONFIG_PM */
+};
+#endif /* CONFIG_PCI */
+
+/***********************************************************************
+** acxpci_e_init_module
+**
+** Module initialization routine, called once at module load time
+*/
+int __init acxpci_e_init_module(void)
+{
+	int res = 0;
+
+	FN_ENTER;
+
+#if (ACX_IO_WIDTH==32)
+	printk("acx: compiled to use 32bit I/O access. "
+	       "I/O timing issues might occur, such as "
+	       "non-working firmware upload. Report them\n");
+#else
+	printk("acx: compiled to use 16bit I/O access only "
+	       "(compatibility mode)\n");
+#endif
+
+#ifdef __LITTLE_ENDIAN
+#define ENDIANNESS_STRING "running on a little-endian CPU\n"
+#else
+#define ENDIANNESS_STRING "running on a BIG-ENDIAN CPU\n"
+#endif
+	log(L_INIT,
+	    "acx: " ENDIANNESS_STRING
+	    "acx: PCI/VLYNQ module " ACX_RELEASE " initialized, "
+	    "waiting for cards to probe...\n");
+
+#ifdef CONFIG_PCI
+	res = pci_register_driver(&acxpci_drv_id);
+#endif
+#ifdef CONFIG_VLYNQ
+	res = vlynq_register_driver(&vlynq_acx);
+#endif
+	FN_EXIT1(res);
+	return res;
+}
+
+
+/***********************************************************************
+** acxpci_e_cleanup_module
+**
+** Called at module unload time. This is our last chance to
+** clean up after ourselves.
+*/
+void __exit acxpci_e_cleanup_module(void)
+{
+	FN_ENTER;
+
+#ifdef CONFIG_VLYNQ
+	vlynq_unregister_driver(&vlynq_acx);
+#endif
+#ifdef CONFIG_PCI
+	pci_unregister_driver(&acxpci_drv_id);
+#endif
+
+	FN_EXIT0;
+}
diff -Nurp linux-2.6.23-sabayon.orig/drivers/net/wireless/acx/README linux-2.6.23-sabayon/drivers/net/wireless/acx/README
--- linux-2.6.23-sabayon.orig/drivers/net/wireless/acx/README	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.23-sabayon/drivers/net/wireless/acx/README	2007-10-10 10:51:23.000000000 +0200
@@ -0,0 +1,158 @@
+/****************  claimer ******************
+** Copyright (C) 2003  ACX100 Open Source Project
+**
+** The contents of this file are subject to the Mozilla Public
+** License Version 1.1 (the "License"); you may not use this file
+** except in compliance with the License. You may obtain a copy of
+** the License at http://www.mozilla.org/MPL/
+**
+** Software distributed under the License is distributed on an "AS
+** IS" basis, WITHOUT WARRANTY OF ANY KIND, either express or
+** implied. See the License for the specific language governing
+** rights and limitations under the License.
+**
+** Alternatively, the contents of this file may be used under the
+** terms of the GNU Public License version 2 (the "GPL"), in which
+** case the provisions of the GPL are applicable instead of the
+** above.  If you wish to allow the use of your version of this file
+** only under the terms of the GPL and not to allow others to use
+** your version of this file under the MPL, indicate your decision
+** by deleting the provisions above and replace them with the notice
+** and other provisions required by the GPL.  If you do not delete
+** the provisions above, a recipient may use your version of this
+** file under either the MPL or the GPL.
+** ------------------------------------------------------------------
+** Inquiries regarding the ACX100 Open Source Project can be
+** made directly to:
+**
+** http://sourceforge.net/forum/forum.php?forum_id=257272
+** 
+** http://acx100.sourceforge.net/wiki
+** ------------------------------------------------------------------
+*/
+
+This tarball is targeted at 2.6 inclusion only.
+Not designed to work or even compile with 2.4.
+dscape wifi stack is mandatory 
+
+dscape Wifi stack isn't yet part of the standard kernel, 
+
+Contact:
+netdev@vger.kernel.org
+acx100-devel@lists.sourceforge.net
+acx100-users@lists.sourceforge.net
+
+Bug reports:
+
+Visit http://www.catb.org/~esr/faqs/smart-questions.html
+
+Please describe your wireless setup, manufacturer and type
+(acx100/acx100usb/acx111?) of your hardware. Which firmware image(s)
+are you using? If problem is reproducible, #define ACX_DEBUG 2
+in acx_config.h and modprobe driver with debug=0xffff.
+Post resulting kernel log (bzipped). It is large but very useful
+for bug hunting. Try older versions of the driver.
+
+Firmware images:
+
+You should not supply firmware_dir= parameter anymore. Driver will try
+to load the following images via hotplug (not from /usr/share/acx
+directory as older driver did, hotplug firmware directory location
+varies for different distros, try /lib/firmware or
+/usr/lib/hotplug/firmware):
+
+PCI driver:
+'tiacxNNNcMM' (NNN=100/111, MM=radio module ID (in uppercase hex)):
+combined firmware for specified chipset and radio.
+Failing that, it will try to load images named 'tiacxNNN'
+(main firmware for specified chipset) and 'tiacxNNNrMM' (corresponding
+radio module). For example, my firmware is in file named 'tiacx111c16'.
+Alternatively, I may remove it and use pair of files 'tiacx111' and
+'tiacx111r16' instead.
+USB driver:
+image is named 'tiacxNNNusbcMM'
+
+Build instructions:
+
+* Create drivers/net/wireless/acx subdirectory inside
+  your kernel tree.
+* BTW, if your kernel has drivers/net/wireless/tiacx directory,
+  you already may have acx driver (some different version).
+  Decide which one do you want.
+* Unpack tarball into drivers/net/wireless/acx directory.
+* Add a line to drivers/net/wireless/Makefile:
+	obj-m += acx/
+* Build your modules as usual (perhaps "make modules modules_install").
+
+This will create acx module.
+
+Remove "acx-obj-y += usb.o" line in Makefile
+and "#define CONFIG_ACX_USB 1" line in acx_config.h
+if you want PCI-only driver. Ditto for USB-only one.
+
+USB snooping:
+
+If you are an USB driver developer and need to see USB traffic,
+http://benoit.papillault.free.fr/usbsnoop/ may be useful.
+Another very good way to snoop the USB frames is under Linux if your
+driver happens to run under ndiswrapper (which is often the case),
+either by savage printk's, or by using the USB snooping facilities from
+Pete Zaitcev.
+
+
+From: Per Bjornsson <perbj@stanford.edu>
+To: ACX100 user mailing list <acx100-users@lists.sourceforge.net>
+Date: Fri, 08 Jul 2005 13:44:26 -0700
+
+Hi,
+
+Just a note for those who, like me, prefer not to bother recompiling
+their whole kernel: It's not at all difficult to compile Denis's
+snapshots out of tree, despite what the readme file says! At least in
+somewhat recent 2.6.x kernels, there's a special syntax for compiling
+modules in a particular directory (as noted in the kernel docs in
+Documentation/kbuild/modules.txt):
+
+      * Unpack Denis's tarball in a new directory (note that the
+        tarballs currently don't contain a root directory, just the
+        files, so you want to do the untarring in an empty directory)
+      * If you're building for the currently running kernel, build the
+        modules with the command
+	make -C /lib/modules/`uname -r`/build M=`pwd`
+      * Install the modules (must be root for this step, so use
+        'su' if that's your preferred method of doing root stuff) with
+	make -C /lib/modules/`uname -r`/build M=`pwd` modules_install
+
+I figured that the snapshots might get more testing if more people know
+that they don't have to muck around with the whole kernel source in
+order to build this. I tested this on Fedora Core 4; sane distributions
+should be using this setup for accessing the kernel build files (if they
+listened to Linus's suggestions anyways). The one trick is that you
+might need a special "kernel development files" package; on Fedora Core,
+the files are included in the regular kernel package for FC2 and 3 but
+you need the 'kernel-devel' package for FC4.
+
+And finally, the kernel won't figure out that the module has been
+installed until you run 'depmod -ae' as root. You can check that
+something useful got picked up with 'modinfo'. (Both of these commands
+are likely installed in /sbin so you might need the full path unless
+you're fully logged in as root.)
+
+The latest snapshot (acx-20050708.tar.bz2) generally seems to work well
+for me, except that it's somewhat noisy and reports a lot of DUPs in the
+system log. However, it appears to associate more consistently with my
+access point that the old versions (when I had those modprobed on boot
+and brought up by the system network scripts, the card would often just
+sit and scan around and never actually associate until I manually
+restarted the connection) - admittedly I've only tried a couple of times
+yet so I don't know just how consistent this is. My hardware is a
+Netgear WG311v2, using the firmware from the latest Netgear Windows
+driver. (Can't check the details right now since I'm not at that
+computer, sorry - it got too late when I was mucking with this and other
+stuff yesterday for me to get a message sent...)
+
+Cheers,
+Per
+--
+Per Bjornsson <perbj@stanford.edu>
+Ph.D. Candidate, Department of Applied Physics, Stanford University
diff -Nurp linux-2.6.23-sabayon.orig/drivers/net/wireless/acx/usb.c linux-2.6.23-sabayon/drivers/net/wireless/acx/usb.c
--- linux-2.6.23-sabayon.orig/drivers/net/wireless/acx/usb.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.23-sabayon/drivers/net/wireless/acx/usb.c	2007-10-10 10:51:23.000000000 +0200
@@ -0,0 +1,1884 @@
+/**** (legal) claimer in README
+** Copyright (C) 2003  ACX100 Open Source Project
+*/
+
+/***********************************************************************
+** USB support for TI ACX100 based devices. Many parts are taken from
+** the PCI driver.
+**
+** Authors:
+**  Martin Wawro <martin.wawro AT uni-dortmund.de>
+**  Andreas Mohr <andi AT lisas.de>
+**
+** LOCKING
+** callback functions called by USB core are running in interrupt context
+** and thus have names with _i_.
+*/
+#define ACX_MAC80211_USB 1
+
+#include <linux/version.h>
+#if LINUX_VERSION_CODE <= KERNEL_VERSION(2, 6, 18)
+#include <linux/config.h>
+#endif
+#include <linux/types.h>
+#include <linux/module.h>
+#include <linux/moduleparam.h>
+#include <linux/kernel.h>
+#include <linux/usb.h>
+#include <linux/netdevice.h>
+#include <linux/rtnetlink.h>
+#include <linux/etherdevice.h>
+#include <linux/wireless.h>
+#include <net/iw_handler.h>
+#include <linux/vmalloc.h>
+#include <linux/ethtool.h>
+#include <linux/workqueue.h>
+
+#include "acx.h"
+
+
+/***********************************************************************
+*/
+/* number of endpoints of an interface */
+#define NUM_EP(intf) (intf)->altsetting[0].desc.bNumEndpoints
+#define EP(intf, nr) (intf)->altsetting[0].endpoint[(nr)].desc
+#define GET_DEV(udev) usb_get_dev((udev))
+#define PUT_DEV(udev) usb_put_dev((udev))
+
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,14)
+/* removed in 2.6.14. We will use fake value for now */
+#define URB_ASYNC_UNLINK 0
+#endif
+
+
+/***********************************************************************
+*/
+/* ACX100 (TNETW1100) USB device: D-Link DWL-120+ */
+#define ACX100_VENDOR_ID 0x2001
+#define ACX100_PRODUCT_ID_UNBOOTED 0x3B01
+#define ACX100_PRODUCT_ID_BOOTED 0x3B00
+
+/* TNETW1450 USB devices */
+#define VENDOR_ID_DLINK		0x07b8	/* D-Link Corp. */
+#define PRODUCT_ID_WUG2400	0xb21a	/* AboCom WUG2400 or SafeCom SWLUT-54125 */
+#define VENDOR_ID_AVM_GMBH	0x057c
+#define PRODUCT_ID_AVM_WLAN_USB	0x5601
+#define PRODUCT_ID_AVM_WLAN_USB_si	0x6201  /* "self install" named Version: 
+						 * driver kills kernel on inbound scans from fritz box ??  */
+#define VENDOR_ID_ZCOM		0x0cde
+#define PRODUCT_ID_ZCOM_XG750	0x0017	/* not tested yet */
+#define VENDOR_ID_TI		0x0451
+#define PRODUCT_ID_TI_UNKNOWN	0x60c5	/* not tested yet */
+
+#define ACX_USB_CTRL_TIMEOUT	5500	/* steps in ms */
+
+/* Buffer size for fw upload, same for both ACX100 USB and TNETW1450 */
+#define USB_RWMEM_MAXLEN	2048
+
+/* The number of bulk URBs to use */
+#define ACX_TX_URB_CNT		8
+#define ACX_RX_URB_CNT		2
+
+/* Should be sent to the bulkout endpoint */
+#define ACX_USB_REQ_UPLOAD_FW	0x10
+#define ACX_USB_REQ_ACK_CS	0x11
+#define ACX_USB_REQ_CMD		0x12
+
+/***********************************************************************
+** Prototypes
+*/
+static int acxusb_e_probe(struct usb_interface *, const struct usb_device_id *);
+static void acxusb_e_disconnect(struct usb_interface *);
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 19)
+static void acxusb_i_complete_tx(struct urb *);
+static void acxusb_i_complete_rx(struct urb *);
+#else
+static void acxusb_i_complete_tx(struct urb *, struct pt_regs *);
+static void acxusb_i_complete_rx(struct urb *, struct pt_regs *);
+#endif
+static int acxusb_e_open(struct ieee80211_hw *);
+static int acxusb_e_close(struct ieee80211_hw *);
+//static void acxusb_i_set_rx_mode(struct net_device *);
+static int acxusb_boot(struct usb_device *, int is_tnetw1450, int *radio_type);
+
+static void acxusb_l_poll_rx(acx_device_t * adev, usb_rx_t * rx);
+
+/*static void acxusb_i_tx_timeout(struct net_device *);*/
+
+/* static void dump_device(struct usb_device *); */
+/* static void dump_device_descriptor(struct usb_device_descriptor *); */
+/* static void dump_config_descriptor(struct usb_config_descriptor *); */
+
+/***********************************************************************
+** Module Data
+*/
+#define TXBUFSIZE sizeof(usb_txbuffer_t)
+/*
+ * Now, this is just plain lying, but the device insists in giving us
+ * huge packets. We supply extra space after rxbuffer. Need to understand
+ * it better...
+ */
+#define RXBUFSIZE (sizeof(rxbuffer_t) + \
+		   (sizeof(usb_rx_t) - sizeof(struct usb_rx_plain)))
+
+static const struct usb_device_id acxusb_ids[] = {
+	{USB_DEVICE(ACX100_VENDOR_ID, ACX100_PRODUCT_ID_BOOTED)},
+	{USB_DEVICE(ACX100_VENDOR_ID, ACX100_PRODUCT_ID_UNBOOTED)},
+	{USB_DEVICE(VENDOR_ID_DLINK, PRODUCT_ID_WUG2400)},
+	{USB_DEVICE(VENDOR_ID_AVM_GMBH, PRODUCT_ID_AVM_WLAN_USB)},
+	{USB_DEVICE(VENDOR_ID_AVM_GMBH, PRODUCT_ID_AVM_WLAN_USB_si)},
+	{USB_DEVICE(VENDOR_ID_ZCOM, PRODUCT_ID_ZCOM_XG750)},
+	{USB_DEVICE(VENDOR_ID_TI, PRODUCT_ID_TI_UNKNOWN)},
+	{}
+};
+
+MODULE_DEVICE_TABLE(usb, acxusb_ids);
+
+/* USB driver data structure as required by the kernel's USB core */
+static struct usb_driver
+ acxusb_driver = {
+	.name = "acx_usb",
+	.probe = acxusb_e_probe,
+	.disconnect = acxusb_e_disconnect,
+	.id_table = acxusb_ids
+};
+
+void acxusb_put_devname(acx_device_t *adev, struct ethtool_drvinfo *info)
+{
+
+        usb_make_path(adev->usbdev, info->bus_info, sizeof info->bus_info);
+}
+/***********************************************************************
+** USB helper
+**
+** ldd3 ch13 says:
+** When the function is usb_kill_urb, the urb lifecycle is stopped. This
+** function is usually used when the device is disconnected from the system,
+** in the disconnect callback. For some drivers, the usb_unlink_urb function
+** should be used to tell the USB core to stop an urb. This function does not
+** wait for the urb to be fully stopped before returning to the caller.
+** This is useful for stoppingthe urb while in an interrupt handler or when
+** a spinlock is held, as waiting for a urb to fully stop requires the ability
+** for the USB core to put the calling process to sleep. This function requires
+** that the URB_ASYNC_UNLINK flag value be set in the urb that is being asked
+** to be stopped in order to work properly.
+**
+** (URB_ASYNC_UNLINK is obsolete, usb_unlink_urb will always be
+** asynchronous while usb_kill_urb is synchronous and should be called
+** directly (drivers/usb/core/urb.c))
+**
+** In light of this, timeout is just for paranoid reasons...
+*
+** Actually, it's useful for debugging. If we reach timeout, we're doing
+** something wrong with the urbs.
+*/
+static void acxusb_unlink_urb(struct urb *urb)
+{
+	if (!urb)
+		return;
+
+	if (urb->status == -EINPROGRESS) {
+		int timeout = 10;
+
+		usb_unlink_urb(urb);
+		while (--timeout && urb->status == -EINPROGRESS) {
+			mdelay(1);
+		}
+		if (!timeout) {
+			printk(KERN_ERR "acx_usb: urb unlink timeout!\n");
+		}
+	}
+}
+
+
+/***********************************************************************
+** EEPROM and PHY read/write helpers
+*/
+/***********************************************************************
+** acxusb_s_read_phy_reg
+*/
+int acxusb_s_read_phy_reg(acx_device_t * adev, u32 reg, u8 * charbuf)
+{
+	/* mem_read_write_t mem; */
+
+	FN_ENTER;
+
+	printk("%s doesn't seem to work yet, disabled.\n", __func__);
+
+	/*
+	   mem.addr = cpu_to_le16(reg);
+	   mem.type = cpu_to_le16(0x82);
+	   mem.len = cpu_to_le32(4);
+	   acx_s_issue_cmd(adev, ACX1xx_CMD_MEM_READ, &mem, sizeof(mem));
+	   *charbuf = mem.data;
+	   log(L_DEBUG, "read radio PHY[0x%04X]=0x%02X\n", reg, *charbuf);
+	 */
+
+	FN_EXIT1(OK);
+	return OK;
+}
+
+
+/***********************************************************************
+*/
+int acxusb_s_write_phy_reg(acx_device_t * adev, u32 reg, u8 value)
+{
+	mem_read_write_t mem;
+
+	FN_ENTER;
+
+	mem.addr = cpu_to_le16(reg);
+	mem.type = cpu_to_le16(0x82);
+	mem.len = cpu_to_le32(4);
+	mem.data = value;
+	acx_s_issue_cmd(adev, ACX1xx_CMD_MEM_WRITE, &mem, sizeof(mem));
+	log(L_DEBUG, "write radio PHY[0x%04X]=0x%02X\n", reg, value);
+
+	FN_EXIT1(OK);
+	return OK;
+}
+
+
+/***********************************************************************
+** acxusb_s_issue_cmd_timeo
+** Excecutes a command in the command mailbox
+**
+** buffer = a pointer to the data.
+** The data must not include 4 byte command header
+*/
+
+/* TODO: ideally we shall always know how much we need
+** and this shall be 0 */
+#define BOGUS_SAFETY_PADDING 0x40
+
+#undef FUNC
+#define FUNC "issue_cmd"
+
+#if !ACX_DEBUG
+int
+acxusb_s_issue_cmd_timeo(acx_device_t * adev,
+			 unsigned cmd,
+			 void *buffer, unsigned buflen, unsigned timeout)
+{
+#else
+int
+acxusb_s_issue_cmd_timeo_debug(acx_device_t * adev,
+			       unsigned cmd,
+			       void *buffer,
+			       unsigned buflen,
+			       unsigned timeout, const char *cmdstr)
+{
+#endif
+	/* USB ignores timeout param */
+
+	struct usb_device *usbdev;
+	struct {
+		u16 cmd;
+		u16 status;
+		u8 data[1];
+	} ACX_PACKED *loc;
+	const char *devname;
+	int acklen, blocklen, inpipe, outpipe;
+	int cmd_status;
+	int result;
+
+	FN_ENTER;
+
+	devname = wiphy_name(adev->ieee->wiphy);
+	/* no "wlan%%d: ..." please */
+	if (!devname || !devname[0] || devname[4] == '%')
+		devname = "acx";
+
+	log(L_CTL, FUNC "(cmd:%s,buflen:%u,type:0x%04X)\n",
+	    cmdstr, buflen,
+	    buffer ? le16_to_cpu(((acx_ie_generic_t *) buffer)->type) : -1);
+
+	loc = kmalloc(buflen + 4 + BOGUS_SAFETY_PADDING, GFP_KERNEL);
+	if (!loc) {
+		printk("%s: " FUNC "(): no memory for data buffer\n", devname);
+		goto bad;
+	}
+
+	/* get context from acx_device */
+	usbdev = adev->usbdev;
+
+	/* check which kind of command was issued */
+	loc->cmd = cpu_to_le16(cmd);
+	loc->status = 0;
+
+/* NB: buflen == frmlen + 4
+**
+** Interrogate: write 8 bytes: (cmd,status,rid,frmlen), then
+**		read (cmd,status,rid,frmlen,data[frmlen]) back
+**
+** Configure: write (cmd,status,rid,frmlen,data[frmlen])
+**
+** Possibly bogus special handling of ACX1xx_IE_SCAN_STATUS removed
+*/
+
+	/* now write the parameters of the command if needed */
+	acklen = buflen + 4 + BOGUS_SAFETY_PADDING;
+	blocklen = buflen;
+	if (buffer && buflen) {
+		/* if it's an INTERROGATE command, just pass the length
+		 * of parameters to read, as data */
+		if (cmd == ACX1xx_CMD_INTERROGATE) {
+			blocklen = 4;
+			acklen = buflen + 4;
+		}
+		memcpy(loc->data, buffer, blocklen);
+	}
+	blocklen += 4;		/* account for cmd,status */
+
+	/* obtain the I/O pipes */
+	outpipe = usb_sndctrlpipe(usbdev, 0);
+	inpipe = usb_rcvctrlpipe(usbdev, 0);
+	log(L_CTL, "ctrl inpipe=0x%X outpipe=0x%X\n", inpipe, outpipe);
+	log(L_CTL, "sending USB control msg (out) (blocklen=%d)\n", blocklen);
+	if (acx_debug & L_DATA)
+		acx_dump_bytes(loc, blocklen);
+
+	result = usb_control_msg(usbdev, outpipe, ACX_USB_REQ_CMD,	/* request */
+				 USB_TYPE_VENDOR | USB_DIR_OUT,	/* requesttype */
+				 0,	/* value */
+				 0,	/* index */
+				 loc,	/* dataptr */
+				 blocklen,	/* size */
+				 ACX_USB_CTRL_TIMEOUT	/* timeout in ms */
+	    );
+
+	if (result == -ENODEV) {
+		log(L_CTL, "no device present (unplug?)\n");
+		goto good;
+	}
+
+	log(L_CTL, "wrote %d bytes\n", result);
+	if (result < 0) {
+		goto bad;
+	}
+
+	/* check for device acknowledge */
+	log(L_CTL, "sending USB control msg (in) (acklen=%d)\n", acklen);
+	loc->status = 0;	/* delete old status flag -> set to IDLE */
+	/* shall we zero out the rest? */
+	result = usb_control_msg(usbdev, inpipe, ACX_USB_REQ_CMD,	/* request */
+				 USB_TYPE_VENDOR | USB_DIR_IN,	/* requesttype */
+				 0,	/* value */
+				 0,	/* index */
+				 loc,	/* dataptr */
+				 acklen,	/* size */
+				 ACX_USB_CTRL_TIMEOUT	/* timeout in ms */
+	    );
+	if (result < 0) {
+		printk("%s: " FUNC "(): USB read error %d\n", devname, result);
+		goto bad;
+	}
+	if (acx_debug & L_CTL) {
+		printk("read %d bytes: ", result);
+		acx_dump_bytes(loc, result);
+	}
+
+/*
+   check for result==buflen+4? Was seen:
+
+interrogate(type:ACX100_IE_DOT11_ED_THRESHOLD,len:4)
+issue_cmd(cmd:ACX1xx_CMD_INTERROGATE,buflen:8,type:4111)
+ctrl inpipe=0x80000280 outpipe=0x80000200
+sending USB control msg (out) (blocklen=8)
+01 00 00 00 0F 10 04 00
+wrote 8 bytes
+sending USB control msg (in) (acklen=12) sizeof(loc->data
+read 4 bytes <==== MUST BE 12!!
+*/
+
+	cmd_status = le16_to_cpu(loc->status);
+	if (cmd_status != 1) {
+		printk("%s: " FUNC "(): cmd_status is not SUCCESS: %d (%s)\n",
+		       devname, cmd_status, acx_cmd_status_str(cmd_status));
+		/* TODO: goto bad; ? */
+	}
+	if ((cmd == ACX1xx_CMD_INTERROGATE) && buffer && buflen) {
+		memcpy(buffer, loc->data, buflen);
+		log(L_CTL, "response frame: cmd=0x%04X status=%d\n",
+		    le16_to_cpu(loc->cmd), cmd_status);
+	}
+      good:
+	kfree(loc);
+	FN_EXIT1(OK);
+	return OK;
+      bad:
+	/* Give enough info so that callers can avoid
+	 ** printing their own diagnostic messages */
+#if ACX_DEBUG
+	printk("%s: " FUNC "(cmd:%s) FAILED\n", devname, cmdstr);
+#else
+	printk("%s: " FUNC "(cmd:0x%04X) FAILED\n", devname, cmd);
+#endif
+	dump_stack();
+	kfree(loc);
+	FN_EXIT1(NOT_OK);
+	return NOT_OK;
+}
+
+
+/***********************************************************************
+** acxusb_boot()
+** Inputs:
+**    usbdev -> Pointer to kernel's usb_device structure
+**
+** Returns:
+**  (int) Errorcode or 0 on success
+**
+** This function triggers the loading of the firmware image from harddisk
+** and then uploads the firmware to the USB device. After uploading the
+** firmware and transmitting the checksum, the device resets and appears
+** as a new device on the USB bus (the device we can finally deal with)
+*/
+static inline int
+acxusb_fw_needs_padding(firmware_image_t *fw_image, unsigned int usb_maxlen)
+{
+	unsigned int num_xfers = ((fw_image->size - 1) / usb_maxlen) + 1;
+
+	return ((num_xfers % 2) == 0);
+}
+
+static int
+acxusb_boot(struct usb_device *usbdev, int is_tnetw1450, int *radio_type)
+{
+	char filename[sizeof("tiacx1NNusbcRR")];
+
+	firmware_image_t *fw_image = NULL;
+	char *usbbuf;
+	unsigned int offset;
+	unsigned int blk_len, inpipe, outpipe;
+	u32 num_processed;
+	u32 img_checksum, sum;
+	u32 file_size;
+	int result = -EIO;
+	int i;
+
+	FN_ENTER;
+
+	/* dump_device(usbdev); */
+
+	usbbuf = kmalloc(USB_RWMEM_MAXLEN, GFP_KERNEL);
+	if (!usbbuf) {
+		printk(KERN_ERR
+		       "acx: no memory for USB transfer buffer (%d bytes)\n",
+		       USB_RWMEM_MAXLEN);
+		result = -ENOMEM;
+		goto end;
+	}
+	if (is_tnetw1450) {
+		/* Obtain the I/O pipes */
+		outpipe = usb_sndbulkpipe(usbdev, 1);
+		inpipe = usb_rcvbulkpipe(usbdev, 2);
+
+		printk(KERN_DEBUG "wait for device ready\n");
+		for (i = 0; i <= 2; i++) {
+			result = usb_bulk_msg(usbdev, inpipe,
+					      usbbuf,
+					      USB_RWMEM_MAXLEN,
+					      &num_processed, 2000);
+
+			if ((*(u32 *) & usbbuf[4] == 0x40000001)
+			    && (*(u16 *) & usbbuf[2] == 0x1)
+			    && ((*(u16 *) usbbuf & 0x3fff) == 0)
+			    && ((*(u16 *) usbbuf & 0xc000) == 0xc000))
+				break;
+			msleep(10);
+		}
+		if (i == 2)
+			goto fw_end;
+
+		*radio_type = usbbuf[8];
+	} else {
+		/* Obtain the I/O pipes */
+		outpipe = usb_sndctrlpipe(usbdev, 0);
+		inpipe = usb_rcvctrlpipe(usbdev, 0);
+
+		/* FIXME: shouldn't be hardcoded */
+		*radio_type = RADIO_MAXIM_0D;
+	}
+
+	snprintf(filename, sizeof(filename), "tiacx1%02dusbc%02X",
+		 is_tnetw1450 * 11, *radio_type);
+
+	fw_image = acx_s_read_fw(&usbdev->dev, filename, &file_size);
+	if (!fw_image) {
+		result = -EIO;
+		goto end;
+	}
+	log(L_INIT, "firmware size: %d bytes\n", file_size);
+
+	img_checksum = le32_to_cpu(fw_image->chksum);
+
+	if (is_tnetw1450) {
+		u8 cmdbuf[20];
+		const u8 *p;
+		u8 need_padding;
+		u32 tmplen, val;
+
+		memset(cmdbuf, 0, 16);
+
+		need_padding =
+		    acxusb_fw_needs_padding(fw_image, USB_RWMEM_MAXLEN);
+		tmplen = need_padding ? file_size - 4 : file_size - 8;
+		*(u16 *) & cmdbuf[0] = 0xc000;
+		*(u16 *) & cmdbuf[2] = 0x000b;
+		*(u32 *) & cmdbuf[4] = tmplen;
+		*(u32 *) & cmdbuf[8] = file_size - 8;
+		*(u32 *) & cmdbuf[12] = img_checksum;
+
+		result =
+		    usb_bulk_msg(usbdev, outpipe, cmdbuf, 16, &num_processed,
+				 HZ);
+		if (result < 0)
+			goto fw_end;
+
+		p = (const u8 *)&fw_image->size;
+
+		/* first calculate checksum for image size part */
+		sum = p[0] + p[1] + p[2] + p[3];
+		p += 4;
+
+		/* now continue checksum for firmware data part */
+		tmplen = le32_to_cpu(fw_image->size);
+		for (i = 0; i < tmplen /* image size */ ; i++) {
+			sum += *p++;
+		}
+
+		if (sum != le32_to_cpu(fw_image->chksum)) {
+			printk("acx: FATAL: firmware upload: "
+			       "checksums don't match! "
+			       "(0x%08x vs. 0x%08x)\n", sum, fw_image->chksum);
+			goto fw_end;
+		}
+
+		offset = 8;
+		while (offset < file_size) {
+			blk_len = file_size - offset;
+			if (blk_len > USB_RWMEM_MAXLEN) {
+				blk_len = USB_RWMEM_MAXLEN;
+			}
+
+			log(L_INIT,
+			    "uploading firmware (%d bytes, offset=%d)\n",
+			    blk_len, offset);
+			memcpy(usbbuf, ((u8 *) fw_image) + offset, blk_len);
+
+			p = usbbuf;
+			for (i = 0; i < blk_len; i += 4) {
+				*(u32 *) p = be32_to_cpu(*(u32 *) p);
+				p += 4;
+			}
+
+			result =
+			    usb_bulk_msg(usbdev, outpipe, usbbuf, blk_len,
+					 &num_processed, HZ);
+			if ((result < 0) || (num_processed != blk_len))
+				goto fw_end;
+			offset += blk_len;
+		}
+		if (need_padding) {
+			printk(KERN_DEBUG "send padding\n");
+			memset(usbbuf, 0, 4);
+			result =
+			    usb_bulk_msg(usbdev, outpipe, usbbuf, 4,
+					 &num_processed, HZ);
+			if ((result < 0) || (num_processed != 4))
+				goto fw_end;
+		}
+		printk(KERN_DEBUG "read firmware upload result\n");
+		memset(cmdbuf, 0, 20);	/* additional memset */
+		result =
+		    usb_bulk_msg(usbdev, inpipe, cmdbuf, 20, &num_processed,
+				 2000);
+		if (result < 0)
+			goto fw_end;
+		if (*(u32 *) & cmdbuf[4] == 0x40000003)
+			goto fw_end;
+		if (*(u32 *) & cmdbuf[4])
+			goto fw_end;
+		if (*(u16 *) & cmdbuf[16] != 1)
+			goto fw_end;
+
+		val = *(u32 *) & cmdbuf[0];
+		if ((val & 0x3fff)
+		    || ((val & 0xc000) != 0xc000))
+			goto fw_end;
+
+		val = *(u32 *) & cmdbuf[8];
+		if (val & 2) {
+			result =
+			    usb_bulk_msg(usbdev, inpipe, cmdbuf, 20,
+					 &num_processed, 2000);
+			if (result < 0)
+				goto fw_end;
+			val = *(u32 *) & cmdbuf[8];
+		}
+		/* yup, no "else" here! */
+		if (val & 1) {
+			memset(usbbuf, 0, 4);
+			result =
+			    usb_bulk_msg(usbdev, outpipe, usbbuf, 4,
+					 &num_processed, HZ);
+			if ((result < 0) || (!num_processed))
+				goto fw_end;
+		}
+
+		printk("TNETW1450 firmware upload successful!\n");
+		result = 0;
+		goto end;
+	      fw_end:
+		result = -EIO;
+		goto end;
+	} else {
+		/* ACX100 USB */
+
+		/* now upload the firmware, slice the data into blocks */
+		offset = 8;
+		while (offset < file_size) {
+			blk_len = file_size - offset;
+			if (blk_len > USB_RWMEM_MAXLEN) {
+				blk_len = USB_RWMEM_MAXLEN;
+			}
+			log(L_INIT,
+			    "uploading firmware (%d bytes, offset=%d)\n",
+			    blk_len, offset);
+			memcpy(usbbuf, ((u8 *) fw_image) + offset, blk_len);
+			result = usb_control_msg(usbdev, outpipe, ACX_USB_REQ_UPLOAD_FW, USB_TYPE_VENDOR | USB_DIR_OUT, (file_size - 8) & 0xffff,	/* value */
+						 (file_size - 8) >> 16,	/* index */
+						 usbbuf,	/* dataptr */
+						 blk_len,	/* size */
+						 3000	/* timeout in ms */
+			    );
+			offset += blk_len;
+			if (result < 0) {
+				printk(KERN_ERR "acx: error %d during upload "
+				       "of firmware, aborting\n", result);
+				goto end;
+			}
+		}
+
+		/* finally, send the checksum and reboot the device */
+		/* does this trigger the reboot? */
+		result = usb_control_msg(usbdev, outpipe, ACX_USB_REQ_UPLOAD_FW, USB_TYPE_VENDOR | USB_DIR_OUT, img_checksum & 0xffff,	/* value */
+					 img_checksum >> 16,	/* index */
+					 NULL,	/* dataptr */
+					 0,	/* size */
+					 3000	/* timeout in ms */
+		    );
+		if (result < 0) {
+			printk(KERN_ERR "acx: error %d during tx of checksum, "
+			       "aborting\n", result);
+			goto end;
+		}
+		result = usb_control_msg(usbdev, inpipe, ACX_USB_REQ_ACK_CS, USB_TYPE_VENDOR | USB_DIR_IN, img_checksum & 0xffff,	/* value */
+					 img_checksum >> 16,	/* index */
+					 usbbuf,	/* dataptr */
+					 8,	/* size */
+					 3000	/* timeout in ms */
+		    );
+		if (result < 0) {
+			printk(KERN_ERR "acx: error %d during ACK of checksum, "
+			       "aborting\n", result);
+			goto end;
+		}
+		if (*usbbuf != 0x10) {
+			printk(KERN_ERR "acx: invalid checksum?\n");
+			result = -EINVAL;
+			goto end;
+		}
+		result = 0;
+	}
+
+      end:
+	vfree(fw_image);
+	kfree(usbbuf);
+
+	FN_EXIT1(result);
+	return result;
+}
+
+
+/* FIXME: maybe merge it with usual eeprom reading, into common code? */
+static void acxusb_s_read_eeprom_version(acx_device_t * adev)
+{
+	u8 eeprom_ver[0x8];
+
+	memset(eeprom_ver, 0, sizeof(eeprom_ver));
+	acx_s_interrogate(adev, &eeprom_ver, ACX1FF_IE_EEPROM_VER);
+
+	/* FIXME: which one of those values to take? */
+	adev->eeprom_version = eeprom_ver[5];
+}
+
+
+/*
+ * temporary helper function to at least fill important cfgopt members with
+ * useful replacement values until we figure out how one manages to fetch
+ * the configoption struct in the USB device case...
+ */
+static int acxusb_s_fill_configoption(acx_device_t * adev)
+{
+	adev->cfgopt_probe_delay = 200;
+	adev->cfgopt_dot11CCAModes = 4;
+	adev->cfgopt_dot11Diversity = 1;
+	adev->cfgopt_dot11ShortPreambleOption = 1;
+	adev->cfgopt_dot11PBCCOption = 1;
+	adev->cfgopt_dot11ChannelAgility = 0;
+	adev->cfgopt_dot11PhyType = 5;
+	adev->cfgopt_dot11TempType = 1;
+	return OK;
+}
+
+static const struct ieee80211_ops acxusb_hw_ops = {
+        .tx = acx_i_start_xmit,
+        .conf_tx = acx_net_conf_tx,
+        .add_interface = acx_add_interface,
+        .remove_interface = acx_remove_interface,
+        .open = acxusb_e_open,
+        .stop = acxusb_e_close,
+        .reset = acx_net_reset,
+        .config = acx_net_config,
+        .config_interface = acx_config_interface,
+        .set_multicast_list = acx_i_set_multicast_list,
+        .set_key = acx_net_set_key,         
+        .get_stats = acx_e_get_stats,
+        .get_tx_stats = acx_net_get_tx_stats,
+};
+
+/***********************************************************************
+** acxusb_e_probe()
+**
+** This function is invoked by the kernel's USB core whenever a new device is
+** attached to the system or the module is loaded. It is presented a usb_device
+** structure from which information regarding the device is obtained and evaluated.
+** In case this driver is able to handle one of the offered devices, it returns
+** a non-null pointer to a driver context and thereby claims the device.
+*/
+
+
+static int
+acxusb_e_probe(struct usb_interface *intf, const struct usb_device_id *devID)
+{
+	struct usb_device *usbdev = interface_to_usbdev(intf);
+	acx_device_t *adev = NULL;
+	struct usb_config_descriptor *config;
+	struct usb_endpoint_descriptor *epdesc;
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 11)
+	struct usb_host_endpoint *ep;
+#endif
+	struct usb_interface_descriptor *ifdesc;
+	const char *msg;
+	int numconfigs, numfaces, numep;
+	int result = OK;
+	int i;
+	int radio_type;
+	/* this one needs to be more precise in case there appears
+	 * a TNETW1450 from the same vendor */
+	int is_tnetw1450 = (usbdev->descriptor.idVendor != ACX100_VENDOR_ID);
+	struct ieee80211_hw *ieee;
+
+	FN_ENTER;
+
+	if (is_tnetw1450) {
+		/* Boot the device (i.e. upload the firmware) */
+		acxusb_boot(usbdev, is_tnetw1450, &radio_type);
+
+		/* TNETW1450-based cards will continue right away with
+		 * the same USB ID after booting */
+	} else {
+		/* First check if this is the "unbooted" hardware */
+		if (usbdev->descriptor.idProduct == ACX100_PRODUCT_ID_UNBOOTED) {
+
+			/* Boot the device (i.e. upload the firmware) */
+			acxusb_boot(usbdev, is_tnetw1450, &radio_type);
+
+			/* DWL-120+ will first boot the firmware,
+			 * then later have a *separate* probe() run
+			 * since its USB ID will have changed after
+			 * firmware boot!
+			 * Since the first probe() run has no
+			 * other purpose than booting the firmware,
+			 * simply return immediately.
+			 */
+			log(L_INIT,
+			    "finished booting, returning from probe()\n");
+			result = OK;	/* success */
+			goto end;
+		} else {
+			if (usbdev->descriptor.idProduct != ACX100_PRODUCT_ID_BOOTED)
+				/* device not unbooted, but invalid USB ID!? */
+				goto end_nodev;
+		}
+	}
+
+/* Ok, so it's our device and it has already booted */
+
+	/* Allocate memory for a network device */
+
+	ieee = ieee80211_alloc_hw(sizeof(*adev), &acxusb_hw_ops);
+	if (!ieee) {
+		msg = "acx: no memory for ieee80211_dev\n";
+		goto end_nomem;
+	}
+
+
+        ieee->flags &=   ~IEEE80211_HW_RX_INCLUDES_FCS &                
+                         ~IEEE80211_HW_MONITOR_DURING_OPER &
+                         ~IEEE80211_HW_WEP_INCLUDE_IV;
+        ieee->queues = 1;
+
+	/* Register the callbacks for the network device functions */
+
+
+	/* Setup private driver context */
+
+	adev = ieee2adev(ieee);
+	adev->ieee = ieee;
+	
+	adev->dev_type = DEVTYPE_USB;
+	adev->radio_type = radio_type;
+	if (is_tnetw1450) {
+		/* well, actually it's a TNETW1450, but since it
+		 * seems to be sufficiently similar to TNETW1130,
+		 * I don't want to change large amounts of code now */
+		adev->chip_type = CHIPTYPE_ACX111;
+	} else {
+		adev->chip_type = CHIPTYPE_ACX100;
+	}
+
+	adev->usbdev = usbdev;
+	spin_lock_init(&adev->lock);	/* initial state: unlocked */
+	mutex_init(&adev->mutex);
+
+	/* Check that this is really the hardware we know about.
+	 ** If not sure, at least notify the user that he
+	 ** may be in trouble...
+	 */
+	numconfigs = (int)usbdev->descriptor.bNumConfigurations;
+	if (numconfigs != 1)
+		printk("acx: number of configurations is %d, "
+		       "this driver only knows how to handle 1, "
+		       "be prepared for surprises\n", numconfigs);
+
+	config = &usbdev->config->desc;
+	numfaces = config->bNumInterfaces;
+	if (numfaces != 1)
+		printk("acx: number of interfaces is %d, "
+		       "this driver only knows how to handle 1, "
+		       "be prepared for surprises\n", numfaces);
+
+	ifdesc = &intf->altsetting->desc;
+	numep = ifdesc->bNumEndpoints;
+	log(L_DEBUG, "# of endpoints: %d\n", numep);
+
+	if (is_tnetw1450) {
+		adev->bulkoutep = 1;
+		adev->bulkinep = 2;
+	} else {
+		/* obtain information about the endpoint
+		 ** addresses, begin with some default values
+		 */
+		adev->bulkoutep = 1;
+		adev->bulkinep = 1;
+		for (i = 0; i < numep; i++) {
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 11)
+			ep = usbdev->ep_in[i];
+			if (!ep)
+				continue;
+			epdesc = &ep->desc;
+#else
+			epdesc = usb_epnum_to_ep_desc(usbdev, i);
+			if (!epdesc)
+				continue;
+#endif
+			if (epdesc->bmAttributes & USB_ENDPOINT_XFER_BULK) {
+				if (epdesc->bEndpointAddress & 0x80)
+					adev->bulkinep =
+					    epdesc->bEndpointAddress & 0xF;
+				else
+					adev->bulkoutep =
+					    epdesc->bEndpointAddress & 0xF;
+			}
+		}
+	}
+	log(L_DEBUG, "bulkout ep: 0x%X\n", adev->bulkoutep);
+	log(L_DEBUG, "bulkin ep: 0x%X\n", adev->bulkinep);
+
+	/* already done by memset: adev->rxtruncsize = 0; */
+	log(L_DEBUG, "TXBUFSIZE=%d RXBUFSIZE=%d\n",
+	    (int)TXBUFSIZE, (int)RXBUFSIZE);
+
+	/* Allocate the RX/TX containers. */
+	adev->usb_tx = kmalloc(sizeof(usb_tx_t) * ACX_TX_URB_CNT, GFP_KERNEL);
+	if (!adev->usb_tx) {
+		msg = "acx: no memory for tx container";
+		goto end_nomem;
+	}
+	adev->usb_rx = kmalloc(sizeof(usb_rx_t) * ACX_RX_URB_CNT, GFP_KERNEL);
+	if (!adev->usb_rx) {
+		msg = "acx: no memory for rx container";
+		goto end_nomem;
+	}
+
+	/* Setup URBs for bulk-in/out messages */
+	for (i = 0; i < ACX_RX_URB_CNT; i++) {
+		adev->usb_rx[i].urb = usb_alloc_urb(0, GFP_KERNEL);
+		if (!adev->usb_rx[i].urb) {
+			msg = "acx: no memory for input URB\n";
+			goto end_nomem;
+		}
+		adev->usb_rx[i].urb->status = 0;
+		adev->usb_rx[i].adev = adev;
+		adev->usb_rx[i].busy = 0;
+	}
+
+	for (i = 0; i < ACX_TX_URB_CNT; i++) {
+		adev->usb_tx[i].urb = usb_alloc_urb(0, GFP_KERNEL);
+		if (!adev->usb_tx[i].urb) {
+			msg = "acx: no memory for output URB\n";
+			goto end_nomem;
+		}
+		adev->usb_tx[i].urb->status = 0;
+		adev->usb_tx[i].adev = adev;
+		adev->usb_tx[i].busy = 0;
+	}
+	adev->tx_free = ACX_TX_URB_CNT;
+
+	usb_set_intfdata(intf, adev);
+	SET_IEEE80211_DEV(ieee, &intf->dev);
+
+	/* TODO: move all of fw cmds to open()? But then we won't know our MAC addr
+	   until ifup (it's available via reading ACX1xx_IE_DOT11_STATION_ID)... */
+
+	/* put acx out of sleep mode and initialize it */
+	acx_s_issue_cmd(adev, ACX1xx_CMD_WAKE, NULL, 0);
+
+	result = acx_s_init_mac(adev);
+	if (result)
+		goto end;
+
+	/* TODO: see similar code in pci.c */
+	acxusb_s_read_eeprom_version(adev);
+	acxusb_s_fill_configoption(adev);
+	acx_s_set_defaults(adev);
+	acx_s_get_firmware_version(adev);
+	acx_display_hardware_details(adev);
+
+/*	MAC_COPY(ndev->dev_addr, adev->dev_addr); */
+
+	/* Register the network device */
+	log(L_INIT, "registering network device\n");
+	result = ieee80211_register_hw(adev->ieee);
+	if (result) {
+		msg = "acx: failed to register USB network device "
+		    "(error %d)\n";
+		goto end_nomem;
+	}
+
+	acx_proc_register_entries(ieee);
+
+
+	printk("acx: USB module " ACX_RELEASE " loaded successfully\n");
+
+	acx_init_task_scheduler(adev);
+
+#if CMD_DISCOVERY
+	great_inquisitor(adev);
+#endif
+
+	/* Everything went OK, we are happy now */
+	result = OK;
+	goto end;
+
+      end_nomem:
+	printk(msg, result);
+
+	if (ieee) {
+		if (adev->usb_rx) {
+			for (i = 0; i < ACX_RX_URB_CNT; i++)
+				usb_free_urb(adev->usb_rx[i].urb);
+			kfree(adev->usb_rx);
+		}
+		if (adev->usb_tx) {
+			for (i = 0; i < ACX_TX_URB_CNT; i++)
+				usb_free_urb(adev->usb_tx[i].urb);
+			kfree(adev->usb_tx);
+		}
+		ieee80211_free_hw(ieee);
+	}
+
+	result = -ENOMEM;
+	goto end;
+
+      end_nodev:
+	/* no device we could handle, return error. */
+	result = -EIO;
+
+      end:
+	FN_EXIT1(result);
+	return result;
+}
+
+
+/***********************************************************************
+** acxusb_e_disconnect()
+**
+** This function is invoked whenever the user pulls the plug from the USB
+** device or the module is removed from the kernel. In these cases, the
+** network devices have to be taken down and all allocated memory has
+** to be freed.
+*/
+void acxusb_e_disconnect(struct usb_interface *intf)
+{
+	unsigned long flags;
+	int i;
+	acx_device_t *adev = usb_get_intfdata(intf);
+
+	FN_ENTER;
+
+	/* No WLAN device... no sense */
+	if (!adev)
+		goto end;
+
+	/* Unregister network device
+	 *
+	 * If the interface is up, unregister_netdev() will take
+	 * care of calling our close() function, which takes
+	 * care of unlinking the urbs, sending the device to
+	 * sleep, etc...
+	 * This can't be called with sem or lock held because
+	 * _close() will try to grab it as well if it's called,
+	 * deadlocking the machine.
+	 */
+	acx_proc_unregister_entries(adev->ieee);
+	ieee80211_unregister_hw(adev->ieee);
+
+	acx_sem_lock(adev);
+	acx_lock(adev, flags);
+	/* This device exists no more */
+	usb_set_intfdata(intf, NULL);
+
+	/*
+	 * Here we only free them. _close() took care of
+	 * unlinking them.
+	 */
+	for (i = 0; i < ACX_RX_URB_CNT; ++i) {
+		usb_free_urb(adev->usb_rx[i].urb);
+	}
+	for (i = 0; i < ACX_TX_URB_CNT; ++i) {
+		usb_free_urb(adev->usb_tx[i].urb);
+	}
+
+	/* Freeing containers */
+	kfree(adev->usb_rx);
+	kfree(adev->usb_tx);
+
+	acx_unlock(adev, flags);
+	acx_sem_unlock(adev);
+
+	ieee80211_free_hw(adev->ieee);
+      end:
+	FN_EXIT0;
+}
+
+/***********************************************************************
+** acxusb_e_open()
+** This function is called when the user sets up the network interface.
+** It initializes a management timer, sets up the USB card and starts
+** the network tx queue and USB receive.
+*/
+int acxusb_e_open(struct ieee80211_hw *hw)
+{
+	acx_device_t *adev = ieee2adev(hw);
+	unsigned long flags;
+	int i;
+
+	FN_ENTER;
+
+	acx_sem_lock(adev);
+
+	/* put the ACX100 out of sleep mode */
+//	acx_s_issue_cmd(adev, ACX1xx_CMD_WAKE, NULL, 0);
+
+	init_timer(&adev->mgmt_timer);
+	adev->mgmt_timer.function = acx_i_timer;
+	adev->mgmt_timer.data = (unsigned long)adev;
+
+	/* acx_s_start needs it */
+	SET_BIT(adev->dev_state_mask, ACX_STATE_IFACE_UP);
+	acx_s_start(adev);
+
+	/* don't acx_start_queue() here, we need to associate first */
+
+	acx_lock(adev, flags);
+	for (i = 0; i < ACX_RX_URB_CNT; i++) {
+		adev->usb_rx[i].urb->status = 0;
+	}
+
+	acxusb_l_poll_rx(adev, &adev->usb_rx[0]);
+
+        acx_setup_modes(adev);
+	ieee80211_start_queues(adev->ieee);
+	acx_unlock(adev, flags);
+
+	acx_sem_unlock(adev);
+
+	FN_EXIT0;
+	return 0;
+}
+
+
+/***********************************************************************
+** acxusb_e_close()
+**
+** This function stops the network functionality of the interface (invoked
+** when the user calls ifconfig <wlan> down). The tx queue is halted and
+** the device is marked as down. In case there were any pending USB bulk
+** transfers, these are unlinked (asynchronously). The module in-use count
+** is also decreased in this function.
+*/
+int acxusb_e_close(struct ieee80211_hw *hw)
+{
+	acx_device_t *adev = ieee2adev(hw);
+	unsigned long flags;
+	int i;
+
+	FN_ENTER;
+
+	    acx_sem_lock(adev);
+	if (adev->dev_state_mask & ACX_STATE_IFACE_UP)
+	{
+//		acxusb_e_down(adev);
+		CLEAR_BIT(adev->dev_state_mask, ACX_STATE_IFACE_UP);
+	}
+
+/* Code below is remarkably similar to acxpci_s_down(). Maybe we can merge them? */
+
+        acx_free_modes(adev);
+
+	/* Make sure we don't get any more rx requests */
+	acx_s_issue_cmd(adev, ACX1xx_CMD_DISABLE_RX, NULL, 0);
+	acx_s_issue_cmd(adev, ACX1xx_CMD_DISABLE_TX, NULL, 0);
+
+	/*
+	 * We must do FLUSH *without* holding sem to avoid a deadlock.
+	 * See pci.c:acxpci_s_down() for deails.
+	 */
+	acx_sem_unlock(adev);
+	flush_scheduled_work();
+	acx_sem_lock(adev);
+
+	/* Power down the device */
+	acx_s_issue_cmd(adev, ACX1xx_CMD_SLEEP, NULL, 0);
+
+	/* Stop the transmit queue, mark the device as DOWN */
+	acx_lock(adev, flags);
+//	acx_stop_queue(ndev, "on ifdown");
+//      acx_set_status(adev, ACX_STATUS_0_STOPPED);
+	/* stop pending rx/tx urb transfers */
+	for (i = 0; i < ACX_TX_URB_CNT; i++) {
+		acxusb_unlink_urb(adev->usb_tx[i].urb);
+		adev->usb_tx[i].busy = 0;
+	}
+	for (i = 0; i < ACX_RX_URB_CNT; i++) {
+		acxusb_unlink_urb(adev->usb_rx[i].urb);
+		adev->usb_rx[i].busy = 0;
+	}
+	adev->tx_free = ACX_TX_URB_CNT;
+	acx_unlock(adev, flags);
+
+	/* Must do this outside of lock */
+	del_timer_sync(&adev->mgmt_timer);
+
+	acx_sem_unlock(adev);
+
+	FN_EXIT0;
+	return 0;
+}
+
+
+/***********************************************************************
+** acxusb_l_poll_rx
+** This function (re)initiates a bulk-in USB transfer on a given urb
+*/
+void acxusb_l_poll_rx(acx_device_t * adev, usb_rx_t * rx)
+{
+	struct usb_device *usbdev;
+	struct urb *rxurb;
+	int errcode, rxnum;
+	unsigned int inpipe;
+
+	FN_ENTER;
+
+	rxurb = rx->urb;
+	usbdev = adev->usbdev;
+
+	rxnum = rx - adev->usb_rx;
+
+	inpipe = usb_rcvbulkpipe(usbdev, adev->bulkinep);
+	if (unlikely(rxurb->status == -EINPROGRESS)) {
+		printk(KERN_ERR
+		       "acx: error, rx triggered while rx urb in progress\n");
+		/* FIXME: this is nasty, receive is being cancelled by this code
+		 * on the other hand, this should not happen anyway...
+		 */
+		usb_unlink_urb(rxurb);
+	} else if (unlikely(rxurb->status == -ECONNRESET)) {
+		log(L_USBRXTX, "acx_usb: _poll_rx: connection reset\n");
+		goto end;
+	}
+	rxurb->actual_length = 0;
+	usb_fill_bulk_urb(rxurb, usbdev, inpipe, &rx->bulkin,	/* dataptr */
+			  RXBUFSIZE,	/* size */
+			  acxusb_i_complete_rx,	/* handler */
+			  rx	/* handler param */
+	    );
+	rxurb->transfer_flags = URB_ASYNC_UNLINK;
+
+	/* ATOMIC: we may be called from complete_rx() usb callback */
+	errcode = usb_submit_urb(rxurb, GFP_ATOMIC);
+	/* FIXME: evaluate the error code! */
+	log(L_USBRXTX, "SUBMIT RX (%d) inpipe=0x%X size=%d errcode=%d\n",
+	    rxnum, inpipe, (int)RXBUFSIZE, errcode);
+      end:
+	FN_EXIT0;
+}
+
+
+/***********************************************************************
+** acxusb_i_complete_rx()
+** Inputs:
+**     urb -> pointer to USB request block
+**    regs -> pointer to register-buffer for syscalls (see asm/ptrace.h)
+**
+** This function is invoked by USB subsystem whenever a bulk receive
+** request returns.
+** The received data is then committed to the network stack and the next
+** USB receive is triggered.
+*/
+void acxusb_i_complete_rx(struct urb *urb)
+{
+	acx_device_t *adev;
+	rxbuffer_t *ptr;
+	rxbuffer_t *inbuf;
+	usb_rx_t *rx;
+	unsigned long flags;
+	int size, remsize, packetsize, rxnum;
+
+	FN_ENTER;
+
+	BUG_ON(!urb->context);
+
+	rx = (usb_rx_t *) urb->context;
+	adev = rx->adev;
+
+	acx_lock(adev, flags);
+
+	/*
+	 * Happens on disconnect or close. Don't play with the urb.
+	 * Don't resubmit it. It will get unlinked by close()
+	 */
+	if (unlikely(!(adev->dev_state_mask & ACX_STATE_IFACE_UP))) {
+		log(L_USBRXTX, "rx: device is down, not doing anything\n");
+		goto end_unlock;
+	}
+
+	inbuf = &rx->bulkin;
+	size = urb->actual_length;
+	remsize = size;
+	rxnum = rx - adev->usb_rx;
+
+	log(L_USBRXTX, "RETURN RX (%d) status=%d size=%d\n",
+	    rxnum, urb->status, size);
+
+	/* Send the URB that's waiting. */
+	log(L_USBRXTX, "rxnum=%d, sending=%d\n", rxnum, rxnum ^ 1);
+	acxusb_l_poll_rx(adev, &adev->usb_rx[rxnum ^ 1]);
+
+	if (unlikely(size > sizeof(rxbuffer_t)))
+		printk("acx_usb: rx too large: %d, please report\n", size);
+
+	/* check if the transfer was aborted */
+	switch (urb->status) {
+	case 0:		/* No error */
+		break;
+	case -EOVERFLOW:
+		printk(KERN_ERR "acx: rx data overrun\n");
+		adev->rxtruncsize = 0;	/* Not valid anymore. */
+		goto end_unlock;
+	case -ECONNRESET:
+		adev->rxtruncsize = 0;
+		goto end_unlock;
+	case -ESHUTDOWN:	/* rmmod */
+		adev->rxtruncsize = 0;
+		goto end_unlock;
+	default:
+		adev->rxtruncsize = 0;
+		adev->stats.rx_errors++;
+		printk("acx: rx error (urb status=%d)\n", urb->status);
+		goto end_unlock;
+	}
+
+	if (unlikely(!size))
+		printk("acx: warning, encountered zerolength rx packet\n");
+
+	if (urb->transfer_buffer != inbuf)
+		goto end_unlock;
+
+	/* check if previous frame was truncated
+	 ** FIXME: this code can only handle truncation
+	 ** of consecutive packets!
+	 */
+	ptr = inbuf;
+	if (adev->rxtruncsize) {
+		int tail_size;
+
+		ptr = &adev->rxtruncbuf;
+		packetsize = RXBUF_BYTES_USED(ptr);
+		if (acx_debug & L_USBRXTX) {
+			printk("handling truncated frame (truncsize=%d size=%d "
+			       "packetsize(from trunc)=%d)\n",
+			       adev->rxtruncsize, size, packetsize);
+			acx_dump_bytes(ptr, RXBUF_HDRSIZE);
+			acx_dump_bytes(inbuf, RXBUF_HDRSIZE);
+		}
+
+		/* bytes needed for rxtruncbuf completion: */
+		tail_size = packetsize - adev->rxtruncsize;
+
+		if (size < tail_size) {
+			/* there is not enough data to complete this packet,
+			 ** simply append the stuff to the truncation buffer
+			 */
+			memcpy(((char *)ptr) + adev->rxtruncsize, inbuf, size);
+			adev->rxtruncsize += size;
+			remsize = 0;
+		} else {
+			/* ok, this data completes the previously
+			 ** truncated packet. copy it into a descriptor
+			 ** and give it to the rest of the stack        */
+
+			/* append tail to previously truncated part
+			 ** NB: adev->rxtruncbuf (pointed to by ptr) can't
+			 ** overflow because this is already checked before
+			 ** truncation buffer was filled. See below,
+			 ** "if (packetsize > sizeof(rxbuffer_t))..." code */
+			memcpy(((char *)ptr) + adev->rxtruncsize, inbuf,
+			       tail_size);
+
+			if (acx_debug & L_USBRXTX) {
+				printk("full trailing packet + 12 bytes:\n");
+				acx_dump_bytes(inbuf,
+					       tail_size + RXBUF_HDRSIZE);
+			}
+			acx_l_process_rxbuf(adev, ptr);
+			adev->rxtruncsize = 0;
+			ptr = (rxbuffer_t *) (((char *)inbuf) + tail_size);
+			remsize -= tail_size;
+		}
+		log(L_USBRXTX, "post-merge size=%d remsize=%d\n",
+		    size, remsize);
+	}
+
+	/* size = USB data block size
+	 ** remsize = unprocessed USB bytes left
+	 ** ptr = current pos in USB data block
+	 */
+	while (remsize) {
+		if (remsize < RXBUF_HDRSIZE) {
+			printk("acx: truncated rx header (%d bytes)!\n",
+			       remsize);
+			if (ACX_DEBUG)
+				acx_dump_bytes(ptr, remsize);
+			break;
+		}
+
+		packetsize = RXBUF_BYTES_USED(ptr);
+		log(L_USBRXTX, "packet with packetsize=%d\n", packetsize);
+
+		if (RXBUF_IS_TXSTAT(ptr)) {
+			/* do rate handling */
+			usb_txstatus_t *stat = (void *)ptr;
+
+			log(L_USBRXTX, "tx: stat: mac_cnt_rcvd:%04X "
+			    "queue_index:%02X mac_status:%02X hostdata:%08X "
+			    "rate:%u ack_failures:%02X rts_failures:%02X "
+			    "rts_ok:%02X\n",
+			    stat->mac_cnt_rcvd,
+			    stat->queue_index, stat->mac_status, stat->hostdata,
+			    stat->rate, stat->ack_failures, stat->rts_failures,
+			    stat->rts_ok);
+/*
+			if (adev->rate_auto && client_no < VEC_SIZE(adev->sta_list)) {
+				client_t *clt = &adev->sta_list[client_no];
+				u16 cur = stat->hostdata >> 16;
+
+				if (clt && clt->rate_cur == cur) {
+					acx_l_handle_txrate_auto(adev, clt,
+						cur, // intended rate 
+						stat->rate, 0, // actually used rate 
+						stat->mac_status, // error? 
+						ACX_TX_URB_CNT - adev->tx_free);
+				}
+			}
+*/ goto next;
+		}
+
+		if (packetsize > sizeof(rxbuffer_t)) {
+			printk("acx: packet exceeds max wlan "
+			       "frame size (%d > %d). size=%d\n",
+			       packetsize, (int)sizeof(rxbuffer_t), size);
+			if (ACX_DEBUG)
+				acx_dump_bytes(ptr, 16);
+			/* FIXME: put some real error-handling in here! */
+			break;
+		}
+
+		if (packetsize > remsize) {
+			/* frame truncation handling */
+			if (acx_debug & L_USBRXTX) {
+				printk("need to truncate packet, "
+				       "packetsize=%d remsize=%d "
+				       "size=%d bytes:",
+				       packetsize, remsize, size);
+				acx_dump_bytes(ptr, RXBUF_HDRSIZE);
+			}
+			memcpy(&adev->rxtruncbuf, ptr, remsize);
+			adev->rxtruncsize = remsize;
+			break;
+		}
+
+		/* packetsize <= remsize */
+		/* now handle the received data */
+		acx_l_process_rxbuf(adev, ptr);
+	      next:
+		ptr = (rxbuffer_t *) (((char *)ptr) + packetsize);
+		remsize -= packetsize;
+		if ((acx_debug & L_USBRXTX) && remsize) {
+			printk("more than one packet in buffer, "
+			       "second packet hdr:");
+			acx_dump_bytes(ptr, RXBUF_HDRSIZE);
+		}
+	}
+
+      end_unlock:
+	acx_unlock(adev, flags);
+/* end: */
+	FN_EXIT0;
+}
+
+
+/***********************************************************************
+** acxusb_i_complete_tx()
+** Inputs:
+**     urb -> pointer to USB request block
+**    regs -> pointer to register-buffer for syscalls (see asm/ptrace.h)
+**
+** This function is invoked upon termination of a USB transfer.
+*/
+void acxusb_i_complete_tx(struct urb *urb)
+{
+	acx_device_t *adev;
+	usb_tx_t *tx;
+	unsigned long flags;
+	int txnum;
+
+	FN_ENTER;
+
+	BUG_ON(!urb->context);
+
+	tx = (usb_tx_t *) urb->context;
+	adev = tx->adev;
+
+	txnum = tx - adev->usb_tx;
+
+	acx_lock(adev, flags);
+
+	/*
+	 * If the iface isn't up, we don't have any right
+	 * to play with them. The urb may get unlinked.
+	 */
+	if (unlikely(!(adev->dev_state_mask & ACX_STATE_IFACE_UP))) {
+		log(L_USBRXTX, "tx: device is down, not doing anything\n");
+		goto end_unlock;
+	}
+
+	log(L_USBRXTX, "RETURN TX (%d): status=%d size=%d\n",
+	    txnum, urb->status, urb->actual_length);
+
+	/* handle USB transfer errors */
+	switch (urb->status) {
+	case 0:		/* No error */
+		break;
+	case -ESHUTDOWN:
+		goto end_unlock;
+		break;
+	case -ECONNRESET:
+		goto end_unlock;
+		break;
+		/* FIXME: real error-handling code here please */
+	default:
+		printk(KERN_ERR "acx: tx error, urb status=%d\n", urb->status);
+		/* FIXME: real error-handling code here please */
+	}
+
+	/* free the URB and check for more data */
+	tx->busy = 0;
+	adev->tx_free++;
+	if ((adev->tx_free >= TX_START_QUEUE)
+	    && (adev->status == ACX_STATUS_4_ASSOCIATED)
+/*	    && (acx_queue_stopped(adev->ndev)*/) {
+		log(L_BUF, "tx: wake queue (%u free txbufs)\n", adev->tx_free);
+/*		acx_wake_queue(adev->ndev, NULL); */
+	}
+
+      end_unlock:
+	acx_unlock(adev, flags);
+/* end: */
+	FN_EXIT0;
+}
+
+
+/***************************************************************
+** acxusb_l_alloc_tx
+** Actually returns a usb_tx_t* ptr
+*/
+tx_t *acxusb_l_alloc_tx(acx_device_t * adev)
+{
+	usb_tx_t *tx;
+	unsigned head;
+
+	FN_ENTER;
+
+	head = adev->tx_head;
+	do {
+		head = (head + 1) % ACX_TX_URB_CNT;
+		if (!adev->usb_tx[head].busy) {
+			log(L_USBRXTX, "allocated tx %d\n", head);
+			tx = &adev->usb_tx[head];
+			tx->busy = 1;
+			adev->tx_free--;
+			/* Keep a few free descs between head and tail of tx ring.
+			 ** It is not absolutely needed, just feels safer */
+			if (adev->tx_free < TX_STOP_QUEUE) {
+				log(L_BUF, "tx: stop queue "
+				    "(%u free txbufs)\n", adev->tx_free);
+/*				acx_stop_queue(adev->ndev, NULL); */
+			}
+			goto end;
+		}
+	} while (likely(head != adev->tx_head));
+	tx = NULL;
+	printk_ratelimited("acx: tx buffers full\n");
+      end:
+	adev->tx_head = head;
+	FN_EXIT0;
+	return (tx_t *) tx;
+}
+
+
+/***************************************************************
+** Used if alloc_tx()'ed buffer needs to be cancelled without doing tx
+*/
+void acxusb_l_dealloc_tx(tx_t * tx_opaque)
+{
+	usb_tx_t *tx = (usb_tx_t *) tx_opaque;
+	tx->busy = 0;
+}
+
+
+/***************************************************************
+*/
+void *acxusb_l_get_txbuf(acx_device_t * adev, tx_t * tx_opaque)
+{
+	usb_tx_t *tx = (usb_tx_t *) tx_opaque;
+	return &tx->bulkout.data;
+}
+
+
+/***************************************************************
+** acxusb_l_tx_data
+**
+** Can be called from IRQ (rx -> (AP bridging or mgmt response) -> tx).
+** Can be called from acx_i_start_xmit (data frames from net core).
+*/
+void acxusb_l_tx_data(acx_device_t * adev, tx_t * tx_opaque, int wlanpkt_len, struct ieee80211_tx_control *ctl,
+				struct sk_buff* skb)
+{
+	struct usb_device *usbdev;
+	struct urb *txurb;
+	usb_tx_t *tx;
+	usb_txbuffer_t *txbuf;
+//	client_t *clt;
+	struct ieee80211_hdr *whdr;
+	unsigned int outpipe;
+	int ucode, txnum;
+
+	FN_ENTER;
+
+	tx = ((usb_tx_t *) tx_opaque);
+	txurb = tx->urb;
+	txbuf = &tx->bulkout;
+	whdr = (struct ieee80211_hdr *) txbuf->data;
+	txnum = tx - adev->usb_tx;
+
+	log(L_DEBUG, "using buf#%d free=%d len=%d\n",
+	    txnum, adev->tx_free, wlanpkt_len);
+/*
+	switch (adev->mode) {
+	case ACX_MODE_0_ADHOC:
+	case ACX_MODE_3_AP:
+		clt = acx_l_sta_list_get(adev, whdr->a1);
+		break;
+	case ACX_MODE_2_STA:
+//              clt = adev->ap_client;
+		break;
+	default:
+		clt = NULL;
+		break;
+	}
+	if (unlikely(clt && !clt->rate_cur)) {
+		printk("acx: driver bug! bad ratemask\n");
+		goto end;
+	}
+*/
+
+	/* fill the USB transfer header */
+	txbuf->desc = cpu_to_le16(USB_TXBUF_TXDESC);
+	txbuf->mpdu_len = cpu_to_le16(wlanpkt_len);
+	txbuf->queue_index = 1;
+	txbuf->rate = ctl->tx_rate; //clt->rate_100;
+//		FIXME();	//This used to have | (clt - adev->ap_client)
+	txbuf->hostdata = (ctl->tx_rate << 16);
+	txbuf->ctrl1 = DESC_CTL_FIRSTFRAG;
+	if (1 == adev->preamble_cur)
+		SET_BIT(txbuf->ctrl1, DESC_CTL_SHORT_PREAMBLE);
+	txbuf->ctrl2 = 0;
+	txbuf->data_len = cpu_to_le16(wlanpkt_len);
+
+	if (unlikely(acx_debug & L_DATA)) {
+		printk("dump of bulk out urb:\n");
+		acx_dump_bytes(txbuf, wlanpkt_len + USB_TXBUF_HDRSIZE);
+	}
+
+	if (unlikely(txurb->status == -EINPROGRESS)) {
+		printk
+		    ("acx: trying to submit tx urb while already in progress\n");
+	}
+
+	/* now schedule the USB transfer */
+	usbdev = adev->usbdev;
+	outpipe = usb_sndbulkpipe(usbdev, adev->bulkoutep);
+
+	usb_fill_bulk_urb(txurb, usbdev, outpipe, txbuf,	/* dataptr */
+			  wlanpkt_len + USB_TXBUF_HDRSIZE,	/* size */
+			  acxusb_i_complete_tx,	/* handler */
+			  tx	/* handler param */
+	    );
+
+	txurb->transfer_flags = URB_ASYNC_UNLINK | URB_ZERO_PACKET;
+	ucode = usb_submit_urb(txurb, GFP_ATOMIC);
+	log(L_USBRXTX, "SUBMIT TX (%d): outpipe=0x%X buf=%p txsize=%d "
+	    "rate=%u errcode=%d\n", txnum, outpipe, txbuf,
+	    wlanpkt_len + USB_TXBUF_HDRSIZE, txbuf->rate, ucode);
+
+	if (unlikely(ucode)) {
+		printk(KERN_ERR "acx: submit_urb() error=%d txsize=%d\n",
+		       ucode, wlanpkt_len + USB_TXBUF_HDRSIZE);
+
+		/* on error, just mark the frame as done and update
+		 ** the statistics
+		 */
+		adev->stats.tx_errors++;
+		tx->busy = 0;
+		adev->tx_free++;
+		/* needed? if (adev->tx_free > TX_START_QUEUE) acx_wake_queue(...) */
+	}
+	FN_EXIT0;
+}
+
+
+/***********************************************************************
+static void acxusb_i_set_rx_mode(struct net_device *ndev)
+{
+}
+*/
+
+
+/***********************************************************************
+*/
+#ifdef HAVE_TX_TIMEOUT
+/*
+void acxusb_i_tx_timeout(struct net_device *ndev)
+{
+	acx_device_t *adev = ndev2adev(ndev);
+	unsigned long flags;
+	int i;
+
+	FN_ENTER;
+
+	acx_lock(adev, flags);
+*/	/* unlink the URBs */
+/*	for (i = 0; i < ACX_TX_URB_CNT; i++) {
+		acxusb_unlink_urb(adev->usb_tx[i].urb);
+		adev->usb_tx[i].busy = 0;
+	}
+	adev->tx_free = ACX_TX_URB_CNT;
+*/	/* TODO: stats update */
+/*	acx_unlock(adev, flags);
+
+	FN_EXIT0;
+}
+*/
+#endif
+
+
+/***********************************************************************
+** init_module()
+**
+** This function is invoked upon loading of the kernel module.
+** It registers itself at the kernel's USB subsystem.
+**
+** Returns: Errorcode on failure, 0 on success
+*/
+int __init acxusb_e_init_module(void)
+{
+	log(L_INIT, "USB module " ACX_RELEASE " initialized, "
+	    "probing for devices...\n");
+	return usb_register(&acxusb_driver);
+}
+
+
+
+/***********************************************************************
+** cleanup_module()
+**
+** This function is invoked as last step of the module unloading. It simply
+** deregisters this module at the kernel's USB subsystem.
+*/
+void __exit acxusb_e_cleanup_module(void)
+{
+	usb_deregister(&acxusb_driver);
+}
+
+
+/***********************************************************************
+** DEBUG STUFF
+*/
+#if ACX_DEBUG
+
+#ifdef UNUSED
+static void dump_device(struct usb_device *usbdev)
+{
+	int i;
+	struct usb_config_descriptor *cd;
+
+	printk("acx device dump:\n");
+	printk("  devnum: %d\n", usbdev->devnum);
+	printk("  speed: %d\n", usbdev->speed);
+	printk("  tt: 0x%X\n", (unsigned int)(usbdev->tt));
+	printk("  ttport: %d\n", (unsigned int)(usbdev->ttport));
+	printk("  toggle[0]: 0x%X  toggle[1]: 0x%X\n",
+	       (unsigned int)(usbdev->toggle[0]),
+	       (unsigned int)(usbdev->toggle[1]));
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 11)
+	/* This saw a change after 2.6.10 */
+	printk("  ep_in wMaxPacketSize: ");
+	for (i = 0; i < 16; ++i)
+		if (usbdev->ep_in[i] != NULL)
+			printk("%d:%d ", i,
+			       usbdev->ep_in[i]->desc.wMaxPacketSize);
+	printk("\n");
+	printk("  ep_out wMaxPacketSize: ");
+	for (i = 0; i < ARRAY_SIZE(usbdev->ep_out); ++i)
+		if (usbdev->ep_out[i] != NULL)
+			printk("%d:%d ", i,
+			       usbdev->ep_out[i]->desc.wMaxPacketSize);
+	printk("\n");
+#else
+	printk("  epmaxpacketin: ");
+	for (i = 0; i < 16; i++)
+		printk("%d ", usbdev->epmaxpacketin[i]);
+	printk("\n");
+	printk("  epmaxpacketout: ");
+	for (i = 0; i < 16; i++)
+		printk("%d ", usbdev->epmaxpacketout[i]);
+	printk("\n");
+#endif
+	printk("  parent: 0x%X\n", (unsigned int)usbdev->parent);
+	printk("  bus: 0x%X\n", (unsigned int)usbdev->bus);
+#ifdef NO_DATATYPE
+	printk("  configs: ");
+	for (i = 0; i < usbdev->descriptor.bNumConfigurations; i++)
+		printk("0x%X ", usbdev->config[i]);
+	printk("\n");
+#endif
+	printk("  actconfig: %p\n", usbdev->actconfig);
+	dump_device_descriptor(&usbdev->descriptor);
+
+	cd = &usbdev->config->desc;
+	dump_config_descriptor(cd);
+}
+
+
+/***********************************************************************
+*/
+static void dump_config_descriptor(struct usb_config_descriptor *cd)
+{
+	printk("Configuration Descriptor:\n");
+	if (!cd) {
+		printk("NULL\n");
+		return;
+	}
+	printk("  bLength: %d (0x%X)\n", cd->bLength, cd->bLength);
+	printk("  bDescriptorType: %d (0x%X)\n", cd->bDescriptorType,
+	       cd->bDescriptorType);
+	printk("  bNumInterfaces: %d (0x%X)\n", cd->bNumInterfaces,
+	       cd->bNumInterfaces);
+	printk("  bConfigurationValue: %d (0x%X)\n", cd->bConfigurationValue,
+	       cd->bConfigurationValue);
+	printk("  iConfiguration: %d (0x%X)\n", cd->iConfiguration,
+	       cd->iConfiguration);
+	printk("  bmAttributes: %d (0x%X)\n", cd->bmAttributes,
+	       cd->bmAttributes);
+	/* printk("  MaxPower: %d (0x%X)\n", cd->bMaxPower, cd->bMaxPower); */
+}
+
+
+static void dump_device_descriptor(struct usb_device_descriptor *dd)
+{
+	printk("Device Descriptor:\n");
+	if (!dd) {
+		printk("NULL\n");
+		return;
+	}
+	printk("  bLength: %d (0x%X)\n", dd->bLength, dd->bLength);
+	printk("  bDescriptortype: %d (0x%X)\n", dd->bDescriptorType,
+	       dd->bDescriptorType);
+	printk("  bcdUSB: %d (0x%X)\n", dd->bcdUSB, dd->bcdUSB);
+	printk("  bDeviceClass: %d (0x%X)\n", dd->bDeviceClass,
+	       dd->bDeviceClass);
+	printk("  bDeviceSubClass: %d (0x%X)\n", dd->bDeviceSubClass,
+	       dd->bDeviceSubClass);
+	printk("  bDeviceProtocol: %d (0x%X)\n", dd->bDeviceProtocol,
+	       dd->bDeviceProtocol);
+	printk("  bMaxPacketSize0: %d (0x%X)\n", dd->bMaxPacketSize0,
+	       dd->bMaxPacketSize0);
+	printk("  idVendor: %d (0x%X)\n", dd->idVendor, dd->idVendor);
+	printk("  idProduct: %d (0x%X)\n", dd->idProduct, dd->idProduct);
+	printk("  bcdDevice: %d (0x%X)\n", dd->bcdDevice, dd->bcdDevice);
+	printk("  iManufacturer: %d (0x%X)\n", dd->iManufacturer,
+	       dd->iManufacturer);
+	printk("  iProduct: %d (0x%X)\n", dd->iProduct, dd->iProduct);
+	printk("  iSerialNumber: %d (0x%X)\n", dd->iSerialNumber,
+	       dd->iSerialNumber);
+	printk("  bNumConfigurations: %d (0x%X)\n", dd->bNumConfigurations,
+	       dd->bNumConfigurations);
+}
+#endif /* UNUSED */
+
+#endif /* ACX_DEBUG */
diff -Nurp linux-2.6.23-sabayon.orig/drivers/net/wireless/Kconfig linux-2.6.23-sabayon/drivers/net/wireless/Kconfig
--- linux-2.6.23-sabayon.orig/drivers/net/wireless/Kconfig	2007-10-10 10:49:43.000000000 +0200
+++ linux-2.6.23-sabayon/drivers/net/wireless/Kconfig	2007-10-10 10:51:36.000000000 +0200
@@ -619,6 +619,7 @@ source "drivers/net/wireless/zd1211rw/Kc
 source "drivers/net/wireless/rt2x00/Kconfig"
 source "drivers/net/wireless/iwlwifi/Kconfig"
 source "drivers/net/wireless/zd1211rw-mac80211/Kconfig"
+source "drivers/net/wireless/acx/Kconfig"
 
 source "drivers/net/wireless/Kconfig.ipw3945"
 
diff -Nurp linux-2.6.23-sabayon.orig/drivers/net/wireless/Makefile linux-2.6.23-sabayon/drivers/net/wireless/Makefile
--- linux-2.6.23-sabayon.orig/drivers/net/wireless/Makefile	2007-10-10 10:49:47.000000000 +0200
+++ linux-2.6.23-sabayon/drivers/net/wireless/Makefile	2007-10-10 10:52:23.000000000 +0200
@@ -59,6 +59,7 @@ obj-$(CONFIG_ADM8211)	+= adm8211.o
 obj-$(CONFIG_IWLWIFI)	+= iwlwifi/
 
 obj-$(CONFIG_RT2X00)		+= rt2x00/
+obj-$(CONFIG_ACX_MAC80211)	+= acx/
 
 obj-$(CONFIG_P54_COMMON)	+= p54common.o
 obj-$(CONFIG_P54_USB)		+= p54usb.o
