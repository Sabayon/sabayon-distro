diff -Nurp linux-2.6.27.orig/fs/aufs/aufs.h linux-2.6.27/fs/aufs/aufs.h
--- linux-2.6.27.orig/fs/aufs/aufs.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.27/fs/aufs/aufs.h	2008-12-14 10:37:40.000000000 +0100
@@ -0,0 +1,70 @@
+/*
+ * Copyright (C) 2005-2008 Junjiro Okajima
+ *
+ * This program, aufs is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+ */
+
+/*
+ * main header files
+ *
+ * $Id: aufs.h,v 1.5 2008/11/03 01:06:40 sfjro Exp $
+ */
+
+#ifndef __AUFS_H__
+#define __AUFS_H__
+
+#ifdef __KERNEL__
+
+#include <linux/version.h>
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2, 6, 25)
+#error you got wrong version
+#endif
+
+/* introduced in linux-2.6.27 */
+#include <linux/bug.h>
+#ifndef WARN_ONCE
+#define WARN_ONCE(cond, fmt ...) WARN_ON(cond)
+#endif
+
+/* ---------------------------------------------------------------------- */
+
+#include "debug.h"
+
+#include "branch.h"
+#include "cpup.h"
+#include "dcsub.h"
+#include "dentry.h"
+#include "dir.h"
+#include "file.h"
+#include "hinode.h"
+#include "inode.h"
+#include "misc.h"
+#include "module.h"
+#include "opts.h"
+#include "super.h"
+#include "sysaufs.h"
+#include "vfsub.h"
+#include "whout.h"
+#include "wkq.h"
+/* reserved for future use */
+/* #include "xattr.h" */
+
+#ifdef AuNoInlineForStack
+#undef noinline_for_stack
+#define noinline_for_stack /* */
+#endif
+
+#endif /* __KERNEL__ */
+#endif /* __AUFS_H__ */
diff -Nurp linux-2.6.27.orig/fs/aufs/branch.c linux-2.6.27/fs/aufs/branch.c
--- linux-2.6.27.orig/fs/aufs/branch.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.27/fs/aufs/branch.c	2008-12-14 10:37:40.000000000 +0100
@@ -0,0 +1,1038 @@
+/*
+ * Copyright (C) 2005-2008 Junjiro Okajima
+ *
+ * This program, aufs is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+ */
+
+/*
+ * branch management
+ *
+ * $Id: branch.c,v 1.22 2008/12/01 03:49:29 sfjro Exp $
+ */
+
+#include <linux/iso_fs.h>
+#include <linux/loop.h>
+#include <linux/romfs_fs.h>
+#include <linux/smp_lock.h>
+#include "aufs.h"
+
+static void au_br_do_free(struct au_branch *br)
+{
+	int i;
+	struct au_wbr *wbr;
+
+	AuTraceEnter();
+
+	if (br->br_xino.xi_file)
+		fput(br->br_xino.xi_file);
+	mutex_destroy(&br->br_xino.xi_nondir_mtx);
+	wbr = br->br_wbr;
+	if (wbr)
+		for (i = 0; i < AuBrWh_Last; i++)
+			dput(wbr->wbr_wh[i]);
+	/* do not call au_br_nfs_lockdep_off() here */
+	if (br->br_mnt && !au_test_nfs(br->br_mnt->mnt_sb))
+		mntput(br->br_mnt);
+	else {
+		lockdep_off();
+		mntput(br->br_mnt);
+		lockdep_on();
+	}
+	AuDebugOn(au_br_count(br));
+	if (wbr) {
+		AuDebugOn(atomic_read(&wbr->wbr_wh_running));
+		au_rwsem_destroy(&wbr->wbr_wh_rwsem);
+	}
+	kfree(wbr);
+	kfree(br);
+}
+
+/*
+ * frees all branches
+ */
+void au_br_free(struct au_sbinfo *sbinfo)
+{
+	aufs_bindex_t bmax;
+	struct au_branch **br;
+
+	AuTraceEnter();
+	bmax = sbinfo->si_bend + 1;
+	br = sbinfo->si_branch;
+	while (bmax--)
+		au_br_do_free(*br++);
+}
+
+/*
+ * find the index of a branch which is specified by @br_id.
+ */
+int au_br_index(struct super_block *sb, aufs_bindex_t br_id)
+{
+	aufs_bindex_t bindex, bend;
+
+	AuTraceEnter();
+
+	bend = au_sbend(sb);
+	for (bindex = 0; bindex <= bend; bindex++)
+		if (au_sbr_id(sb, bindex) == br_id)
+			return bindex;
+	return -1;
+}
+
+/*
+ * test if the @h_sb is real-readonly.
+ */
+int au_test_def_rr(struct super_block *h_sb)
+{
+	switch (h_sb->s_magic) {
+#ifdef CONFIG_AUFS_RR_SQUASHFS
+	case SQUASHFS_MAGIC_LZMA:
+	case SQUASHFS_MAGIC:
+	case SQUASHFS_MAGIC_LZMA_SWAP:
+	case SQUASHFS_MAGIC_SWAP:
+		return 1; /* real readonly */
+#endif
+
+#if defined(CONFIG_ISO9660_FS) || defined(CONFIG_ISO9660_FS_MODULE)
+	case ISOFS_SUPER_MAGIC:
+		return 1;
+#endif
+
+#if defined(CONFIG_CRAMFS) || defined(CONFIG_CRAMFS_MODULE)
+	case CRAMFS_MAGIC:
+		return 1;
+#endif
+
+#if defined(CONFIG_ROMFS_FS) || defined(CONFIG_ROMFS_FS_MODULE)
+	case ROMFS_MAGIC:
+		return 1;
+#endif
+
+	default:
+		return 0;
+	}
+}
+
+/* ---------------------------------------------------------------------- */
+
+/*
+ * test if two hidden_dentries have overlapping branches.
+ */
+static int do_test_overlap(struct super_block *sb, struct dentry *h_d1,
+			   struct dentry *h_d2)
+{
+	struct dentry *d;
+
+	LKTRTrace("%.*s, %.*s\n", AuDLNPair(h_d1), AuDLNPair(h_d2));
+
+	d = au_test_subdir(h_d1, h_d2);
+	if (unlikely(d)) {
+		AuDbgDentry(h_d1);
+		AuDbgDentry(h_d2);
+	}
+	return !!d;
+}
+
+static int test_overlap_loopback(struct super_block *sb, struct dentry *h_d1,
+				 struct dentry *h_d2)
+{
+#if defined(CONFIG_BLK_DEV_LOOP) || defined(CONFIG_BLK_DEV_LOOP_MODULE)
+	struct inode *h_inode;
+	struct loop_device *l;
+
+	LKTRTrace("%.*s, %.*s\n", AuDLNPair(h_d1), AuDLNPair(h_d2));
+	AuDbgDentry(h_d1);
+	AuDbgDentry(h_d2);
+	AuDbgSb(h_d1->d_sb);
+	AuDbgSb(h_d2->d_sb);
+
+	h_inode = h_d1->d_inode;
+	if (MAJOR(h_inode->i_sb->s_dev) != LOOP_MAJOR)
+		return 0;
+
+	l = h_inode->i_sb->s_bdev->bd_disk->private_data;
+	h_d1 = l->lo_backing_file->f_dentry;
+	/* h_d1 can be local NFS. in this case aufs cannot detect the loop */
+	AuDbgDentry(h_d1);
+	AuDbgDentry(h_d2);
+	AuDbgSb(h_d1->d_sb);
+	AuDbgSb(h_d2->d_sb);
+	if (unlikely(h_d1->d_sb == sb))
+		return 1;
+	return do_test_overlap(sb, h_d1, h_d2);
+#else
+	return 0;
+#endif
+}
+
+static int test_overlap(struct super_block *sb, struct dentry *h_d1,
+			struct dentry *h_d2)
+{
+	LKTRTrace("d1 %.*s, d2 %.*s\n", AuDLNPair(h_d1), AuDLNPair(h_d2));
+
+	if (unlikely(h_d1 == h_d2)) {
+		AuDbgDentry(h_d1);
+		AuDbgDentry(h_d2);
+		return 1;
+	}
+	return do_test_overlap(sb, h_d1, h_d2)
+		|| do_test_overlap(sb, h_d2, h_d1)
+		|| test_overlap_loopback(sb, h_d1, h_d2)
+		|| test_overlap_loopback(sb, h_d2, h_d1);
+}
+
+/* ---------------------------------------------------------------------- */
+
+static int au_br_init_wh(struct super_block *sb, aufs_bindex_t bindex,
+			 struct au_branch *br, int new_perm,
+			 struct dentry *h_root, struct vfsmount *h_mnt)
+{
+	int err, old_perm;
+	struct inode *h_dir;
+	struct au_wbr *wbr;
+
+	LKTRTrace("b%d, new_perm %d\n", bindex, new_perm);
+	SiMustWriteLock(sb);
+
+	wbr = br->br_wbr;
+	h_dir = h_root->d_inode;
+	old_perm = br->br_perm;
+	mutex_lock_nested(&h_dir->i_mutex, AuLsc_I_PARENT);
+	if (wbr)
+		wbr_wh_write_lock(wbr);
+	br->br_perm = new_perm;
+	err = au_wh_init(h_root, br, h_mnt, sb, bindex);
+	br->br_perm = old_perm;
+	if (wbr)
+		wbr_wh_write_unlock(wbr);
+	mutex_unlock(&h_dir->i_mutex);
+	if (!err && wbr && !au_br_writable(new_perm)) {
+		AuDebugOn(wbr->wbr_whbase);
+		AuDebugOn(wbr->wbr_plink);
+		AuDebugOn(wbr->wbr_tmp);
+		kfree(wbr);
+		br->br_wbr = NULL;
+	}
+
+	AuTraceErr(err);
+	return err;
+}
+
+/* ---------------------------------------------------------------------- */
+
+/*
+ * returns a newly allocated branch. @new_nbranch is a number of branches
+ * after adding a branch.
+ */
+static struct au_branch *alloc_addbr(struct super_block *sb, int new_nbranch,
+				     int perm)
+{
+	struct au_branch **branchp, *add_branch;
+	int sz;
+	void *p;
+	struct dentry *root;
+	struct inode *inode;
+	struct au_hinode *hinodep;
+	struct au_hdentry *hdentryp;
+
+	LKTRTrace("new_nbranch %d\n", new_nbranch);
+	SiMustWriteLock(sb);
+	root = sb->s_root;
+	DiMustWriteLock(root);
+	inode = root->d_inode;
+	IiMustWriteLock(inode);
+
+	add_branch = kmalloc(sizeof(*add_branch), GFP_NOFS);
+	if (unlikely(!add_branch))
+		goto out;
+	add_branch->br_wbr = NULL;
+	if (au_br_writable(perm)) {
+		add_branch->br_wbr = kmalloc(sizeof(*add_branch->br_wbr),
+					     GFP_NOFS);
+		if (unlikely(!add_branch->br_wbr))
+			goto out_br;
+	}
+
+	sz = sizeof(*branchp) * (new_nbranch - 1);
+	if (unlikely(!sz))
+		sz = sizeof(*branchp);
+	p = au_sbi(sb)->si_branch;
+	branchp = au_kzrealloc(p, sz, sizeof(*branchp) * new_nbranch, GFP_NOFS);
+	if (unlikely(!branchp))
+		goto out_wbr;
+	au_sbi(sb)->si_branch = branchp;
+
+	sz = sizeof(*hdentryp) * (new_nbranch - 1);
+	if (unlikely(!sz))
+		sz = sizeof(*hdentryp);
+	p = au_di(root)->di_hdentry;
+	hdentryp = au_kzrealloc(p, sz, sizeof(*hdentryp) * new_nbranch,
+				GFP_NOFS);
+	if (unlikely(!hdentryp))
+		goto out_wbr;
+	au_di(root)->di_hdentry = hdentryp;
+
+	sz = sizeof(*hinodep) * (new_nbranch - 1);
+	if (unlikely(!sz))
+		sz = sizeof(*hinodep);
+	p = au_ii(inode)->ii_hinode;
+	hinodep = au_kzrealloc(p, sz, sizeof(*hinodep) * new_nbranch, GFP_NOFS);
+	if (unlikely(!hinodep))
+		goto out_wbr;
+	au_ii(inode)->ii_hinode = hinodep;
+	return add_branch; /* success */
+
+ out_wbr:
+	kfree(add_branch->br_wbr);
+ out_br:
+	kfree(add_branch);
+ out:
+	AuTraceErr(-ENOMEM);
+	return ERR_PTR(-ENOMEM);
+}
+
+/*
+ * test if the branch permission is legal or not.
+ */
+static int test_br(struct super_block *sb, struct inode *inode, int brperm,
+		   char *path)
+{
+	int err;
+
+	err = 0;
+	if (unlikely(au_br_writable(brperm) && IS_RDONLY(inode))) {
+		AuErr("write permission for readonly fs or inode, %s\n", path);
+		err = -EINVAL;
+	}
+
+	AuTraceErr(err);
+	return err;
+}
+
+static int au_unsupported_fs(struct super_block *sb)
+{
+	return sb->s_magic == PROC_SUPER_MAGIC
+#ifdef SYSFS_MAGIC
+		|| sb->s_magic == SYSFS_MAGIC
+#endif
+		|| !strcmp(au_sbtype(sb), "unionfs");
+}
+
+/*
+ * returns:
+ * 0: success, the caller will add it
+ * plus: success, it is already unified, the caller should ignore it
+ * minus: error
+ */
+static int test_add(struct super_block *sb, struct au_opt_add *add, int remount)
+{
+	int err;
+	struct dentry *root;
+	struct inode *inode, *h_inode;
+	aufs_bindex_t bend, bindex;
+
+	LKTRTrace("%s, remo%d\n", add->path, remount);
+
+	root = sb->s_root;
+	bend = au_sbend(sb);
+	if (unlikely(bend >= 0
+		     && au_find_dbindex(root, add->nd.path.dentry) >= 0)) {
+		err = 1;
+		if (!remount) {
+			err = -EINVAL;
+			AuErr("%s duplicated\n", add->path);
+		}
+		goto out;
+	}
+
+	err = -ENOSPC; /* -E2BIG; */
+	if (unlikely(AUFS_BRANCH_MAX <= add->bindex
+		     || AUFS_BRANCH_MAX - 1 <= bend)) {
+		AuErr("number of branches exceeded %s\n", add->path);
+		goto out;
+	}
+
+	err = -EDOM;
+	if (unlikely(add->bindex < 0 || bend + 1 < add->bindex)) {
+		AuErr("bad index %d\n", add->bindex);
+		goto out;
+	}
+
+	inode = add->nd.path.dentry->d_inode;
+	AuDebugOn(!inode || !S_ISDIR(inode->i_mode));
+	err = -ENOENT;
+	if (unlikely(!inode->i_nlink)) {
+		AuErr("no existence %s\n", add->path);
+		goto out;
+	}
+
+	err = -EINVAL;
+	if (unlikely(inode->i_sb == sb)) {
+		AuErr("%s must be outside\n", add->path);
+		goto out;
+	}
+
+	if (unlikely(au_test_nested(inode->i_sb))) {
+		AuErr("nested " AUFS_NAME " %s\n", add->path);
+		goto out;
+	}
+
+	if (unlikely(au_unsupported_fs(inode->i_sb))) {
+		AuErr("unsupported filesystem, %s\n", add->path);
+		goto out;
+	}
+
+	if (unlikely(au_test_unsupported_nfs(inode->i_sb))) {
+		AuErr(AuNoNfsBranchMsg " %s\n", add->path);
+		goto out;
+	}
+
+	if (unlikely(au_test_unsupported_nfs4(inode->i_sb))) {
+		AuErr(AuNoNfsv4BranchMsg " %s\n", add->path);
+		goto out;
+	}
+
+	err = test_br(sb, add->nd.path.dentry->d_inode, add->perm, add->path);
+	if (unlikely(err))
+		goto out;
+
+	if (bend < 0)
+		return 0; /* success */
+
+	err = -EINVAL;
+	for (bindex = 0; bindex <= bend; bindex++)
+		if (unlikely(test_overlap(sb, add->nd.path.dentry,
+					  au_h_dptr(root, bindex)))) {
+			AuErr("%s is overlapped\n", add->path);
+			goto out;
+		}
+
+	err = 0;
+	h_inode = au_h_dptr(root, 0)->d_inode;
+	if (unlikely(au_opt_test(au_mntflags(sb), WARN_PERM)
+		     && ((h_inode->i_mode & S_IALLUGO)
+			 != (inode->i_mode & S_IALLUGO)
+			 || h_inode->i_uid != inode->i_uid
+			 || h_inode->i_gid != inode->i_gid)))
+		AuWarn("uid/gid/perm %s %u/%u/0%o, %u/%u/0%o\n",
+		       add->path,
+		       inode->i_uid, inode->i_gid, (inode->i_mode & S_IALLUGO),
+		       h_inode->i_uid, h_inode->i_gid,
+		       (h_inode->i_mode & S_IALLUGO));
+
+ out:
+	AuTraceErr(err);
+	return err;
+}
+
+static int au_wbr_init(struct au_branch *br, struct super_block *sb,
+		       int perm, struct path *path)
+{
+	int err;
+	struct au_wbr *wbr;
+
+	AuTraceEnter();
+	wbr = br->br_wbr;
+	AuDebugOn(!wbr);
+
+	au_rw_init_nolock(&wbr->wbr_wh_rwsem);
+	memset(wbr->wbr_wh, 0, sizeof(wbr->wbr_wh));
+	atomic_set(&wbr->wbr_wh_running, 0);
+	wbr->wbr_bytes = 0;
+
+	err = au_br_init_wh(sb, /*bindex*/-1, br, perm,
+			    path->dentry, path->mnt);
+
+	AuTraceErr(err);
+	return err;
+}
+
+static int au_br_init(struct au_branch *br, struct super_block *sb,
+		      struct au_opt_add *add)
+{
+	int err;
+	unsigned int mnt_flags;
+
+	AuTraceEnter();
+
+	err = 0;
+	br->br_mnt = NULL;
+	br->br_xino.xi_file = NULL;
+	mutex_init(&br->br_xino.xi_nondir_mtx);
+	atomic_set(&br->br_xino_running, 0);
+	atomic_set(&br->br_count, 0);
+
+	if (au_br_writable(add->perm)) {
+		err = au_wbr_init(br, sb, add->perm, &add->nd.path);
+		if (unlikely(err))
+			goto out;
+	}
+
+	br->br_mnt = mntget(add->nd.path.mnt);
+	mnt_flags = au_mntflags(sb);
+	if (au_opt_test(mnt_flags, XINO)) {
+		err = au_xino_br(sb, br, add->nd.path.dentry->d_inode->i_ino,
+				 au_sbr(sb, 0)->br_xino.xi_file, /*do_test*/1);
+		if (unlikely(err)) {
+			AuDebugOn(br->br_xino.xi_file);
+			goto out;
+		}
+#if 0 /* reserved for future use */
+	} else if (au_opt_test(mnt_flags, XINODIR)) {
+		err = au_xinodir_br(sb, br, add->nd.path.dentry->d_inode->i_ino,
+				    /*do_test*/1);
+		if (unlikely(err)) {
+			AuDebugOn(br->br_xino.xi_file);
+			goto out;
+		}
+#endif
+	}
+
+	br->br_id = au_new_br_id(sb);
+	br->br_perm = add->perm;
+	br->br_xino_upper = AUFS_XINO_TRUNC_INIT;
+	sysaufs_br_init(br);
+	br->br_generation = au_sigen(sb);
+	/* smp_mb(); */ /* atomic_set */
+
+ out:
+	AuTraceErr(err);
+	return err;
+}
+
+int au_br_add(struct super_block *sb, struct au_opt_add *add, int remount)
+{
+	int err, amount;
+	aufs_bindex_t bend, add_bindex;
+	struct dentry *root, *dentry;
+	struct au_iinfo *iinfo;
+	struct au_sbinfo *sbinfo;
+	struct au_dinfo *dinfo;
+	struct inode *root_inode;
+	unsigned long long maxb;
+	struct au_branch **branchp, *add_branch;
+	struct au_hdentry *hdentryp;
+	struct au_hinode *hinodep;
+
+	dentry = add->nd.path.dentry;
+	LKTRTrace("b%d, %s, 0x%x, %.*s\n",
+		  add->bindex, add->path, add->perm, AuDLNPair(dentry));
+	SiMustWriteLock(sb);
+	root = sb->s_root;
+	DiMustWriteLock(root);
+	root_inode = root->d_inode;
+	IMustLock(root_inode);
+	IiMustWriteLock(root_inode);
+
+	err = test_add(sb, add, remount);
+	if (unlikely(err < 0))
+		goto out;
+	if (err) {
+		err = 0;
+		goto out; /* success */
+	}
+
+	bend = au_sbend(sb);
+	add_branch = alloc_addbr(sb, bend + 2, add->perm);
+	err = PTR_ERR(add_branch);
+	if (IS_ERR(add_branch))
+		goto out;
+	err = au_br_init(add_branch, sb, add);
+	if (unlikely(err)) {
+		au_br_do_free(add_branch);
+		goto out;
+	}
+
+	add_bindex = add->bindex;
+	if (remount)
+		sysaufs_brs_del(sb, add_bindex);
+
+	sbinfo = au_sbi(sb);
+	dinfo = au_di(root);
+	iinfo = au_ii(root_inode);
+
+	amount = bend + 1 - add_bindex;
+	branchp = sbinfo->si_branch + add_bindex;
+	memmove(branchp + 1, branchp, sizeof(*branchp) * amount);
+	*branchp = add_branch;
+	hdentryp = dinfo->di_hdentry + add_bindex;
+	memmove(hdentryp + 1, hdentryp, sizeof(*hdentryp) * amount);
+	au_h_dentry_init(hdentryp);
+	hinodep = iinfo->ii_hinode + add_bindex;
+	memmove(hinodep + 1, hinodep, sizeof(*hinodep) * amount);
+	hinodep->hi_inode = NULL;
+	au_hin_init(hinodep, NULL);
+
+	sbinfo->si_bend++;
+	dinfo->di_bend++;
+	iinfo->ii_bend++;
+	if (unlikely(bend < 0)) {
+		sbinfo->si_bend = 0;
+		dinfo->di_bstart = 0;
+		iinfo->ii_bstart = 0;
+	}
+	au_set_h_dptr(root, add_bindex, dget(dentry));
+	au_set_h_iptr(root_inode, add_bindex, au_igrab(dentry->d_inode), 0);
+	if (remount)
+		sysaufs_brs_add(sb, add_bindex);
+
+	if (!add_bindex)
+		au_cpup_attr_all(root_inode, /*force*/1);
+	else
+		au_add_nlink(root_inode, dentry->d_inode);
+	maxb = dentry->d_sb->s_maxbytes;
+	if (sb->s_maxbytes < maxb)
+		sb->s_maxbytes = maxb;
+
+	/* safe d_parent reference */
+	if (!au_xino_def_br(sbinfo)
+	    && add_branch->br_xino.xi_file
+	    && add_branch->br_xino.xi_file->f_dentry->d_parent == dentry)
+		au_xino_def_br_set(add_branch, sbinfo);
+
+ out:
+	AuTraceErr(err);
+	return err;
+}
+
+/* ---------------------------------------------------------------------- */
+
+#define AuVerbose(do_info, fmt, args...) do { \
+	if (!do_info) \
+		LKTRTrace(fmt, ##args); \
+	else \
+		AuInfo(fmt, ##args); \
+} while (0)
+
+/*
+ * test if the branch is deletable or not.
+ */
+static int test_dentry_busy(struct dentry *root, aufs_bindex_t bindex,
+			    au_gen_t sigen)
+{
+	int err, i, j, ndentry;
+	struct au_dcsub_pages dpages;
+	struct au_dpage *dpage;
+	struct dentry *d;
+	aufs_bindex_t bstart, bend;
+	unsigned char verbose;
+	struct inode *inode;
+
+	LKTRTrace("b%d, gen%d\n", bindex, sigen);
+	SiMustWriteLock(root->d_sb);
+
+	err = au_dpages_init(&dpages, GFP_NOFS);
+	if (unlikely(err))
+		goto out;
+	err = au_dcsub_pages(&dpages, root, NULL, NULL);
+	if (unlikely(err))
+		goto out_dpages;
+
+	verbose = !!au_opt_test(au_mntflags(root->d_sb), VERBOSE);
+	for (i = 0; !err && i < dpages.ndpage; i++) {
+		dpage = dpages.dpages + i;
+		ndentry = dpage->ndentry;
+		for (j = 0; !err && j < ndentry; j++) {
+			d = dpage->dentries[j];
+			AuDebugOn(!atomic_read(&d->d_count));
+			inode = d->d_inode;
+			AuDebugOn(!inode);
+			if (au_digen(d) == sigen
+			    && au_iigen(inode) == sigen)
+				di_read_lock_child(d, AuLock_IR);
+			else {
+				di_write_lock_child(d);
+				err = au_reval_dpath(d, sigen);
+				if (!err)
+					di_downgrade_lock(d, AuLock_IR);
+				else {
+					di_write_unlock(d);
+					break;
+				}
+			}
+
+			bstart = au_dbstart(d);
+			bend = au_dbend(d);
+			if (bstart <= bindex
+			    && bindex <= bend
+			    && au_h_dptr(d, bindex)
+			    && (!S_ISDIR(d->d_inode->i_mode)
+				|| bstart == bend)) {
+				err = -EBUSY;
+				AuVerbose(verbose, "busy %.*s\n", AuDLNPair(d));
+			}
+			di_read_unlock(d, AuLock_IR);
+		}
+	}
+
+ out_dpages:
+	au_dpages_free(&dpages);
+ out:
+	AuTraceErr(err);
+	return err;
+}
+
+static int test_inode_busy(struct super_block *sb, aufs_bindex_t bindex,
+			   au_gen_t sigen)
+{
+	int err;
+	struct inode *i;
+	aufs_bindex_t bstart, bend;
+	unsigned char verbose;
+
+	LKTRTrace("b%d, gen%d\n", bindex, sigen);
+	SiMustWriteLock(sb);
+
+	err = 0;
+	verbose = !!au_opt_test(au_mntflags(sb), VERBOSE);
+	list_for_each_entry(i, &sb->s_inodes, i_sb_list) {
+		AuDebugOn(!atomic_read(&i->i_count));
+		if (!list_empty(&i->i_dentry))
+			continue;
+
+		if (au_iigen(i) == sigen)
+			ii_read_lock_child(i);
+		else {
+			ii_write_lock_child(i);
+			err = au_refresh_hinode_self(i);
+			if (!err)
+				ii_downgrade_lock(i);
+			else {
+				ii_write_unlock(i);
+				break;
+			}
+		}
+
+		bstart = au_ibstart(i);
+		bend = au_ibend(i);
+		if (bstart <= bindex
+		    && bindex <= bend
+		    && au_h_iptr(i, bindex)
+		    && (!S_ISDIR(i->i_mode) || bstart == bend)) {
+			err = -EBUSY;
+			AuVerbose(verbose, "busy i%lu\n", i->i_ino);
+			ii_read_unlock(i);
+			break;
+		}
+		ii_read_unlock(i);
+	}
+
+	AuTraceErr(err);
+	return err;
+}
+
+static int test_children_busy(struct dentry *root, aufs_bindex_t bindex)
+{
+	int err;
+	au_gen_t sigen;
+
+	LKTRTrace("b%d\n", bindex);
+	SiMustWriteLock(root->d_sb);
+	DiMustWriteLock(root);
+	/* dont trust BKL */
+	AuDebugOn(!kernel_locked());
+
+	sigen = au_sigen(root->d_sb);
+	DiMustNoWaiters(root);
+	IiMustNoWaiters(root->d_inode);
+	di_write_unlock(root);
+	err = test_dentry_busy(root, bindex, sigen);
+	if (!err)
+		err = test_inode_busy(root->d_sb, bindex, sigen);
+	di_write_lock_child(root); /* aufs_write_lock() calls ..._child() */
+
+	AuTraceErr(err);
+	return err;
+}
+
+int au_br_del(struct super_block *sb, struct au_opt_del *del, int remount)
+{
+	int err, rerr, i;
+	aufs_bindex_t bindex, bend, br_id;
+	unsigned char do_wh, verbose;
+	struct au_sbinfo *sbinfo;
+	struct au_dinfo *dinfo;
+	struct au_iinfo *iinfo;
+	struct au_branch *br, **brp;
+	struct au_wbr *wbr;
+	struct au_hdentry *hdp;
+	struct au_hinode *hip;
+
+	LKTRTrace("%s, %.*s\n", del->path, AuDLNPair(del->h_root));
+	SiMustWriteLock(sb);
+	DiMustWriteLock(sb->s_root);
+	IiMustWriteLock(sb->s_root->d_inode);
+
+	err = 0;
+	bindex = au_find_dbindex(sb->s_root, del->h_root);
+	if (bindex < 0) {
+		if (remount)
+			goto out; /* success */
+		err = -ENOENT;
+		AuErr("%s no such branch\n", del->path);
+		goto out;
+	}
+	LKTRTrace("bindex b%d\n", bindex);
+
+	err = -EBUSY;
+	verbose = !!au_opt_test(au_mntflags(sb), VERBOSE);
+	bend = au_sbend(sb);
+	if (unlikely(!bend)) {
+		AuVerbose(verbose, "no more branches left\n");
+		goto out;
+	}
+	br = au_sbr(sb, bindex);
+	if (unlikely(au_br_count(br))) {
+		AuVerbose(verbose, "%d file(s) opened\n", au_br_count(br));
+		goto out;
+	}
+
+	wbr = br->br_wbr;
+	do_wh = wbr && (wbr->wbr_whbase || wbr->wbr_plink || wbr->wbr_tmp);
+	if (do_wh) {
+#if 0 /* reserved for future use */
+		/* remove whiteout base */
+		err = au_br_init_wh(sb, bindex, br, AuBr_RO, del->h_root,
+				    br->br_mnt);
+		if (unlikely(err))
+			goto out;
+#else
+		for (i = 0; i < AuBrWh_Last; i++) {
+			dput(wbr->wbr_wh[i]);
+			wbr->wbr_wh[i] = NULL;
+		}
+#endif
+	}
+
+	err = test_children_busy(sb->s_root, bindex);
+	if (unlikely(err)) {
+		if (do_wh)
+			goto out_wh;
+		goto out;
+	}
+
+	err = 0;
+	if (remount)
+		sysaufs_brs_del(sb, bindex);
+	sbinfo = au_sbi(sb);
+	dinfo = au_di(sb->s_root);
+	iinfo = au_ii(sb->s_root->d_inode);
+
+	dput(au_h_dptr(sb->s_root, bindex));
+	au_hiput(iinfo->ii_hinode + bindex);
+	br_id = br->br_id;
+	au_br_do_free(br);
+
+	/* todo: realloc and shrink memory? */
+	if (bindex < bend) {
+		const aufs_bindex_t n = bend - bindex;
+
+		brp = sbinfo->si_branch + bindex;
+		memmove(brp, brp + 1, sizeof(*brp) * n);
+		hdp = dinfo->di_hdentry + bindex;
+		memmove(hdp, hdp + 1, sizeof(*hdp) * n);
+		hip = iinfo->ii_hinode + bindex;
+		memmove(hip, hip + 1, sizeof(*hip) * n);
+	}
+	sbinfo->si_branch[0 + bend] = NULL;
+	dinfo->di_hdentry[0 + bend].hd_dentry = NULL;
+	iinfo->ii_hinode[0 + bend].hi_inode = NULL;
+	au_hin_init(iinfo->ii_hinode + bend, NULL);
+
+	sbinfo->si_bend--;
+	dinfo->di_bend--;
+	iinfo->ii_bend--;
+	if (remount)
+		sysaufs_brs_add(sb, bindex);
+
+	if (!bindex)
+		au_cpup_attr_all(sb->s_root->d_inode, /*force*/1);
+	else
+		au_sub_nlink(sb->s_root->d_inode, del->h_root->d_inode);
+	if (au_opt_test(au_mntflags(sb), PLINK))
+		au_plink_half_refresh(sb, br_id);
+
+	if (sb->s_maxbytes == del->h_root->d_sb->s_maxbytes) {
+		bend--;
+		sb->s_maxbytes = 0;
+		for (bindex = 0; bindex <= bend; bindex++) {
+			unsigned long long maxb;
+			maxb = au_sbr_sb(sb, bindex)->s_maxbytes;
+			if (sb->s_maxbytes < maxb)
+				sb->s_maxbytes = maxb;
+		}
+	}
+
+	if (au_xino_def_br(sbinfo) == br)
+		au_xino_def_br_set(NULL, sbinfo);
+	goto out; /* success */
+
+ out_wh:
+	/* revert */
+	rerr = au_br_init_wh(sb, bindex, br, br->br_perm, del->h_root,
+			     br->br_mnt);
+	if (rerr)
+		AuWarn("failed re-creating base whiteout, %s. (%d)\n",
+		       del->path, rerr);
+ out:
+	AuTraceErr(err);
+	return err;
+}
+
+static int do_need_sigen_inc(int a, int b)
+{
+	return au_br_whable(a) && !au_br_whable(b);
+}
+
+static int need_sigen_inc(int old, int new)
+{
+	return do_need_sigen_inc(old, new)
+		|| do_need_sigen_inc(new, old);
+}
+
+static int au_br_mod_files_ro(struct super_block *sb, aufs_bindex_t bindex)
+{
+	int err;
+	struct file *file, *hf;
+
+	AuTraceEnter();
+	SiMustWriteLock(sb);
+
+	/* no need file_list_lock() since sbinfo is locked */
+	err = 0;
+	list_for_each_entry(file, &sb->s_files, f_u.fu_list) {
+		LKTRTrace("%.*s\n", AuDLNPair(file->f_dentry));
+		if (!au_test_aufs_file(file))
+			continue;
+
+		fi_read_lock(file);
+		if (!S_ISREG(file->f_dentry->d_inode->i_mode)
+		    || !(file->f_mode & FMODE_WRITE)
+		    || au_fbstart(file) != bindex) {
+			FiMustNoWaiters(file);
+			fi_read_unlock(file);
+			continue;
+		}
+
+		if (unlikely(au_test_mmapped(file))) {
+			err = -EBUSY;
+			FiMustNoWaiters(file);
+			fi_read_unlock(file);
+			break;
+		}
+
+		/* todo: already flushed? */
+		hf = au_h_fptr(file, au_fbstart(file));
+		hf->f_flags = au_file_roflags(hf->f_flags);
+		hf->f_mode &= ~FMODE_WRITE;
+		put_write_access(hf->f_dentry->d_inode);
+		FiMustNoWaiters(file);
+		fi_read_unlock(file);
+	}
+
+	AuTraceErr(err);
+	return err;
+}
+
+int au_br_mod(struct super_block *sb, struct au_opt_mod *mod, int remount,
+	      int *do_update)
+{
+	int err;
+	struct dentry *root;
+	aufs_bindex_t bindex;
+	struct au_branch *br;
+	struct inode *hidden_dir;
+
+	LKTRTrace("%s, %.*s, 0x%x\n",
+		  mod->path, AuDLNPair(mod->h_root), mod->perm);
+	SiMustWriteLock(sb);
+	root = sb->s_root;
+	DiMustWriteLock(root);
+	IiMustWriteLock(root->d_inode);
+
+	bindex = au_find_dbindex(root, mod->h_root);
+	if (bindex < 0) {
+		if (remount)
+			return 0; /* success */
+		err = -ENOENT;
+		AuErr("%s no such branch\n", mod->path);
+		goto out;
+	}
+	LKTRTrace("bindex b%d\n", bindex);
+
+	hidden_dir = mod->h_root->d_inode;
+	err = test_br(sb, hidden_dir, mod->perm, mod->path);
+	if (unlikely(err))
+		goto out;
+
+	br = au_sbr(sb, bindex);
+	if (br->br_perm == mod->perm)
+		return 0; /* success */
+
+	if (au_br_writable(br->br_perm)) {
+#if 1
+		/* remove whiteout base */
+		err = au_br_init_wh(sb, bindex, br, mod->perm, mod->h_root,
+				    br->br_mnt);
+		if (unlikely(err))
+			goto out;
+#else /* reserved for future use */
+		struct au_wbr *wbr;
+		wbr = br->wbr;
+		if (wbr)
+			for (i = 0; i < AuBrWh_Last; i++) {
+				dput(wbr->wbr_wh[i]);
+				wbr->wbr_wh[i] = NULL;
+			}
+#endif
+
+		if (!au_br_writable(mod->perm)) {
+			/* rw --> ro, file might be mmapped */
+
+#if 1 /* todo: test more? */
+			DiMustNoWaiters(root);
+			IiMustNoWaiters(root->d_inode);
+			di_write_unlock(root);
+			err = au_br_mod_files_ro(sb, bindex);
+			/* aufs_write_lock() calls ..._child() */
+			di_write_lock_child(root);
+#endif
+		}
+	} else if (au_br_writable(mod->perm)) {
+		/* ro --> rw */
+		err = -ENOMEM;
+		br->br_wbr = kmalloc(sizeof(*br->br_wbr), GFP_NOFS);
+		if (br->br_wbr) {
+			struct path path = {
+				.mnt	= br->br_mnt,
+				.dentry	= mod->h_root
+			};
+
+			err = au_wbr_init(br, sb, mod->perm, &path);
+			if (unlikely(err)) {
+				kfree(br->br_wbr);
+				br->br_wbr = NULL;
+			}
+		}
+	}
+
+	if (!err) {
+		*do_update |= need_sigen_inc(br->br_perm, mod->perm);
+		br->br_perm = mod->perm;
+	}
+
+ out:
+	AuTraceErr(err);
+	return err;
+}
diff -Nurp linux-2.6.27.orig/fs/aufs/branch.h linux-2.6.27/fs/aufs/branch.h
--- linux-2.6.27.orig/fs/aufs/branch.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.27/fs/aufs/branch.h	2008-12-14 10:37:40.000000000 +0100
@@ -0,0 +1,436 @@
+/*
+ * Copyright (C) 2005-2008 Junjiro Okajima
+ *
+ * This program, aufs is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+ */
+
+/*
+ * branch filesystems and xino for them
+ *
+ * $Id: branch.h,v 1.16 2008/11/17 02:12:17 sfjro Exp $
+ */
+
+#ifndef __AUFS_BRANCH_H__
+#define __AUFS_BRANCH_H__
+
+#ifdef __KERNEL__
+
+#include <linux/fs.h>
+#include <linux/mount.h>
+#include <linux/sysfs.h>
+#include <linux/aufs_type.h>
+#include "misc.h"
+#include "super.h"
+
+/* ---------------------------------------------------------------------- */
+
+/* an entry in a xino file */
+struct au_xino_entry {
+	ino_t ino;
+	/* __u32 h_gen; */ /* reserved for future use */
+} __packed;
+
+/* reserved for future use */
+/* #define AuXino_INVALID_HGEN	(-1) */
+
+/* a xino file */
+struct au_xino_file {
+	struct file		*xi_file;
+	struct mutex		xi_nondir_mtx;
+
+	/* reserved for future use */
+#if 0
+	struct file		**xi_file;
+
+	/* array management */
+	unsigned long long	xi_limit;	/* Max xino file size */
+	unsigned long long	xi_size;	 /* s_maxbytes */
+
+	/* truncation */
+	unsigned long long	xi_upper;	/* watermark in bytes */
+	unsigned long long	xi_step;	/* to next watermark in bytes */
+
+	/* truncation */
+	blkcnt_t		xi_upper;	/* watermark in blocks */
+	atomic_t 		xi_running;
+#endif
+};
+
+/* members for writable branch only */
+enum {AuBrWh_BASE, AuBrWh_PLINK, AuBrWh_TMP, AuBrWh_Last};
+struct au_wbr {
+	struct au_rwsem		wbr_wh_rwsem;
+	struct dentry		*wbr_wh[AuBrWh_Last];
+	atomic_t 		wbr_wh_running;
+#define wbr_whbase		wbr_wh[AuBrWh_BASE]	/* whiteout base */
+#define wbr_plink		wbr_wh[AuBrWh_PLINK]	/* pseudo-link dir */
+#define wbr_tmp			wbr_wh[AuBrWh_TMP]	/* temporary dir */
+
+	/* mfs mode */
+	unsigned long long	wbr_bytes;
+};
+
+/* protected by superblock rwsem */
+struct au_branch {
+	struct au_xino_file	br_xino;
+
+	aufs_bindex_t		br_id;
+
+	int			br_perm;
+	struct vfsmount		*br_mnt;
+	atomic_t		br_count;
+
+	struct au_wbr		*br_wbr;
+
+#if 1 /* reserved for future use */
+	/* xino truncation */
+	blkcnt_t		br_xino_upper;	/* watermark in blocks */
+	atomic_t		br_xino_running;
+#endif
+
+#ifdef CONFIG_SYSFS
+	/* an entry under sysfs per mount-point */
+	char			br_name[8];
+	struct attribute	br_attr;
+#endif
+
+	au_gen_t		br_generation;
+};
+
+/* ---------------------------------------------------------------------- */
+
+/* branch permission and attribute */
+enum {
+	AuBrPerm_RW,		/* writable, linkable wh */
+	AuBrPerm_RO,		/* readonly, no wh */
+	AuBrPerm_RR,		/* natively readonly, no wh */
+
+	AuBrPerm_RWNoLinkWH,	/* un-linkable whiteouts */
+
+	AuBrPerm_ROWH,
+	AuBrPerm_RRWH,		/* whiteout-able */
+
+	AuBrPerm_Last
+};
+
+static inline int au_br_writable(int brperm)
+{
+	return brperm == AuBrPerm_RW || brperm == AuBrPerm_RWNoLinkWH;
+}
+
+static inline int au_br_whable(int brperm)
+{
+	return brperm == AuBrPerm_RW
+		|| brperm == AuBrPerm_ROWH
+		|| brperm == AuBrPerm_RRWH;
+}
+
+#if 0 /* reserved for future use */
+static inline int au_br_linkable_wh(int brperm)
+{
+	return brperm == AuBrPerm_RW;
+}
+#endif
+
+static inline int au_br_hinotifyable(int brperm)
+{
+#ifdef CONFIG_AUFS_HINOTIFY
+	return brperm != AuBrPerm_RR && brperm != AuBrPerm_RRWH;
+#else
+	return 0;
+#endif
+}
+
+/* ---------------------------------------------------------------------- */
+
+/* branch.c */
+struct au_sbinfo;
+void au_br_free(struct au_sbinfo *sinfo);
+int au_test_def_rr(struct super_block *h_sb);
+int au_br_index(struct super_block *sb, aufs_bindex_t br_id);
+struct au_opt_add;
+int au_br_add(struct super_block *sb, struct au_opt_add *add, int remount);
+struct au_opt_del;
+int au_br_del(struct super_block *sb, struct au_opt_del *del, int remount);
+struct au_opt_mod;
+int au_br_mod(struct super_block *sb, struct au_opt_mod *mod, int remount,
+	      int *do_update);
+
+/* xino.c */
+#define Au_LOFF_MAX	((loff_t)LLONG_MAX)
+int au_xib_trunc(struct super_block *sb);
+ssize_t xino_fread(au_readf_t func, struct file *file, void *buf, size_t size,
+		   loff_t *pos);
+ssize_t xino_fwrite(au_writef_t func, struct file *file, void *buf, size_t size,
+		    loff_t *pos);
+struct file *au_xino_create(struct super_block *sb, char *fname, int silent);
+struct file *au_xino_create2(struct super_block *sb, struct file *base_file,
+			     struct file *copy_src);
+ino_t au_xino_new_ino(struct super_block *sb);
+int au_xino_write0(struct super_block *sb, aufs_bindex_t bindex, ino_t h_ino,
+		   ino_t ino);
+int au_xino_write(struct super_block *sb, aufs_bindex_t bindex, ino_t h_ino,
+		  struct au_xino_entry *xinoe);
+int au_xino_read(struct super_block *sb, aufs_bindex_t bindex, ino_t h_ino,
+		 struct au_xino_entry *xinoe);
+int au_xino_br(struct super_block *sb, struct au_branch *br, ino_t hino,
+	       struct file *base_file, int do_test);
+int au_xino_trunc(struct super_block *sb, aufs_bindex_t bindex);
+
+struct au_opt_xino;
+int au_xino_set(struct super_block *sb, struct au_opt_xino *xino, int remount);
+void au_xino_clr(struct super_block *sb);
+struct file *au_xino_def(struct super_block *sb);
+
+struct au_opt_xinodir;
+#if 0 /* def CONFIG_AUFS_EXPORT */ /* reserved for future use */
+/* export.c */
+int au_xinodir_br(struct super_block *sb, struct au_branch *br, ino_t hino,
+		  int do_test);
+int au_xinodir_set(struct super_block *sb, struct au_opt_xinodir *xinodir,
+		   int remount);
+#else
+static inline
+int au_xinodir_br(struct super_block *sb, struct au_branch *br, ino_t hino,
+		  int do_test)
+{
+	return 0;
+}
+
+static inline
+int au_xinodir_set(struct super_block *sb, struct au_opt_xinodir *xinodir,
+		   int remount)
+{
+	return 0;
+}
+#endif
+
+/* ---------------------------------------------------------------------- */
+
+/* todo: memory barrier? */
+static inline int au_br_count(struct au_branch *br)
+{
+	return atomic_read(&br->br_count);
+}
+
+static inline int au_br_get(struct au_branch *br)
+{
+	return atomic_inc_return(&br->br_count);
+}
+
+static inline int au_br_put(struct au_branch *br)
+{
+	return atomic_dec_return(&br->br_count);
+}
+
+static inline au_gen_t au_br_gen(struct au_branch *br)
+{
+	return br->br_generation;
+}
+
+/*
+ * test if the @br is readonly or not.
+ */
+static inline int au_br_rdonly(struct au_branch *br)
+{
+	return ((br->br_mnt->mnt_sb->s_flags & MS_RDONLY)
+		|| !au_br_writable(br->br_perm))
+		? -EROFS : 0;
+}
+
+/* ---------------------------------------------------------------------- */
+
+/* Superblock to branch */
+static inline
+aufs_bindex_t au_sbr_id(struct super_block *sb, aufs_bindex_t bindex)
+{
+	return au_sbr(sb, bindex)->br_id;
+}
+
+static inline
+struct vfsmount *au_sbr_mnt(struct super_block *sb, aufs_bindex_t bindex)
+{
+	return au_sbr(sb, bindex)->br_mnt;
+}
+
+static inline
+struct super_block *au_sbr_sb(struct super_block *sb, aufs_bindex_t bindex)
+{
+	return au_sbr_mnt(sb, bindex)->mnt_sb;
+}
+
+#if 0 /* reserved for future use */
+static inline int au_sbr_count(struct super_block *sb, aufs_bindex_t bindex)
+{
+	return au_br_count(au_sbr(sb, bindex));
+}
+
+static inline void au_sbr_get(struct super_block *sb, aufs_bindex_t bindex)
+{
+	au_br_get(au_sbr(sb, bindex));
+}
+#endif
+
+static inline void au_sbr_put(struct super_block *sb, aufs_bindex_t bindex)
+{
+	au_br_put(au_sbr(sb, bindex));
+}
+
+static inline int au_sbr_perm(struct super_block *sb, aufs_bindex_t bindex)
+{
+	return au_sbr(sb, bindex)->br_perm;
+}
+
+static inline int au_sbr_whable(struct super_block *sb, aufs_bindex_t bindex)
+{
+	return au_br_whable(au_sbr_perm(sb, bindex));
+}
+
+static inline int au_br_want_write(struct au_branch *br)
+{
+	int err;
+
+	AuDebugOn(!au_br_writable(br->br_perm));
+	err = au_mnt_want_write(br->br_mnt);
+	AuTraceErr(err);
+	return err;
+}
+
+static inline void au_br_drop_write(struct au_branch *br)
+{
+	AuDebugOn(!au_br_writable(br->br_perm));
+	au_mnt_drop_write(br->br_mnt);
+}
+
+static inline int au_test_trunc_xino(struct super_block *sb)
+{
+	return au_test_tmpfs(sb);
+}
+
+/* temporary support for i#1 in cramfs */
+static inline int au_test_unique_ino(struct dentry *h_dentry, ino_t h_ino)
+{
+#if defined(CONFIG_CRAMFS) || defined(CONFIG_CRAMFS_MODULE)
+	if (unlikely(h_dentry->d_sb->s_magic == CRAMFS_MAGIC))
+		return h_ino != 1;
+#endif
+	return 1;
+}
+
+static inline struct vfsmount *au_do_nfsmnt(struct vfsmount *h_mnt)
+{
+	if (!au_test_nfs(h_mnt->mnt_sb))
+		return NULL;
+	return h_mnt;
+}
+
+static inline void au_br_nfs_lockdep_off(struct super_block *sb)
+{
+	if (au_test_nfs(sb))
+		lockdep_off();
+}
+
+static inline void au_br_nfs_lockdep_on(struct super_block *sb)
+{
+	/* hoping this condition will be optimized... */
+	if (au_test_nfs(sb))
+		lockdep_on();
+}
+
+#ifdef CONFIG_AUFS_BR_NFS
+static inline int au_test_unsupported_nfs(struct super_block *h_sb)
+{
+	return 0;
+}
+
+/* it doesn't mntget() */
+static inline
+struct vfsmount *au_nfsmnt(struct super_block *sb, aufs_bindex_t bindex)
+{
+	return au_do_nfsmnt(au_sbr_mnt(sb, bindex));
+}
+
+#define AuNoNfsBranchMsg "dummy"
+
+#else
+static inline int au_test_unsupported_nfs(struct super_block *h_sb)
+{
+	return h_sb->s_magic == NFS_SUPER_MAGIC;
+}
+
+/* it doesn't mntget() */
+static inline
+struct vfsmount *au_nfsmnt(struct super_block *sb, aufs_bindex_t bindex)
+{
+	return NULL;
+}
+
+#define AuNoNfsBranchMsg "NFS branch is not supported" \
+	", try some configurations and patches included in aufs source CVS."
+
+#endif /* CONFIG_AUFS_BR_NFS */
+
+#ifdef CONFIG_AUFS_BR_NFS_V4
+static inline int au_test_unsupported_nfs4(struct super_block *h_sb)
+{
+	return 0;
+}
+
+#define AuNoNfsv4BranchMsg "dummy"
+
+#else
+static inline int au_test_unsupported_nfs4(struct super_block *h_sb)
+{
+	return h_sb->s_magic == NFS_SUPER_MAGIC
+		&& !strcmp(h_sb->s_type->name, "nfs4");
+}
+
+#define AuNoNfsv4BranchMsg "NFSv4 branch is not supported" \
+	", try some configurations and patches included in aufs source CVS."
+
+#endif /* CONFIG_AUFS_BR_NFS_v4 */
+
+/* support atomic open */
+static inline int au_test_fs_intent(struct super_block *h_sb)
+{
+	return au_test_nfs4(h_sb) /*|| au_test_fuse(h_sb)*/;
+}
+
+/* ---------------------------------------------------------------------- */
+
+/*
+ * br_wh_read_lock, br_wh_write_lock
+ * br_wh_read_unlock, br_wh_write_unlock, br_wh_downgrade_lock
+ */
+AuSimpleRwsemFuncs(wbr_wh, struct au_wbr *wbr, wbr->wbr_wh_rwsem);
+
+/* to debug easier, do not make them inlined functions */
+#define WbrWhMustReadLock(wbr) do { \
+	/* SiMustAnyLock(sb); */ \
+	AuRwMustReadLock(&(wbr)->wbr_wh_rwsem); \
+} while (0)
+
+#define WbrWhMustWriteLock(wbr) do { \
+	/* SiMustAnyLock(sb); */ \
+	AuRwMustWriteLock(&(wbr)->wbr_wh_rwsem); \
+} while (0)
+
+#define WbrWhMustAnyLock(br) do { \
+	/* SiMustAnyLock(sb); */ \
+	AuRwMustAnyLock(&(wbr)->wbr_wh_rwsem); \
+} while (0)
+
+#endif /* __KERNEL__ */
+#endif /* __AUFS_BRANCH_H__ */
diff -Nurp linux-2.6.27.orig/fs/aufs/br_fuse.c linux-2.6.27/fs/aufs/br_fuse.c
--- linux-2.6.27.orig/fs/aufs/br_fuse.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.27/fs/aufs/br_fuse.c	2008-12-14 10:37:40.000000000 +0100
@@ -0,0 +1,80 @@
+/*
+ * Copyright (C) 2005-2008 Junjiro Okajima
+ *
+ * This program, aufs is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+ */
+
+/*
+ * special handling for inode attributes on FUSE branch
+ *
+ * $Id: br_fuse.c,v 1.7 2008/12/01 03:49:29 sfjro Exp $
+ */
+
+#include "aufs.h"
+
+/* h_mnt can be NULL, is it safe? */
+int au_update_fuse_h_inode(struct vfsmount *h_mnt, struct dentry *h_dentry)
+{
+	int err;
+	struct kstat st;
+
+	LKTRTrace("%.*s\n", AuDLNPair(h_dentry));
+
+	err = 0;
+	if (h_dentry->d_inode
+	    /* && atomic_read(&h_dentry->d_inode->i_count) */
+	    && au_test_fuse(h_dentry->d_sb)) {
+		err = vfsub_getattr(h_mnt, h_dentry, &st, /*dlgt*/0);
+		if (unlikely(err)) {
+			AuDbg("err %d\n", err);
+			au_debug_on();
+			AuDbgDentry(h_dentry);
+			au_debug_off();
+			WARN_ON(err);
+		}
+	}
+	return err;
+}
+
+#if 0 /* temp */
+/*
+ * This function was born after a discussion with the FUSE developer.
+ * The inode attributes on a filesystem who defines i_op->getattr()
+ * is unreliable since such fs may not maintain the attributes at lookup.
+ * This function doesn't want the result of stat, instead wants the side-effect
+ * which refreshes the attributes.
+ * Hmm, there seems to be no such filesystem except fuse.
+ */
+int vfsub_i_attr(struct vfsmount *mnt, struct dentry *dentry, int dlgt)
+{
+	int err;
+	struct inode *inode;
+	struct inode_operations *op;
+	struct kstat st;
+
+	inode = dentry->d_inode;
+	AuDebugOn(!inode);
+
+	err = 0;
+	op = inode->i_op;
+	if (op && op->getattr && !au_test_aufs(dentry->d_sb)) {
+		err = security_inode_getattr(mnt, dentry);
+		if (!err)
+			err = op->getattr(mnt, dentry, &st);
+	}
+	AuTraceErr(err);
+	return err;
+}
+#endif
diff -Nurp linux-2.6.27.orig/fs/aufs/br_nfs.c linux-2.6.27/fs/aufs/br_nfs.c
--- linux-2.6.27.orig/fs/aufs/br_nfs.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.27/fs/aufs/br_nfs.c	2008-12-14 10:37:40.000000000 +0100
@@ -0,0 +1,356 @@
+/*
+ * Copyright (C) 2005-2008 Junjiro Okajima
+ *
+ * This program, aufs is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+ */
+
+/*
+ * lookup functions for NFS branch in linux-2.6.19 and later
+ *
+ * $Id: br_nfs.c,v 1.9 2008/12/01 03:49:29 sfjro Exp $
+ */
+
+#include "aufs.h"
+
+static struct file *au_find_h_intent(struct au_hdentry *hd, struct file *file)
+{
+	struct file *h_file, *hf;
+	struct au_hdintent *hdi, *tmp, *do_free;
+
+	LKTRTrace("%.*s\n", AuDLNPair(hd->hd_dentry));
+
+	h_file = NULL;
+	do_free = NULL;
+	spin_lock(&hd->hd_lock);
+	list_for_each_entry_safe(hdi, tmp, hd->hd_intent_list, hdi_list) {
+		hf = hdi->hdi_file[AuIntent_BRANCH];
+		if (hdi->hdi_file[AuIntent_AUFS] == file
+		    && hf->f_dentry == hd->hd_dentry) {
+			h_file = hf;
+			do_free = hdi;
+			list_del(&hdi->hdi_list);
+			break;
+		}
+	}
+	spin_unlock(&hd->hd_lock);
+	kfree(do_free);
+
+	return h_file;
+}
+
+struct file *au_h_intent(struct dentry *dentry, aufs_bindex_t bindex,
+			 struct file *file)
+{
+	struct file *h_file;
+	struct au_hdentry *hd = au_di(dentry)->di_hdentry + bindex;
+
+	LKTRTrace("%.*s, b%d, f %p\n", AuDLNPair(dentry), bindex, file);
+	DiMustAnyLock(dentry);
+	AuDebugOn(bindex < au_di(dentry)->di_bstart
+		  || bindex > au_di(dentry)->di_bend);
+
+	h_file = NULL;
+	if (!hd->hd_intent_list || !file)
+		return h_file; /* success */
+
+	/* AuDebugOn(au_test_wkq(current)); */
+	h_file = au_find_h_intent(hd, file);
+	return h_file;
+}
+
+static int au_set_h_intent(struct dentry *dentry, aufs_bindex_t bindex,
+			   struct file *file, struct file *h_file)
+{
+	int err;
+	struct au_hdentry *hd = au_di(dentry)->di_hdentry + bindex;
+	struct au_hdintent *hdi;
+	struct file *hf;
+
+	LKTRTrace("%.*s, b%d, f %p\n", AuDLNPair(dentry), bindex, file);
+	/* d_revalidate() holds read_lock */
+	/* DiMustWriteLock(dentry); */
+	AuDebugOn(bindex < au_di(dentry)->di_bstart
+		  || bindex > au_di(dentry)->di_bend
+		  || !file
+		  || !h_file
+		  /* || au_test_wkq(current) */);
+
+	err = -ENOMEM;
+	if (hd->hd_intent_list) {
+		while (1) {
+			hf = au_find_h_intent(hd, file);
+			if (!hf)
+				break;
+			fput(hf);
+			AuWarn("freed hfile %.*s b%d left\n",
+			       AuDLNPair(dentry), bindex);
+		}
+	} else {
+		spin_lock(&hd->hd_lock);
+		if (!hd->hd_intent_list) {
+			hd->hd_intent_list
+				= kmalloc(sizeof(*hd->hd_intent_list),
+					  GFP_ATOMIC);
+			if (unlikely(!hd->hd_intent_list)) {
+				spin_unlock(&hd->hd_lock);
+				goto out;
+			}
+			INIT_LIST_HEAD(hd->hd_intent_list);
+		}
+		spin_unlock(&hd->hd_lock);
+	}
+
+	hdi = kmalloc(sizeof(*hdi), GFP_NOFS);
+	if (unlikely(!hdi))
+		goto out;
+
+	err = 0;
+	/* hdi->hdi_pid = current->pid; */
+	hdi->hdi_file[AuIntent_AUFS] = file;
+	hdi->hdi_file[AuIntent_BRANCH] = h_file;
+	spin_lock(&hd->hd_lock);
+	list_add(&hdi->hdi_list, hd->hd_intent_list);
+	spin_unlock(&hd->hd_lock);
+
+ out:
+	AuTraceErr(err);
+	return err;
+}
+
+int au_br_nfs_h_intent(struct file *nd_file, struct dentry *dentry,
+		       aufs_bindex_t bindex, struct nameidata *nd)
+{
+	int err;
+
+	AuTraceEnter();
+
+	err = 0;
+	if (!nd_file)
+		goto out;
+
+	AuDebugOn(!nd);
+	err = au_set_h_intent(dentry, bindex, nd->intent.open.file, nd_file);
+	if (unlikely(err)) {
+		fput(nd_file);
+		au_set_h_dptr(dentry, bindex, NULL);
+		/* todo: update bstart and bend? */
+	}
+
+ out:
+	AuTraceErr(err);
+	return err;
+}
+
+/* ---------------------------------------------------------------------- */
+
+void au_hintent_put(struct au_hdentry *hd, int do_free)
+{
+	struct au_hdintent *hdi, *tmp;
+	struct file *hf;
+
+	if (hd->hd_intent_list) {
+		/* no spin lock */
+		list_for_each_entry_safe(hdi, tmp, hd->hd_intent_list,
+					 hdi_list) {
+			LKTRTrace("hdi %p\n", hdi);
+			hf = hdi->hdi_file[AuIntent_BRANCH];
+			if (hf)
+				fput(hf);
+			/* list_del(&hdi->hdi_list); */
+			kfree(hdi);
+		}
+		if (do_free)
+			kfree(hd->hd_intent_list);
+	}
+}
+
+/* ---------------------------------------------------------------------- */
+
+int au_fake_intent(/* struct au_ndsub *save,  */struct nameidata *nd,
+		   struct au_branch *br)
+{
+	int err;
+
+	LKTRTrace("perm %d\n", br->br_perm);
+
+	err = 0;
+	nd->intent.open.file = NULL;
+	if (nd->flags & LOOKUP_OPEN) {
+		if (au_test_fs_intent(br->br_mnt->mnt_sb)) {
+			err = -ENFILE;
+			nd->intent.open.file = get_empty_filp();
+			if (unlikely(!nd->intent.open.file))
+				goto out;
+			err = 0;
+		}
+		if (!au_br_writable(br->br_perm)) {
+			nd->intent.open.flags = FMODE_READ
+				| au_file_roflags(nd->intent.open.flags);
+			nd->flags &= ~LOOKUP_CREATE;
+		}
+	}
+
+ out:
+	AuTraceErr(err);
+	return err;
+}
+
+static void au_put_filp(struct file *file)
+{
+#if !defined(CONFIG_AUFS_MODULE) || defined(CONFIG_AUFS_PUT_FILP_PATCH)
+	if (unlikely(file))
+		put_filp(file);
+#else
+	WARN_ONCE(file, "unexpected put_fillp() call");
+#endif
+}
+
+int au_hin_after_reval(struct nameidata *nd, struct dentry *dentry,
+		       aufs_bindex_t bindex, struct file *file)
+{
+	int err;
+
+	LKTRTrace("nd %p, %.*s, b%d, f %d\n",
+		  nd, AuDLNPair(dentry), bindex, !!file);
+
+	err = 0;
+	if ((nd->flags & LOOKUP_OPEN)
+	    && nd->intent.open.file
+	    && !IS_ERR(nd->intent.open.file)) {
+		if (nd->intent.open.file->f_dentry) {
+			err = au_set_h_intent(dentry, bindex, file,
+					      nd->intent.open.file);
+			if (!err)
+				nd->intent.open.file = NULL;
+		}
+		au_put_filp(nd->intent.open.file);
+	}
+
+	return err;
+}
+
+#ifdef CONFIG_AUFS_DLGT
+struct au_lookup_hash_args {
+	struct dentry **errp;
+	struct qstr *name;
+	struct dentry *base;
+	struct nameidata *nd;
+};
+
+static void au_call_lookup_hash(void *args)
+{
+	struct au_lookup_hash_args *a = args;
+	*a->errp = vfsub__lookup_hash(a->name, a->base, a->nd);
+}
+
+static struct dentry *
+au_lkup_hash_dlgt(struct qstr *this, struct dentry *parent,
+		  struct nameidata *nd, unsigned int flags)
+{
+	struct dentry *dentry;
+	int dirperm1;
+
+	dirperm1 = au_ftest_ndx(flags, DIRPERM1);
+	if (!dirperm1 && !au_ftest_ndx(flags, DLGT))
+		dentry = vfsub__lookup_hash(this, parent, nd);
+	else {
+		int wkq_err;
+		struct au_lookup_hash_args args = {
+			.errp	= &dentry,
+			.name	= this,
+			.base	= parent,
+			.nd	= nd
+		};
+		wkq_err = au_wkq_wait(au_call_lookup_hash, &args,
+				      /*dlgt*/!dirperm1);
+		if (unlikely(wkq_err))
+			dentry = ERR_PTR(wkq_err);
+	}
+
+	AuTraceErrPtr(dentry);
+	return dentry;
+}
+#else
+static struct dentry *
+au_lkup_hash_dlgt(struct qstr *this, struct dentry *parent,
+		  struct nameidata *nd, unsigned int flags)
+{
+	return vfsub__lookup_hash(this, parent, nd);
+}
+#endif /* CONFIG_AUFS_DLGT */
+
+struct dentry *au_lkup_hash(const char *name, struct dentry *parent,
+			    int len, struct au_ndx *ndx)
+{
+	struct dentry *dentry;
+	char *p;
+	unsigned long hash;
+	struct qstr this;
+	unsigned int c;
+	struct nameidata tmp_nd, *ndo;
+	int err;
+
+	LKTRTrace("%.*s/%.*s\n", AuDLNPair(parent), len, name);
+
+	/* todo: export and call __lookup_one_len() in fs/namei.c? */
+	dentry = ERR_PTR(-EACCES);
+	this.name = name;
+	this.len = len;
+	if (unlikely(!len))
+		goto out;
+
+	p = (void *)name;
+	hash = init_name_hash();
+	while (len--) {
+		c = *p++;
+		if (unlikely(c == '/' || c == '\0'))
+			goto out;
+		hash = partial_name_hash(c, hash);
+	}
+	this.hash = end_name_hash(hash);
+
+	ndo = ndx->nd;
+	if (ndo) {
+		tmp_nd = *ndo;
+		err = au_fake_intent(&tmp_nd, ndx->br);
+		dentry = ERR_PTR(err);
+		if (unlikely(err))
+			goto out_intent;
+	} else
+		memset(&tmp_nd, 0, sizeof(tmp_nd));
+
+	tmp_nd.path.dentry = parent;
+	tmp_nd.path.mnt = ndx->nfsmnt;
+	path_get(&tmp_nd.path);
+	dentry = au_lkup_hash_dlgt(&this, parent, &tmp_nd, ndx->flags);
+	if (!IS_ERR(dentry)) {
+		/* why negative dentry for a new dir was unhashed? */
+		if (unlikely(d_unhashed(dentry)))
+			d_rehash(dentry);
+		if (tmp_nd.intent.open.file
+		    && tmp_nd.intent.open.file->f_dentry) {
+			ndx->nd_file = tmp_nd.intent.open.file;
+			tmp_nd.intent.open.file = NULL;
+			/* au_br_get(ndx->br); */
+		}
+	}
+	path_put(&tmp_nd.path);
+
+ out_intent:
+	au_put_filp(tmp_nd.intent.open.file);
+ out:
+	AuTraceErrPtr(dentry);
+	return dentry;
+}
diff -Nurp linux-2.6.27.orig/fs/aufs/br_xfs.c linux-2.6.27/fs/aufs/br_xfs.c
--- linux-2.6.27.orig/fs/aufs/br_xfs.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.27/fs/aufs/br_xfs.c	2008-07-07 03:12:38.000000000 +0200
@@ -0,0 +1,69 @@
+/*
+ * Copyright (C) 2005-2008 Junjiro Okajima
+ *
+ * This program, aufs is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+ */
+
+/*
+ * special handling inode attributes on XFS branch in linux-2.6.24 and later
+ *
+ * $Id: br_xfs.c,v 1.3 2008/07/07 01:12:38 sfjro Exp $
+ */
+
+#include "aufs.h"
+
+/* h_mnt can be NULL, is it safe? */
+dev_t au_h_rdev(struct inode *h_inode, struct vfsmount *h_mnt,
+		struct dentry *h_dentry)
+{
+	dev_t rdev;
+	int err;
+	struct kstat st;
+
+	LKTRTrace("hi%lu\n", h_inode->i_ino);
+	if (h_dentry)
+		LKTRTrace("%.*s\n", AuDLNPair(h_dentry));
+
+	rdev = h_inode->i_rdev;
+	if (!rdev || !au_test_xfs(h_inode->i_sb))
+		goto out;
+
+	rdev = 0;
+	if (!h_dentry) {
+		err = 0;
+		h_dentry = d_find_alias(h_inode);
+		if (unlikely(!h_dentry))
+			goto failure;
+		err = PTR_ERR(h_dentry);
+		if (IS_ERR(h_dentry)) {
+			h_dentry = NULL;
+			goto failure;
+		}
+		LKTRTrace("%.*s\n", AuDLNPair(h_dentry));
+	} else
+		dget(h_dentry);
+
+	err = vfsub_getattr(h_mnt, h_dentry, &st, /*dlgt*/0);
+	dput(h_dentry);
+	if (!err) {
+		rdev = st.rdev;
+		goto out; /* success */
+	}
+
+ failure:
+	AuIOErr("failed rdev for XFS inode, hi%lu, %d\n", h_inode->i_ino, err);
+ out:
+	return rdev;
+}
diff -Nurp linux-2.6.27.orig/fs/aufs/cpup.c linux-2.6.27/fs/aufs/cpup.c
--- linux-2.6.27.orig/fs/aufs/cpup.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.27/fs/aufs/cpup.c	2008-12-14 10:37:40.000000000 +0100
@@ -0,0 +1,1137 @@
+/*
+ * Copyright (C) 2005-2008 Junjiro Okajima
+ *
+ * This program, aufs is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+ */
+
+/*
+ * copy-up functions, see wbr_policy.c for copy-down
+ *
+ * $Id: cpup.c,v 1.22 2008/12/01 03:49:29 sfjro Exp $
+ */
+
+#include <linux/fs_stack.h>
+#include <linux/uaccess.h>
+#include "aufs.h"
+
+/* todo? violent cpup_attr_*() functions don't care inode lock */
+
+void au_cpup_attr_timesizes(struct inode *inode)
+{
+	struct inode *h_inode;
+
+	LKTRTrace("i%lu\n", inode->i_ino);
+	/* todo? IMustLock(inode); */
+	h_inode = au_h_iptr(inode, au_ibstart(inode));
+	AuDebugOn(!h_inode);
+	/* todo? IMustLock(!h_inode); */
+
+	fsstack_copy_attr_times(inode, h_inode);
+	vfsub_copy_inode_size(inode, h_inode);
+}
+
+void au_cpup_attr_nlink(struct inode *inode, int force)
+{
+	struct inode *h_inode;
+	struct super_block *sb;
+	aufs_bindex_t bindex, bend;
+
+	LKTRTrace("i%lu\n", inode->i_ino);
+	/* todo? IMustLock(inode); */
+	AuDebugOn(!inode->i_mode);
+
+	sb = inode->i_sb;
+	bindex = au_ibstart(inode);
+	h_inode = au_h_iptr(inode, bindex);
+
+	if (!force
+	    && !S_ISDIR(h_inode->i_mode)
+	    && au_opt_test(au_mntflags(sb), PLINK)
+	    && au_plink_test(sb, inode))
+		return;
+
+	inode->i_nlink = h_inode->i_nlink;
+
+	/*
+	 * fewer nlink makes find(1) noisy, but larger nlink doesn't.
+	 * it may includes whplink directory.
+	 */
+	if (S_ISDIR(h_inode->i_mode)) {
+		bend = au_ibend(inode);
+		for (bindex++; bindex <= bend; bindex++) {
+			h_inode = au_h_iptr(inode, bindex);
+			if (h_inode)
+				au_add_nlink(inode, h_inode);
+		}
+	}
+}
+
+void au_cpup_attr_changeable(struct inode *inode)
+{
+	struct inode *h_inode;
+
+	LKTRTrace("i%lu\n", inode->i_ino);
+	/* todo? IMustLock(inode); */
+	h_inode = au_h_iptr(inode, au_ibstart(inode));
+	AuDebugOn(!h_inode);
+
+	inode->i_mode = h_inode->i_mode;
+	inode->i_uid = h_inode->i_uid;
+	inode->i_gid = h_inode->i_gid;
+	au_cpup_attr_timesizes(inode);
+
+	/* todo: remove this? */
+	inode->i_flags = h_inode->i_flags;
+}
+
+void au_cpup_igen(struct inode *inode, struct inode *h_inode)
+{
+	struct au_iinfo *iinfo = au_ii(inode);
+	iinfo->ii_higen = h_inode->i_generation;
+	iinfo->ii_hsb1 = h_inode->i_sb;
+}
+
+void au_cpup_attr_all(struct inode *inode, int force)
+{
+	struct inode *h_inode;
+
+	LKTRTrace("i%lu\n", inode->i_ino);
+	/* todo? IMustLock(inode); */
+	h_inode = au_h_iptr(inode, au_ibstart(inode));
+	AuDebugOn(!h_inode);
+
+	au_cpup_attr_changeable(inode);
+	if (inode->i_nlink > 0)
+		au_cpup_attr_nlink(inode, force);
+
+	switch (inode->i_mode & S_IFMT) {
+	case S_IFBLK:
+	case S_IFCHR:
+		inode->i_rdev = au_h_rdev(h_inode, /*h_mnt*/NULL,
+					  /*h_dentry*/NULL);
+	}
+	inode->i_blkbits = h_inode->i_blkbits;
+	au_cpup_igen(inode, h_inode);
+}
+
+/* ---------------------------------------------------------------------- */
+
+/* Note: dt_dentry and dt_hidden_dentry are not dget/dput-ed */
+
+/* keep the timestamps of the parent dir when cpup */
+void au_dtime_store(struct au_dtime *dt, struct dentry *dentry,
+		    struct dentry *h_dentry, struct au_hinode *hinode,
+		    struct au_hinode *hdir)
+{
+	struct inode *h_inode;
+
+	LKTRTrace("%.*s, hdir %d\n", AuDLNPair(dentry), !!hdir);
+	AuDebugOn(!dentry || !h_dentry || !h_dentry->d_inode);
+
+	dt->dt_dentry = dentry;
+	dt->dt_h_dentry = h_dentry;
+	dt->dt_hinode = hinode;
+	dt->dt_hdir = hdir;
+	h_inode = h_dentry->d_inode;
+	dt->dt_atime = h_inode->i_atime;
+	dt->dt_mtime = h_inode->i_mtime;
+	/* smp_mb(); */
+}
+
+void au_dtime_revert(struct au_dtime *dt)
+{
+	struct iattr attr;
+	int err;
+	struct au_hin_ignore ign[2];
+	struct vfsub_args vargs;
+
+	LKTRTrace("%.*s\n", AuDLNPair(dt->dt_dentry));
+
+	attr.ia_atime = dt->dt_atime;
+	attr.ia_mtime = dt->dt_mtime;
+	attr.ia_valid = ATTR_FORCE | ATTR_MTIME | ATTR_MTIME_SET
+		| ATTR_ATIME | ATTR_ATIME_SET;
+
+	vfsub_args_init(&vargs, ign,
+			au_test_dlgt(au_mntflags(dt->dt_dentry->d_sb)), 0);
+	/*
+	 * IN_ATTRIB should be divided into
+	 * IN_ATTRIB_ATIME, IN_ATTRIB_MTIME ...,
+	 * and define all ORed new IN_ATTRIB macro.
+	 */
+	vfsub_ign_hinode(&vargs, IN_ATTRIB, dt->dt_hinode);
+	vfsub_ign_hinode(&vargs, IN_ATTRIB, dt->dt_hdir);
+	err = vfsub_notify_change(dt->dt_h_dentry, &attr, &vargs);
+	if (unlikely(err))
+		AuWarn("restoring timestamps failed(%d). ignored\n", err);
+}
+
+/* ---------------------------------------------------------------------- */
+
+static noinline_for_stack
+int cpup_iattr(struct dentry *dst, aufs_bindex_t bindex, struct dentry *h_src,
+	       struct au_hinode *hdir, struct vfsub_args *vargs)
+{
+	int err, sbits;
+	struct dentry *h_dst;
+	struct iattr ia;
+	struct inode *h_isrc, *h_idst;
+
+	h_dst = au_h_dptr(dst, bindex);
+	LKTRTrace("%.*s\n", AuDLNPair(h_dst));
+	h_idst = h_dst->d_inode;
+	/* todo? IMustLock(h_idst); */
+	h_isrc = h_src->d_inode;
+	/* todo? IMustLock(h_isrc); */
+
+	ia.ia_valid = ATTR_FORCE | ATTR_MODE | ATTR_UID | ATTR_GID
+		| ATTR_ATIME | ATTR_MTIME
+		| ATTR_ATIME_SET | ATTR_MTIME_SET;
+	ia.ia_mode = h_isrc->i_mode;
+	ia.ia_uid = h_isrc->i_uid;
+	ia.ia_gid = h_isrc->i_gid;
+	ia.ia_atime = h_isrc->i_atime;
+	ia.ia_mtime = h_isrc->i_mtime;
+	sbits = !!(ia.ia_mode & (S_ISUID | S_ISGID));
+
+	vfsub_args_reinit(vargs);
+	vfsub_ign_hinode(vargs, IN_ATTRIB, hdir);
+	err = vfsub_notify_change(h_dst, &ia, vargs);
+
+	/* is this nfs only? */
+	if (!err && sbits && au_test_nfs(h_dst->d_sb)) {
+		ia.ia_valid = ATTR_FORCE | ATTR_MODE;
+		ia.ia_mode = h_isrc->i_mode;
+		vfsub_args_reinit(vargs);
+		vfsub_ign_hinode(vargs, IN_ATTRIB, hdir);
+		err = vfsub_notify_change(h_dst, &ia, vargs);
+	}
+
+	/* todo? remove this? */
+	if (!err)
+		h_idst->i_flags = h_isrc->i_flags;
+
+	AuTraceErr(err);
+	return err;
+}
+
+/*
+ * to support a sparse file which is opened with O_APPEND,
+ * we need to close the file.
+ */
+static noinline_for_stack
+int cpup_regular(struct dentry *dentry, aufs_bindex_t bdst, aufs_bindex_t bsrc,
+		 loff_t len, struct au_hinode *hdir, struct vfsub_args *vargs)
+{
+	int err, i;
+	struct super_block *sb;
+	struct inode *h_inode;
+	enum { SRC, DST };
+	struct {
+		aufs_bindex_t bindex;
+		unsigned int flags;
+		struct dentry *dentry;
+		struct file *file;
+		void *label, *label_file;
+	} *h, hidden[] = {
+		{
+			.bindex = bsrc,
+			.flags = O_RDONLY | O_NOATIME | O_LARGEFILE,
+			.file = NULL,
+			.label = &&out,
+			.label_file = &&out_src_file
+		},
+		{
+			.bindex = bdst,
+			.flags = O_WRONLY | O_NOATIME | O_LARGEFILE,
+			.file = NULL,
+			.label = &&out_src_file,
+			.label_file = &&out_dst_file
+		}
+	};
+
+	LKTRTrace("dentry %.*s, bdst %d, bsrc %d, len %lld\n",
+		  AuDLNPair(dentry), bdst, bsrc, len);
+	AuDebugOn(bsrc <= bdst);
+	AuDebugOn(!len);
+	sb = dentry->d_sb;
+	AuDebugOn(au_test_ro(sb, bdst, dentry->d_inode));
+	/* bsrc branch can be ro/rw. */
+
+	h = hidden;
+	for (i = 0; i < 2; i++, h++) {
+		h->dentry = au_h_dptr(dentry, h->bindex);
+		AuDebugOn(!h->dentry);
+		h_inode = h->dentry->d_inode;
+		AuDebugOn(!h_inode || !S_ISREG(h_inode->i_mode));
+		h->file = au_h_open(dentry, h->bindex, h->flags, /*file*/NULL);
+		err = PTR_ERR(h->file);
+		if (IS_ERR(h->file))
+			goto *h->label;
+		err = -EINVAL;
+		if (unlikely(!h->file->f_op))
+			goto *h->label_file;
+	}
+
+	/* stop updating while we copyup */
+	IMustLock(hidden[SRC].dentry->d_inode);
+	err = au_copy_file(hidden[DST].file, hidden[SRC].file, len, hdir, sb,
+			   vargs);
+
+ out_dst_file:
+	fput(hidden[DST].file);
+	au_sbr_put(sb, hidden[DST].bindex);
+ out_src_file:
+	fput(hidden[SRC].file);
+	au_sbr_put(sb, hidden[SRC].bindex);
+ out:
+	AuTraceErr(err);
+	return err;
+}
+
+static int au_do_cpup_regular(struct dentry *dentry, aufs_bindex_t bdst,
+			      aufs_bindex_t bsrc, loff_t len,
+			      struct au_hinode *hdir, struct dentry *h_dst,
+			      struct vfsub_args *vargs)
+{
+	int err, rerr;
+	loff_t l;
+
+	AuTraceEnter();
+
+	err = 0;
+	l = i_size_read(au_h_iptr(dentry->d_inode, bsrc));
+	if (len == -1 || l < len)
+		len = l;
+	if (len)
+		err = cpup_regular(dentry, bdst, bsrc, len, hdir, vargs);
+	if (!err)
+		goto out; /* success */
+
+	vfsub_args_reinit(vargs);
+	vfsub_ign_hinode(vargs, IN_DELETE, hdir);
+	rerr = vfsub_unlink(hdir->hi_inode, h_dst, vargs);
+	if (rerr) {
+		AuIOErr("failed unlinking cpup-ed %.*s(%d, %d)\n",
+			AuDLNPair(h_dst), err, rerr);
+		err = -EIO;
+	}
+
+ out:
+	AuTraceErr(err);
+	return err;
+}
+
+static int au_do_cpup_symlink(struct dentry *h_dst, struct dentry *h_src,
+			      struct inode *h_dir, umode_t mode,
+			      struct vfsub_args *vargs)
+{
+	int err, symlen;
+	char *sym;
+	mm_segment_t old_fs;
+
+	AuTraceEnter();
+
+	err = -ENOMEM;
+	sym = __getname();
+	if (unlikely(!sym))
+		goto out;
+
+	old_fs = get_fs();
+	set_fs(KERNEL_DS);
+	symlen = h_src->d_inode->i_op->readlink(h_src, (char __user *)sym,
+						PATH_MAX);
+	err = symlen;
+	set_fs(old_fs);
+
+	if (symlen > 0) {
+		sym[symlen] = 0;
+		err = vfsub_symlink(h_dir, h_dst, sym, mode, vargs);
+	}
+	__putname(sym);
+
+ out:
+	AuTraceErr(err);
+	return err;
+}
+
+/* return with hidden dst inode is locked */
+static noinline_for_stack
+int cpup_entry(struct dentry *dentry, aufs_bindex_t bdst, aufs_bindex_t bsrc,
+	       loff_t len, unsigned int flags, struct dentry *dst_parent,
+	       struct vfsub_args *vargs)
+{
+	int err;
+	unsigned char isdir, hinotify;
+	struct dentry *h_src, *h_dst, *h_parent, *gparent;
+	struct inode *h_inode, *h_dir;
+	struct au_dtime dt;
+	umode_t mode;
+	struct super_block *sb;
+	struct au_hinode *hgdir, *hdir;
+	unsigned int mnt_flags;
+	const int do_dt = au_ftest_cpup(flags, DTIME);
+
+	LKTRTrace("%.*s, i%lu, bdst %d, bsrc %d, len %lld, dtime %u\n",
+		  AuDLNPair(dentry), dentry->d_inode->i_ino, bdst, bsrc, len,
+		  do_dt);
+	sb = dentry->d_sb;
+	AuDebugOn(bdst >= bsrc || au_test_ro(sb, bdst, NULL));
+	/* bsrc branch can be ro/rw. */
+
+	h_src = au_h_dptr(dentry, bsrc);
+	AuDebugOn(!h_src);
+	h_inode = h_src->d_inode;
+	AuDebugOn(!h_inode);
+	AuDebugOn(h_inode != au_h_iptr(dentry->d_inode, bsrc));
+
+	/* stop referencing while we are creating */
+	h_dst = au_h_dptr(dentry, bdst);
+	AuDebugOn(h_dst && h_dst->d_inode);
+	h_parent = h_dst->d_parent; /* dir inode is locked */
+	h_dir = h_parent->d_inode;
+	IMustLock(h_dir);
+	AuDebugOn(h_parent != h_dst->d_parent);
+
+	hdir = NULL;
+	mnt_flags = au_mntflags(sb);
+	hinotify = !!au_opt_test(mnt_flags, UDBA_INOTIFY);
+	if (hinotify) {
+		hdir = au_hi(dst_parent->d_inode, bdst);
+		AuDebugOn(hdir->hi_inode != h_dir);
+	}
+
+	if (do_dt) {
+		hgdir = NULL;
+		if (hinotify && !IS_ROOT(dst_parent)) {
+			gparent = dget_parent(dst_parent);
+			hgdir = au_hi(gparent->d_inode, bdst);
+			IMustLock(hgdir->hi_inode);
+			dput(gparent);
+		}
+		au_dtime_store(&dt, dst_parent, h_parent, hdir, hgdir);
+	}
+
+	isdir = 0;
+	vfsub_args_reinit(vargs);
+	vfsub_ign_hinode(vargs, IN_CREATE, hdir);
+	mode = h_inode->i_mode;
+	switch (mode & S_IFMT) {
+	case S_IFREG:
+		/* stop updating while we are referencing */
+		IMustLock(h_inode);
+		err = au_h_create(h_dir, h_dst, mode | S_IWUSR, vargs, NULL,
+				  au_nfsmnt(sb, bdst));
+		if (!err)
+			err = au_do_cpup_regular(dentry, bdst, bsrc, len,
+						 hdir, h_dst, vargs);
+		break;
+	case S_IFDIR:
+		isdir = 1;
+		err = vfsub_mkdir(h_dir, h_dst, mode, vargs);
+		if (!err) {
+			/* setattr case: dir is not locked */
+			if (0 && au_ibstart(dst_parent->d_inode) == bdst)
+				au_cpup_attr_nlink(dst_parent->d_inode,
+						   /*force*/1);
+			au_cpup_attr_nlink(dentry->d_inode, /*force*/1);
+		}
+		break;
+	case S_IFLNK:
+		err = au_do_cpup_symlink(h_dst, h_src, h_dir, mode, vargs);
+		break;
+	case S_IFCHR:
+	case S_IFBLK:
+		AuDebugOn(!capable(CAP_MKNOD));
+		/*FALLTHROUGH*/
+	case S_IFIFO:
+	case S_IFSOCK:
+		err = vfsub_mknod(h_dir, h_dst, mode,
+				  au_h_rdev(h_inode, /*h_mnt*/NULL, h_src),
+				  vargs);
+		break;
+	default:
+		AuIOErr("Unknown inode type 0%o\n", mode);
+		err = -EIO;
+	}
+
+	if (hinotify
+	    && !isdir
+	    && au_opt_test_xino(mnt_flags)
+	    && h_inode->i_nlink == 1
+	    /* todo: unnecessary? */
+	    /* && dentry->d_inode->i_nlink == 1 */
+	    && bdst < bsrc
+	    && !au_ftest_cpup(flags, KEEPLINO))
+		au_xino_write0(sb, bsrc, h_inode->i_ino, /*ino*/0);
+		/* ignore this error */
+
+	if (do_dt)
+		au_dtime_revert(&dt);
+	AuTraceErr(err);
+	return err;
+}
+
+/*
+ * copyup the @dentry from @bsrc to @bdst.
+ * the caller must set the both of hidden dentries.
+ * @len is for truncating when it is -1 copyup the entire file.
+ */
+static int au_cpup_single(struct dentry *dentry, aufs_bindex_t bdst,
+			  aufs_bindex_t bsrc, loff_t len, unsigned int flags,
+			  struct dentry *dst_parent, struct vfsub_args *vargs)
+{
+	int err, rerr;
+	unsigned int mnt_flags;
+	aufs_bindex_t old_ibstart;
+	unsigned char isdir, plink, hinotify;
+	struct au_dtime dt;
+	struct dentry *h_src, *h_dst, *h_parent, *gparent;
+	struct inode *dst_inode, *h_dir, *inode;
+	struct super_block *sb;
+	struct au_hinode *hgdir, *hdir;
+
+	LKTRTrace("%.*s, i%lu, bdst %d, bsrc %d, len %lld, flags 0x%x\n",
+		  AuDLNPair(dentry), dentry->d_inode->i_ino, bdst, bsrc, len,
+		  flags);
+	sb = dentry->d_sb;
+	AuDebugOn(bsrc <= bdst);
+	h_dst = au_h_dptr(dentry, bdst);
+	AuDebugOn(!h_dst || h_dst->d_inode);
+	h_parent = h_dst->d_parent; /* dir inode is locked */
+	h_dir = h_parent->d_inode;
+	IMustLock(h_dir);
+	h_src = au_h_dptr(dentry, bsrc);
+	AuDebugOn(!h_src || !h_src->d_inode);
+	inode = dentry->d_inode;
+	IiMustWriteLock(inode);
+	if (!dst_parent)
+		dst_parent = dget_parent(dentry);
+	else
+		dget(dst_parent);
+
+	mnt_flags = au_mntflags(sb);
+	plink = !!au_opt_test(mnt_flags, PLINK);
+	hinotify = !!au_opt_test(mnt_flags, UDBA_INOTIFY);
+	hdir = NULL;
+	if (hinotify)
+		hdir = au_hi(dst_parent->d_inode, bdst);
+	dst_inode = au_h_iptr(inode, bdst);
+	if (dst_inode) {
+		if (unlikely(!plink)) {
+			err = -EIO;
+			AuIOErr("i%lu exists on a upper branch "
+				"but plink is disabled\n", inode->i_ino);
+			goto out;
+		}
+
+		if (dst_inode->i_nlink) {
+			const int do_dt = au_ftest_cpup(flags, DTIME);
+
+			h_src = au_plink_lkup(sb, bdst, inode);
+			err = PTR_ERR(h_src);
+			if (IS_ERR(h_src))
+				goto out;
+			if (unlikely(!h_src->d_inode)) {
+				err = -EIO;
+				AuIOErr("i%lu exists on a upper branch "
+					"but plink is broken\n", inode->i_ino);
+				dput(h_src);
+				goto out;
+			}
+
+			if (do_dt) {
+				hgdir = NULL;
+				if (hinotify && !IS_ROOT(dst_parent)) {
+					gparent = dget_parent(dst_parent);
+					hgdir = au_hi(gparent->d_inode, bdst);
+					IMustLock(hgdir->hi_inode);
+					dput(gparent);
+				}
+				au_dtime_store(&dt, dst_parent, h_parent, hdir,
+					       hgdir);
+			}
+			vfsub_args_reinit(vargs);
+			vfsub_ign_hinode(vargs, IN_CREATE, hdir);
+			err = vfsub_link(h_src, h_dir, h_dst, vargs);
+			if (do_dt)
+				au_dtime_revert(&dt);
+			dput(h_src);
+			goto out;
+		} else
+			/* todo: cpup_wh_file? */
+			/* udba work */
+			au_update_brange(inode, 1);
+	}
+
+	old_ibstart = au_ibstart(inode);
+	err = cpup_entry(dentry, bdst, bsrc, len, flags, dst_parent, vargs);
+	if (unlikely(err))
+		goto out;
+	dst_inode = h_dst->d_inode;
+	mutex_lock_nested(&dst_inode->i_mutex, AuLsc_I_CHILD2);
+
+	/* todo: test dlgt? */
+	err = cpup_iattr(dentry, bdst, h_src, hdir, vargs);
+#if 0 /* reserved for future use */
+	if (0 && !err)
+		err = cpup_xattrs(h_src, h_dst);
+#endif
+	isdir = S_ISDIR(dst_inode->i_mode);
+	if (!err) {
+		if (bdst < old_ibstart)
+			au_set_ibstart(inode, bdst);
+		au_set_h_iptr(inode, bdst, au_igrab(dst_inode),
+			      au_hi_flags(inode, isdir));
+		mutex_unlock(&dst_inode->i_mutex);
+		if (!isdir
+		    && h_src->d_inode->i_nlink > 1
+		    && plink)
+			au_plink_append(sb, inode, h_dst, bdst);
+		goto out; /* success */
+	}
+
+	/* revert */
+	mutex_unlock(&dst_inode->i_mutex);
+	hgdir = NULL;
+	if (au_opt_test(mnt_flags, UDBA_INOTIFY) && !IS_ROOT(dst_parent)) {
+		gparent = dget_parent(dst_parent);
+		hgdir = au_hi(gparent->d_inode, bdst);
+		dput(gparent);
+	}
+	au_dtime_store(&dt, dst_parent, h_parent, hdir, hgdir);
+	vfsub_args_reinit(vargs);
+	vfsub_ign_hinode(vargs, IN_DELETE, hdir);
+	if (!isdir)
+		rerr = vfsub_unlink(h_dir, h_dst, vargs);
+	else
+		rerr = vfsub_rmdir(h_dir, h_dst, vargs);
+	au_dtime_revert(&dt);
+	if (rerr) {
+		AuIOErr("failed removing broken entry(%d, %d)\n", err, rerr);
+		err = -EIO;
+	}
+
+ out:
+	dput(dst_parent);
+	AuTraceErr(err);
+	return err;
+}
+
+struct au_cpup_single_args {
+	int *errp;
+	struct dentry *dentry;
+	aufs_bindex_t bdst, bsrc;
+	loff_t len;
+	unsigned int flags;
+	struct dentry *dst_parent;
+	struct vfsub_args *vargs;
+};
+
+static void au_call_cpup_single(void *args)
+{
+	struct au_cpup_single_args *a = args;
+	*a->errp = au_cpup_single(a->dentry, a->bdst, a->bsrc, a->len,
+				  a->flags, a->dst_parent, a->vargs);
+}
+
+int au_sio_cpup_single(struct dentry *dentry, aufs_bindex_t bdst,
+		       aufs_bindex_t bsrc, loff_t len, unsigned int flags,
+		       struct dentry *dst_parent)
+{
+	int err, wkq_err;
+	struct dentry *h_dentry;
+	umode_t mode;
+	struct au_hin_ignore ign;
+	struct vfsub_args vargs;
+
+	LKTRTrace("%.*s, i%lu, bdst %d, bsrc %d, len %lld, flags 0x%x\n",
+		  AuDLNPair(dentry), dentry->d_inode->i_ino, bdst, bsrc, len,
+		  flags);
+
+	vfsub_args_init(&vargs, &ign, au_test_dlgt(au_mntflags(dentry->d_sb)),
+			/*force_unlink*/0);
+	h_dentry = au_h_dptr(dentry, bsrc);
+	mode = h_dentry->d_inode->i_mode & S_IFMT;
+	if ((mode != S_IFCHR && mode != S_IFBLK)
+	    || capable(CAP_MKNOD))
+		err = au_cpup_single(dentry, bdst, bsrc, len, flags,
+				     dst_parent, &vargs);
+	else {
+		struct au_cpup_single_args args = {
+			.errp		= &err,
+			.dentry		= dentry,
+			.bdst		= bdst,
+			.bsrc		= bsrc,
+			.len		= len,
+			.flags		= flags,
+			.dst_parent	= dst_parent,
+			.vargs		= &vargs
+		};
+		vfsub_fclr(vargs.flags, DLGT);
+		wkq_err = au_wkq_wait(au_call_cpup_single, &args, /*dlgt*/0);
+		if (unlikely(wkq_err))
+			err = wkq_err;
+	}
+
+	AuTraceErr(err);
+	return err;
+}
+
+/*
+ * copyup the @dentry from the first active hidden branch to @bdst,
+ * using au_cpup_single().
+ */
+static int au_cpup_simple(struct dentry *dentry, aufs_bindex_t bdst, loff_t len,
+			  unsigned int flags, struct vfsub_args *vargs)
+{
+	int err;
+	struct inode *inode;
+	aufs_bindex_t bsrc, bend;
+
+	LKTRTrace("%.*s, bdst %d, len %lld, flags 0x%x\n",
+		  AuDLNPair(dentry), bdst, len, flags);
+	inode = dentry->d_inode;
+	AuDebugOn(!S_ISDIR(inode->i_mode) && au_dbstart(dentry) < bdst);
+
+	bend = au_dbend(dentry);
+	for (bsrc = bdst + 1; bsrc <= bend; bsrc++)
+		if (au_h_dptr(dentry, bsrc))
+			break;
+	AuDebugOn(!au_h_dptr(dentry, bsrc));
+
+	err = au_lkup_neg(dentry, bdst);
+	if (!err) {
+		err = au_cpup_single(dentry, bdst, bsrc, len, flags, NULL,
+				     vargs);
+		if (!err)
+			return 0; /* success */
+
+		/* revert */
+		au_set_h_dptr(dentry, bdst, NULL);
+		au_set_dbstart(dentry, bsrc);
+	}
+
+	AuTraceErr(err);
+	return err;
+}
+
+struct au_cpup_simple_args {
+	int *errp;
+	struct dentry *dentry;
+	aufs_bindex_t bdst;
+	loff_t len;
+	unsigned int flags;
+	struct vfsub_args *vargs;
+};
+
+static void au_call_cpup_simple(void *args)
+{
+	struct au_cpup_simple_args *a = args;
+	*a->errp = au_cpup_simple(a->dentry, a->bdst, a->len, a->flags,
+				  a->vargs);
+}
+
+int au_sio_cpup_simple(struct dentry *dentry, aufs_bindex_t bdst, loff_t len,
+		       unsigned int flags)
+{
+	int err, wkq_err;
+	unsigned char do_sio, dlgt;
+	struct dentry *parent;
+	struct inode *h_dir, *dir;
+	struct au_hin_ignore ign;
+	struct vfsub_args vargs;
+
+	LKTRTrace("%.*s, b%d, len %lld, flags 0x%x\n",
+		  AuDLNPair(dentry), bdst, len, flags);
+
+	parent = dget_parent(dentry);
+	dir = parent->d_inode;
+	h_dir = au_h_iptr(dir, bdst);
+	dlgt = !!au_test_dlgt(au_mntflags(dir->i_sb));
+	do_sio = !!au_test_h_perm_sio(h_dir, MAY_EXEC | MAY_WRITE, dlgt);
+	if (!do_sio) {
+		/*
+		 * testing CAP_MKNOD is for generic fs,
+		 * but CAP_FSETID is for xfs only, currently.
+		 */
+		umode_t mode = dentry->d_inode->i_mode;
+		do_sio = (((mode & (S_IFCHR | S_IFBLK))
+			   && !capable(CAP_MKNOD))
+			  || ((mode & (S_ISUID | S_ISGID))
+			      && !capable(CAP_FSETID)));
+	}
+	vfsub_args_init(&vargs, &ign, dlgt, /*force_unlink*/0);
+	if (!do_sio)
+		err = au_cpup_simple(dentry, bdst, len, flags, &vargs);
+	else {
+		struct au_cpup_simple_args args = {
+			.errp		= &err,
+			.dentry		= dentry,
+			.bdst		= bdst,
+			.len		= len,
+			.flags		= flags,
+			.vargs		= &vargs
+		};
+		vfsub_fclr(vargs.flags, DLGT);
+		wkq_err = au_wkq_wait(au_call_cpup_simple, &args, /*dlgt*/0);
+		if (unlikely(wkq_err))
+			err = wkq_err;
+	}
+
+	dput(parent);
+	AuTraceErr(err);
+	return err;
+}
+
+/* ---------------------------------------------------------------------- */
+
+static int au_do_cpup_wh(struct dentry *dentry, aufs_bindex_t bdst,
+			 struct dentry *wh_dentry, struct file *file,
+			 loff_t len, struct vfsub_args *vargs)
+{
+	int err;
+	struct au_dinfo *dinfo;
+	aufs_bindex_t bstart;
+	struct dentry *h_d_bdst, *h_d_bstart;
+
+	AuTraceEnter();
+
+	dinfo = au_di(dentry);
+	bstart = dinfo->di_bstart;
+	h_d_bdst = dinfo->di_hdentry[0 + bdst].hd_dentry;
+	dinfo->di_bstart = bdst;
+	dinfo->di_hdentry[0 + bdst].hd_dentry = wh_dentry;
+	h_d_bstart = dinfo->di_hdentry[0 + bstart].hd_dentry;
+	if (file)
+		dinfo->di_hdentry[0 + bstart].hd_dentry
+			= au_h_fptr(file, au_fbstart(file))->f_dentry;
+	err = au_cpup_single(dentry, bdst, bstart, len, !AuCpup_DTIME,
+			     /*h_parent*/NULL, vargs);
+	if (!err && file) {
+		err = au_reopen_nondir(file);
+		dinfo->di_hdentry[0 + bstart].hd_dentry = h_d_bstart;
+	}
+	dinfo->di_hdentry[0 + bdst].hd_dentry = h_d_bdst;
+	dinfo->di_bstart = bstart;
+
+	AuTraceErr(err);
+	return err;
+}
+
+/*
+ * copyup the deleted file for writing.
+ */
+static int au_cpup_wh(struct dentry *dentry, aufs_bindex_t bdst, loff_t len,
+		      struct file *file)
+{
+	int err;
+	unsigned char dlgt;
+	struct dentry *parent, *h_parent, *wh_dentry;
+	struct super_block *sb;
+	unsigned int mnt_flags;
+	struct au_dtime dt;
+	struct au_hin_ignore ign;
+	struct vfsub_args vargs;
+	struct au_hinode *hgdir, *hdir;
+	struct au_ndx ndx = {
+		.nd	= NULL,
+		.flags	= 0,
+		/* .br	= NULL */
+	};
+
+	LKTRTrace("%.*s, bdst %d, len %llu\n", AuDLNPair(dentry), bdst, len);
+	AuDebugOn(S_ISDIR(dentry->d_inode->i_mode)
+		  || (file && !(file->f_mode & FMODE_WRITE)));
+	DiMustWriteLock(dentry);
+
+	parent = dget_parent(dentry);
+	IiMustAnyLock(parent->d_inode);
+	h_parent = au_h_dptr(parent, bdst);
+	AuDebugOn(!h_parent);
+
+	sb = parent->d_sb;
+	mnt_flags = au_mntflags(sb);
+	dlgt = 0;
+	ndx.nfsmnt = au_nfsmnt(sb, bdst);
+	if (au_test_dlgt(mnt_flags)) {
+		dlgt = 1;
+		au_fset_ndx(ndx.flags, DLGT);
+	}
+	wh_dentry = au_whtmp_lkup(h_parent, &dentry->d_name, &ndx);
+	err = PTR_ERR(wh_dentry);
+	if (IS_ERR(wh_dentry))
+		goto out;
+
+	hdir = NULL;
+	hgdir = NULL;
+	if (au_opt_test(mnt_flags, UDBA_INOTIFY)) {
+		hdir = au_hi(parent->d_inode, bdst);
+		if (!IS_ROOT(parent)) {
+			struct dentry *gparent;
+			gparent = dget_parent(parent);
+			hgdir = au_hi(gparent->d_inode, bdst);
+			dput(gparent);
+		}
+	}
+	au_dtime_store(&dt, parent, h_parent, hdir, hgdir);
+	vfsub_args_init(&vargs, &ign, dlgt, /*force_unlink*/0);
+	err = au_do_cpup_wh(dentry, bdst, wh_dentry, file, len, &vargs);
+	if (unlikely(err))
+		goto out_wh;
+
+	AuDebugOn(!d_unhashed(dentry));
+	/* dget first to force sillyrename on nfs */
+	dget(wh_dentry);
+	vfsub_args_reinit(&vargs);
+	vfsub_ign_hinode(&vargs, IN_DELETE, hdir);
+	err = vfsub_unlink(h_parent->d_inode, wh_dentry, &vargs);
+	if (unlikely(err)) {
+		AuIOErr("failed remove copied-up tmp file %.*s(%d)\n",
+			AuDLNPair(wh_dentry), err);
+		err = -EIO;
+	}
+	au_dtime_revert(&dt);
+	au_set_hi_wh(dentry->d_inode, bdst, wh_dentry);
+
+ out_wh:
+	dput(wh_dentry);
+ out:
+	dput(parent);
+	AuTraceErr(err);
+	return err;
+}
+
+struct au_cpup_wh_args {
+	int *errp;
+	struct dentry *dentry;
+	aufs_bindex_t bdst;
+	loff_t len;
+	struct file *file;
+};
+
+static void au_call_cpup_wh(void *args)
+{
+	struct au_cpup_wh_args *a = args;
+	*a->errp = au_cpup_wh(a->dentry, a->bdst, a->len, a->file);
+}
+
+int au_sio_cpup_wh(struct dentry *dentry, aufs_bindex_t bdst, loff_t len,
+		   struct file *file)
+{
+	int err, wkq_err;
+	struct dentry *parent, *h_tmp, *h_parent, *h_dentry;
+	struct inode *dir, *h_dir, *h_tmpdir, *h_inode;
+	struct au_wbr *wbr;
+
+	AuTraceEnter();
+	parent = dget_parent(dentry);
+	dir = parent->d_inode;
+	IiMustAnyLock(dir);
+
+	h_tmp = NULL;
+	h_parent = NULL;
+	h_dir = au_igrab(au_h_iptr(dir, bdst));
+	h_tmpdir = h_dir;
+	if (!h_dir->i_nlink) {
+		DiMustWriteLock(parent);
+		wbr = au_sbr(dentry->d_sb, bdst)->br_wbr;
+		AuDebugOn(!wbr);
+		h_tmp = wbr->wbr_tmp;
+
+		h_parent = dget(au_h_dptr(parent, bdst));
+		au_set_h_dptr(parent, bdst, NULL);
+		au_set_h_dptr(parent, bdst, dget(h_tmp));
+		h_tmpdir = h_tmp->d_inode;
+		au_set_h_iptr(dir, bdst, NULL, 0);
+		au_set_h_iptr(dir, bdst, au_igrab(h_tmpdir), /*flags*/0);
+
+		/* this temporary unlock is safe */
+		if (file)
+			h_dentry = au_h_fptr(file, au_fbstart(file))->f_dentry;
+		else
+			h_dentry = au_h_dptr(dentry, au_dbstart(dentry));
+		h_inode = h_dentry->d_inode;
+		IMustLock(h_inode);
+		mutex_unlock(&h_inode->i_mutex);
+		mutex_lock_nested(&h_tmpdir->i_mutex, AuLsc_I_PARENT3);
+		mutex_lock_nested(&h_inode->i_mutex, AuLsc_I_CHILD);
+	}
+
+	if (!au_test_h_perm_sio
+	    (h_tmpdir, MAY_EXEC | MAY_WRITE,
+	     au_test_dlgt(au_mntflags(dentry->d_sb))))
+		err = au_cpup_wh(dentry, bdst, len, file);
+	else {
+		struct au_cpup_wh_args args = {
+			.errp	= &err,
+			.dentry	= dentry,
+			.bdst	= bdst,
+			.len	= len,
+			.file	= file
+		};
+		wkq_err = au_wkq_wait(au_call_cpup_wh, &args, /*dlgt*/0);
+		if (unlikely(wkq_err))
+			err = wkq_err;
+	}
+
+	/* todo: is this restore safe? */
+	if (h_tmp) {
+		mutex_unlock(&h_tmpdir->i_mutex);
+		au_set_h_iptr(dir, bdst, NULL, 0);
+		au_set_h_iptr(dir, bdst, au_igrab(h_dir), /*flags*/0);
+		au_set_h_dptr(parent, bdst, NULL);
+		au_set_h_dptr(parent, bdst, h_parent);
+	}
+	iput(h_dir);
+	dput(parent);
+
+	AuTraceErr(err);
+	return err;
+}
+
+/* ---------------------------------------------------------------------- */
+
+/*
+ * generic routine for both of copy-up and copy-down.
+ * Although I've tried building a path by dcsub, I gave up this approach.
+ * Since the ancestor directory may be moved/renamed during copy.
+ */
+/* cf. revalidate function in file.c */
+int au_cp_dirs(struct dentry *dentry, aufs_bindex_t bdst,
+	       int (*cp)(struct dentry *dentry, aufs_bindex_t bdst,
+			 struct dentry *h_parent, void *arg),
+	       void *arg)
+{
+	int err;
+	unsigned char pin_flags;
+	struct au_pin pin;
+	struct super_block *sb;
+	struct dentry *d, *parent, *h_parent, *real_parent;
+
+	LKTRTrace("%.*s, b%d, parent i%lu\n",
+		  AuDLNPair(dentry), bdst, (unsigned long)parent_ino(dentry));
+	sb = dentry->d_sb;
+	AuDebugOn(au_test_ro(sb, bdst, NULL));
+	err = 0;
+	parent = dget_parent(dentry);
+	IiMustWriteLock(parent->d_inode);
+	if (IS_ROOT(parent))
+		goto out;
+
+	pin_flags = AuPin_MNT_WRITE;
+	if (au_opt_test(au_mntflags(sb), UDBA_INOTIFY))
+		au_fset_pin(pin_flags, DO_GPARENT);
+	au_pin_init(&pin, dentry, bdst, AuLsc_DI_PARENT3, AuLsc_I_PARENT2,
+		    pin_flags);
+
+	/* do not use au_dpage */
+	real_parent = parent;
+	while (1) {
+		dput(parent);
+		parent = dget_parent(dentry);
+		h_parent = au_h_dptr(parent, bdst);
+		if (h_parent)
+			goto out; /* success */
+
+		/* find top dir which is needed to cpup */
+		do {
+			d = parent;
+			dput(parent);
+			parent = dget_parent(d);
+			di_read_lock_parent3(parent, !AuLock_IR);
+			h_parent = au_h_dptr(parent, bdst);
+			di_read_unlock(parent, !AuLock_IR);
+		} while (!h_parent);
+
+		if (d != real_parent)
+			di_write_lock_child3(d);
+
+		/* somebody else might create while we were sleeping */
+		if (!au_h_dptr(d, bdst) || !au_h_dptr(d, bdst)->d_inode) {
+			if (au_h_dptr(d, bdst))
+				au_update_dbstart(d);
+
+			au_pin_do_set_dentry(pin.pin  + AuPin_PARENT, d);
+			err = au_do_pin(pin.pin + AuPin_PARENT,
+					au_pin_gp(&pin));
+			if (!err) {
+				err = cp(d, bdst, h_parent, arg);
+				au_unpin(&pin);
+			}
+		}
+
+		if (d != real_parent)
+			di_write_unlock(d);
+		if (unlikely(err))
+			break;
+	}
+
+ out:
+	dput(parent);
+	AuTraceErr(err);
+	return err;
+}
+
+static int au_cpup_dir(struct dentry *dentry, aufs_bindex_t bdst,
+		       struct dentry *h_parent, void *arg)
+{
+	int err;
+
+	err = au_sio_cpup_simple(dentry, bdst, -1, AuCpup_DTIME);
+
+	AuTraceErr(err);
+	return err;
+}
+
+int au_cpup_dirs(struct dentry *dentry, aufs_bindex_t bdst)
+{
+	int err;
+
+	err = au_cp_dirs(dentry, bdst, au_cpup_dir, NULL);
+
+	AuTraceErr(err);
+	return err;
+}
+
+int au_test_and_cpup_dirs(struct dentry *dentry, aufs_bindex_t bdst)
+{
+	int err;
+	struct dentry *parent;
+	struct inode *dir;
+
+	parent = dget_parent(dentry);
+	dir = parent->d_inode;
+	LKTRTrace("%.*s, b%d, parent i%lu\n",
+		  AuDLNPair(dentry), bdst, dir->i_ino);
+	DiMustReadLock(parent);
+	IiMustReadLock(dir);
+
+	err = 0;
+	if (au_h_iptr(dir, bdst))
+		goto out;
+
+	di_read_unlock(parent, AuLock_IR);
+	di_write_lock_parent(parent);
+	/* someone else might change our inode while we were sleeping */
+	if (!au_h_iptr(dir, bdst))
+		err = au_cpup_dirs(dentry, bdst);
+	di_downgrade_lock(parent, AuLock_IR);
+
+ out:
+	dput(parent);
+	AuTraceErr(err);
+	return err;
+}
diff -Nurp linux-2.6.27.orig/fs/aufs/cpup.h linux-2.6.27/fs/aufs/cpup.h
--- linux-2.6.27.orig/fs/aufs/cpup.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.27/fs/aufs/cpup.h	2008-10-20 03:46:55.000000000 +0200
@@ -0,0 +1,78 @@
+/*
+ * Copyright (C) 2005-2008 Junjiro Okajima
+ *
+ * This program, aufs is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+ */
+
+/*
+ * copy-up/down functions
+ *
+ * $Id: cpup.h,v 1.6 2008/10/20 01:46:55 sfjro Exp $
+ */
+
+#ifndef __AUFS_CPUP_H__
+#define __AUFS_CPUP_H__
+
+#ifdef __KERNEL__
+
+#include <linux/fs.h>
+#include <linux/aufs_type.h>
+
+void au_cpup_attr_timesizes(struct inode *inode);
+void au_cpup_attr_nlink(struct inode *inode, int force);
+void au_cpup_attr_changeable(struct inode *inode);
+void au_cpup_igen(struct inode *inode, struct inode *h_inode);
+void au_cpup_attr_all(struct inode *inode, int force);
+
+/* ---------------------------------------------------------------------- */
+
+/* cpup flags */
+#define AuCpup_DTIME	1		/* do dtime_store/revert */
+#define AuCpup_KEEPLINO	(1 << 1)	/* do not clear the lower xino,
+					   for link(2) */
+#define au_ftest_cpup(flags, name)	((flags) & AuCpup_##name)
+#define au_fset_cpup(flags, name)	{ (flags) |= AuCpup_##name; }
+#define au_fclr_cpup(flags, name)	{ (flags) &= ~AuCpup_##name; }
+
+int au_sio_cpup_single(struct dentry *dentry, aufs_bindex_t bdst,
+		       aufs_bindex_t bsrc, loff_t len, unsigned int flags,
+		       struct dentry *dst_parent);
+int au_sio_cpup_simple(struct dentry *dentry, aufs_bindex_t bdst, loff_t len,
+		       unsigned int flags);
+int au_sio_cpup_wh(struct dentry *dentry, aufs_bindex_t bdst, loff_t len,
+		   struct file *file);
+
+int au_cp_dirs(struct dentry *dentry, aufs_bindex_t bdst,
+	       int (*cp)(struct dentry *dentry, aufs_bindex_t bdst,
+			 struct dentry *h_parent, void *arg),
+	       void *arg);
+int au_cpup_dirs(struct dentry *dentry, aufs_bindex_t bdst);
+int au_test_and_cpup_dirs(struct dentry *dentry, aufs_bindex_t bdst);
+
+/* ---------------------------------------------------------------------- */
+
+/* keep timestamps when copyup */
+struct au_dtime {
+	struct dentry *dt_dentry, *dt_h_dentry;
+	struct au_hinode *dt_hinode, *dt_hdir;
+	struct timespec dt_atime, dt_mtime;
+};
+void au_dtime_store(struct au_dtime *dt, struct dentry *dentry,
+		    struct dentry *h_dentry, struct au_hinode *hinode,
+		    struct au_hinode *hdir);
+void au_dtime_revert(struct au_dtime *dt);
+
+#endif /* __KERNEL__ */
+#endif /* __AUFS_CPUP_H__ */
diff -Nurp linux-2.6.27.orig/fs/aufs/CVS/Entries linux-2.6.27/fs/aufs/CVS/Entries
--- linux-2.6.27.orig/fs/aufs/CVS/Entries	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.27/fs/aufs/CVS/Entries	2008-12-14 10:37:40.000000000 +0100
@@ -0,0 +1,60 @@
+/Makefile/1.10/Mon Oct 20 01:47:24 2008//
+/br_xfs.c/1.3/Mon Jul  7 01:12:38 2008//
+/cpup.h/1.6/Mon Oct 20 01:46:55 2008//
+/dcsub.h/1.4/Mon Jul 21 02:54:22 2008//
+/dlgt.c/1.5/Mon Aug 11 02:50:34 2008//
+/finfo.c/1.5/Mon Sep 29 03:43:22 2008//
+/hinode.h/1.11/Mon Oct  6 00:30:02 2008//
+/module.h/1.8/Mon Aug 25 01:50:37 2008//
+/sysaufs.c/1.10/Mon Sep 15 03:14:55 2008//
+/sysaufs.h/1.11/Mon Sep 15 03:14:55 2008//
+/wkq.h/1.9/Mon Oct 20 01:47:43 2008//
+/aufs.h/1.5/Sun Dec 14 09:37:40 2008//
+/br_fuse.c/1.7/Sun Dec 14 09:37:40 2008//
+/br_nfs.c/1.9/Sun Dec 14 09:37:40 2008//
+/branch.c/1.22/Sun Dec 14 09:37:40 2008//
+/branch.h/1.16/Sun Dec 14 09:37:40 2008//
+/cpup.c/1.22/Sun Dec 14 09:37:40 2008//
+/dcsub.c/1.8/Sun Dec 14 09:37:40 2008//
+/debug.c/1.18/Sun Dec 14 09:37:40 2008//
+/debug.h/1.11/Sun Dec 14 09:37:40 2008//
+/dentry.c/1.20/Sun Dec 14 09:37:40 2008//
+/dentry.h/1.11/Sun Dec 14 09:37:40 2008//
+/dinfo.c/1.9/Sun Dec 14 09:37:40 2008//
+/dir.c/1.18/Sun Dec 14 09:37:40 2008//
+/dir.h/1.6/Sun Dec 14 09:37:40 2008//
+/export.c/1.22/Sun Dec 14 09:37:40 2008//
+/f_op.c/1.15/Sun Dec 14 09:37:40 2008//
+/file.c/1.19/Sun Dec 14 09:37:40 2008//
+/file.h/1.7/Sun Dec 14 09:37:40 2008//
+/getattr.c/1.4/Sun Dec 14 09:37:40 2008//
+/hin_or_dlgt.c/1.8/Sun Dec 14 09:37:40 2008//
+/hinotify.c/1.22/Sun Dec 14 09:37:40 2008//
+/i_op.c/1.27/Sun Dec 14 09:37:40 2008//
+/i_op_add.c/1.20/Sun Dec 14 09:37:40 2008//
+/i_op_del.c/1.16/Sun Dec 14 09:37:40 2008//
+/i_op_ren.c/1.19/Sun Dec 14 09:37:40 2008//
+/iinfo.c/1.12/Sun Dec 14 09:37:40 2008//
+/inode.c/1.17/Sun Dec 14 09:37:40 2008//
+/inode.h/1.19/Sun Dec 14 09:37:40 2008//
+/misc.c/1.19/Sun Dec 14 09:37:40 2008//
+/misc.h/1.10/Sun Dec 14 09:37:40 2008//
+/module.c/1.12/Sun Dec 14 09:37:40 2008//
+/opts.c/1.19/Sun Dec 14 09:37:40 2008//
+/opts.h/1.8/Sun Dec 14 09:37:40 2008//
+/plink.c/1.12/Sun Dec 14 09:37:40 2008//
+/robr.c/1.8/Sun Dec 14 09:37:40 2008//
+/sbinfo.c/1.15/Sun Dec 14 09:37:40 2008//
+/super.c/1.22/Sun Dec 14 09:37:40 2008//
+/super.h/1.21/Sun Dec 14 09:37:40 2008//
+/sysfs.c/1.18/Sun Dec 14 09:37:40 2008//
+/sysrq.c/1.13/Sun Dec 14 09:37:40 2008//
+/vdir.c/1.13/Sun Dec 14 09:37:40 2008//
+/vfsub.c/1.14/Sun Dec 14 09:37:40 2008//
+/vfsub.h/1.13/Sun Dec 14 09:37:40 2008//
+/wbr_policy.c/1.14/Sun Dec 14 09:37:40 2008//
+/whout.c/1.18/Sun Dec 14 09:37:40 2008//
+/whout.h/1.4/Sun Dec 14 09:37:40 2008//
+/wkq.c/1.16/Sun Dec 14 09:37:40 2008//
+/xino.c/1.19/Sun Dec 14 09:37:40 2008//
+D
diff -Nurp linux-2.6.27.orig/fs/aufs/CVS/Repository linux-2.6.27/fs/aufs/CVS/Repository
--- linux-2.6.27.orig/fs/aufs/CVS/Repository	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.27/fs/aufs/CVS/Repository	2008-10-24 15:40:15.000000000 +0200
@@ -0,0 +1 @@
+aufs/fs/aufs25
diff -Nurp linux-2.6.27.orig/fs/aufs/CVS/Root linux-2.6.27/fs/aufs/CVS/Root
--- linux-2.6.27.orig/fs/aufs/CVS/Root	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.27/fs/aufs/CVS/Root	2008-10-24 15:40:15.000000000 +0200
@@ -0,0 +1 @@
+:pserver:anonymous@aufs.cvs.sourceforge.net:/cvsroot/aufs
diff -Nurp linux-2.6.27.orig/fs/aufs/dcsub.c linux-2.6.27/fs/aufs/dcsub.c
--- linux-2.6.27.orig/fs/aufs/dcsub.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.27/fs/aufs/dcsub.c	2008-12-14 10:37:40.000000000 +0100
@@ -0,0 +1,251 @@
+/*
+ * Copyright (C) 2005-2008 Junjiro Okajima
+ *
+ * This program, aufs is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+ */
+
+/*
+ * sub-routines for dentry cache
+ *
+ * $Id: dcsub.c,v 1.8 2008/12/01 03:49:29 sfjro Exp $
+ */
+
+#include "aufs.h"
+
+static void au_dpage_free(struct au_dpage *dpage)
+{
+	int i;
+
+	AuTraceEnter();
+	AuDebugOn(!dpage);
+
+	for (i = 0; i < dpage->ndentry; i++)
+		dput(dpage->dentries[i]);
+	free_page((unsigned long)dpage->dentries);
+}
+
+int au_dpages_init(struct au_dcsub_pages *dpages, gfp_t gfp)
+{
+	int err;
+	void *p;
+
+	AuTraceEnter();
+
+	err = -ENOMEM;
+	dpages->dpages = kmalloc(sizeof(*dpages->dpages), gfp);
+	if (unlikely(!dpages->dpages))
+		goto out;
+	p = (void *)__get_free_page(gfp);
+	if (unlikely(!p))
+		goto out_dpages;
+	dpages->dpages[0].ndentry = 0;
+	dpages->dpages[0].dentries = p;
+	dpages->ndpage = 1;
+	return 0; /* success */
+
+ out_dpages:
+	kfree(dpages->dpages);
+ out:
+	AuTraceErr(err);
+	return err;
+}
+
+void au_dpages_free(struct au_dcsub_pages *dpages)
+{
+	int i;
+
+	AuTraceEnter();
+
+	for (i = 0; i < dpages->ndpage; i++)
+		au_dpage_free(dpages->dpages + i);
+	kfree(dpages->dpages);
+}
+
+static int au_dpages_append(struct au_dcsub_pages *dpages,
+			    struct dentry *dentry, gfp_t gfp)
+{
+	int err, sz;
+	struct au_dpage *dpage;
+	void *p;
+
+	/* AuTraceEnter(); */
+
+	dpage = dpages->dpages + dpages->ndpage - 1;
+	AuDebugOn(!dpage);
+	sz = PAGE_SIZE / sizeof(dentry);
+	if (unlikely(dpage->ndentry >= sz)) {
+		LKTRLabel(new dpage);
+		err = -ENOMEM;
+		sz = dpages->ndpage * sizeof(*dpages->dpages);
+		p = au_kzrealloc(dpages->dpages, sz,
+				 sz + sizeof(*dpages->dpages), gfp);
+		if (unlikely(!p))
+			goto out;
+		dpages->dpages = p;
+		dpage = dpages->dpages + dpages->ndpage;
+		p = (void *)__get_free_page(gfp);
+		if (unlikely(!p))
+			goto out;
+		dpage->ndentry = 0;
+		dpage->dentries = p;
+		dpages->ndpage++;
+	}
+
+	dpage->dentries[dpage->ndentry++] = dget(dentry);
+	return 0; /* success */
+
+ out:
+	/* AuTraceErr(err); */
+	return err;
+}
+
+int au_dcsub_pages(struct au_dcsub_pages *dpages, struct dentry *root,
+		   au_dpages_test test, void *arg)
+{
+	int err;
+	struct dentry *this_parent = root;
+	struct list_head *next;
+	struct super_block *sb = root->d_sb;
+
+	AuTraceEnter();
+
+	err = 0;
+	spin_lock(&dcache_lock);
+ repeat:
+	next = this_parent->d_subdirs.next;
+ resume:
+	if (this_parent->d_sb == sb
+	    && !IS_ROOT(this_parent)
+	    && atomic_read(&this_parent->d_count)
+	    && this_parent->d_inode
+	    && (!test || test(this_parent, arg))) {
+		err = au_dpages_append(dpages, this_parent, GFP_ATOMIC);
+		if (unlikely(err))
+			goto out;
+	}
+
+	while (next != &this_parent->d_subdirs) {
+		struct list_head *tmp = next;
+		struct dentry *dentry = list_entry(tmp, struct dentry,
+						   d_u.d_child);
+		next = tmp->next;
+		if (/*d_unhashed(dentry) || */!dentry->d_inode)
+			continue;
+		if (!list_empty(&dentry->d_subdirs)) {
+			this_parent = dentry;
+			goto repeat;
+		}
+		if (dentry->d_sb == sb
+		    && atomic_read(&dentry->d_count)
+		    && (!test || test(dentry, arg))) {
+			err = au_dpages_append(dpages, dentry, GFP_ATOMIC);
+			if (unlikely(err))
+				goto out;
+		}
+	}
+
+	if (this_parent != root) {
+		next = this_parent->d_u.d_child.next;
+		this_parent = this_parent->d_parent; /* dcache_lock is locked */
+		goto resume;
+	}
+ out:
+	spin_unlock(&dcache_lock);
+#if 0 /* debug */
+	if (!err) {
+		int i, j;
+		j = 0;
+		for (i = 0; i < dpages->ndpage; i++) {
+			if ((dpages->dpages + i)->ndentry)
+				AuDbg("%d: %d\n",
+				      i, (dpages->dpages + i)->ndentry);
+			j += (dpages->dpages + i)->ndentry;
+		}
+		if (j)
+			AuDbg("ndpage %d, %d\n", dpages->ndpage, j);
+	}
+#endif
+	AuTraceErr(err);
+	return err;
+}
+
+int au_dcsub_pages_rev(struct au_dcsub_pages *dpages, struct dentry *dentry,
+		       int do_include, au_dpages_test test, void *arg)
+{
+	int err;
+
+	AuTraceEnter();
+
+	err = 0;
+	spin_lock(&dcache_lock);
+	if (do_include && (!test || test(dentry, arg))) {
+		err = au_dpages_append(dpages, dentry, GFP_ATOMIC);
+		if (unlikely(err))
+			goto out;
+	}
+	while (!IS_ROOT(dentry)) {
+		dentry = dentry->d_parent; /* dcache_lock is locked */
+		if (!test || test(dentry, arg)) {
+			err = au_dpages_append(dpages, dentry, GFP_ATOMIC);
+			if (unlikely(err))
+				break;
+		}
+	}
+
+ out:
+	spin_unlock(&dcache_lock);
+
+	AuTraceErr(err);
+	return err;
+}
+
+struct dentry *au_test_subdir(struct dentry *d1, struct dentry *d2)
+{
+	struct dentry *trap, **dentries;
+	int err, i, j;
+	struct au_dcsub_pages dpages;
+	struct au_dpage *dpage;
+
+	LKTRTrace("%.*s, %.*s\n", AuDLNPair(d1), AuDLNPair(d2));
+
+	trap = ERR_PTR(-ENOMEM);
+	err = au_dpages_init(&dpages, GFP_NOFS);
+	if (unlikely(err))
+		goto out;
+	err = au_dcsub_pages_rev(&dpages, d1, /*do_include*/1, NULL, NULL);
+	if (unlikely(err))
+		goto out_dpages;
+
+	trap = d1;
+	for (i = 0; !err && i < dpages.ndpage; i++) {
+		dpage = dpages.dpages + i;
+		dentries = dpage->dentries;
+		for (j = 0; !err && j < dpage->ndentry; j++) {
+			struct dentry *d;
+			d = dentries[j];
+			err = (d == d2);
+			if (!err)
+				trap = d;
+		}
+	}
+	if (!err)
+		trap = NULL;
+
+ out_dpages:
+	au_dpages_free(&dpages);
+ out:
+	AuTraceErrPtr(trap);
+	return trap;
+}
diff -Nurp linux-2.6.27.orig/fs/aufs/dcsub.h linux-2.6.27/fs/aufs/dcsub.h
--- linux-2.6.27.orig/fs/aufs/dcsub.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.27/fs/aufs/dcsub.h	2008-07-21 04:54:22.000000000 +0200
@@ -0,0 +1,54 @@
+/*
+ * Copyright (C) 2005-2008 Junjiro Okajima
+ *
+ * This program, aufs is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+ */
+
+/*
+ * sub-routines for dentry cache
+ *
+ * $Id: dcsub.h,v 1.4 2008/07/21 02:54:22 sfjro Exp $
+ */
+
+#ifndef __AUFS_DCSUB_H__
+#define __AUFS_DCSUB_H__
+
+#ifdef __KERNEL__
+
+#include <linux/dcache.h>
+
+struct au_dpage {
+	int ndentry;
+	struct dentry **dentries;
+};
+
+struct au_dcsub_pages {
+	int ndpage;
+	struct au_dpage *dpages;
+};
+
+/* ---------------------------------------------------------------------- */
+
+int au_dpages_init(struct au_dcsub_pages *dpages, gfp_t gfp);
+void au_dpages_free(struct au_dcsub_pages *dpages);
+typedef int (*au_dpages_test)(struct dentry *dentry, void *arg);
+int au_dcsub_pages(struct au_dcsub_pages *dpages, struct dentry *root,
+		   au_dpages_test test, void *arg);
+int au_dcsub_pages_rev(struct au_dcsub_pages *dpages, struct dentry *dentry,
+		       int do_include, au_dpages_test test, void *arg);
+struct dentry *au_test_subdir(struct dentry *d1, struct dentry *d2);
+
+#endif /* __KERNEL__ */
+#endif /* __AUFS_DCSUB_H__ */
diff -Nurp linux-2.6.27.orig/fs/aufs/debug.c linux-2.6.27/fs/aufs/debug.c
--- linux-2.6.27.orig/fs/aufs/debug.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.27/fs/aufs/debug.c	2008-12-14 10:37:40.000000000 +0100
@@ -0,0 +1,522 @@
+/*
+ * Copyright (C) 2005-2008 Junjiro Okajima
+ *
+ * This program, aufs is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+ */
+
+/*
+ * debug print functions
+ *
+ * $Id: debug.c,v 1.18 2008/11/17 02:12:17 sfjro Exp $
+ */
+
+#include "aufs.h"
+
+atomic_t au_cond = ATOMIC_INIT(0);
+
+char *au_plevel = KERN_DEBUG;
+#define dpri(fmt, arg...) do { \
+	if (LktrCond) \
+		printk("%s" fmt, au_plevel, ##arg); \
+} while (0)
+
+/* ---------------------------------------------------------------------- */
+
+void au_dpri_whlist(struct au_nhash *whlist)
+{
+	int i;
+	struct hlist_head *head;
+	struct au_vdir_wh *tpos;
+	struct hlist_node *pos;
+
+	for (i = 0; i < AuSize_NHASH; i++) {
+		head = whlist->heads + i;
+		hlist_for_each_entry(tpos, pos, head, wh_hash)
+			dpri("b%d, %.*s, %d\n",
+			     tpos->wh_bindex,
+			     tpos->wh_str.len, tpos->wh_str.name,
+			     tpos->wh_str.len);
+	}
+}
+
+void au_dpri_vdir(struct au_vdir *vdir)
+{
+	int i;
+	union au_vdir_deblk_p p;
+	unsigned char *o;
+
+	if (!vdir || IS_ERR(vdir)) {
+		dpri("err %ld\n", PTR_ERR(vdir));
+		return;
+	}
+
+	dpri("nblk %d, deblk %p, last{%d, %p}, ver %lu\n",
+	     vdir->vd_nblk, vdir->vd_deblk,
+	     vdir->vd_last.i, vdir->vd_last.p.p, vdir->vd_version);
+	for (i = 0; i < vdir->vd_nblk; i++) {
+		p.deblk = vdir->vd_deblk[i];
+		o = p.p;
+		dpri("[%d]: %p\n", i, o);
+	}
+}
+
+static int do_pri_inode(aufs_bindex_t bindex, struct inode *inode,
+			struct dentry *wh)
+{
+	char *n = NULL;
+	int l = 0, ntfy = 0;
+
+	if (!inode || IS_ERR(inode)) {
+		dpri("i%d: err %ld\n", bindex, PTR_ERR(inode));
+		return -1;
+	}
+
+	/* the type of i_blocks depends upon CONFIG_LSF */
+	BUILD_BUG_ON(sizeof(inode->i_blocks) != sizeof(unsigned long)
+		     && sizeof(inode->i_blocks) != sizeof(u64));
+	if (wh) {
+		n = (void *)wh->d_name.name;
+		l = wh->d_name.len;
+	}
+
+	ntfy = au_test_inotify(inode);
+	dpri("i%d: i%lu, %s, cnt %d, nl %u, 0%o, ntfy %d, sz %llu, blk %llu,"
+	     " ct %lld, np %lu, st 0x%lx, f 0x%x, g %x%s%.*s\n",
+	     bindex,
+	     inode->i_ino, inode->i_sb ? au_sbtype(inode->i_sb) : "??",
+	     atomic_read(&inode->i_count), inode->i_nlink, inode->i_mode,
+	     ntfy,
+	     i_size_read(inode), (unsigned long long)inode->i_blocks,
+	     (long long)timespec_to_ns(&inode->i_ctime) & 0x0ffff,
+	     inode->i_mapping ? inode->i_mapping->nrpages : 0,
+	     inode->i_state, inode->i_flags, inode->i_generation,
+	     l ? ", wh " : "", l, n);
+	return 0;
+}
+
+void au_dpri_inode(struct inode *inode)
+{
+	struct au_iinfo *iinfo;
+	aufs_bindex_t bindex;
+	int err;
+
+	err = do_pri_inode(-1, inode, NULL);
+	if (err || !au_test_aufs(inode->i_sb))
+		return;
+
+	iinfo = au_ii(inode);
+	if (!iinfo)
+		return;
+	dpri("i-1: bstart %d, bend %d, gen %d\n",
+	     iinfo->ii_bstart, iinfo->ii_bend, au_iigen(inode));
+	if (iinfo->ii_bstart < 0)
+		return;
+	for (bindex = iinfo->ii_bstart; bindex <= iinfo->ii_bend; bindex++)
+		do_pri_inode(bindex, iinfo->ii_hinode[0 + bindex].hi_inode,
+			     iinfo->ii_hinode[0 + bindex].hi_whdentry);
+}
+
+static int do_pri_dentry(aufs_bindex_t bindex, struct dentry *dentry,
+			 struct list_head *intent)
+{
+	struct dentry *wh = NULL;
+
+	if (!dentry || IS_ERR(dentry)) {
+		dpri("d%d: err %ld\n", bindex, PTR_ERR(dentry));
+		return -1;
+	}
+	/* do not call dget_parent() here */
+	dpri("d%d: %.*s?/%.*s, %s, cnt %d, flags 0x%x, intent %d\n",
+	     bindex,
+	     AuDLNPair(dentry->d_parent), AuDLNPair(dentry),
+	     dentry->d_sb ? au_sbtype(dentry->d_sb) : "??",
+	     atomic_read(&dentry->d_count), dentry->d_flags, !!intent);
+	if (bindex >= 0 && dentry->d_inode && au_test_aufs(dentry->d_sb)) {
+		struct au_iinfo *iinfo = au_ii(dentry->d_inode);
+		if (iinfo)
+			wh = iinfo->ii_hinode[0 + bindex].hi_whdentry;
+	}
+	do_pri_inode(bindex, dentry->d_inode, wh);
+	return 0;
+}
+
+static struct list_head *au_dbg_h_intent(struct au_dinfo *dinfo,
+					 aufs_bindex_t bindex)
+{
+#ifdef CONFIG_AUFS_BR_NFS
+	return dinfo->di_hdentry[0 + bindex].hd_intent_list;
+#else
+	return NULL;
+#endif
+}
+
+void au_dpri_dentry(struct dentry *dentry)
+{
+	struct au_dinfo *dinfo;
+	aufs_bindex_t bindex;
+	int err;
+
+	err = do_pri_dentry(-1, dentry, NULL);
+	if (err || !au_test_aufs(dentry->d_sb))
+		return;
+
+	dinfo = au_di(dentry);
+	if (!dinfo)
+		return;
+	dpri("d-1: bstart %d, bend %d, bwh %d, bdiropq %d, gen %d\n",
+	     dinfo->di_bstart, dinfo->di_bend,
+	     dinfo->di_bwh, dinfo->di_bdiropq, au_digen(dentry));
+	if (dinfo->di_bstart < 0)
+		return;
+	for (bindex = dinfo->di_bstart; bindex <= dinfo->di_bend; bindex++)
+		do_pri_dentry(bindex, dinfo->di_hdentry[0 + bindex].hd_dentry,
+			      au_dbg_h_intent(dinfo, bindex));
+}
+
+static int do_pri_file(aufs_bindex_t bindex, struct file *file)
+{
+	char a[32];
+
+	if (!file || IS_ERR(file)) {
+		dpri("f%d: err %ld\n", bindex, PTR_ERR(file));
+		return -1;
+	}
+	a[0] = 0;
+	if (bindex < 0
+	    && file->f_dentry
+	    && au_test_aufs(file->f_dentry->d_sb)
+	    && au_fi(file))
+		snprintf(a, sizeof(a), ", mmapped %d", au_test_mmapped(file));
+	dpri("f%d: mode 0x%x, flags 0%o, cnt %ld, pos %llu%s\n",
+	     bindex, file->f_mode, file->f_flags, (long)file_count(file),
+	     file->f_pos, a);
+	if (file->f_dentry)
+		do_pri_dentry(bindex, file->f_dentry, NULL);
+	return 0;
+}
+
+void au_dpri_file(struct file *file)
+{
+	struct au_finfo *finfo;
+	aufs_bindex_t bindex;
+	int err;
+
+	err = do_pri_file(-1, file);
+	if (err || !file->f_dentry || !au_test_aufs(file->f_dentry->d_sb))
+		return;
+
+	finfo = au_fi(file);
+	if (!finfo)
+		return;
+	if (finfo->fi_bstart < 0)
+		return;
+	for (bindex = finfo->fi_bstart; bindex <= finfo->fi_bend; bindex++) {
+		struct au_hfile *hf;
+		hf = finfo->fi_hfile + bindex;
+		do_pri_file(bindex, hf ? hf->hf_file : NULL);
+	}
+}
+
+static int do_pri_br(aufs_bindex_t bindex, struct au_branch *br)
+{
+	struct vfsmount *mnt;
+	struct super_block *sb;
+
+	if (!br || IS_ERR(br)
+	    || !(mnt = br->br_mnt) || IS_ERR(mnt)
+	    || !(sb = mnt->mnt_sb) || IS_ERR(sb)) {
+		dpri("s%d: err %ld\n", bindex, PTR_ERR(br));
+		return -1;
+	}
+
+	dpri("s%d: {perm 0x%x, cnt %d, wbr %p}, "
+	     "%s, dev 0x%02x%02x, flags 0x%lx, cnt(BIAS) %d, active %d, "
+	     "xino %d\n",
+	     bindex, br->br_perm, au_br_count(br), br->br_wbr,
+	     au_sbtype(sb), MAJOR(sb->s_dev), MINOR(sb->s_dev),
+	     sb->s_flags, sb->s_count - S_BIAS,
+	     atomic_read(&sb->s_active), !!br->br_xino.xi_file);
+	return 0;
+}
+
+void au_dpri_sb(struct super_block *sb)
+{
+	struct au_sbinfo *sbinfo;
+	aufs_bindex_t bindex;
+	int err;
+	/* to reuduce stack size */
+	struct {
+		struct vfsmount mnt;
+		struct au_branch fake;
+	} *a;
+
+	/* this function can be called from magic sysrq */
+	a = kzalloc(sizeof(*a), GFP_ATOMIC);
+	if (unlikely(!a)) {
+		dpri("no memory\n");
+		return;
+	}
+
+	a->mnt.mnt_sb = sb;
+	a->fake.br_perm = 0;
+	a->fake.br_mnt = &a->mnt;
+	a->fake.br_xino.xi_file = NULL;
+	atomic_set(&a->fake.br_count, 0);
+	smp_mb(); /* atomic_set */
+	err = do_pri_br(-1, &a->fake);
+	kfree(a);
+	dpri("dev 0x%x\n", sb->s_dev);
+	if (err || !au_test_aufs(sb))
+		return;
+
+	sbinfo = au_sbi(sb);
+	if (!sbinfo)
+		return;
+	dpri("nw %d, gen %u, kobj %d\n",
+	     atomic_read(&sbinfo->si_nowait.nw_len), sbinfo->si_generation,
+	     atomic_read(&sbinfo->si_kobj.kref.refcount));
+	for (bindex = 0; bindex <= sbinfo->si_bend; bindex++)
+		do_pri_br(bindex, sbinfo->si_branch[0 + bindex]);
+}
+
+/* ---------------------------------------------------------------------- */
+
+void au_dbg_sleep(int sec)
+{
+	static DECLARE_WAIT_QUEUE_HEAD(wq);
+	wait_event_timeout(wq, 0, sec * HZ);
+}
+
+void au_dbg_sleep_jiffy(int jiffy)
+{
+	static DECLARE_WAIT_QUEUE_HEAD(wq);
+	wait_event_timeout(wq, 0, jiffy);
+}
+
+void au_dbg_iattr(struct iattr *ia)
+{
+#define AuBit(name)	if (ia->ia_valid & ATTR_ ## name) \
+				dpri(#name "\n")
+	AuBit(MODE);
+	AuBit(UID);
+	AuBit(GID);
+	AuBit(SIZE);
+	AuBit(ATIME);
+	AuBit(MTIME);
+	AuBit(CTIME);
+	AuBit(ATIME_SET);
+	AuBit(MTIME_SET);
+	AuBit(FORCE);
+	AuBit(ATTR_FLAG);
+	AuBit(KILL_SUID);
+	AuBit(KILL_SGID);
+	AuBit(FILE);
+	AuBit(KILL_PRIV);
+	AuBit(OPEN);
+	AuBit(TIMES_SET);
+#undef	AuBit
+	dpri("ia_file %p\n", ia->ia_file);
+}
+
+/* ---------------------------------------------------------------------- */
+
+void au_debug_sbinfo_init(struct au_sbinfo *sbinfo)
+{
+#ifdef ForceInotify
+	au_opt_set_udba(sbinfo->si_mntflags, UDBA_INOTIFY);
+#endif
+#ifdef ForceDlgt
+	au_opt_set(sbinfo->si_mntflags, DLGT);
+#endif
+#ifdef ForceNoPlink
+	au_opt_clr(sbinfo->si_mntflags, PLINK);
+#endif
+#ifdef ForceNoXino
+	au_opt_clr(sbinfo->si_mntflags, XINO);
+#endif
+#ifdef ForceNoRefrof
+	au_opt_clr(sbinfo->si_mntflags, REFROF);
+#endif
+#ifdef ForceShwh
+	au_opt_set(sbinfo->si_mntflags, SHWH);
+#endif
+
+#ifdef CONFIG_AUFS_DEBUG_LOCK
+	{
+		int i;
+		for (i = 0; i < AuDbgLock_Last; i++)
+			au_spl_init(sbinfo->si_dbg_lock + i);
+	}
+#endif
+}
+
+int __init au_debug_init(void)
+{
+	aufs_bindex_t bindex;
+	struct au_vdir_destr destr;
+
+	bindex = -1;
+	AuDebugOn(bindex >= 0);
+
+	destr.len = -1;
+	AuDebugOn(destr.len < NAME_MAX);
+
+#ifdef CONFIG_4KSTACKS
+	AuWarn("CONFIG_4KSTACKS is defined.\n");
+#endif
+
+#ifdef ForceBrs
+	sysaufs_brs = 1;
+#endif
+
+#if 0 /* verbose debug */
+	{
+		union {
+			struct au_branch *br;
+			struct au_dinfo *di;
+			struct au_finfo *fi;
+			struct au_iinfo *ii;
+			struct au_hinode *hi;
+			struct au_sbinfo *si;
+			struct au_vdir_destr *destr;
+			struct au_vdir_de *de;
+			struct au_vdir_wh *wh;
+			struct au_vdir *vd;
+		} u;
+
+		pr_info("br{"
+			"xino %d, "
+			"id %d, perm %d, mnt %d, count %d, "
+			"wbr %d, "
+			"xup %d, xrun %d, "
+			"gen %d, "
+			"sa %d} %d\n",
+			offsetof(typeof(*u.br), br_xino),
+			offsetof(typeof(*u.br), br_id),
+			offsetof(typeof(*u.br), br_perm),
+			offsetof(typeof(*u.br), br_mnt),
+			offsetof(typeof(*u.br), br_count),
+			offsetof(typeof(*u.br), wbr),
+			offsetof(typeof(*u.br), br_xino_upper),
+			offsetof(typeof(*u.br), br_xino_running),
+			offsetof(typeof(*u.br), br_generation),
+			offsetof(typeof(*u.br), br_sabr),
+			sizeof(*u.br));
+		pr_info("di{gen %d, rwsem %d, bstart %d, bend %d, bwh %d, "
+			"bdiropq %d, hdentry %d} %d\n",
+			offsetof(typeof(*u.di), di_generation),
+			offsetof(typeof(*u.di), di_rwsem),
+			offsetof(typeof(*u.di), di_bstart),
+			offsetof(typeof(*u.di), di_bend),
+			offsetof(typeof(*u.di), di_bwh),
+			offsetof(typeof(*u.di), di_bdiropq),
+			offsetof(typeof(*u.di), di_hdentry),
+			sizeof(*u.di));
+		pr_info("fi{gen %d, rwsem %d, hfile %d, bstart %d, bend %d, "
+			"h_vm_ops %d, vdir_cach %d} %d\n",
+			offsetof(typeof(*u.fi), fi_generation),
+			offsetof(typeof(*u.fi), fi_rwsem),
+			offsetof(typeof(*u.fi), fi_hfile),
+			offsetof(typeof(*u.fi), fi_bstart),
+			offsetof(typeof(*u.fi), fi_bend),
+			offsetof(typeof(*u.fi), fi_h_vm_ops),
+			offsetof(typeof(*u.fi), fi_vdir_cache),
+			sizeof(*u.fi));
+		pr_info("ii{gen %d, hsb %d, "
+			"rwsem %d, bstart %d, bend %d, hinode %d, vdir %d} "
+			"%d\n",
+			offsetof(typeof(*u.ii), ii_generation),
+			offsetof(typeof(*u.ii), ii_hsb1),
+			offsetof(typeof(*u.ii), ii_rwsem),
+			offsetof(typeof(*u.ii), ii_bstart),
+			offsetof(typeof(*u.ii), ii_bend),
+			offsetof(typeof(*u.ii), ii_hinode),
+			offsetof(typeof(*u.ii), ii_vdir),
+			sizeof(*u.ii));
+		pr_info("hi{inode %d, id %d, notify %d, wh %d} %d\n",
+			offsetof(typeof(*u.hi), hi_inode),
+			offsetof(typeof(*u.hi), hi_id),
+			offsetof(typeof(*u.hi), hi_notify),
+			offsetof(typeof(*u.hi), hi_whdentry),
+			sizeof(*u.hi));
+		pr_info("si{nwt %d, rwsem %d, gen %d, stat %d, "
+			"bend %d, last id %d, br %d, "
+			"cpup %d, creat %d, ops %d, ops %d, "
+			"rr %d, mfs %d, "
+			"mntflags %d, "
+			"xread %d, xwrite %d, xib %d, xmtx %d, buf %d, "
+			"xlast %d, xnext %d, "
+			"rdcache %d, "
+			"dirwh %d, "
+			"pl %d, "
+			"mnt %d, "
+			"sys %d, "
+			/* "lvma_l %d, lvma %d" */
+			"} %d\n",
+			offsetof(typeof(*u.si), si_nowait),
+			offsetof(typeof(*u.si), si_rwsem),
+			offsetof(typeof(*u.si), si_generation),
+			offsetof(typeof(*u.si), au_si_status),
+			offsetof(typeof(*u.si), si_bend),
+			offsetof(typeof(*u.si), si_last_br_id),
+			offsetof(typeof(*u.si), si_branch),
+			offsetof(typeof(*u.si), si_wbr_copyup),
+			offsetof(typeof(*u.si), si_wbr_create),
+			offsetof(typeof(*u.si), si_wbr_copyup_ops),
+			offsetof(typeof(*u.si), si_wbr_create_ops),
+			offsetof(typeof(*u.si), si_wbr_rr_next),
+			offsetof(typeof(*u.si), si_wbr_mfs),
+			offsetof(typeof(*u.si), si_mntflags),
+			offsetof(typeof(*u.si), si_xread),
+			offsetof(typeof(*u.si), si_xwrite),
+			offsetof(typeof(*u.si), si_xib),
+			offsetof(typeof(*u.si), si_xib_mtx),
+			offsetof(typeof(*u.si), si_xib_buf),
+			offsetof(typeof(*u.si), si_xib_last_pindex),
+			offsetof(typeof(*u.si), si_xib_next_bit),
+			offsetof(typeof(*u.si), si_rdcache),
+			offsetof(typeof(*u.si), si_dirwh),
+			offsetof(typeof(*u.si), si_plink),
+			offsetof(typeof(*u.si), si_mnt),
+			offsetof(typeof(*u.si), si_sa),
+			/*offsetof(typeof(*u.si), si_lvma_lock),
+			offsetof(typeof(*u.si), si_lvma),*/
+			sizeof(*u.si));
+		pr_info("destr{len %d, name %d} %d\n",
+			offsetof(typeof(*u.destr), len),
+			offsetof(typeof(*u.destr), name),
+			sizeof(*u.destr));
+		pr_info("de{ino %d, type %d, str %d} %d\n",
+			offsetof(typeof(*u.de), de_ino),
+			offsetof(typeof(*u.de), de_type),
+			offsetof(typeof(*u.de), de_str),
+			sizeof(*u.de));
+		pr_info("wh{hash %d, bindex %d, str %d} %d\n",
+			offsetof(typeof(*u.wh), wh_hash),
+			offsetof(typeof(*u.wh), wh_bindex),
+			offsetof(typeof(*u.wh), wh_str),
+			sizeof(*u.wh));
+		pr_info("vd{deblk %d, nblk %d, last %d, ver %d, jiffy %d} %d\n",
+			offsetof(typeof(*u.vd), vd_deblk),
+			offsetof(typeof(*u.vd), vd_nblk),
+			offsetof(typeof(*u.vd), vd_last),
+			offsetof(typeof(*u.vd), vd_version),
+			offsetof(typeof(*u.vd), vd_jiffy),
+			sizeof(*u.vd));
+	}
+#endif
+
+	return 0;
+}
diff -Nurp linux-2.6.27.orig/fs/aufs/debug.h linux-2.6.27/fs/aufs/debug.h
--- linux-2.6.27.orig/fs/aufs/debug.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.27/fs/aufs/debug.h	2008-12-14 10:37:40.000000000 +0100
@@ -0,0 +1,333 @@
+/*
+ * Copyright (C) 2005-2008 Junjiro Okajima
+ *
+ * This program, aufs is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+ */
+
+/*
+ * debug print functions
+ *
+ * $Id: debug.h,v 1.11 2008/12/01 03:49:33 sfjro Exp $
+ */
+
+#ifndef __AUFS_DEBUG_H__
+#define __AUFS_DEBUG_H__
+
+#ifdef __KERNEL__
+
+#include <linux/fs.h>
+#include <linux/kd.h>
+#include <linux/vt_kern.h>
+#include <linux/sysrq.h>
+
+/* to debug easier, do not make it an inlined function */
+#define MtxMustLock(mtx)	AuDebugOn(!mutex_is_locked(mtx))
+
+#ifdef CONFIG_AUFS_DEBUG
+/* sparse warns about pointer */
+#define AuDebugOn(a)		BUG_ON(!!(a))
+extern atomic_t au_cond;
+#define au_debug_on()		atomic_inc_return(&au_cond)
+#define au_debug_off()		atomic_dec_return(&au_cond)
+static inline int au_debug_test(void)
+{
+	return atomic_read(&au_cond);
+}
+#else
+#define AuDebugOn(a)		do {} while (0)
+#define au_debug_on()		do {} while (0)
+#define au_debug_off()		do {} while (0)
+static inline int au_debug_test(void)
+{
+	return 0;
+}
+#endif /* CONFIG_AUFS_DEBUG */
+
+/* ---------------------------------------------------------------------- */
+
+/* debug print */
+#if defined(CONFIG_LKTR) || defined(CONFIG_LKTR_MODULE)
+#include <linux/lktr.h>
+#ifdef CONFIG_AUFS_DEBUG
+#undef LktrCond
+#define LktrCond	unlikely(au_debug_test() || (lktr_cond && lktr_cond()))
+#endif
+#else
+#define LktrCond			au_debug_test()
+#define LKTRDumpVma(pre, vma, suf)	do {} while (0)
+#define LKTRDumpStack()			do {} while (0)
+#define LKTRTrace(fmt, args...) do { \
+	if (LktrCond) \
+		AuDbg(fmt, ##args); \
+} while (0)
+#define LKTRLabel(label)		LKTRTrace("%s\n", #label)
+#endif /* CONFIG_LKTR */
+
+#define AuTraceErr(e) do { \
+	if (unlikely((e) < 0)) \
+		LKTRTrace("err %d\n", (int)(e)); \
+} while (0)
+
+#define AuTraceErrPtr(p) do { \
+	if (IS_ERR(p)) \
+		LKTRTrace("err %ld\n", PTR_ERR(p)); \
+} while (0)
+
+#define AuTraceEnter()	LKTRLabel(enter)
+
+/* dirty macros for debug print, use with "%.*s" and caution */
+#define AuLNPair(qstr)		(qstr)->len, (qstr)->name
+#define AuDLNPair(d)		AuLNPair(&(d)->d_name)
+
+/* ---------------------------------------------------------------------- */
+
+#define AuDpri(lvl, fmt, arg...) \
+	printk(lvl AUFS_NAME " %s:%d:%s[%d]: " fmt, \
+	       __func__, __LINE__, current->comm, current->pid, ##arg)
+#define AuDbg(fmt, arg...)	AuDpri(KERN_DEBUG, fmt, ##arg)
+#define AuInfo(fmt, arg...)	AuDpri(KERN_INFO, fmt, ##arg)
+#define AuWarn(fmt, arg...)	AuDpri(KERN_WARNING, fmt, ##arg)
+#define AuErr(fmt, arg...)	AuDpri(KERN_ERR, fmt, ##arg)
+#define AuIOErr(fmt, arg...)	AuErr("I/O Error, " fmt, ##arg)
+#define AuIOErrWhck(fmt, arg...) AuErr("I/O Error, try whck. " fmt, ##arg)
+#define AuWarn1(fmt, arg...) do { \
+	static unsigned char _c; \
+	if (!_c++) \
+		AuWarn(fmt, ##arg); \
+} while (0)
+
+#define AuErr1(fmt, arg...) do { \
+	static unsigned char _c; \
+	if (!_c++) \
+		AuErr(fmt, ##arg); \
+} while (0)
+
+#define AuIOErr1(fmt, arg...) do { \
+	static unsigned char _c; \
+	if (!_c++) \
+		AuIOErr(fmt, ##arg); \
+} while (0)
+
+#define AuUnsupportMsg	"This operation is not supported." \
+			" Please report this application to aufs-users ML."
+#define AuUnsupport(fmt, args...) do { \
+	AuErr(AuUnsupportMsg "\n" fmt, ##args); \
+	dump_stack(); \
+} while (0)
+
+/* ---------------------------------------------------------------------- */
+
+struct au_sbinfo;
+#ifdef CONFIG_AUFS_DEBUG
+extern char *au_plevel;
+struct au_nhash;
+void au_dpri_whlist(struct au_nhash *whlist);
+struct au_vdir;
+void au_dpri_vdir(struct au_vdir *vdir);
+void au_dpri_inode(struct inode *inode);
+void au_dpri_dentry(struct dentry *dentry);
+void au_dpri_file(struct file *filp);
+void au_dpri_sb(struct super_block *sb);
+void au_dbg_sleep(int sec);
+void au_dbg_sleep_jiffy(int jiffy);
+
+#ifndef ATTR_TIMES_SET
+#define ATTR_TIMES_SET 0
+#endif
+void au_dbg_iattr(struct iattr *ia);
+int __init au_debug_init(void);
+void au_debug_sbinfo_init(struct au_sbinfo *sbinfo);
+#define AuDbgWhlist(w) do { \
+	LKTRTrace(#w "\n"); \
+	au_dpri_whlist(w); \
+} while (0)
+
+#define AuDbgVdir(v) do { \
+	LKTRTrace(#v "\n"); \
+	au_dpri_vdir(v); \
+} while (0)
+
+#define AuDbgInode(i) do { \
+	LKTRTrace(#i "\n"); \
+	au_dpri_inode(i); \
+} while (0)
+
+#define AuDbgDentry(d) do { \
+	LKTRTrace(#d "\n"); \
+	au_dpri_dentry(d); \
+} while (0)
+
+#define AuDbgFile(f) do { \
+	LKTRTrace(#f "\n"); \
+	au_dpri_file(f); \
+} while (0)
+
+#define AuDbgSb(sb) do { \
+	LKTRTrace(#sb "\n"); \
+	au_dpri_sb(sb); \
+} while (0)
+
+#define AuDbgSleep(sec) do { \
+	AuDbg("sleep %d sec\n", sec); \
+	au_dbg_sleep(sec); \
+} while (0)
+
+#define AuDbgSleepJiffy(jiffy) do { \
+	AuDbg("sleep %d jiffies\n", jiffy); \
+	au_dbg_sleep_jiffy(jiffy); \
+} while (0)
+
+#define AuDbgIAttr(ia) do { \
+	AuDbg("ia_valid 0x%x\n", (ia)->ia_valid); \
+	au_dbg_iattr(ia); \
+} while (0)
+#else
+static inline int au_debug_init(void)
+{
+	return 0;
+}
+static inline void au_debug_sbinfo_init(struct au_sbinfo *sbinfo)
+{
+	/* empty */
+}
+#define AuDbgWhlist(w)		do {} while (0)
+#define AuDbgVdir(v)		do {} while (0)
+#define AuDbgInode(i)		do {} while (0)
+#define AuDbgDentry(d)		do {} while (0)
+#define AuDbgFile(f)		do {} while (0)
+#define AuDbgSb(sb)		do {} while (0)
+#define AuDbgSleep(sec)		do {} while (0)
+#define AuDbgSleepJiffy(jiffy)	do {} while (0)
+#define AuDbgIAttr(ia)		do {} while (0)
+#endif /* CONFIG_AUFS_DEBUG */
+
+#ifdef DbgUdbaRace
+#define AuDbgSleep_UdbaRace()	AuDbgSleep(DbgUdbaRace)
+#else
+#define AuDbgSleep_UdbaRace()	do {} while (0)
+#endif
+
+/* ---------------------------------------------------------------------- */
+
+#ifdef CONFIG_AUFS_MAGIC_SYSRQ
+int __init au_sysrq_init(void);
+void au_sysrq_fin(void);
+
+#ifdef CONFIG_HW_CONSOLE
+#define au_dbg_blocked() do { \
+	WARN_ON(1); \
+	handle_sysrq('w', vc_cons[fg_console].d->vc_tty); \
+} while (0)
+#else
+#define au_dbg_blocked()	do {} while (0)
+#endif
+
+#else
+static inline int au_sysrq_init(void)
+{
+	return 0;
+}
+#define au_sysrq_fin()		do {} while (0)
+#define au_dbg_blocked()	do {} while (0)
+#endif /* CONFIG_AUFS_MAGIC_SYSRQ */
+
+enum {
+	AuDbgLock_SI_LOCKING,
+	AuDbgLock_SI_LOCKED,
+	AuDbgLock_DI_LOCKING,
+	AuDbgLock_DI_LOCKED,
+	AuDbgLock_II_LOCKING,
+	AuDbgLock_II_LOCKED,
+	AuDbgLock_Last
+};
+#ifdef CONFIG_AUFS_DEBUG_LOCK
+void au_dbg_locking_si_reg(struct super_block *sb, int flags);
+void au_dbg_locking_si_unreg(struct super_block *sb, int flags);
+void au_dbg_locked_si_reg(struct super_block *sb, int flags);
+void au_dbg_locked_si_unreg(struct super_block *sb, int flags);
+void au_dbg_locking_di_reg(struct dentry *d, int flags, unsigned int lsc);
+void au_dbg_locking_di_unreg(struct dentry *d, int flags);
+void au_dbg_locked_di_reg(struct dentry *d, int flags, unsigned int lsc);
+void au_dbg_locked_di_unreg(struct dentry *d, int flags);
+void au_dbg_locking_ii_reg(struct inode *i, int flags, unsigned int lsc);
+void au_dbg_locking_ii_unreg(struct inode *i, int flags);
+void au_dbg_locked_ii_reg(struct inode *i, int flags, unsigned int lsc);
+void au_dbg_locked_ii_unreg(struct inode *i, int flags);
+#else
+static inline
+void au_dbg_locking_si_reg(struct super_block *sb, int flags)
+{
+	/* empty */
+}
+static inline
+void au_dbg_locking_si_unreg(struct super_block *sb, int flags)
+{
+	/* empty */
+}
+static inline
+void au_dbg_locked_si_reg(struct super_block *sb, int flags)
+{
+	/* empty */
+}
+static inline
+void au_dbg_locked_si_unreg(struct super_block *sb, int flags)
+{
+	/* empty */
+}
+
+static inline
+void au_dbg_locking_di_reg(struct dentry *d, int flags, unsigned int lsc)
+{
+	/* empty */
+}
+static inline
+void au_dbg_locking_di_unreg(struct dentry *d, int flags)
+{
+	/* empty */
+}
+static inline
+void au_dbg_locked_di_reg(struct dentry *d, int flags, unsigned int lsc)
+{
+	/* empty */
+}
+static inline
+void au_dbg_locked_di_unreg(struct dentry *d, int flags)
+{
+	/* empty */
+}
+static inline
+void au_dbg_locking_ii_reg(struct inode *i, int flags, unsigned int lsc)
+{
+	/* empty */
+}
+static inline
+void au_dbg_locking_ii_unreg(struct inode *i, int flags)
+{
+	/* empty */
+}
+static inline
+void au_dbg_locked_ii_reg(struct inode *i, int flags, unsigned int lsc)
+{
+	/* empty */
+}
+static inline
+void au_dbg_locked_ii_unreg(struct inode *i, int flags)
+{
+	/* empty */
+}
+#endif /* CONFIG_AUFS_DEBUG_LOCK */
+
+#endif /* __KERNEL__ */
+#endif /* __AUFS_DEBUG_H__ */
diff -Nurp linux-2.6.27.orig/fs/aufs/dentry.c linux-2.6.27/fs/aufs/dentry.c
--- linux-2.6.27.orig/fs/aufs/dentry.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.27/fs/aufs/dentry.c	2008-12-14 10:37:40.000000000 +0100
@@ -0,0 +1,972 @@
+/*
+ * Copyright (C) 2005-2008 Junjiro Okajima
+ *
+ * This program, aufs is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+ */
+
+/*
+ * lookup and dentry operations
+ *
+ * $Id: dentry.c,v 1.20 2008/12/08 06:11:32 sfjro Exp $
+ */
+
+#include "aufs.h"
+
+/* ---------------------------------------------------------------------- */
+
+/*
+ * au_lkup_one() is a generic abstract entry function which calls
+ * lookup_one_len() or __lookup_hash() finally. it is some condisions that makes
+ * lookup complicated, which are nfs branch, open-intent and dlgt mode.
+ */
+
+#if defined(CONFIG_AUFS_BR_NFS) || defined(CONFIG_AUFS_DLGT)
+/* cf. lookup_one_len() in linux/fs/namei.c */
+struct dentry *au_lkup_one(const char *name, struct dentry *parent, int len,
+			   struct au_ndx *ndx)
+{
+	struct dentry *dentry;
+
+	LKTRTrace("%.*s/%.*s, ndx{%d, 0x%x}\n",
+		  AuDLNPair(parent), len, name, !!ndx->nfsmnt, ndx->flags);
+
+	ndx->nd_file = NULL;
+	if (!ndx->nfsmnt)
+		dentry = au_lkup_one_dlgt(name, parent, len, ndx->flags);
+	else
+		dentry = au_lkup_hash(name, parent, len, ndx);
+
+	AuTraceErrPtr(dentry);
+	return dentry;
+}
+#endif /* CONFIG_AUFS_BR_NFS || CONFIG_AUFS_DLGT */
+
+struct au_lkup_one_args {
+	struct dentry **errp;
+	const char *name;
+	struct dentry *parent;
+	int len;
+	struct au_ndx *ndx;
+};
+
+static void au_call_lkup_one(void *args)
+{
+	struct au_lkup_one_args *a = args;
+	*a->errp = au_lkup_one(a->name, a->parent, a->len, a->ndx);
+}
+
+#define AuLkup_ALLOW_NEG	1
+#define AuLkup_DLGT		(1 << 1)
+#define AuLkup_DIRPERM1		(1 << 2)
+#define au_ftest_lkup(flags, name)	((flags) & AuLkup_##name)
+#define au_fset_lkup(flags, name)	{ (flags) |= AuLkup_##name; }
+#define au_fclr_lkup(flags, name)	{ (flags) &= ~AuLkup_##name; }
+#ifndef CONFIG_AUFS_DLGT
+#undef AuLkup_DLGT
+#define AuLkup_DLGT	0
+#undef AuLkup_DIRPERM1
+#define AuLkup_DIRPERM1	0
+#endif
+
+struct au_do_lookup_args {
+	unsigned int		flags;
+	mode_t			type;
+	struct nameidata	*nd;
+};
+
+/*
+ * returns positive/negative dentry, NULL or an error.
+ * NULL means whiteout-ed or not-found.
+ */
+static /* noinline_for_stack */
+struct dentry *au_do_lookup(struct dentry *h_parent, struct dentry *dentry,
+			    aufs_bindex_t bindex, struct qstr *wh_name,
+			    struct au_do_lookup_args *args)
+{
+	struct dentry *h_dentry;
+	int err, wh_found, opq;
+	unsigned char wh_able;
+	struct inode *h_dir, *h_inode, *inode;
+	struct qstr *name;
+	struct super_block *sb;
+	unsigned int nd_flags;
+	struct au_ndx ndx = {
+		.flags	= 0,
+		.nd	= args->nd
+	};
+	const int allow_neg = au_ftest_lkup(args->flags, ALLOW_NEG);
+
+	LKTRTrace("%.*s/%.*s, b%d, {flags 0x%x, type 0%o, nd %d}\n",
+		  AuDLNPair(h_parent), AuDLNPair(dentry), bindex,
+		  args->flags, args->type, !!args->nd);
+	if (args->nd)
+		LKTRTrace("nd{0x%x}\n", args->nd->flags);
+	AuDebugOn(IS_ROOT(dentry));
+	h_dir = h_parent->d_inode;
+
+	nd_flags = 0;
+	wh_found = 0;
+	sb = dentry->d_sb;
+	ndx.nfsmnt = au_nfsmnt(sb, bindex);
+	if (au_ftest_lkup(args->flags, DLGT))
+		au_fset_ndx(ndx.flags, DLGT);
+	if (au_ftest_lkup(args->flags, DIRPERM1))
+		au_fset_ndx(ndx.flags, DIRPERM1);
+	LKTRTrace("nfsmnt %p\n", ndx.nfsmnt);
+	ndx.br = au_sbr(sb, bindex);
+	wh_able = !!au_br_whable(ndx.br->br_perm);
+	name = &dentry->d_name;
+	if (wh_able)
+		wh_found = au_test_robr_wh(name, h_parent, wh_name,
+					   /*try_sio*/0, &ndx);
+	h_dentry = ERR_PTR(wh_found);
+	if (!wh_found)
+		goto real_lookup;
+	if (unlikely(wh_found < 0))
+		goto out;
+
+	/* We found a whiteout */
+	/* au_set_dbend(dentry, bindex); */
+	au_set_dbwh(dentry, bindex);
+	if (!allow_neg)
+		return NULL; /* success */
+	if (ndx.nd
+	    && au_test_nfs(h_parent->d_sb)
+	    && (ndx.nd->flags & LOOKUP_CREATE)) {
+		nd_flags = ndx.nd->flags;
+		ndx.nd->flags &= ~(LOOKUP_OPEN | LOOKUP_CREATE);
+	}
+
+ real_lookup:
+	/* do not superio. */
+	h_dentry = au_lkup_one(name->name, h_parent, name->len, &ndx);
+	if (IS_ERR(h_dentry))
+		goto out;
+	AuDebugOn(d_unhashed(h_dentry));
+	h_inode = h_dentry->d_inode;
+	if (!h_inode) {
+		if (!allow_neg)
+			goto out_neg;
+	} else if (wh_found
+		   || (args->type && args->type != (h_inode->i_mode & S_IFMT)))
+		goto out_neg;
+
+	if (au_dbend(dentry) <= bindex)
+		au_set_dbend(dentry, bindex);
+	if (au_dbstart(dentry) < 0 || bindex < au_dbstart(dentry))
+		au_set_dbstart(dentry, bindex);
+	au_set_h_dptr(dentry, bindex, h_dentry);
+
+	err = au_br_nfs_h_intent(ndx.nd_file, dentry, bindex, args->nd);
+	if (unlikely(err)) {
+		h_dentry = ERR_PTR(err);
+		goto out;
+	}
+
+	inode = dentry->d_inode;
+	if (!h_inode || !S_ISDIR(h_inode->i_mode) || !wh_able
+	    || (inode && !S_ISDIR(inode->i_mode)))
+		goto out; /* success */
+
+	mutex_lock_nested(&h_inode->i_mutex, AuLsc_I_CHILD);
+	opq = au_diropq_test(h_dentry, &ndx);
+	mutex_unlock(&h_inode->i_mutex);
+	if (opq > 0)
+		au_set_dbdiropq(dentry, bindex);
+	else if (unlikely(opq < 0)) {
+		au_set_h_dptr(dentry, bindex, NULL);
+		h_dentry = ERR_PTR(opq);
+	}
+	goto out;
+
+ out_neg:
+	dput(h_dentry);
+	h_dentry = NULL;
+ out:
+	if (nd_flags)
+		ndx.nd->flags |= (nd_flags & (LOOKUP_OPEN | LOOKUP_CREATE));
+	AuTraceErrPtr(h_dentry);
+	return h_dentry;
+}
+
+/*
+ * returns the number of hidden positive dentries,
+ * otherwise an error.
+ * can be called at unlinking with @type is zero.
+ */
+int au_lkup_dentry(struct dentry *dentry, aufs_bindex_t bstart, mode_t type,
+		   struct nameidata *nd)
+{
+	int npositive, err;
+	unsigned int mnt_flags;
+	aufs_bindex_t bindex, btail, bdiropq;
+	unsigned char isdir;
+	struct qstr whname;
+	struct au_do_lookup_args args = {
+		.type	= type,
+		.nd	= nd
+	};
+	const struct qstr *name = &dentry->d_name;
+	struct dentry *parent;
+	struct super_block *sb;
+	struct inode *inode;
+
+	LKTRTrace("%.*s, b%d, type 0%o\n", AuLNPair(name), bstart, type);
+	AuDebugOn(bstart < 0 || IS_ROOT(dentry));
+
+	/* dir may not be locked */
+	parent = dget_parent(dentry);
+
+	err = au_test_robr_shwh(dentry->d_sb, name);
+	if (unlikely(err))
+		goto out;
+
+	err = au_wh_name_alloc(name->name, name->len, &whname);
+	if (unlikely(err))
+		goto out;
+
+	sb = dentry->d_sb;
+	mnt_flags = au_mntflags(sb);
+	inode = dentry->d_inode;
+	isdir = !!(inode && S_ISDIR(inode->i_mode));
+	args.flags = 0;
+	if (au_test_dlgt(mnt_flags))
+		au_fset_lkup(args.flags, DLGT);
+	if (au_test_dirperm1(mnt_flags))
+		au_fset_lkup(args.flags, DIRPERM1);
+	if (!type)
+		au_fset_lkup(args.flags, ALLOW_NEG);
+	npositive = 0;
+	btail = au_dbtaildir(parent);
+	for (bindex = bstart; bindex <= btail; bindex++) {
+		struct dentry *h_parent, *h_dentry;
+		struct inode *h_inode, *h_dir;
+
+		h_dentry = au_h_dptr(dentry, bindex);
+		if (h_dentry) {
+			if (h_dentry->d_inode)
+				npositive++;
+			if (type != S_IFDIR)
+				break;
+			continue;
+		}
+		h_parent = au_h_dptr(parent, bindex);
+		if (!h_parent)
+			continue;
+		h_dir = h_parent->d_inode;
+		if (!h_dir || !S_ISDIR(h_dir->i_mode))
+			continue;
+
+		mutex_lock_nested(&h_dir->i_mutex, AuLsc_I_PARENT);
+		h_dentry = au_do_lookup(h_parent, dentry, bindex, &whname,
+					&args);
+		mutex_unlock(&h_dir->i_mutex);
+		err = PTR_ERR(h_dentry);
+		if (IS_ERR(h_dentry))
+			goto out_wh;
+		au_fclr_lkup(args.flags, ALLOW_NEG);
+
+		if (au_dbwh(dentry) >= 0)
+			break;
+		if (!h_dentry)
+			continue;
+		h_inode = h_dentry->d_inode;
+		if (!h_inode)
+			continue;
+		npositive++;
+		if (!args.type)
+			args.type = h_inode->i_mode & S_IFMT;
+		if (args.type != S_IFDIR)
+			break;
+		else if (isdir) {
+			/* the type of lowers may be different */
+			bdiropq = au_dbdiropq(dentry);
+			if (bdiropq >= 0 && bdiropq <= bindex)
+				break;
+		}
+	}
+
+	if (npositive) {
+		LKTRLabel(positive);
+		au_update_dbstart(dentry);
+	}
+	err = npositive;
+	if (!au_opt_test(mnt_flags, UDBA_NONE) && au_dbstart(dentry) < 0)
+		/* both of real entry and whiteout found */
+		err = -EIO;
+
+ out_wh:
+	au_wh_name_free(&whname);
+ out:
+	dput(parent);
+	AuTraceErr(err);
+	return err;
+}
+
+struct dentry *au_sio_lkup_one(const char *name, struct dentry *parent, int len,
+			       struct au_ndx *ndx)
+{
+	struct dentry *dentry;
+	int wkq_err;
+
+	LKTRTrace("%.*s/%.*s\n", AuDLNPair(parent), len, name);
+
+	if (!au_test_h_perm_sio(parent->d_inode, MAY_EXEC,
+				au_ftest_ndx(ndx->flags, DLGT)))
+		dentry = au_lkup_one(name, parent, len, ndx);
+	else {
+		/* todo: ugly? */
+		unsigned int flags = ndx->flags;
+		struct au_lkup_one_args args = {
+			.errp	= &dentry,
+			.name	= name,
+			.parent	= parent,
+			.len	= len,
+			.ndx	= ndx
+		};
+
+		au_fclr_ndx(ndx->flags, DLGT);
+		au_fclr_ndx(ndx->flags, DIRPERM1);
+		wkq_err = au_wkq_wait(au_call_lkup_one, &args, /*dlgt*/0);
+		if (unlikely(wkq_err))
+			dentry = ERR_PTR(wkq_err);
+		ndx->flags = flags;
+	}
+
+	AuTraceErrPtr(dentry);
+	return dentry;
+}
+
+/*
+ * lookup @dentry on @bindex which should be negative.
+ */
+int au_lkup_neg(struct dentry *dentry, aufs_bindex_t bindex)
+{
+	int err;
+	struct dentry *parent, *h_parent, *h_dentry;
+	struct inode *h_dir;
+	struct au_ndx ndx = {
+		.flags	= 0,
+		.nd	= NULL,
+		/* .br	= NULL */
+	};
+	struct super_block *sb;
+	unsigned int mnt_flags;
+
+	LKTRTrace("%.*s, b%d\n", AuDLNPair(dentry), bindex);
+	/* dir may not be locked */
+	parent = dget_parent(dentry);
+	AuDebugOn(!parent || !parent->d_inode
+		  || !S_ISDIR(parent->d_inode->i_mode));
+	h_parent = au_h_dptr(parent, bindex);
+	AuDebugOn(!h_parent);
+	h_dir = h_parent->d_inode;
+	AuDebugOn(!h_dir || !S_ISDIR(h_dir->i_mode));
+
+	sb = dentry->d_sb;
+	mnt_flags = au_mntflags(sb);
+	ndx.nfsmnt = au_nfsmnt(sb, bindex);
+	if (au_test_dlgt(mnt_flags))
+		au_fset_ndx(ndx.flags, DLGT);
+	if (au_test_dirperm1(mnt_flags))
+		au_fset_ndx(ndx.flags, DIRPERM1);
+	h_dentry = au_sio_lkup_one(dentry->d_name.name, h_parent,
+				   dentry->d_name.len, &ndx);
+	err = PTR_ERR(h_dentry);
+	if (IS_ERR(h_dentry))
+		goto out;
+	if (unlikely(h_dentry->d_inode)) {
+		err = -EIO;
+		AuIOErr("b%d %.*s should be negative.\n",
+			bindex, AuDLNPair(h_dentry));
+		dput(h_dentry);
+		goto out;
+	}
+
+	if (bindex < au_dbstart(dentry))
+		au_set_dbstart(dentry, bindex);
+	if (au_dbend(dentry) < bindex)
+		au_set_dbend(dentry, bindex);
+	au_set_h_dptr(dentry, bindex, h_dentry);
+	err = 0;
+
+ out:
+	dput(parent);
+	AuTraceErr(err);
+	return err;
+}
+
+/*
+ * returns the number of found hidden positive dentries,
+ * otherwise an error.
+ */
+int au_refresh_hdentry(struct dentry *dentry, mode_t type)
+{
+	int npositive, new_sz;
+	struct au_dinfo *dinfo;
+	struct super_block *sb;
+	struct dentry *parent;
+	aufs_bindex_t bindex, parent_bend, parent_bstart, bwh, bdiropq, bend;
+	struct au_hdentry *p;
+	au_gen_t sgen;
+
+	LKTRTrace("%.*s, type 0%o\n", AuDLNPair(dentry), type);
+	DiMustWriteLock(dentry);
+	sb = dentry->d_sb;
+	AuDebugOn(IS_ROOT(dentry));
+	sgen = au_sigen(sb);
+	parent = dget_parent(dentry);
+	AuDebugOn(au_digen(parent) != sgen
+		  || au_iigen(parent->d_inode) != sgen);
+
+	npositive = -ENOMEM;
+	new_sz = sizeof(*dinfo->di_hdentry) * (au_sbend(sb) + 1);
+	dinfo = au_di(dentry);
+	p = au_kzrealloc(dinfo->di_hdentry, sizeof(*p) * (dinfo->di_bend + 1),
+			 new_sz, GFP_NOFS);
+	if (unlikely(!p))
+		goto out;
+	dinfo->di_hdentry = p;
+
+	bend = dinfo->di_bend;
+	bwh = dinfo->di_bwh;
+	bdiropq = dinfo->di_bdiropq;
+	p += dinfo->di_bstart;
+	for (bindex = dinfo->di_bstart; bindex <= bend; bindex++, p++) {
+		struct dentry *hd, *hdp;
+		struct au_hdentry tmp, *q;
+		aufs_bindex_t new_bindex;
+
+		hd = p->hd_dentry;
+		if (!hd)
+			continue;
+		hdp = dget_parent(hd);
+		if (hdp == au_h_dptr(parent, bindex)) {
+			dput(hdp);
+			continue;
+		}
+
+		new_bindex = au_find_dbindex(parent, hdp);
+		dput(hdp);
+		AuDebugOn(new_bindex == bindex);
+		if (dinfo->di_bwh == bindex)
+			bwh = new_bindex;
+		if (dinfo->di_bdiropq == bindex)
+			bdiropq = new_bindex;
+		/* todo: test more? */
+		if (new_bindex < 0) {
+			au_hdput(p, /*do_free*/0);
+			p->hd_dentry = NULL;
+			continue;
+		}
+		/* swap two hidden dentries, and loop again */
+		q = dinfo->di_hdentry + new_bindex;
+		tmp = *q;
+		*q = *p;
+		*p = tmp;
+		if (tmp.hd_dentry) {
+			bindex--;
+			p--;
+		}
+	}
+
+	/* todo: test more? */
+	dinfo->di_bwh = -1;
+	if (bwh >= 0 && bwh <= au_sbend(sb) && au_sbr_whable(sb, bwh))
+		dinfo->di_bwh = bwh;
+	dinfo->di_bdiropq = -1;
+	if (bdiropq >= 0
+	    && bdiropq <= au_sbend(sb)
+	    && au_sbr_whable(sb, bdiropq))
+		dinfo->di_bdiropq = bdiropq;
+	parent_bend = au_dbend(parent);
+	p = dinfo->di_hdentry;
+	for (bindex = 0; bindex <= parent_bend; bindex++, p++)
+		if (p->hd_dentry) {
+			dinfo->di_bstart = bindex;
+			break;
+		}
+	p = dinfo->di_hdentry + parent_bend;
+	for (bindex = parent_bend; bindex >= 0; bindex--, p--)
+		if (p->hd_dentry) {
+			dinfo->di_bend = bindex;
+			break;
+		}
+
+	npositive = 0;
+	parent_bstart = au_dbstart(parent);
+	if (type != S_IFDIR && dinfo->di_bstart == parent_bstart)
+		goto out_dgen; /* success */
+
+	npositive = au_lkup_dentry(dentry, parent_bstart, type, /*nd*/NULL);
+	if (npositive < 0)
+		goto out;
+	if (dinfo->di_bwh >= 0 && dinfo->di_bwh <= dinfo->di_bstart)
+		d_drop(dentry);
+
+ out_dgen:
+	au_update_digen(dentry);
+ out:
+	dput(parent);
+	AuTraceErr(npositive);
+	return npositive;
+}
+
+static int au_lock_nd(struct dentry *dentry, struct nameidata *nd)
+{
+	int locked = 0;
+	if (nd && dentry != nd->path.dentry) {
+		di_read_lock_parent(nd->path.dentry, 0);
+		locked = 1;
+	}
+	return locked;
+}
+
+static void au_unlock_nd(int locked, struct nameidata *nd)
+{
+	if (locked)
+		di_read_unlock(nd->path.dentry, 0);
+}
+
+/* #define TestingFuse */
+static noinline_for_stack
+int au_do_h_d_reval(struct dentry *dentry, aufs_bindex_t bindex,
+		    struct nameidata *nd, struct dentry *h_dentry)
+{
+	int err, valid, e;
+	int (*reval)(struct dentry *, struct nameidata *);
+	struct super_block *sb;
+	struct nameidata fake_nd, *p;
+
+	LKTRTrace("%.*s, b%d, nd %d\n", AuDLNPair(dentry), bindex, !!nd);
+
+	err = 0;
+	reval = NULL;
+	if (h_dentry->d_op)
+		reval = h_dentry->d_op->d_revalidate;
+	if (!reval)
+		goto out;
+
+	sb = dentry->d_sb;
+	if (nd) {
+		memcpy(&fake_nd, nd, sizeof(*nd));
+		err = au_fake_intent(&fake_nd, au_sbr(sb, bindex));
+		if (unlikely(err)) {
+			err = -EINVAL;
+			goto out;
+		}
+	}
+	p = au_fake_dm(&fake_nd, nd, sb, bindex);
+	AuDebugOn(IS_ERR(p));
+	AuDebugOn(nd && p != &fake_nd);
+	LKTRTrace("b%d\n", bindex);
+
+	/* it may return tri-state */
+	valid = reval(h_dentry, p);
+	if (unlikely(valid < 0))
+		err = valid;
+	else if (!valid)
+		err = -EINVAL;
+	else
+		AuDebugOn(err);
+
+	if (p) {
+		AuDebugOn(!nd);
+		e = au_hin_after_reval(p, dentry, bindex, nd->intent.open.file);
+#ifndef TestingFuse
+		au_update_fuse_h_inode(p->path.mnt, h_dentry); /*ignore*/
+#endif
+		if (unlikely(e && !err))
+			err = e;
+	}
+#ifndef TestingFuse
+	else
+		au_update_fuse_h_inode(NULL, h_dentry); /*ignore*/
+#endif
+	au_fake_dm_release(p);
+
+ out:
+	AuTraceErr(err);
+	return err;
+}
+
+static noinline_for_stack
+int h_d_revalidate(struct dentry *dentry, struct inode *inode,
+		   struct nameidata *nd, int do_udba)
+{
+	int err;
+	aufs_bindex_t bindex, btail, bstart, ibs, ibe;
+	unsigned char plus, locked, unhashed, is_root, h_plus;
+	struct super_block *sb;
+	struct inode *first, *h_inode, *h_cached_inode;
+	umode_t mode, h_mode;
+	struct dentry *h_dentry;
+	struct qstr *name;
+
+	LKTRTrace("%.*s, nd %d\n", AuDLNPair(dentry), !!nd);
+	AuDebugOn(inode && au_digen(dentry) != au_iigen(inode));
+
+	err = 0;
+	sb = dentry->d_sb;
+	plus = 0;
+	mode = 0;
+	first = NULL;
+	ibs = -1;
+	ibe = -1;
+	unhashed = !!d_unhashed(dentry);
+	is_root = !!IS_ROOT(dentry);
+	name = &dentry->d_name;
+
+	/*
+	 * Theoretically, REVAL test should be unnecessary in case of INOTIFY.
+	 * But inotify doesn't fire some necessary events,
+	 *	IN_ATTRIB for atime/nlink/pageio
+	 *	IN_DELETE for NFS dentry
+	 * Let's do REVAL test too.
+	 */
+	if (do_udba && inode) {
+		mode = (inode->i_mode & S_IFMT);
+		plus = (inode->i_nlink > 0);
+		first = au_h_iptr(inode, au_ibstart(inode));
+		ibs = au_ibstart(inode);
+		ibe = au_ibend(inode);
+	}
+
+	bstart = au_dbstart(dentry);
+	btail = bstart;
+	if (inode && S_ISDIR(inode->i_mode))
+		btail = au_dbtaildir(dentry);
+	locked = !!au_lock_nd(dentry, nd);
+	for (bindex = bstart; bindex <= btail; bindex++) {
+		h_dentry = au_h_dptr(dentry, bindex);
+		if (!h_dentry)
+			continue;
+
+		LKTRTrace("b%d, %.*s\n", bindex, AuDLNPair(h_dentry));
+#ifdef TestingFuse
+		/* force re-lookup for fuse, in order to update attributes */
+		if (au_test_fuse(h_dentry->d_sb))
+			goto err;
+#endif
+
+		if (unlikely(do_udba
+			     && !is_root
+			     && (unhashed != !!d_unhashed(h_dentry)
+				 || name->len != h_dentry->d_name.len
+				 || memcmp(name->name, h_dentry->d_name.name,
+					   name->len)
+				     ))) {
+			LKTRTrace("unhash 0x%x 0x%x, %.*s %.*s\n",
+				  unhashed, d_unhashed(h_dentry),
+				  AuDLNPair(dentry), AuDLNPair(h_dentry));
+			goto err;
+		}
+
+		err = au_do_h_d_reval(dentry, bindex, nd, h_dentry);
+		if (unlikely(err))
+			/* do not goto err, to keep the errno */
+			break;
+
+		/* todo: plink too? */
+		if (!do_udba)
+			continue;
+
+		/* UDBA tests */
+		h_inode = h_dentry->d_inode;
+		if (unlikely(!!inode != !!h_inode))
+			goto err;
+
+		h_plus = plus;
+		h_mode = mode;
+		h_cached_inode = h_inode;
+		if (h_inode) {
+			h_mode = (h_inode->i_mode & S_IFMT);
+			h_plus = (h_inode->i_nlink > 0);
+		}
+		if (inode && ibs <= bindex && bindex <= ibe)
+			h_cached_inode = au_h_iptr(inode, bindex);
+
+		LKTRTrace("{%d, 0%o, %p}, h{%d, 0%o, %p}\n",
+			  plus, mode, h_cached_inode,
+			  h_plus, h_mode, h_inode);
+		if (unlikely(plus != h_plus
+			     || mode != h_mode
+			     || h_cached_inode != h_inode))
+			goto err;
+		continue;
+
+	err:
+		err = -EINVAL;
+		break;
+	}
+	au_unlock_nd(locked, nd);
+
+	/*
+	 * judging by timestamps is meaningless since some filesystem uses
+	 * CURRENT_TIME_SEC instead of CURRENT_TIME.
+	 */
+	/*
+	 * NFS may stop IN_DELETE because of DCACHE_NFSFS_RENAMED.
+	 */
+
+	AuTraceErr(err);
+	return err;
+}
+
+static int simple_reval_dpath(struct dentry *dentry, au_gen_t sgen)
+{
+	int err;
+	mode_t type;
+	struct dentry *parent;
+	struct inode *inode;
+
+	LKTRTrace("%.*s, sgen %d\n", AuDLNPair(dentry), sgen);
+	SiMustAnyLock(dentry->d_sb);
+	DiMustWriteLock(dentry);
+	inode = dentry->d_inode;
+	AuDebugOn(!inode);
+
+	if (au_digen(dentry) == sgen && au_iigen(inode) == sgen)
+		return 0;
+
+	parent = dget_parent(dentry);
+	di_read_lock_parent(parent, AuLock_IR);
+	AuDebugOn(au_digen(parent) != sgen
+		  || au_iigen(parent->d_inode) != sgen);
+#ifdef CONFIG_AUFS_DEBUG
+	{
+		int i, j;
+		struct au_dcsub_pages dpages;
+		struct au_dpage *dpage;
+		struct dentry **dentries;
+
+		err = au_dpages_init(&dpages, GFP_NOFS);
+		AuDebugOn(err);
+		err = au_dcsub_pages_rev(&dpages, parent, /*do_include*/1, NULL,
+					 NULL);
+		AuDebugOn(err);
+		for (i = dpages.ndpage - 1; !err && i >= 0; i--) {
+			dpage = dpages.dpages + i;
+			dentries = dpage->dentries;
+			for (j = dpage->ndentry - 1; !err && j >= 0; j--)
+				AuDebugOn(au_digen(dentries[j]) != sgen);
+		}
+		au_dpages_free(&dpages);
+	}
+#endif
+	type = (inode->i_mode & S_IFMT);
+	/* returns a number of positive dentries */
+	err = au_refresh_hdentry(dentry, type);
+	if (err >= 0)
+		err = au_refresh_hinode(inode, dentry);
+	di_read_unlock(parent, AuLock_IR);
+	dput(parent);
+	AuTraceErr(err);
+	return err;
+}
+
+int au_reval_dpath(struct dentry *dentry, au_gen_t sgen)
+{
+	int err;
+	struct dentry *d, *parent;
+	struct inode *inode;
+
+	LKTRTrace("%.*s, sgen %d\n", AuDLNPair(dentry), sgen);
+	AuDebugOn(!dentry->d_inode);
+	DiMustWriteLock(dentry);
+
+	if (!au_ftest_si(au_sbi(dentry->d_sb), FAILED_REFRESH_DIRS))
+		return simple_reval_dpath(dentry, sgen);
+
+	/* slow loop, keep it simple and stupid */
+	/* cf: au_cpup_dirs() */
+	err = 0;
+	parent = NULL;
+	while (au_digen(dentry) != sgen || au_iigen(dentry->d_inode) != sgen) {
+		d = dentry;
+		while (1) {
+			dput(parent);
+			parent = dget_parent(d);
+			if (au_digen(parent) == sgen
+			    && au_iigen(parent->d_inode) == sgen)
+				break;
+			d = parent;
+		}
+
+		inode = d->d_inode;
+		if (d != dentry)
+			di_write_lock_child(d);
+
+		/* someone might update our dentry while we were sleeping */
+		if (au_digen(d) != sgen || au_iigen(d->d_inode) != sgen) {
+			di_read_lock_parent(parent, AuLock_IR);
+			/* returns a number of positive dentries */
+			err = au_refresh_hdentry(d, inode->i_mode & S_IFMT);
+			if (err >= 0)
+				err = au_refresh_hinode(inode, d);
+			di_read_unlock(parent, AuLock_IR);
+		}
+
+		if (d != dentry)
+			di_write_unlock(d);
+		dput(parent);
+		if (unlikely(err))
+			break;
+	}
+
+	AuTraceErr(err);
+	return err;
+}
+
+/*
+ * THIS IS A BOOLEAN FUNCTION: returns 1 if valid, 0 otherwise.
+ * nfsd passes NULL as nameidata.
+ */
+static int aufs_d_revalidate(struct dentry *dentry, struct nameidata *nd)
+{
+	int valid, err;
+	au_gen_t sgen;
+	unsigned char do_udba;
+	struct nameidata tmp_nd, *ndp;
+	struct super_block *sb;
+	struct inode *inode;
+
+	LKTRTrace("dentry %.*s\n", AuDLNPair(dentry));
+	if (nd && nd->path.dentry)
+		LKTRTrace("nd{%.*s, 0x%x}\n",
+			  AuDLNPair(nd->path.dentry), nd->flags);
+	/*
+	 * dir case: AuDebugOn(dentry->d_parent != nd->dentry);
+	 * remove failure case:AuDebugOn(!IS_ROOT(dentry)
+	 * 				 && d_unhashed(dentry));
+	*/
+	AuDebugOn(!dentry->d_fsdata);
+
+	err = -EINVAL;
+	sb = dentry->d_sb;
+	aufs_read_lock(dentry, AuLock_FLUSH | AuLock_DW);
+	inode = dentry->d_inode;
+	sgen = au_sigen(sb);
+	if (au_digen(dentry) != sgen) {
+		AuDebugOn(IS_ROOT(dentry));
+#ifdef ForceInotify
+		AuDbg("UDBA or digen, %.*s\n", AuDLNPair(dentry));
+#endif
+		if (inode)
+			err = au_reval_dpath(dentry, sgen);
+		if (unlikely(err))
+			goto out_dgrade;
+		AuDebugOn(au_digen(dentry) != sgen);
+	}
+	if (inode && au_iigen(inode) != sgen) {
+		AuDebugOn(IS_ROOT(dentry));
+#ifdef ForceInotify
+		AuDbg("UDBA or survived, %.*s\n", AuDLNPair(dentry));
+#endif
+		err = au_refresh_hinode(inode, dentry);
+		if (unlikely(err))
+			goto out_dgrade;
+		AuDebugOn(au_iigen(inode) != sgen);
+	}
+	di_downgrade_lock(dentry, AuLock_IR);
+
+#if 0 /* todo: support it? */
+	/* parent dir i_nlink is not updated in the case of setattr */
+	if (S_ISDIR(inode->i_mode)) {
+		mutex_lock(&inode->i_mutex);
+		ii_write_lock(inode);
+		au_cpup_attr_nlink(inode);
+		ii_write_unlock(inode);
+		mutex_unlock(&inode->i_mutex);
+	}
+#endif
+
+	AuDebugOn(au_digen(dentry) != sgen);
+	AuDebugOn(inode && au_iigen(inode) != sgen);
+	err = -EINVAL;
+	do_udba = !au_opt_test(au_mntflags(sb), UDBA_NONE);
+	if (do_udba && inode) {
+		aufs_bindex_t bstart = au_ibstart(inode);
+		if (bstart >= 0
+		    && au_test_higen(inode, au_h_iptr(inode, bstart)))
+			goto out;
+	}
+	ndp = au_dup_nd(au_sbi(sb), &tmp_nd, nd);
+#if 0
+	if (nd) {
+		path = nd->path;
+		nd->path.dentry = au_h_dptr(nd->path.dentry, bindex);
+	if (fake_nd->path.dentry) {
+		fake_nd->path.mnt = au_sbr_mnt(sb, bindex);
+		AuDebugOn(!fake_nd->path.mnt);
+		path_get(&fake_nd->path);
+		nd->path.
+			}
+	}
+#endif
+	err = h_d_revalidate(dentry, inode, ndp, do_udba);
+	if (unlikely(!err && do_udba && au_dbstart(dentry) < 0))
+		/* both of real entry and whiteout found */
+		err = -EIO;
+	goto out;
+
+ out_dgrade:
+	di_downgrade_lock(dentry, AuLock_IR);
+ out:
+	au_store_fmode_exec(nd, inode);
+	aufs_read_unlock(dentry, AuLock_IR);
+	AuTraceErr(err);
+	valid = !err;
+	if (!valid)
+		LKTRTrace("%.*s invalid\n", AuDLNPair(dentry));
+	return valid;
+}
+
+static void aufs_d_release(struct dentry *dentry)
+{
+	struct au_dinfo *dinfo;
+	aufs_bindex_t bend, bindex;
+
+	LKTRTrace("%.*s\n", AuDLNPair(dentry));
+	AuDebugOn(!d_unhashed(dentry));
+
+	dinfo = dentry->d_fsdata;
+	if (!dinfo)
+		return;
+
+	/* dentry may not be revalidated */
+	bindex = dinfo->di_bstart;
+	if (bindex >= 0) {
+		struct au_hdentry *p;
+		bend = dinfo->di_bend;
+		AuDebugOn(bend < bindex);
+		p = dinfo->di_hdentry + bindex;
+		while (bindex++ <= bend) {
+			if (p->hd_dentry)
+				au_hdput(p, /*do_free*/1);
+			p++;
+		}
+	}
+	kfree(dinfo->di_hdentry);
+	au_rwsem_destroy(&dinfo->di_rwsem);
+	au_cache_free_dinfo(dinfo);
+	au_hin_di_reinit(dentry);
+}
+
+struct dentry_operations aufs_dop = {
+	.d_revalidate	= aufs_d_revalidate,
+	.d_release	= aufs_d_release,
+	/* never use d_delete, especially in case of nfs server */
+};
diff -Nurp linux-2.6.27.orig/fs/aufs/dentry.h linux-2.6.27/fs/aufs/dentry.h
--- linux-2.6.27.orig/fs/aufs/dentry.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.27/fs/aufs/dentry.h	2008-12-14 10:37:40.000000000 +0100
@@ -0,0 +1,396 @@
+/*
+ * Copyright (C) 2005-2008 Junjiro Okajima
+ *
+ * This program, aufs is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+ */
+
+/*
+ * lookup and dentry operations
+ *
+ * $Id: dentry.h,v 1.11 2008/12/08 06:11:35 sfjro Exp $
+ */
+
+#ifndef __AUFS_DENTRY_H__
+#define __AUFS_DENTRY_H__
+
+#ifdef __KERNEL__
+
+#include <linux/fs.h>
+#include <linux/namei.h>
+#include <linux/aufs_type.h>
+#include "misc.h"
+#include "super.h"
+#include "vfsub.h"
+
+/* nameidata open_intent */
+enum {
+	AuIntent_AUFS,
+	AuIntent_BRANCH,
+	AuIntent_Last
+};
+
+struct au_hdintent {
+	struct list_head	hdi_list;
+	struct file		*hdi_file[AuIntent_Last];
+};
+
+struct au_hdentry {
+	struct dentry		*hd_dentry;
+
+#ifdef CONFIG_AUFS_BR_NFS
+	spinlock_t		hd_lock; /* intest_list */
+	struct list_head	*hd_intent_list;
+#endif
+};
+
+struct au_dinfo {
+	atomic_t		di_generation;
+
+	struct au_rwsem		di_rwsem;
+	aufs_bindex_t		di_bstart, di_bend, di_bwh, di_bdiropq;
+	struct au_hdentry	*di_hdentry;
+};
+
+/* nameidata extension flags */
+#define AuNdx_DLGT	1
+#define AuNdx_DIRPERM1	(1 << 1)
+#define au_ftest_ndx(flags, name)	((flags) & AuNdx_##name)
+#define au_fset_ndx(flags, name)	{ (flags) |= AuNdx_##name; }
+#define au_fclr_ndx(flags, name)	{ (flags) &= ~AuNdx_##name; }
+#ifndef CONFIG_AUFS_DLGT
+#undef AuNdx_DLGT
+#define AuNdx_DLGT	0
+#undef AuNdx_DIRPERM1
+#define AuNdx_DIRPERM1	0
+#endif
+
+struct au_ndx {
+	struct vfsmount *nfsmnt;
+	unsigned int flags;
+	struct nameidata *nd;
+	struct au_branch *br;
+	struct file *nd_file;
+};
+
+/* ---------------------------------------------------------------------- */
+
+static inline void au_do_h_dentry_init(struct au_hdentry *hdentry)
+{
+	hdentry->hd_dentry = NULL;
+}
+
+#ifdef CONFIG_AUFS_BR_NFS
+static inline void au_h_dentry_init(struct au_hdentry *hdentry)
+{
+	au_do_h_dentry_init(hdentry);
+	spin_lock_init(&hdentry->hd_lock);
+}
+
+static inline void au_h_dentry_init_all(struct au_hdentry *hdentry, int n)
+{
+	while (n--)
+		spin_lock_init(&hdentry[n].hd_lock);
+}
+
+/* br_nfs.c */
+struct file *au_h_intent(struct dentry *dentry, aufs_bindex_t bindex,
+			 struct file *file);
+int au_br_nfs_h_intent(struct file *nd_file, struct dentry *dentry,
+		       aufs_bindex_t bindex, struct nameidata *nd);
+void au_hintent_put(struct au_hdentry *hd, int do_free);
+int au_fake_intent(struct nameidata *nd, struct au_branch *br);
+int au_hin_after_reval(struct nameidata *nd, struct dentry *dentry,
+		       aufs_bindex_t bindex, struct file *file);
+struct dentry *au_lkup_hash(const char *name, struct dentry *parent, int len,
+			    struct au_ndx *ndx);
+#else
+
+static inline void au_h_dentry_init(struct au_hdentry *hdentry)
+{
+	au_do_h_dentry_init(hdentry);
+}
+
+static inline void au_h_dentry_init_all(struct au_hdentry *hdentry, int n)
+{
+	/* nothing */
+}
+
+static inline
+struct file *au_h_intent(struct dentry *dentry, aufs_bindex_t bindex,
+			 struct file *file)
+{
+	/* return ERR_PTR(-ENOSYS); */
+	return NULL;
+}
+
+static inline
+int au_br_nfs_h_intent(struct file *nd_file, struct dentry *dentry,
+		       aufs_bindex_t bindex, struct nameidata *nd)
+{
+	return 0;
+}
+
+static inline void au_hintent_put(struct au_hdentry *hd, int do_free)
+{
+	/* empty */
+}
+
+static inline int au_fake_intent(struct nameidata *nd, struct au_branch *br)
+{
+	return 0;
+}
+
+static inline
+int au_hin_after_reval(struct nameidata *nd, struct dentry *dentry,
+		       aufs_bindex_t bindex, struct file *file)
+{
+	return 0;
+}
+
+#ifdef CONFIG_AUFS_DLGT
+static inline
+struct dentry *au_lkup_hash(const char *name, struct dentry *parent, int len,
+			    struct au_ndx *ndx)
+{
+	/* return ERR_PTR(-ENOSYS); */
+	return vfsub_lookup_one_len(name, parent, len);
+}
+#endif
+#endif /* CONFIG_AUFS_BR_NFS */
+
+#ifdef CONFIG_AUFS_DLGT
+/* dlgt.c */
+struct dentry *au_lkup_one_dlgt(const char *name, struct dentry *parent,
+				int len, unsigned int flags);
+#elif defined(CONFIG_AUFS_BR_NFS)
+/* regardelss kernel version */
+static inline
+struct dentry *au_lkup_one_dlgt(const char *name, struct dentry *parent,
+				int len, unsigned int flags)
+{
+	return vfsub_lookup_one_len(name, parent, len);
+}
+#endif
+
+/* dentry.c */
+extern struct dentry_operations aufs_dop;
+#if defined(CONFIG_AUFS_BR_NFS) || defined(CONFIG_AUFS_DLGT)
+struct dentry *au_lkup_one(const char *name, struct dentry *parent, int len,
+			   struct au_ndx *ndx);
+#else
+static inline
+struct dentry *au_lkup_one(const char *name, struct dentry *parent, int len,
+			   struct au_ndx *ndx)
+{
+	/* todo? ndx->nd_file = NULL; */
+	return vfsub_lookup_one_len(name, parent, len);
+}
+#endif
+struct dentry *au_sio_lkup_one(const char *name, struct dentry *parent, int len,
+			       struct au_ndx *ndx);
+int au_lkup_dentry(struct dentry *dentry, aufs_bindex_t bstart, mode_t type,
+		   struct nameidata *nd);
+int au_lkup_neg(struct dentry *dentry, aufs_bindex_t bindex);
+int au_refresh_hdentry(struct dentry *dentry, mode_t type);
+int au_reval_dpath(struct dentry *dentry, au_gen_t sgen);
+
+/* dinfo.c */
+int au_alloc_dinfo(struct dentry *dentry);
+struct au_dinfo *au_di(struct dentry *dentry);
+
+void di_read_lock(struct dentry *d, int flags, unsigned int lsc);
+void di_read_unlock(struct dentry *d, int flags);
+void di_downgrade_lock(struct dentry *d, int flags);
+void di_write_lock(struct dentry *d, unsigned int lsc);
+void di_write_unlock(struct dentry *d);
+void di_write_lock2_child(struct dentry *d1, struct dentry *d2, int isdir);
+void di_write_lock2_parent(struct dentry *d1, struct dentry *d2, int isdir);
+void di_write_unlock2(struct dentry *d1, struct dentry *d2);
+
+struct dentry *au_h_dptr(struct dentry *dentry, aufs_bindex_t bindex);
+
+aufs_bindex_t au_dbtail(struct dentry *dentry);
+aufs_bindex_t au_dbtaildir(struct dentry *dentry);
+#if 0 /* reserved for future use */
+aufs_bindex_t au_dbtail_generic(struct dentry *dentry);
+#endif
+
+void au_set_dbdiropq(struct dentry *dentry, aufs_bindex_t bindex);
+void au_set_h_dptr(struct dentry *dentry, aufs_bindex_t bindex,
+		   struct dentry *h_dentry);
+
+void au_update_dbrange(struct dentry *dentry, int do_put_zero);
+void au_update_dbstart(struct dentry *dentry);
+void au_update_dbend(struct dentry *dentry);
+int au_find_dbindex(struct dentry *dentry, struct dentry *h_dentry);
+
+/* ---------------------------------------------------------------------- */
+
+/* todo: memory barrier? */
+static inline au_gen_t au_digen(struct dentry *d)
+{
+	return atomic_read(&au_di(d)->di_generation);
+}
+
+#ifdef CONFIG_AUFS_HINOTIFY
+static inline au_gen_t au_digen_dec(struct dentry *d)
+{
+	return atomic_dec_return(&au_di(d)->di_generation);
+}
+
+static inline void au_hin_di_reinit(struct dentry *d)
+{
+	d->d_fsdata = NULL;
+}
+#else
+static inline void au_hin_di_reinit(struct dentry *d)
+{
+	/* empty */
+}
+#endif /* CONFIG_AUFS_HINOTIFY */
+
+/* ---------------------------------------------------------------------- */
+
+/* lock subclass for dinfo */
+enum {
+	AuLsc_DI_CHILD,		/* child first */
+	AuLsc_DI_CHILD2,	/* rename(2), link(2), and cpup at hinotify */
+	AuLsc_DI_CHILD3,	/* copyup dirs */
+	AuLsc_DI_PARENT,
+	AuLsc_DI_PARENT2,
+	AuLsc_DI_PARENT3,
+	AuLsc_DI_PARENT4
+};
+
+/*
+ * di_read_lock_child, di_write_lock_child,
+ * di_read_lock_child2, di_write_lock_child2,
+ * di_read_lock_child3, di_write_lock_child3,
+ * di_read_lock_parent, di_write_lock_parent,
+ * di_read_lock_parent2, di_write_lock_parent2,
+ * di_read_lock_parent3, di_write_lock_parent3,
+ * di_read_lock_parent4, di_write_lock_parent4,
+ */
+#define AuReadLockFunc(name, lsc) \
+static inline void di_read_lock_##name(struct dentry *d, int flags) \
+{ di_read_lock(d, flags, AuLsc_DI_##lsc); }
+
+#define AuWriteLockFunc(name, lsc) \
+static inline void di_write_lock_##name(struct dentry *d) \
+{ di_write_lock(d, AuLsc_DI_##lsc); }
+
+#define AuRWLockFuncs(name, lsc) \
+	AuReadLockFunc(name, lsc) \
+	AuWriteLockFunc(name, lsc)
+
+AuRWLockFuncs(child, CHILD);
+AuRWLockFuncs(child2, CHILD2);
+AuRWLockFuncs(child3, CHILD3);
+AuRWLockFuncs(parent, PARENT);
+AuRWLockFuncs(parent2, PARENT2);
+AuRWLockFuncs(parent3, PARENT3);
+AuRWLockFuncs(parent4, PARENT4);
+
+#undef AuReadLockFunc
+#undef AuWriteLockFunc
+#undef AuRWLockFuncs
+
+/* to debug easier, do not make them inlined functions */
+#define DiMustReadLock(d) do { \
+	SiMustAnyLock((d)->d_sb); \
+	AuRwMustReadLock(&au_di(d)->di_rwsem); \
+} while (0)
+
+#define DiMustWriteLock(d) do { \
+	SiMustAnyLock((d)->d_sb); \
+	AuRwMustWriteLock(&au_di(d)->di_rwsem); \
+} while (0)
+
+#define DiMustAnyLock(d) do { \
+	SiMustAnyLock((d)->d_sb); \
+	AuRwMustAnyLock(&au_di(d)->di_rwsem); \
+} while (0)
+
+#define DiMustNoWaiters(d)	AuRwMustNoWaiters(&au_di(d)->di_rwsem)
+
+/* ---------------------------------------------------------------------- */
+
+static inline aufs_bindex_t au_dbstart(struct dentry *dentry)
+{
+	DiMustAnyLock(dentry);
+	return au_di(dentry)->di_bstart;
+}
+
+static inline aufs_bindex_t au_dbend(struct dentry *dentry)
+{
+	DiMustAnyLock(dentry);
+	return au_di(dentry)->di_bend;
+}
+
+static inline aufs_bindex_t au_dbwh(struct dentry *dentry)
+{
+	DiMustAnyLock(dentry);
+	return au_di(dentry)->di_bwh;
+}
+
+static inline aufs_bindex_t au_dbdiropq(struct dentry *dentry)
+{
+	DiMustAnyLock(dentry);
+	AuDebugOn(dentry->d_inode
+		  && dentry->d_inode->i_mode
+		  && !S_ISDIR(dentry->d_inode->i_mode));
+	return au_di(dentry)->di_bdiropq;
+}
+
+/* todo: hard/soft set? */
+static inline void au_set_dbstart(struct dentry *dentry, aufs_bindex_t bindex)
+{
+	DiMustWriteLock(dentry);
+	AuDebugOn(au_sbend(dentry->d_sb) < bindex);
+	/* */
+	au_di(dentry)->di_bstart = bindex;
+}
+
+static inline void au_set_dbend(struct dentry *dentry, aufs_bindex_t bindex)
+{
+	DiMustWriteLock(dentry);
+	AuDebugOn(au_sbend(dentry->d_sb) < bindex
+		  || bindex < au_dbstart(dentry));
+	au_di(dentry)->di_bend = bindex;
+}
+
+static inline void au_set_dbwh(struct dentry *dentry, aufs_bindex_t bindex)
+{
+	DiMustWriteLock(dentry);
+	AuDebugOn(au_sbend(dentry->d_sb) < bindex);
+	/* dbwh can be outside of bstart - bend range */
+	au_di(dentry)->di_bwh = bindex;
+}
+
+static inline void au_hdput(struct au_hdentry *hd, int do_free)
+{
+	au_hintent_put(hd, do_free);
+	dput(hd->hd_dentry);
+}
+
+static inline void au_update_digen(struct dentry *dentry)
+{
+	AuDebugOn(!dentry->d_sb);
+	atomic_set(&au_di(dentry)->di_generation, au_sigen(dentry->d_sb));
+	/* smp_mb(); */ /* atomic_set */
+}
+
+#endif /* __KERNEL__ */
+#endif /* __AUFS_DENTRY_H__ */
diff -Nurp linux-2.6.27.orig/fs/aufs/dinfo.c linux-2.6.27/fs/aufs/dinfo.c
--- linux-2.6.27.orig/fs/aufs/dinfo.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.27/fs/aufs/dinfo.c	2008-12-14 10:37:40.000000000 +0100
@@ -0,0 +1,436 @@
+/*
+ * Copyright (C) 2005-2008 Junjiro Okajima
+ *
+ * This program, aufs is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+ */
+
+/*
+ * dentry private data
+ *
+ * $Id: dinfo.c,v 1.9 2008/12/01 03:49:29 sfjro Exp $
+ */
+
+#include "aufs.h"
+
+int au_alloc_dinfo(struct dentry *dentry)
+{
+	struct au_dinfo *dinfo;
+	struct super_block *sb;
+	int nbr;
+
+	LKTRTrace("%.*s\n", AuDLNPair(dentry));
+	AuDebugOn(dentry->d_fsdata);
+
+	dinfo = au_cache_alloc_dinfo();
+	if (dinfo) {
+		sb = dentry->d_sb;
+		nbr = au_sbend(sb) + 1;
+		if (nbr <= 0)
+			nbr = 1;
+		dinfo->di_hdentry = kcalloc(nbr, sizeof(*dinfo->di_hdentry),
+					    GFP_NOFS);
+		if (dinfo->di_hdentry) {
+			au_h_dentry_init_all(dinfo->di_hdentry, nbr);
+			atomic_set(&dinfo->di_generation, au_sigen(sb));
+			/* smp_mb(); */ /* atomic_set */
+			au_rw_init_wlock_nested(&dinfo->di_rwsem,
+						AuLsc_DI_CHILD);
+			au_dbg_locked_di_reg(dentry, AuLock_DW, AuLsc_DI_CHILD);
+			dinfo->di_bstart = -1;
+			dinfo->di_bend = -1;
+			dinfo->di_bwh = -1;
+			dinfo->di_bdiropq = -1;
+
+			dentry->d_fsdata = dinfo;
+			dentry->d_op = &aufs_dop;
+			return 0; /* success */
+		}
+		au_cache_free_dinfo(dinfo);
+	}
+	AuTraceErr(-ENOMEM);
+	return -ENOMEM;
+}
+
+struct au_dinfo *au_di(struct dentry *dentry)
+{
+	struct au_dinfo *dinfo = dentry->d_fsdata;
+	AuDebugOn(!dinfo
+		 || !dinfo->di_hdentry
+		 /* || au_sbi(dentry->d_sb)->si_bend < dinfo->di_bend */
+		 || dinfo->di_bend < dinfo->di_bstart
+		 /* dbwh can be outside of this range */
+		 || (0 <= dinfo->di_bdiropq
+		     && (dinfo->di_bdiropq < dinfo->di_bstart
+			 /* || dinfo->di_bend < dinfo->di_bdiropq */))
+		);
+	return dinfo;
+}
+
+/* ---------------------------------------------------------------------- */
+
+static void do_ii_write_lock(struct inode *inode, unsigned int lsc)
+{
+	switch (lsc) {
+	case AuLsc_DI_CHILD:
+		ii_write_lock_child(inode);
+		break;
+	case AuLsc_DI_CHILD2:
+		ii_write_lock_child2(inode);
+		break;
+	case AuLsc_DI_CHILD3:
+		ii_write_lock_child3(inode);
+		break;
+	case AuLsc_DI_PARENT:
+		ii_write_lock_parent(inode);
+		break;
+	case AuLsc_DI_PARENT2:
+		ii_write_lock_parent2(inode);
+		break;
+	case AuLsc_DI_PARENT3:
+		ii_write_lock_parent3(inode);
+		break;
+	case AuLsc_DI_PARENT4:
+		ii_write_lock_parent4(inode);
+		break;
+	default:
+		BUG();
+	}
+}
+
+static void do_ii_read_lock(struct inode *inode, unsigned int lsc)
+{
+	switch (lsc) {
+	case AuLsc_DI_CHILD:
+		ii_read_lock_child(inode);
+		break;
+	case AuLsc_DI_CHILD2:
+		ii_read_lock_child2(inode);
+		break;
+	case AuLsc_DI_CHILD3:
+		ii_read_lock_child3(inode);
+		break;
+	case AuLsc_DI_PARENT:
+		ii_read_lock_parent(inode);
+		break;
+	case AuLsc_DI_PARENT2:
+		ii_read_lock_parent2(inode);
+		break;
+	case AuLsc_DI_PARENT3:
+		ii_read_lock_parent3(inode);
+		break;
+	case AuLsc_DI_PARENT4:
+		ii_read_lock_parent4(inode);
+		break;
+	default:
+		BUG();
+	}
+}
+
+void di_read_lock(struct dentry *d, int flags, unsigned int lsc)
+{
+	LKTRTrace("%.*s, %u\n", AuDLNPair(d), lsc);
+	SiMustAnyLock(d->d_sb);
+
+	/* todo: always nested? */
+	au_dbg_locking_di_reg(d, flags, lsc);
+	au_rw_read_lock_nested(&au_di(d)->di_rwsem, lsc);
+	au_dbg_locking_di_unreg(d, flags);
+	au_dbg_locked_di_reg(d, flags, lsc);
+	if (d->d_inode) {
+		if (au_ftest_lock(flags, IW))
+			do_ii_write_lock(d->d_inode, lsc);
+		else if (au_ftest_lock(flags, IR))
+			do_ii_read_lock(d->d_inode, lsc);
+	}
+}
+
+void di_read_unlock(struct dentry *d, int flags)
+{
+	LKTRTrace("%.*s\n", AuDLNPair(d));
+	SiMustAnyLock(d->d_sb);
+
+	if (d->d_inode) {
+		if (au_ftest_lock(flags, IW))
+			ii_write_unlock(d->d_inode);
+		else if (au_ftest_lock(flags, IR))
+			ii_read_unlock(d->d_inode);
+	}
+	au_rw_read_unlock(&au_di(d)->di_rwsem);
+	au_dbg_locked_di_unreg(d, flags);
+}
+
+void di_downgrade_lock(struct dentry *d, int flags)
+{
+	SiMustAnyLock(d->d_sb);
+
+	au_rw_dgrade_lock(&au_di(d)->di_rwsem);
+	if (d->d_inode && au_ftest_lock(flags, IR))
+		ii_downgrade_lock(d->d_inode);
+}
+
+void di_write_lock(struct dentry *d, unsigned int lsc)
+{
+	LKTRTrace("%.*s, %u\n", AuDLNPair(d), lsc);
+	SiMustAnyLock(d->d_sb);
+
+	/* todo: always nested? */
+	au_dbg_locking_di_reg(d, AuLock_IW, lsc);
+	au_rw_write_lock_nested(&au_di(d)->di_rwsem, lsc);
+	au_dbg_locking_di_unreg(d, AuLock_IW);
+	au_dbg_locked_di_reg(d, AuLock_IW, lsc);
+	if (d->d_inode)
+		do_ii_write_lock(d->d_inode, lsc);
+}
+
+void di_write_unlock(struct dentry *d)
+{
+	LKTRTrace("%.*s\n", AuDLNPair(d));
+	SiMustAnyLock(d->d_sb);
+
+	if (d->d_inode)
+		ii_write_unlock(d->d_inode);
+	au_rw_write_unlock(&au_di(d)->di_rwsem);
+	au_dbg_locked_di_unreg(d, AuLock_IW);
+}
+
+void di_write_lock2_child(struct dentry *d1, struct dentry *d2, int isdir)
+{
+	AuTraceEnter();
+	AuDebugOn(d1 == d2
+		  || d1->d_inode == d2->d_inode
+		  || d1->d_sb != d2->d_sb);
+
+	if (isdir && au_test_subdir(d1, d2)) {
+		di_write_lock_child(d1);
+		di_write_lock_child2(d2);
+	} else {
+		/* there should be no races */
+		di_write_lock_child(d2);
+		di_write_lock_child2(d1);
+	}
+}
+
+void di_write_lock2_parent(struct dentry *d1, struct dentry *d2, int isdir)
+{
+	AuTraceEnter();
+	AuDebugOn(d1 == d2
+		  || d1->d_inode == d2->d_inode
+		  || d1->d_sb != d2->d_sb);
+
+	if (isdir && au_test_subdir(d1, d2)) {
+		di_write_lock_parent(d1);
+		di_write_lock_parent2(d2);
+	} else {
+		/* there should be no races */
+		di_write_lock_parent(d2);
+		di_write_lock_parent2(d1);
+	}
+}
+
+void di_write_unlock2(struct dentry *d1, struct dentry *d2)
+{
+	di_write_unlock(d1);
+	if (d1->d_inode == d2->d_inode) {
+		au_rw_write_unlock(&au_di(d2)->di_rwsem);
+		au_dbg_locked_di_unreg(d2, AuLock_IW);
+	} else
+		di_write_unlock(d2);
+}
+
+/* ---------------------------------------------------------------------- */
+
+struct dentry *au_h_dptr(struct dentry *dentry, aufs_bindex_t bindex)
+{
+	struct dentry *d;
+
+	DiMustAnyLock(dentry);
+	if (au_dbstart(dentry) < 0 || bindex < au_dbstart(dentry))
+		return NULL;
+	AuDebugOn(bindex < 0
+		  /* || bindex > au_sbend(dentry->d_sb) */);
+	d = au_di(dentry)->di_hdentry[0 + bindex].hd_dentry;
+	AuDebugOn(d && (atomic_read(&d->d_count) <= 0));
+	return d;
+}
+
+aufs_bindex_t au_dbtail(struct dentry *dentry)
+{
+	aufs_bindex_t bend, bwh;
+
+	bend = au_dbend(dentry);
+	if (0 <= bend) {
+		bwh = au_dbwh(dentry);
+		if (!bwh)
+			return bwh;
+		if (0 < bwh && bwh < bend)
+			return bwh - 1;
+	}
+	return bend;
+}
+
+aufs_bindex_t au_dbtaildir(struct dentry *dentry)
+{
+	aufs_bindex_t bend, bopq;
+
+	AuDebugOn(dentry->d_inode
+		  && dentry->d_inode->i_mode
+		  && !S_ISDIR(dentry->d_inode->i_mode));
+
+	bend = au_dbtail(dentry);
+	if (0 <= bend) {
+		bopq = au_dbdiropq(dentry);
+		AuDebugOn(bend < bopq);
+		if (0 <= bopq && bopq < bend)
+			bend = bopq;
+	}
+	return bend;
+}
+
+#if 0 /* reserved for future use */
+aufs_bindex_t au_dbtail_generic(struct dentry *dentry)
+{
+	struct inode *inode;
+
+	inode = dentry->d_inode;
+	if (inode && S_ISDIR(inode->i_mode))
+		return au_dbtaildir(dentry);
+	else
+		return au_dbtail(dentry);
+}
+#endif
+
+/* ---------------------------------------------------------------------- */
+
+void au_set_dbdiropq(struct dentry *dentry, aufs_bindex_t bindex)
+{
+	DiMustWriteLock(dentry);
+	AuDebugOn(au_sbend(dentry->d_sb) < bindex);
+	AuDebugOn((bindex >= 0
+		   && (bindex < au_dbstart(dentry)
+		       || au_dbend(dentry) < bindex))
+		  || (dentry->d_inode
+		      && dentry->d_inode->i_mode
+		      && !S_ISDIR(dentry->d_inode->i_mode)));
+	au_di(dentry)->di_bdiropq = bindex;
+}
+
+void au_set_h_dptr(struct dentry *dentry, aufs_bindex_t bindex,
+		   struct dentry *h_dentry)
+{
+	struct au_hdentry *hd = au_di(dentry)->di_hdentry + bindex;
+	DiMustWriteLock(dentry);
+	AuDebugOn(bindex < au_di(dentry)->di_bstart
+		  || bindex > au_di(dentry)->di_bend
+		  || (h_dentry && atomic_read(&h_dentry->d_count) <= 0)
+		  || (h_dentry && hd->hd_dentry)
+		);
+	if (hd->hd_dentry)
+		au_hdput(hd, /*do_free*/0);
+	hd->hd_dentry = h_dentry;
+}
+
+/* ---------------------------------------------------------------------- */
+
+void au_update_dbrange(struct dentry *dentry, int do_put_zero)
+{
+	struct au_dinfo *dinfo;
+	aufs_bindex_t bindex;
+	struct dentry *h_d;
+
+	LKTRTrace("%.*s, %d\n", AuDLNPair(dentry), do_put_zero);
+	DiMustWriteLock(dentry);
+
+	dinfo = au_di(dentry);
+	if (!dinfo || dinfo->di_bstart < 0)
+		return;
+
+	if (do_put_zero) {
+		for (bindex = dinfo->di_bstart; bindex <= dinfo->di_bend;
+		     bindex++) {
+			h_d = dinfo->di_hdentry[0 + bindex].hd_dentry;
+			if (h_d && !h_d->d_inode)
+				au_set_h_dptr(dentry, bindex, NULL);
+		}
+	}
+
+	dinfo->di_bstart = -1;
+	while (++dinfo->di_bstart <= dinfo->di_bend)
+		if (dinfo->di_hdentry[0 + dinfo->di_bstart].hd_dentry)
+			break;
+	if (dinfo->di_bstart > dinfo->di_bend) {
+		dinfo->di_bstart = -1;
+		dinfo->di_bend = -1;
+		return;
+	}
+
+	dinfo->di_bend++;
+	while (0 <= --dinfo->di_bend)
+		if (dinfo->di_hdentry[0 + dinfo->di_bend].hd_dentry)
+			break;
+	AuDebugOn(dinfo->di_bstart > dinfo->di_bend || dinfo->di_bend < 0);
+}
+
+void au_update_dbstart(struct dentry *dentry)
+{
+	aufs_bindex_t bindex,
+		bstart = au_dbstart(dentry),
+		bend = au_dbend(dentry);
+	struct dentry *h_dentry;
+
+	LKTRTrace("%.*s\n", AuDLNPair(dentry));
+	DiMustWriteLock(dentry);
+
+	for (bindex = bstart; bindex <= bend; bindex++) {
+		h_dentry = au_h_dptr(dentry, bindex);
+		if (!h_dentry)
+			continue;
+		if (h_dentry->d_inode) {
+			au_set_dbstart(dentry, bindex);
+			return;
+		}
+		au_set_h_dptr(dentry, bindex, NULL);
+	}
+}
+
+void au_update_dbend(struct dentry *dentry)
+{
+	aufs_bindex_t bindex,
+		bstart = au_dbstart(dentry),
+		bend = au_dbend(dentry);
+	struct dentry *h_dentry;
+
+	DiMustWriteLock(dentry);
+	for (bindex = bend; bindex <= bstart; bindex--) {
+		h_dentry = au_h_dptr(dentry, bindex);
+		if (!h_dentry)
+			continue;
+		if (h_dentry->d_inode) {
+			au_set_dbend(dentry, bindex);
+			return;
+		}
+		au_set_h_dptr(dentry, bindex, NULL);
+	}
+}
+
+int au_find_dbindex(struct dentry *dentry, struct dentry *h_dentry)
+{
+	aufs_bindex_t bindex, bend;
+
+	bend = au_dbend(dentry);
+	for (bindex = au_dbstart(dentry); bindex <= bend; bindex++)
+		if (au_h_dptr(dentry, bindex) == h_dentry)
+			return bindex;
+	return -1;
+}
diff -Nurp linux-2.6.27.orig/fs/aufs/dir.c linux-2.6.27/fs/aufs/dir.c
--- linux-2.6.27.orig/fs/aufs/dir.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.27/fs/aufs/dir.c	2008-12-14 10:37:40.000000000 +0100
@@ -0,0 +1,559 @@
+/*
+ * Copyright (C) 2005-2008 Junjiro Okajima
+ *
+ * This program, aufs is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+ */
+
+/*
+ * directory operations
+ *
+ * $Id: dir.c,v 1.18 2008/12/08 06:11:39 sfjro Exp $
+ */
+
+#include <linux/fs_stack.h>
+#include "aufs.h"
+
+static int reopen_dir(struct file *file)
+{
+	int err;
+	struct dentry *dentry, *h_dentry;
+	aufs_bindex_t bindex, btail, bstart;
+	struct file *h_file;
+
+	dentry = file->f_dentry;
+	LKTRTrace("%.*s\n", AuDLNPair(dentry));
+	AuDebugOn(!S_ISDIR(dentry->d_inode->i_mode));
+
+	/* open all hidden dirs */
+	bstart = au_dbstart(dentry);
+#if 1 /* todo: necessary? */
+	for (bindex = au_fbstart(file); bindex < bstart; bindex++)
+		au_set_h_fptr(file, bindex, NULL);
+#endif
+	au_set_fbstart(file, bstart);
+	btail = au_dbtaildir(dentry);
+#if 1 /* todo: necessary? */
+	for (bindex = au_fbend(file); btail < bindex; bindex--)
+		au_set_h_fptr(file, bindex, NULL);
+#endif
+	au_set_fbend(file, btail);
+	for (bindex = bstart; bindex <= btail; bindex++) {
+		h_dentry = au_h_dptr(dentry, bindex);
+		if (!h_dentry)
+			continue;
+		h_file = au_h_fptr(file, bindex);
+		if (h_file) {
+			AuDebugOn(h_file->f_dentry != h_dentry);
+			continue;
+		}
+
+		h_file = au_h_open(dentry, bindex, file->f_flags, file);
+		err = PTR_ERR(h_file);
+		if (IS_ERR(h_file))
+			goto out; /* close all? */
+		/* cpup_file_flags(h_file, file); */
+		au_set_h_fptr(file, bindex, h_file);
+	}
+	au_update_figen(file);
+	/* todo: necessary? */
+	/* file->f_ra = h_file->f_ra; */
+	err = 0;
+
+ out:
+	AuTraceErr(err);
+	return err;
+}
+
+static int do_open_dir(struct file *file, int flags)
+{
+	int err;
+	aufs_bindex_t bindex, btail;
+	struct dentry *dentry, *h_dentry;
+	struct file *h_file;
+
+	dentry = file->f_dentry;
+	LKTRTrace("%.*s, 0x%x\n", AuDLNPair(dentry), flags);
+	AuDebugOn(!dentry->d_inode || !S_ISDIR(dentry->d_inode->i_mode));
+
+	err = 0;
+	au_set_fvdir_cache(file, NULL);
+	file->f_version = dentry->d_inode->i_version;
+	bindex = au_dbstart(dentry);
+	au_set_fbstart(file, bindex);
+	btail = au_dbtaildir(dentry);
+	au_set_fbend(file, btail);
+	for (; !err && bindex <= btail; bindex++) {
+		h_dentry = au_h_dptr(dentry, bindex);
+		if (!h_dentry)
+			continue;
+
+		h_file = au_h_open(dentry, bindex, flags, file);
+		if (IS_ERR(h_file)) {
+			err = PTR_ERR(h_file);
+			break;
+		}
+		au_set_h_fptr(file, bindex, h_file);
+	}
+	au_update_figen(file);
+	/* todo: necessary? */
+	/* file->f_ra = h_file->f_ra; */
+	if (!err)
+		return 0; /* success */
+
+	/* close all */
+	for (bindex = au_fbstart(file); bindex <= btail; bindex++)
+		au_set_h_fptr(file, bindex, NULL);
+	au_set_fbstart(file, -1);
+	au_set_fbend(file, -1);
+	return err;
+}
+
+static int aufs_open_dir(struct inode *inode, struct file *file)
+{
+	LKTRTrace("i%lu, %.*s\n", inode->i_ino, AuDLNPair(file->f_dentry));
+
+	return au_do_open(inode, file, do_open_dir);
+}
+
+static int aufs_release_dir(struct inode *inode, struct file *file)
+{
+	struct au_vdir *vdir_cache;
+	struct super_block *sb;
+
+	LKTRTrace("i%lu, %.*s\n", inode->i_ino, AuDLNPair(file->f_dentry));
+
+	sb = file->f_dentry->d_sb;
+	si_noflush_read_lock(sb);
+	fi_write_lock(file);
+	vdir_cache = au_fvdir_cache(file);
+	if (vdir_cache)
+		au_vdir_free(vdir_cache);
+	fi_write_unlock(file);
+	au_finfo_fin(file);
+	si_read_unlock(sb);
+	return 0;
+}
+
+static int fsync_dir(struct dentry *dentry, int datasync)
+{
+	int err;
+	struct inode *inode;
+	struct super_block *sb;
+	aufs_bindex_t bend, bindex;
+
+	LKTRTrace("%.*s, %d\n", AuDLNPair(dentry), datasync);
+	DiMustAnyLock(dentry);
+	sb = dentry->d_sb;
+	SiMustAnyLock(sb);
+	inode = dentry->d_inode;
+	IMustLock(inode);
+	IiMustAnyLock(inode);
+
+	err = 0;
+	bend = au_dbend(dentry);
+	for (bindex = au_dbstart(dentry); !err && bindex <= bend; bindex++) {
+		struct dentry *h_dentry;
+		struct inode *h_inode;
+		struct file_operations *fop;
+
+		if (au_test_ro(sb, bindex, inode))
+			continue;
+		h_dentry = au_h_dptr(dentry, bindex);
+		if (!h_dentry)
+			continue;
+		h_inode = h_dentry->d_inode;
+		if (!h_inode)
+			continue;
+
+		/* no mnt_want_write() */
+		/* cf. fs/nsfd/vfs.c and fs/nfsd/nfs4recover.c */
+		/* todo: inotiry fired? */
+		mutex_lock(&h_inode->i_mutex);
+		fop = (void *)h_inode->i_fop;
+		err = filemap_fdatawrite(h_inode->i_mapping);
+		if (!err && fop && fop->fsync)
+			err = fop->fsync(NULL, h_dentry, datasync);
+		if (!err)
+			err = filemap_fdatawrite(h_inode->i_mapping);
+		if (!err)
+			au_update_fuse_h_inode(NULL, h_dentry); /*ignore*/
+		mutex_unlock(&h_inode->i_mutex);
+	}
+
+	AuTraceErr(err);
+	return err;
+}
+
+/*
+ * @file may be NULL
+ */
+static int aufs_fsync_dir(struct file *file, struct dentry *dentry,
+			  int datasync)
+{
+	int err;
+	struct inode *inode;
+	struct file *h_file;
+	struct super_block *sb;
+	aufs_bindex_t bend, bindex;
+
+	LKTRTrace("%.*s, %d\n", AuDLNPair(dentry), datasync);
+	inode = dentry->d_inode;
+	IMustLock(inode);
+
+	err = 0;
+	sb = dentry->d_sb;
+	si_noflush_read_lock(sb);
+	if (file) {
+		err = au_reval_and_lock_fdi(file, reopen_dir, /*wlock*/1,
+					/*locked*/1);
+		if (unlikely(err))
+			goto out;
+	} else
+		di_write_lock_child(dentry);
+
+	if (file) {
+		bend = au_fbend(file);
+		for (bindex = au_fbstart(file); !err && bindex <= bend;
+		     bindex++) {
+			h_file = au_h_fptr(file, bindex);
+			if (!h_file || au_test_ro(sb, bindex, inode))
+				continue;
+
+			err = -EINVAL;
+			if (h_file->f_op && h_file->f_op->fsync) {
+				/* todo: try do_fsync() in fs/sync.c? */
+				mutex_lock(&h_file->f_mapping->host->i_mutex);
+				err = h_file->f_op->fsync
+					(h_file, h_file->f_dentry, datasync);
+				if (!err)
+					au_update_fuse_h_inode
+						(h_file->f_vfsmnt,
+						 h_file->f_dentry);
+				/*ignore*/
+				mutex_unlock(&h_file->f_mapping->host->i_mutex);
+			}
+		}
+	} else
+		err = fsync_dir(dentry, datasync);
+	au_cpup_attr_timesizes(inode);
+	di_write_unlock(dentry);
+	if (file)
+		fi_write_unlock(file);
+
+ out:
+	si_read_unlock(sb);
+	AuTraceErr(err);
+	return err;
+}
+
+/* ---------------------------------------------------------------------- */
+
+static int aufs_readdir(struct file *file, void *dirent, filldir_t filldir)
+{
+	int err;
+	struct dentry *dentry;
+	struct inode *inode;
+	struct super_block *sb;
+
+	dentry = file->f_dentry;
+	LKTRTrace("%.*s, pos %lld\n", AuDLNPair(dentry), file->f_pos);
+	inode = dentry->d_inode;
+	IMustLock(inode);
+
+	sb = dentry->d_sb;
+	si_read_lock(sb, AuLock_FLUSH);
+	err = au_reval_and_lock_fdi(file, reopen_dir, /*wlock*/1, /*locked*/1);
+	if (unlikely(err))
+		goto out;
+	err = au_vdir_init(file);
+	di_downgrade_lock(dentry, AuLock_IR);
+	if (unlikely(err))
+		goto out_unlock;
+
+	if (!au_test_nfsd(current)) {
+		err = au_vdir_fill_de(file, dirent, filldir);
+	} else {
+		/*
+		 * nfsd filldir may call lookup_one_len(), vfs_getattr(),
+		 * encode_fh() and others.
+		 */
+		struct inode *h_inode = au_h_iptr(inode, au_ibstart(inode));
+
+		di_read_unlock(dentry, AuLock_IR);
+		si_read_unlock(sb);
+		lockdep_off();
+		err = au_vdir_fill_de(file, dirent, filldir);
+		lockdep_on();
+		fsstack_copy_attr_atime(inode, h_inode);
+		fi_write_unlock(file);
+
+		AuTraceErr(err);
+		return err;
+	}
+
+	fsstack_copy_attr_atime(inode, au_h_iptr(inode, au_ibstart(inode)));
+
+ out_unlock:
+	di_read_unlock(dentry, AuLock_IR);
+	fi_write_unlock(file);
+ out:
+	si_read_unlock(sb);
+	AuTraceErr(err);
+	return err;
+}
+
+/* ---------------------------------------------------------------------- */
+
+#define AuTestEmpty_WHONLY	1
+#define AuTestEmpty_DLGT	(1 << 1)
+#define AuTestEmpty_DIRPERM1	(1 << 2)
+#define AuTestEmpty_CALLED	(1 << 3)
+#define AuTestEmpty_SHWH	(1 << 4)
+#define au_ftest_testempty(flags, name)	((flags) & AuTestEmpty_##name)
+#define au_fset_testempty(flags, name)	{ (flags) |= AuTestEmpty_##name; }
+#define au_fclr_testempty(flags, name)	{ (flags) &= ~AuTestEmpty_##name; }
+#ifndef CONFIG_AUFS_DLGT
+#undef AuTestEmpty_DLGT
+#define AuTestEmpty_DLGT	0
+#undef AuTestEmpty_DIRPERM1
+#define AuTestEmpty_DIRPERM1	0
+#endif
+#ifndef CONFIG_AUFS_SHWH
+#undef AuTestEmpty_SHWH
+#define AuTestEmpty_SHWH	0
+#endif
+
+struct test_empty_arg {
+	struct au_nhash *whlist;
+	unsigned int flags;
+	int err;
+	aufs_bindex_t bindex;
+};
+
+static int test_empty_cb(void *__arg, const char *__name, int namelen,
+			 loff_t offset, u64 ino, unsigned int d_type)
+{
+	struct test_empty_arg *arg = __arg;
+	char *name = (void *)__name;
+
+	LKTRTrace("%.*s\n", namelen, name);
+
+	arg->err = 0;
+	au_fset_testempty(arg->flags, CALLED);
+	/* smp_mb(); */
+	if (name[0] == '.'
+	    && (namelen == 1 || (name[1] == '.' && namelen == 2)))
+		return 0; /* success */
+
+	if (namelen <= AUFS_WH_PFX_LEN
+	    || memcmp(name, AUFS_WH_PFX, AUFS_WH_PFX_LEN)) {
+		if (au_ftest_testempty(arg->flags, WHONLY)
+		    && !au_nhash_test_known_wh(arg->whlist, name, namelen))
+			arg->err = -ENOTEMPTY;
+		goto out;
+	}
+
+	name += AUFS_WH_PFX_LEN;
+	namelen -= AUFS_WH_PFX_LEN;
+	if (!au_nhash_test_known_wh(arg->whlist, name, namelen))
+		arg->err = au_nhash_append_wh
+			(arg->whlist, name, namelen, ino, d_type, arg->bindex,
+			 au_ftest_testempty(arg->flags, SHWH));
+
+ out:
+	/* smp_mb(); */
+	AuTraceErr(arg->err);
+	return arg->err;
+}
+
+static int do_test_empty(struct dentry *dentry, struct test_empty_arg *arg)
+{
+	int err, dlgt;
+	struct file *h_file;
+
+	LKTRTrace("%.*s, {%p, 0x%x, %d}\n",
+		  AuDLNPair(dentry), arg->whlist, arg->flags, arg->bindex);
+
+	h_file = au_h_open(dentry, arg->bindex,
+			   O_RDONLY | O_NONBLOCK | O_DIRECTORY | O_LARGEFILE,
+			   /*file*/NULL);
+	err = PTR_ERR(h_file);
+	if (IS_ERR(h_file))
+		goto out;
+	err = 0;
+	if (au_opt_test(au_mntflags(dentry->d_sb), UDBA_INOTIFY)
+	    && !h_file->f_dentry->d_inode->i_nlink)
+		goto out_put;
+
+	dlgt = au_ftest_testempty(arg->flags, DLGT);
+	do {
+		arg->err = 0;
+		au_fclr_testempty(arg->flags, CALLED);
+		/* smp_mb(); */
+		err = vfsub_readdir(h_file, test_empty_cb, arg, dlgt);
+		if (err >= 0)
+			err = arg->err;
+	} while (!err && au_ftest_testempty(arg->flags, CALLED));
+
+ out_put:
+	fput(h_file);
+	au_sbr_put(dentry->d_sb, arg->bindex);
+ out:
+	AuTraceErr(err);
+	return err;
+}
+
+struct do_test_empty_args {
+	int *errp;
+	struct dentry *dentry;
+	struct test_empty_arg *arg;
+};
+
+static void call_do_test_empty(void *args)
+{
+	struct do_test_empty_args *a = args;
+	*a->errp = do_test_empty(a->dentry, a->arg);
+}
+
+static int sio_test_empty(struct dentry *dentry, struct test_empty_arg *arg)
+{
+	int err, wkq_err;
+	struct dentry *h_dentry;
+	struct inode *h_inode;
+
+	LKTRTrace("%.*s\n", AuDLNPair(dentry));
+	h_dentry = au_h_dptr(dentry, arg->bindex);
+	AuDebugOn(!h_dentry);
+	h_inode = h_dentry->d_inode;
+	AuDebugOn(!h_inode);
+
+	mutex_lock_nested(&h_inode->i_mutex, AuLsc_I_CHILD);
+	err = au_test_h_perm_sio(h_inode, MAY_EXEC | MAY_READ,
+				 au_test_dlgt(au_mntflags(dentry->d_sb)));
+	mutex_unlock(&h_inode->i_mutex);
+	if (!err)
+		err = do_test_empty(dentry, arg);
+	else {
+		struct do_test_empty_args args = {
+			.errp	= &err,
+			.dentry	= dentry,
+			.arg	= arg
+		};
+		unsigned int flags = arg->flags;
+
+		au_fclr_testempty(arg->flags, DLGT);
+		au_fclr_testempty(arg->flags, DIRPERM1);
+		wkq_err = au_wkq_wait(call_do_test_empty, &args, /*dlgt*/0);
+		if (unlikely(wkq_err))
+			err = wkq_err;
+		arg->flags = flags;
+	}
+
+	AuTraceErr(err);
+	return err;
+}
+
+int au_test_empty_lower(struct dentry *dentry)
+{
+	int err;
+	struct inode *inode;
+	struct test_empty_arg arg;
+	struct au_nhash *whlist;
+	aufs_bindex_t bindex, bstart, btail;
+	unsigned int mnt_flags;
+
+	LKTRTrace("%.*s\n", AuDLNPair(dentry));
+	inode = dentry->d_inode;
+	AuDebugOn(!inode || !S_ISDIR(inode->i_mode));
+
+	whlist = au_nhash_new(GFP_NOFS);
+	err = PTR_ERR(whlist);
+	if (IS_ERR(whlist))
+		goto out;
+
+	bstart = au_dbstart(dentry);
+	mnt_flags = au_mntflags(dentry->d_sb);
+	arg.whlist = whlist;
+	arg.flags = 0;
+	if (au_test_dlgt(mnt_flags))
+		au_fset_testempty(arg.flags, DLGT);
+	if (au_opt_test(mnt_flags, SHWH))
+		au_fset_testempty(arg.flags, SHWH);
+	arg.bindex = bstart;
+	err = do_test_empty(dentry, &arg);
+	if (unlikely(err))
+		goto out_whlist;
+
+	au_fset_testempty(arg.flags, WHONLY);
+	if (au_test_dirperm1(mnt_flags))
+		au_fset_testempty(arg.flags, DIRPERM1);
+	btail = au_dbtaildir(dentry);
+	for (bindex = bstart + 1; !err && bindex <= btail; bindex++) {
+		struct dentry *h_dentry;
+		h_dentry = au_h_dptr(dentry, bindex);
+		if (h_dentry && h_dentry->d_inode) {
+			arg.bindex = bindex;
+			err = do_test_empty(dentry, &arg);
+		}
+	}
+
+ out_whlist:
+	au_nhash_del(whlist);
+ out:
+	AuTraceErr(err);
+	return err;
+}
+
+int au_test_empty(struct dentry *dentry, struct au_nhash *whlist)
+{
+	int err;
+	struct inode *inode;
+	struct test_empty_arg arg;
+	aufs_bindex_t bindex, btail;
+
+	LKTRTrace("%.*s\n", AuDLNPair(dentry));
+	inode = dentry->d_inode;
+	AuDebugOn(!inode || !S_ISDIR(inode->i_mode));
+
+	err = 0;
+	arg.whlist = whlist;
+	arg.flags = AuTestEmpty_WHONLY;
+	if (au_opt_test(au_mntflags(dentry->d_sb), SHWH))
+		au_fset_testempty(arg.flags, SHWH);
+	btail = au_dbtaildir(dentry);
+	for (bindex = au_dbstart(dentry); !err && bindex <= btail; bindex++) {
+		struct dentry *h_dentry;
+		h_dentry = au_h_dptr(dentry, bindex);
+		if (h_dentry && h_dentry->d_inode) {
+			arg.bindex = bindex;
+			err = sio_test_empty(dentry, &arg);
+		}
+	}
+
+	AuTraceErr(err);
+	return err;
+}
+
+/* ---------------------------------------------------------------------- */
+
+struct file_operations aufs_dir_fop = {
+	.read		= generic_read_dir,
+	.readdir	= aufs_readdir,
+	/* .unlocked_ioctl	= aufs_ioctl_dir, */
+	.open		= aufs_open_dir,
+	.release	= aufs_release_dir,
+	.flush		= aufs_flush,
+	.fsync		= aufs_fsync_dir,
+};
diff -Nurp linux-2.6.27.orig/fs/aufs/dir.h linux-2.6.27/fs/aufs/dir.h
--- linux-2.6.27.orig/fs/aufs/dir.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.27/fs/aufs/dir.h	2008-12-14 10:37:40.000000000 +0100
@@ -0,0 +1,147 @@
+/*
+ * Copyright (C) 2005-2008 Junjiro Okajima
+ *
+ * This program, aufs is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+ */
+
+/*
+ * directory operations
+ *
+ * $Id: dir.h,v 1.6 2008/12/08 06:11:46 sfjro Exp $
+ */
+
+#ifndef __AUFS_DIR_H__
+#define __AUFS_DIR_H__
+
+#ifdef __KERNEL__
+
+#include <linux/fs.h>
+#include <linux/aufs_type.h>
+
+/* ---------------------------------------------------------------------- */
+
+/* need to be faster and smaller */
+
+/* todo: changeable? */
+#define AuSize_DEBLK	512
+#define AuSize_NHASH	32
+#if AuSize_DEBLK < NAME_MAX || PAGE_SIZE < AuSize_DEBLK
+#error invalid size AuSize_DEBLK
+#endif
+
+typedef char au_vdir_deblk_t[AuSize_DEBLK];
+
+struct au_nhash {
+	struct hlist_head heads[AuSize_NHASH];
+};
+
+struct au_vdir_destr {
+	unsigned char	len;
+	char		name[0];
+} __packed;
+
+struct au_vdir_dehstr {
+	struct hlist_node	hash;
+	struct au_vdir_destr	*str;
+};
+
+struct au_vdir_de {
+	ino_t			de_ino;
+	unsigned char		de_type;
+	/* caution: packed */
+	struct au_vdir_destr	de_str;
+} __packed;
+
+struct au_vdir_wh {
+	struct hlist_node	wh_hash;
+	aufs_bindex_t		wh_bindex;
+#ifdef CONFIG_AUFS_SHWH
+	ino_t			wh_ino;
+	unsigned char		wh_type;
+	/* caution: packed */
+#endif
+	struct au_vdir_destr	wh_str;
+} __packed;
+
+union au_vdir_deblk_p {
+	unsigned char		*p;
+	au_vdir_deblk_t		*deblk;
+	struct au_vdir_de	*de;
+};
+
+struct au_vdir {
+	au_vdir_deblk_t	**vd_deblk;
+	int		vd_nblk;
+	struct {
+		int			i;
+		union au_vdir_deblk_p	p;
+	} vd_last;
+
+	unsigned long	vd_version;
+	unsigned long	vd_jiffy;
+};
+
+/* ---------------------------------------------------------------------- */
+
+/* dir.c */
+extern struct file_operations aufs_dir_fop;
+int au_test_empty_lower(struct dentry *dentry);
+int au_test_empty(struct dentry *dentry, struct au_nhash *whlist);
+
+/* vdir.c */
+struct au_nhash *au_nhash_new(gfp_t gfp);
+void au_nhash_del(struct au_nhash *nhash);
+void au_nhash_init(struct au_nhash *nhash);
+void au_nhash_move(struct au_nhash *dst, struct au_nhash *src);
+void au_nhash_fin(struct au_nhash *nhash);
+int au_nhash_test_longer_wh(struct au_nhash *whlist, aufs_bindex_t btgt,
+			    int limit);
+int au_nhash_test_known_wh(struct au_nhash *whlist, char *name, int namelen);
+int au_nhash_append_wh(struct au_nhash *whlist, char *name, int namelen,
+		       ino_t ino, unsigned int d_type, aufs_bindex_t bindex,
+		       unsigned char shwh);
+void au_vdir_free(struct au_vdir *vdir);
+int au_vdir_init(struct file *file);
+int au_vdir_fill_de(struct file *file, void *dirent, filldir_t filldir);
+
+/* ---------------------------------------------------------------------- */
+
+static inline
+void au_shwh_init_wh(struct au_vdir_wh *wh, ino_t ino, unsigned char d_type)
+{
+#ifdef CONFIG_AUFS_SHWH
+	wh->wh_ino = ino;
+	wh->wh_type = d_type;
+#endif
+}
+
+static inline void au_add_nlink(struct inode *dir, struct inode *h_dir)
+{
+	AuDebugOn(!S_ISDIR(dir->i_mode) || !S_ISDIR(h_dir->i_mode));
+	dir->i_nlink += h_dir->i_nlink - 2;
+	if (h_dir->i_nlink < 2)
+		dir->i_nlink += 2;
+}
+
+static inline void au_sub_nlink(struct inode *dir, struct inode *h_dir)
+{
+	AuDebugOn(!S_ISDIR(dir->i_mode) || !S_ISDIR(h_dir->i_mode));
+	dir->i_nlink -= h_dir->i_nlink - 2;
+	if (h_dir->i_nlink < 2)
+		dir->i_nlink -= 2;
+}
+
+#endif /* __KERNEL__ */
+#endif /* __AUFS_DIR_H__ */
diff -Nurp linux-2.6.27.orig/fs/aufs/dlgt.c linux-2.6.27/fs/aufs/dlgt.c
--- linux-2.6.27.orig/fs/aufs/dlgt.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.27/fs/aufs/dlgt.c	2008-08-11 04:50:34.000000000 +0200
@@ -0,0 +1,113 @@
+/*
+ * Copyright (C) 2005-2008 Junjiro Okajima
+ *
+ * This program, aufs is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+ */
+
+/*
+ * lookup functions in 'delegate' mode
+ *
+ * $Id: dlgt.c,v 1.5 2008/08/11 02:50:34 sfjro Exp $
+ */
+
+#include "aufs.h"
+
+/* ---------------------------------------------------------------------- */
+
+struct au_lookup_one_len_args {
+	struct dentry **errp;
+	const char *name;
+	struct dentry *parent;
+	int len;
+};
+
+static void au_call_lookup_one_len(void *args)
+{
+	struct au_lookup_one_len_args *a = args;
+	*a->errp = vfsub_lookup_one_len(a->name, a->parent, a->len);
+}
+
+struct dentry *au_lkup_one_dlgt(const char *name, struct dentry *parent,
+				int len, unsigned int flags)
+{
+	struct dentry *dentry;
+	int dirperm1;
+
+	LKTRTrace("%.*s/%.*s, 0x%x\n", AuDLNPair(parent), len, name, flags);
+
+	dirperm1 = au_ftest_ndx(flags, DIRPERM1);
+	if (!dirperm1 && !au_ftest_ndx(flags, DLGT))
+		dentry = vfsub_lookup_one_len(name, parent, len);
+	else {
+		int wkq_err;
+		struct au_lookup_one_len_args args = {
+			.errp	= &dentry,
+			.name	= name,
+			.parent	= parent,
+			.len	= len
+		};
+		wkq_err = au_wkq_wait(au_call_lookup_one_len, &args,
+				      /*dlgt*/!dirperm1);
+		if (unlikely(wkq_err))
+			dentry = ERR_PTR(wkq_err);
+	}
+
+	AuTraceErrPtr(dentry);
+	return dentry;
+}
+
+/* ---------------------------------------------------------------------- */
+
+struct security_inode_permission_args {
+	int *errp;
+	struct inode *h_inode;
+	int mask;
+	struct nameidata *fake_nd;
+};
+
+static void call_security_inode_permission(void *args)
+{
+	struct security_inode_permission_args *a = args;
+	LKTRTrace("fsuid %d\n", current->fsuid);
+	*a->errp = vfsub_security_inode_permission(a->h_inode, a->mask,
+						   a->fake_nd);
+}
+
+int au_security_inode_permission(struct inode *h_inode, int mask,
+				 struct nameidata *fake_nd, int dlgt)
+{
+	int err;
+
+	AuTraceEnter();
+
+	if (!dlgt)
+		err = vfsub_security_inode_permission(h_inode, mask, fake_nd);
+	else {
+		int wkq_err;
+		struct security_inode_permission_args args = {
+			.errp		= &err,
+			.h_inode	= h_inode,
+			.mask		= mask,
+			.fake_nd	= fake_nd
+		};
+		wkq_err = au_wkq_wait(call_security_inode_permission, &args,
+				      /*dlgt*/1);
+		if (unlikely(wkq_err))
+			err = wkq_err;
+	}
+
+	AuTraceErr(err);
+	return err;
+}
diff -Nurp linux-2.6.27.orig/fs/aufs/export.c linux-2.6.27/fs/aufs/export.c
--- linux-2.6.27.orig/fs/aufs/export.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.27/fs/aufs/export.c	2008-12-14 10:37:40.000000000 +0100
@@ -0,0 +1,826 @@
+/*
+ * Copyright (C) 2005-2008 Junjiro Okajima
+ *
+ * This program, aufs is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+ */
+
+/*
+ * export via nfs
+ *
+ * $Id: export.c,v 1.22 2008/12/08 06:11:51 sfjro Exp $
+ */
+
+#include <linux/exportfs.h>
+#include <linux/mnt_namespace.h>
+#include <linux/random.h>
+#include "aufs.h"
+
+union conv {
+#ifdef CONFIG_AUFS_INO_T_64
+	__u32 a[2];
+#else
+	__u32 a[1];
+#endif
+	ino_t ino;
+};
+
+static ino_t decode_ino(__u32 *a)
+{
+	union conv u;
+
+	BUILD_BUG_ON(sizeof(u.ino) != sizeof(u.a));
+	u.a[0] = a[0];
+#ifdef CONFIG_AUFS_INO_T_64
+	u.a[1] = a[1];
+#endif
+	return u.ino;
+}
+
+static void encode_ino(__u32 *a, ino_t ino)
+{
+	union conv u;
+
+	u.ino = ino;
+	a[0] = u.a[0];
+#ifdef CONFIG_AUFS_INO_T_64
+	a[1] = u.a[1];
+#endif
+}
+
+/* NFS file handle */
+enum {
+	Fh_br_id,
+	Fh_sigen,
+#ifdef CONFIG_AUFS_INO_T_64
+	/* support 64bit inode number */
+	Fh_ino1,
+	Fh_ino2,
+	Fh_dir_ino1,
+	Fh_dir_ino2,
+#else
+	Fh_ino1,
+	Fh_dir_ino1,
+#endif
+	Fh_igen,
+	Fh_h_type,
+	Fh_tail,
+
+	Fh_ino = Fh_ino1,
+	Fh_dir_ino = Fh_dir_ino1
+};
+
+static int au_test_anon(struct dentry *dentry)
+{
+	return !!(dentry->d_flags & DCACHE_DISCONNECTED);
+}
+
+/* ---------------------------------------------------------------------- */
+/* inode generation external table */
+
+int au_xigen_inc(struct inode *inode)
+{
+	int err;
+	loff_t pos;
+	ssize_t sz;
+	__u32 igen;
+	struct super_block *sb;
+	struct au_sbinfo *sbinfo;
+
+	LKTRTrace("i%lu\n", (unsigned long)inode->i_ino);
+
+	err = 0;
+	sb = inode->i_sb;
+	if (unlikely(!au_opt_test_xino(au_mntflags(sb))))
+		goto out;
+
+	pos = inode->i_ino;
+	pos *= sizeof(igen);
+	igen = inode->i_generation + 1;
+	sbinfo = au_sbi(sb);
+	sz = xino_fwrite(sbinfo->si_xwrite, sbinfo->si_xigen, &igen,
+			 sizeof(igen), &pos);
+	if (sz == sizeof(igen))
+		goto out; /* success */
+
+	err = sz;
+	if (unlikely(sz >= 0)) {
+		err = -EIO;
+		AuIOErr("xigen error (%zd)\n", sz);
+	}
+
+ out:
+	AuTraceErr(err);
+	return err;
+}
+
+int au_xigen_new(struct inode *inode)
+{
+	int err;
+	loff_t pos;
+	ssize_t sz;
+	struct super_block *sb;
+	struct au_sbinfo *sbinfo;
+	struct file *file;
+
+	LKTRTrace("i%lu\n", inode->i_ino);
+
+	err = 0;
+	/* todo: dirty, at mount time */
+	if (inode->i_ino == AUFS_ROOT_INO)
+		goto out;
+	sb = inode->i_sb;
+	if (unlikely(!au_opt_test_xino(au_mntflags(sb))))
+		goto out;
+
+	err = -EFBIG;
+	pos = inode->i_ino;
+	if (unlikely(Au_LOFF_MAX / sizeof(inode->i_generation) - 1 < pos)) {
+		AuIOErr1("too large i%lld\n", pos);
+		goto out;
+	}
+	pos *= sizeof(inode->i_generation);
+
+	err = 0;
+	sbinfo = au_sbi(sb);
+	file = sbinfo->si_xigen;
+	BUG_ON(!file);
+
+	if (i_size_read(file->f_dentry->d_inode)
+	    < pos + sizeof(inode->i_generation)) {
+		inode->i_generation = atomic_inc_return(&sbinfo->si_xigen_next);
+		sz = xino_fwrite(sbinfo->si_xwrite, file, &inode->i_generation,
+				 sizeof(inode->i_generation), &pos);
+	} else
+		sz = xino_fread(sbinfo->si_xread, file, &inode->i_generation,
+				sizeof(inode->i_generation), &pos);
+	if (sz == sizeof(inode->i_generation))
+		goto out; /* success */
+
+	err = sz;
+	if (unlikely(sz >= 0)) {
+		err = -EIO;
+		AuIOErr("xigen error (%zd)\n", sz);
+	}
+
+ out:
+	AuTraceErr(err);
+	return err;
+}
+
+int au_xigen_set(struct super_block *sb, struct file *base)
+{
+	int err;
+	struct au_sbinfo *sbinfo;
+	struct file *file;
+
+	LKTRTrace("%.*s\n", AuDLNPair(base->f_dentry));
+	SiMustWriteLock(sb);
+
+	sbinfo = au_sbi(sb);
+	file = au_xino_create2(sb, base, sbinfo->si_xigen);
+	err = PTR_ERR(file);
+	if (IS_ERR(file))
+		goto out;
+	err = 0;
+	if (sbinfo->si_xigen)
+		fput(sbinfo->si_xigen);
+	sbinfo->si_xigen = file;
+
+ out:
+	AuTraceErr(err);
+	return err;
+}
+
+void au_xigen_clr(struct super_block *sb)
+{
+	struct au_sbinfo *sbinfo;
+
+	sbinfo = au_sbi(sb);
+	if (sbinfo->si_xigen) {
+		fput(sbinfo->si_xigen);
+		sbinfo->si_xigen = NULL;
+	}
+}
+
+/* ---------------------------------------------------------------------- */
+
+static struct dentry *decode_by_ino(struct super_block *sb, ino_t ino,
+				    ino_t dir_ino)
+{
+	struct dentry *dentry, *d;
+	struct inode *inode;
+	au_gen_t sigen;
+
+	LKTRTrace("i%lu, diri%lu\n",
+		  (unsigned long)ino, (unsigned long)dir_ino);
+
+	dentry = NULL;
+	inode = ilookup(sb, ino);
+	if (!inode)
+		goto out;
+
+	dentry = ERR_PTR(-ESTALE);
+	sigen = au_sigen(sb);
+	if (unlikely(is_bad_inode(inode)
+		     || IS_DEADDIR(inode)
+		     || sigen != au_iigen(inode)))
+		goto out_iput;
+
+	dentry = NULL;
+	if (!dir_ino || S_ISDIR(inode->i_mode))
+		dentry = d_find_alias(inode);
+	else {
+		spin_lock(&dcache_lock);
+		list_for_each_entry(d, &inode->i_dentry, d_alias)
+			if (!au_test_anon(d)
+			    && d->d_parent->d_inode->i_ino == dir_ino) {
+				dentry = dget_locked(d);
+				break;
+			}
+		spin_unlock(&dcache_lock);
+	}
+	if (unlikely(dentry && sigen != au_digen(dentry))) {
+		dput(dentry);
+		dentry = ERR_PTR(-ESTALE);
+	}
+
+ out_iput:
+	iput(inode);
+ out:
+	AuTraceErrPtr(dentry);
+	return dentry;
+}
+
+/* ---------------------------------------------------------------------- */
+
+/* todo: dirty? */
+/*
+ * when you mntput() for the return value of this function,
+ * you have to store it to your local var.
+ * ie. never mntput si_mntcache directly.
+ */
+static struct vfsmount *au_do_mnt_get(struct super_block *sb)
+{
+	struct mnt_namespace *ns;
+	struct vfsmount *pos, *mnt;
+
+	AuTraceEnter();
+
+	/* vfsmount_lock is not exported */
+	/* no get/put ?? */
+	AuDebugOn(!current->nsproxy);
+	ns = current->nsproxy->mnt_ns;
+	AuDebugOn(!ns);
+	mnt = NULL;
+	/* the order (reverse) will not be a problem */
+	list_for_each_entry(pos, &ns->list, mnt_list)
+		if (pos->mnt_sb == sb) {
+			mnt = pos;
+			break;
+		}
+	AuDebugOn(!mnt);
+
+	return mntget(mnt);
+}
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2, 6, 26)
+static struct vfsmount *au_mnt_get(struct super_block *sb)
+{
+	struct au_sbinfo *sbinfo;
+	struct vfsmount *mnt;
+
+	sbinfo = au_sbi(sb);
+	spin_lock(&sbinfo->si_mntcache_lock);
+	if (sbinfo->si_mntcache)
+		mnt = mntget(sbinfo->si_mntcache);
+	else {
+		sbinfo->si_mntcache = au_do_mnt_get(sb);
+		mnt = sbinfo->si_mntcache;
+	}
+	spin_unlock(&sbinfo->si_mntcache_lock);
+	return mnt;
+}
+#else
+static struct vfsmount *au_mnt_get(struct super_block *sb)
+{
+	return au_do_mnt_get(sb);
+}
+#endif
+
+struct au_nfsd_si_lock {
+	const au_gen_t sigen;
+	const aufs_bindex_t br_id;
+	unsigned char force_lock;
+};
+
+static aufs_bindex_t si_nfsd_read_lock(struct super_block *sb,
+				       struct au_nfsd_si_lock *nsi_lock)
+{
+	aufs_bindex_t bindex;
+
+	si_read_lock(sb, AuLock_FLUSH);
+
+	/* branch id may be wrapped around */
+	bindex = au_br_index(sb, nsi_lock->br_id);
+	LKTRTrace("b%d\n", bindex);
+	if (bindex >= 0 && nsi_lock->sigen + AUFS_BRANCH_MAX > au_sigen(sb))
+		goto out; /* success */
+
+	if (!nsi_lock->force_lock)
+		si_read_unlock(sb);
+	bindex = -1;
+
+ out:
+	return bindex;
+}
+
+struct find_name_by_ino {
+	int called, found;
+	ino_t ino;
+	char *name;
+	int namelen;
+};
+
+static int
+find_name_by_ino(void *arg, const char *name, int namelen, loff_t offset,
+		 u64 ino, unsigned int d_type)
+{
+	struct find_name_by_ino *a = arg;
+
+	a->called++;
+	if (a->ino != ino)
+		return 0;
+
+	memcpy(a->name, name, namelen);
+	a->namelen = namelen;
+	a->found = 1;
+	return 1;
+}
+
+static struct dentry *au_lkup_by_ino(struct path *path, ino_t ino,
+				     struct au_nfsd_si_lock *nsi_lock)
+{
+	struct dentry *dentry, *parent;
+	struct file *file;
+	struct inode *dir;
+	struct find_name_by_ino arg;
+	int err;
+
+	parent = path->dentry;
+	LKTRTrace("%.*s, i%lu\n", AuDLNPair(parent), (unsigned long)ino);
+
+	if (nsi_lock)
+		si_read_unlock(parent->d_sb);
+	path_get(path);
+	file = dentry_open(parent, path->mnt, au_dir_roflags);
+	dentry = (void *)file;
+	if (IS_ERR(file))
+		goto out;
+
+	dentry = ERR_PTR(-ENOMEM);
+	arg.name = __getname();
+	if (unlikely(!arg.name))
+		goto out_file;
+	arg.ino = ino;
+	arg.found = 0;
+	do {
+		arg.called = 0;
+		/* smp_mb(); */
+		err = vfsub_readdir(file, find_name_by_ino, &arg, /*dlgt*/0);
+	} while (!err && !arg.found && arg.called);
+	dentry = ERR_PTR(err);
+	if (unlikely(err))
+		goto out_name;
+	dentry = ERR_PTR(-ENOENT);
+	if (!arg.found)
+		goto out_name;
+
+	/* do not call au_lkup_one(), nor dlgt */
+	dir = parent->d_inode;
+	mutex_lock(&dir->i_mutex);
+	dentry = vfsub_lookup_one_len(arg.name, parent, arg.namelen);
+	mutex_unlock(&dir->i_mutex);
+	AuTraceErrPtr(dentry);
+	if (IS_ERR(dentry))
+		goto out_name;
+	AuDebugOn(au_test_anon(dentry));
+	if (unlikely(!dentry->d_inode)) {
+		dput(dentry);
+		dentry = ERR_PTR(-ENOENT);
+	}
+
+ out_name:
+	__putname(arg.name);
+ out_file:
+	fput(file);
+ out:
+	if (unlikely(nsi_lock
+		     && si_nfsd_read_lock(parent->d_sb, nsi_lock) < 0))
+		if (!IS_ERR(dentry)) {
+			dput(dentry);
+			dentry = ERR_PTR(-ESTALE);
+		}
+	AuTraceErrPtr(dentry);
+	return dentry;
+}
+
+static /* noinline_for_stack */
+struct dentry *decode_by_dir_ino(struct super_block *sb, ino_t ino,
+				 ino_t dir_ino, struct au_nfsd_si_lock *nsi_lock)
+{
+	struct dentry *dentry, *parent;
+	struct path path;
+
+	LKTRTrace("i%lu, diri%lu\n",
+		  (unsigned long)ino, (unsigned long)dir_ino);
+
+	parent = sb->s_root;
+	if (dir_ino != AUFS_ROOT_INO) {
+		parent = decode_by_ino(sb, dir_ino, 0);
+		dentry = parent;
+		if (!parent)
+			goto out;
+		if (IS_ERR(parent))
+			goto out;
+		AuDebugOn(au_test_anon(parent));
+	} else
+		dget(parent);
+
+	path.dentry = parent;
+	path.mnt = au_mnt_get(sb);
+	dentry = au_lkup_by_ino(&path, ino, nsi_lock);
+	path_put(&path);
+
+ out:
+	AuTraceErrPtr(dentry);
+	return dentry;
+}
+
+/* ---------------------------------------------------------------------- */
+
+static int h_acceptable(void *expv, struct dentry *dentry)
+{
+	return 1;
+}
+
+static char *au_build_path(struct dentry *h_parent, struct path *h_rootpath,
+			   char *buf, int len, struct super_block *sb)
+{
+	char *p;
+	int n;
+	struct path path;
+
+	AuTraceEnter();
+
+	p = d_path(h_rootpath, buf, len);
+	if (IS_ERR(p))
+		goto out;
+	n = strlen(p);
+
+	path.mnt = h_rootpath->mnt;
+	path.dentry = h_parent;
+	p = d_path(&path, buf, len);
+	if (IS_ERR(p))
+		goto out;
+	LKTRTrace("%s\n", p);
+	if (n != 1)
+		p += n;
+	LKTRTrace("%p, %s, %ld\n",
+		  p, p, (long)(p - buf));
+
+	path.mnt = au_mnt_get(sb);
+	path.dentry = sb->s_root;
+	p = d_path(&path, buf, len - strlen(p));
+	mntput(path.mnt);
+	if (IS_ERR(p))
+		goto out;
+	if (n != 1)
+		p[strlen(p)] = '/';
+	LKTRTrace("%s\n", p);
+
+ out:
+	AuTraceErrPtr(p);
+	return p;
+}
+
+static noinline_for_stack
+struct dentry *decode_by_path(struct super_block *sb, aufs_bindex_t bindex,
+			      ino_t ino, __u32 *fh, int fh_len,
+			      struct au_nfsd_si_lock *nsi_lock)
+{
+	struct dentry *dentry, *h_parent, *root;
+	struct super_block *h_sb;
+	char *pathname, *p;
+	struct vfsmount *h_mnt;
+	struct au_branch *br;
+	int err;
+	struct nameidata nd;
+
+	LKTRTrace("b%d\n", bindex);
+	SiMustAnyLock(sb);
+
+	br = au_sbr(sb, bindex);
+	/* au_br_get(br); */
+	h_mnt = br->br_mnt;
+	h_sb = h_mnt->mnt_sb;
+	LKTRTrace("%s, h_decode_fh\n", au_sbtype(h_sb));
+	/* in linux-2.6.24, it takes struct fid * as file handle */
+	/* todo: call lower fh_to_dentry()? fh_to_parent()? */
+	h_parent = exportfs_decode_fh(h_mnt, (void *)(fh + Fh_tail),
+				      fh_len - Fh_tail, fh[Fh_h_type],
+				      h_acceptable, /*context*/NULL);
+	dentry = h_parent;
+	if (unlikely(!h_parent || IS_ERR(h_parent))) {
+		AuWarn1("%s decode_fh failed, %ld\n",
+			au_sbtype(h_sb), PTR_ERR(h_parent));
+		goto out;
+	}
+	dentry = NULL;
+	if (unlikely(au_test_anon(h_parent))) {
+		AuWarn1("%s decode_fh returned a disconnected dentry\n",
+			au_sbtype(h_sb));
+		goto out_h_parent;
+	}
+
+	dentry = ERR_PTR(-ENOMEM);
+	pathname = (void *)__get_free_page(GFP_NOFS);
+	if (unlikely(!pathname))
+		goto out_h_parent;
+
+	root = sb->s_root;
+	nd.path.mnt = h_mnt;
+	di_read_lock_parent(root, !AuLock_IR);
+	nd.path.dentry = au_h_dptr(root, bindex);
+	di_read_unlock(root, !AuLock_IR);
+	p = au_build_path(h_parent, &nd.path, pathname, PAGE_SIZE, sb);
+	dentry = (void *)p;
+	if (IS_ERR(p))
+		goto out_pathname;
+
+	LKTRTrace("%s\n", p);
+	si_read_unlock(sb);
+	err = vfsub_path_lookup(p, LOOKUP_FOLLOW | LOOKUP_DIRECTORY, &nd);
+	dentry = ERR_PTR(err);
+	if (unlikely(err))
+		goto out_relock;
+
+	dentry = ERR_PTR(-ENOENT);
+	AuDebugOn(au_test_anon(nd.path.dentry));
+	if (unlikely(!nd.path.dentry->d_inode))
+		goto out_nd;
+
+	if (ino != nd.path.dentry->d_inode->i_ino)
+		dentry = au_lkup_by_ino(&nd.path, ino, /*nsi_lock*/NULL);
+	else
+		dentry = dget(nd.path.dentry);
+
+ out_nd:
+	path_put(&nd.path);
+ out_relock:
+	if (unlikely(si_nfsd_read_lock(sb, nsi_lock) < 0))
+		if (!IS_ERR(dentry)) {
+			dput(dentry);
+			dentry = ERR_PTR(-ESTALE);
+		}
+ out_pathname:
+	free_page((unsigned long)pathname);
+ out_h_parent:
+	dput(h_parent);
+ out:
+	/* au_br_put(br); */
+	AuTraceErrPtr(dentry);
+	return dentry;
+}
+
+/* ---------------------------------------------------------------------- */
+
+static struct dentry *
+aufs_fh_to_dentry(struct super_block *sb, struct fid *fid, int fh_len,
+		  int fh_type)
+{
+	struct dentry *dentry;
+	__u32 *fh = fid->raw;
+	ino_t ino, dir_ino;
+	aufs_bindex_t bindex;
+	struct au_nfsd_si_lock nsi_lock = {
+		.sigen		= fh[Fh_sigen],
+		.br_id		= fh[Fh_br_id],
+		.force_lock	= 0
+	};
+
+	LKTRTrace("%d, fh{br_id %u, sigen %u, i%u, diri%u, g%u}\n",
+		  fh_type, fh[Fh_br_id], fh[Fh_sigen], fh[Fh_ino],
+		  fh[Fh_dir_ino], fh[Fh_igen]);
+	AuDebugOn(fh_len < Fh_tail);
+
+	dentry = ERR_PTR(-ESTALE);
+	/* branch id may be wrapped around */
+	bindex = si_nfsd_read_lock(sb, &nsi_lock);
+	if (unlikely(bindex < 0))
+		goto out;
+	nsi_lock.force_lock = 1;
+
+	/* is this inode still cached? */
+	ino = decode_ino(fh + Fh_ino);
+	AuDebugOn(ino == AUFS_ROOT_INO);
+	dir_ino = decode_ino(fh + Fh_dir_ino);
+	dentry = decode_by_ino(sb, ino, dir_ino);
+	if (IS_ERR(dentry))
+		goto out_unlock;
+	if (dentry)
+		goto accept;
+
+	/* is the parent dir cached? */
+	dentry = decode_by_dir_ino(sb, ino, dir_ino, &nsi_lock);
+	if (IS_ERR(dentry))
+		goto out_unlock;
+	if (dentry)
+		goto accept;
+
+	/* lookup path */
+	dentry = decode_by_path(sb, bindex, ino, fh, fh_len, &nsi_lock);
+	if (IS_ERR(dentry))
+		goto out_unlock;
+	if (unlikely(!dentry))
+		/* todo?: make it ESTALE */
+		goto out_unlock;
+
+ accept:
+	LKTRLabel(accept);
+	if (dentry->d_inode->i_generation == fh[Fh_igen])
+		goto out_unlock; /* success */
+
+	LKTRLabel(stale);
+	dput(dentry);
+	dentry = ERR_PTR(-ESTALE);
+ out_unlock:
+	LKTRLabel(out_unlock);
+	si_read_unlock(sb);
+ out:
+	LKTRLabel(out);
+	if (0 && IS_ERR(dentry))
+		dentry = ERR_PTR(-ESTALE);
+	AuTraceErrPtr(dentry);
+	return dentry;
+}
+
+#if 0 /* reserved for future use */
+/* support subtreecheck option */
+static struct dentry *aufs_fh_to_parent(struct super_block *sb, struct fid *fid,
+					int fh_len, int fh_type)
+{
+	struct dentry *parent;
+	__u32 *fh = fid->raw;
+	ino_t dir_ino;
+
+	dir_ino = decode_ino(fh + Fh_dir_ino);
+	parent = decode_by_ino(sb, dir_ino, 0);
+	if (IS_ERR(parent))
+		goto out;
+	if (!parent)
+		parent = decode_by_path(sb, au_br_index(sb, fh[Fh_br_id]),
+					dir_ino, fh, fh_len);
+
+ out:
+	AuTraceErrPtr(parent);
+	return parent;
+}
+#endif
+
+/* ---------------------------------------------------------------------- */
+
+static int aufs_encode_fh(struct dentry *dentry, __u32 *fh, int *max_len,
+			  int connectable)
+{
+	int err;
+	aufs_bindex_t bindex, bend;
+	struct super_block *sb, *h_sb;
+	struct inode *inode;
+	struct dentry *parent, *h_parent;
+	struct au_branch *br;
+
+	LKTRTrace("%.*s, max %d, conn %d\n",
+		  AuDLNPair(dentry), *max_len, connectable);
+	AuDebugOn(au_test_anon(dentry));
+
+	parent = NULL;
+	err = -ENOSPC;
+	if (unlikely(*max_len <= Fh_tail)) {
+		AuWarn1("NFSv2 client (max_len %d)?\n", *max_len);
+		goto out;
+	}
+
+	err = FILEID_ROOT;
+	if (IS_ROOT(dentry)) {
+		AuDebugOn(dentry->d_inode->i_ino != AUFS_ROOT_INO);
+		goto out;
+	}
+
+	err = -EIO;
+	h_parent = NULL;
+	sb = dentry->d_sb;
+	aufs_read_lock(dentry, AuLock_FLUSH | AuLock_IR);
+	parent = dget_parent(dentry);
+	di_read_lock_parent(parent, !AuLock_IR);
+	inode = dentry->d_inode;
+	AuDebugOn(!inode);
+#ifdef CONFIG_AUFS_DEBUG
+	{
+		unsigned int mnt_flags = au_mntflags(sb);
+
+		if (unlikely(!au_opt_test_xino(mnt_flags)))
+			AuWarn1("NFS-exporting requires xino\n");
+		if (unlikely(0 && !au_opt_test(mnt_flags, UDBA_INOTIFY)))
+			AuWarn1("udba=inotify is recommended "
+				"for NFS-exporting\n");
+	}
+#endif
+
+	bend = au_dbtaildir(parent);
+	for (bindex = au_dbstart(parent); bindex <= bend; bindex++) {
+		h_parent = au_h_dptr(parent, bindex);
+		if (h_parent) {
+			dget(h_parent);
+			break;
+		}
+	}
+	if (unlikely(!h_parent))
+		goto out_unlock;
+	LKTRTrace("b%d\n", bindex);
+
+	err = -EPERM;
+	br = au_sbr(sb, bindex);
+	h_sb = br->br_mnt->mnt_sb;
+	if (unlikely(!h_sb->s_export_op)) {
+		AuErr1("%s branch is not exportable\n", au_sbtype(h_sb));
+		goto out_dput;
+	}
+
+	fh[Fh_br_id] = br->br_id;
+	fh[Fh_sigen] = au_sigen(sb);
+	encode_ino(fh + Fh_ino, inode->i_ino);
+	encode_ino(fh + Fh_dir_ino, parent->d_inode->i_ino);
+	fh[Fh_igen] = inode->i_generation;
+
+	*max_len -= Fh_tail;
+	/* in linux-2.6.24, it takes struct fid * as file handle */
+	fh[Fh_h_type] = exportfs_encode_fh(h_parent, (void *)(fh + Fh_tail),
+					   max_len,
+					   /*connectable or subtreecheck*/0);
+	err = fh[Fh_h_type];
+	*max_len += Fh_tail;
+	/* todo: macros? */
+	if (err != 255)
+		err = 99;
+	else
+		AuWarn1("%s encode_fh failed\n", au_sbtype(h_sb));
+
+ out_dput:
+	dput(h_parent);
+ out_unlock:
+	di_read_unlock(parent, !AuLock_IR);
+	dput(parent);
+	aufs_read_unlock(dentry, AuLock_IR);
+ out:
+	AuTraceErr(err);
+	if (unlikely(err < 0))
+		err = 255;
+	return err;
+}
+
+/* ---------------------------------------------------------------------- */
+
+static struct export_operations aufs_export_op = {
+	.fh_to_dentry	= aufs_fh_to_dentry,
+	//.fh_to_parent	= aufs_fh_to_parent,
+	.encode_fh	= aufs_encode_fh
+};
+
+void au_export_init(struct super_block *sb)
+{
+	struct au_sbinfo *sbinfo;
+	__u32 u;
+
+	AuTraceEnter();
+	SiMustWriteLock(sb);
+
+	sb->s_export_op = &aufs_export_op;
+	sbinfo = au_sbi(sb);
+	sbinfo->si_xigen = NULL;
+	get_random_bytes(&u, sizeof(u));
+	BUILD_BUG_ON(sizeof(u) != sizeof(int));
+	atomic_set(&sbinfo->si_xigen_next, u);
+	memset(&sbinfo->si_xinodir, 0, sizeof(struct path));
+}
diff -Nurp linux-2.6.27.orig/fs/aufs/file.c linux-2.6.27/fs/aufs/file.c
--- linux-2.6.27.orig/fs/aufs/file.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.27/fs/aufs/file.c	2008-12-14 10:37:40.000000000 +0100
@@ -0,0 +1,772 @@
+/*
+ * Copyright (C) 2005-2008 Junjiro Okajima
+ *
+ * This program, aufs is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+ */
+
+/*
+ * handling file/dir, and address_space operation
+ *
+ * $Id: file.c,v 1.19 2008/12/01 03:49:29 sfjro Exp $
+ */
+
+#include <linux/pagemap.h>
+#include "aufs.h"
+
+/*
+ * a dirty trick for handling FMODE_EXEC and deny_write_access().
+ * because FMODE_EXEC flag is not passed to f_op->open(),
+ * set it to file->private_data temporary.
+ */
+#if !defined(CONFIG_AUFS_MODULE) || defined(CONFIG_AUFS_DENY_WRITE_ACCESS_PATCH)
+int au_store_fmode_exec(struct nameidata *nd, struct inode *inode)
+{
+	int err;
+	union {
+		void *p;
+		unsigned long ul;
+	} u;
+
+	err = 0;
+	if (nd
+	    && (nd->flags & LOOKUP_OPEN)
+	    && nd->intent.open.file
+	    && (nd->intent.open.flags & FMODE_EXEC)
+	    && inode
+	    && S_ISREG(inode->i_mode)) {
+		u.ul = nd->intent.open.flags;
+		nd->intent.open.file->private_data = u.p;
+		/* smp_mb(); */
+		err = 1;
+	}
+
+	return err;
+}
+#endif
+
+/* drop flags for writing */
+unsigned int au_file_roflags(unsigned int flags)
+{
+	flags &= ~(O_WRONLY | O_RDWR | O_APPEND | O_CREAT | O_TRUNC);
+	flags |= O_RDONLY | O_NOATIME;
+	return flags;
+}
+
+/* common functions to regular file and dir */
+struct file *au_h_open(struct dentry *dentry, aufs_bindex_t bindex, int flags,
+		       struct file *file)
+{
+	struct file *h_file;
+	struct dentry *h_dentry;
+	struct inode *h_inode;
+	struct super_block *sb;
+	struct au_branch *br;
+	int err;
+
+	LKTRTrace("%.*s, b%d, flags 0%o, f %d\n",
+		  AuDLNPair(dentry), bindex, flags, !!file);
+	h_dentry = au_h_dptr(dentry, bindex);
+	AuDebugOn(!h_dentry);
+	h_inode = h_dentry->d_inode;
+
+	/* a race condition can happen between open and unlink/rmdir */
+	h_file = ERR_PTR(-ENOENT);
+	if (unlikely((!d_unhashed(dentry) && d_unhashed(h_dentry))
+		     || !h_inode))
+		goto out;
+
+	sb = dentry->d_sb;
+	br = au_sbr(sb, bindex);
+	au_br_get(br);
+	/* drop flags for writing */
+	if (au_test_ro(sb, bindex, dentry->d_inode))
+		flags = au_file_roflags(flags);
+	flags &= ~O_CREAT;
+
+	h_file = NULL;
+	if (file && au_test_nfs(h_dentry->d_sb))
+		h_file = au_h_intent(dentry, bindex, file);
+	if (!h_file)
+		h_file = dentry_open(dget(h_dentry), mntget(br->br_mnt), flags);
+
+	/*
+	 * a dirty trick for handling FMODE_EXEC and deny_write_access().
+	 */
+	if (file && (file->f_mode & FMODE_EXEC)) {
+		h_file->f_mode |= FMODE_EXEC;
+		smp_mb(); /* flush f_mode */
+		err = au_deny_write_access(h_file);
+		if (unlikely(err)) {
+			fput(h_file);
+			h_file = ERR_PTR(err);
+		}
+	}
+	if (IS_ERR(h_file))
+		au_br_put(br);
+
+out:
+	AuTraceErrPtr(h_file);
+	return h_file;
+}
+
+static int do_coo(struct dentry *dentry, aufs_bindex_t bstart)
+{
+	int err;
+	aufs_bindex_t bcpup;
+	unsigned char pin_flags;
+	struct au_pin pin;
+	struct dentry *parent;
+	struct mutex *h_mtx;
+	struct super_block *sb;
+
+	LKTRTrace("%.*s\n", AuDLNPair(dentry));
+	AuDebugOn(IS_ROOT(dentry));
+	DiMustWriteLock(dentry);
+
+	parent = dget_parent(dentry);
+	di_write_lock_parent(parent);
+	sb = dentry->d_sb;
+	err = AuWbrCopyup(au_sbi(sb), dentry);
+	bcpup = err;
+	if (err < 0) {
+		err = 0; /* stop copyup, it is not an error */
+		goto out_dgrade;
+	}
+	err = 0;
+
+	if (!au_h_dptr(parent, bcpup)) {
+		err = au_cpup_dirs(dentry, bcpup);
+		if (unlikely(err))
+			goto out_dgrade;
+	}
+
+	di_downgrade_lock(parent, AuLock_IR);
+	pin_flags = AuPin_DI_LOCKED | AuPin_MNT_WRITE;
+	if (au_opt_test(au_mntflags(sb), UDBA_INOTIFY))
+		au_fset_pin(pin_flags, DO_GPARENT);
+	err = au_pin(&pin, dentry, bcpup, pin_flags);
+	if (unlikely(err))
+		goto out;
+	h_mtx = &au_h_dptr(dentry, bstart)->d_inode->i_mutex;
+	mutex_lock_nested(h_mtx, AuLsc_I_CHILD);
+	AuDebugOn(au_h_dptr(dentry, bcpup));
+	err = au_sio_cpup_simple(dentry, bcpup, -1, AuCpup_DTIME);
+	AuTraceErr(err);
+	mutex_unlock(h_mtx);
+	au_unpin(&pin);
+	goto out;
+
+ out_dgrade:
+	di_downgrade_lock(parent, AuLock_IR);
+ out:
+	di_read_unlock(parent, AuLock_IR);
+	dput(parent);
+	AuTraceErr(err);
+	return err;
+}
+
+int au_do_open(struct inode *inode, struct file *file,
+	       int (*open)(struct file *file, int flags))
+{
+	int err;
+	struct dentry *dentry;
+	struct super_block *sb;
+	aufs_bindex_t bstart;
+	unsigned char coo;
+
+	dentry = file->f_dentry;
+	LKTRTrace("i%lu, %.*s\n", inode->i_ino, AuDLNPair(dentry));
+
+	sb = dentry->d_sb;
+	si_read_lock(sb, AuLock_FLUSH);
+	coo = 0;
+	switch (au_mntflags(sb) & AuOptMask_COO) {
+	case AuOpt_COO_LEAF:
+		coo = !S_ISDIR(inode->i_mode);
+		break;
+	case AuOpt_COO_ALL:
+		coo = 1;
+		break;
+	}
+	err = au_finfo_init(file);
+	if (unlikely(err))
+		goto out;
+
+	if (!coo)
+		di_read_lock_child(dentry, AuLock_IR);
+	else {
+		di_write_lock_child(dentry);
+		bstart = au_dbstart(dentry);
+		if (au_test_ro(sb, bstart, dentry->d_inode)) {
+			err = do_coo(dentry, bstart);
+			if (err) {
+				di_write_unlock(dentry);
+				goto out_finfo;
+			}
+		}
+		di_downgrade_lock(dentry, AuLock_IR);
+	}
+
+	err = open(file, file->f_flags);
+	di_read_unlock(dentry, AuLock_IR);
+
+ out_finfo:
+	fi_write_unlock(file);
+	if (unlikely(err))
+		au_finfo_fin(file);
+ out:
+	si_read_unlock(sb);
+	AuTraceErr(err);
+	return err;
+}
+
+int au_reopen_nondir(struct file *file)
+{
+	int err;
+	aufs_bindex_t bstart, bindex, bend;
+	struct dentry *dentry;
+	struct file *h_file, *h_file_tmp;
+
+	dentry = file->f_dentry;
+	LKTRTrace("%.*s\n", AuDLNPair(dentry));
+	bstart = au_dbstart(dentry);
+	//bstart = au_ibstart(inode);
+	AuDebugOn(S_ISDIR(dentry->d_inode->i_mode)
+		  || !au_h_dptr(dentry, bstart)->d_inode);
+
+	h_file_tmp = NULL;
+	if (au_fbstart(file) == bstart) {
+		h_file = au_h_fptr(file, bstart);
+		if (file->f_mode == h_file->f_mode)
+			return 0; /* success */
+		h_file_tmp = h_file;
+		get_file(h_file_tmp);
+		au_set_h_fptr(file, bstart, NULL);
+	}
+	AuDebugOn(au_fbstart(file) < bstart
+		  || au_fi(file)->fi_hfile[0 + bstart].hf_file);
+
+	h_file = au_h_open(dentry, bstart, file->f_flags & ~O_TRUNC, file);
+	err = PTR_ERR(h_file);
+	if (IS_ERR(h_file))
+		goto out; /* todo: close all? */
+	err = 0;
+	/* cpup_file_flags(h_file, file); */
+	au_set_fbstart(file, bstart);
+	au_set_h_fptr(file, bstart, h_file);
+	au_update_figen(file);
+	/* todo: necessary? */
+	/* file->f_ra = h_file->f_ra; */
+
+	/* close lower files */
+	bend = au_fbend(file);
+	for (bindex = bstart + 1; bindex <= bend; bindex++)
+		au_set_h_fptr(file, bindex, NULL);
+	au_set_fbend(file, bstart);
+
+ out:
+	if (h_file_tmp)
+		fput(h_file_tmp);
+	AuTraceErr(err);
+	return err;
+}
+
+/* ---------------------------------------------------------------------- */
+
+static int au_ready_to_write_wh(struct file *file, loff_t len,
+				aufs_bindex_t bcpup)
+{
+	int err;
+	aufs_bindex_t old_bstart;
+	struct inode *inode;
+	struct dentry *dentry, *hi_wh, *old_h_dentry;
+	struct au_dinfo *dinfo;
+	struct super_block *sb;
+
+	AuTraceEnter();
+
+	dentry = file->f_dentry;
+	inode = dentry->d_inode;
+	hi_wh = au_hi_wh(inode, bcpup);
+	if (!hi_wh)
+		err = au_sio_cpup_wh(dentry, bcpup, len, file);
+	else {
+		/* already copied-up after unlink */
+		dinfo = au_di(dentry);
+		old_bstart = dinfo->di_bstart;
+		dinfo->di_bstart = bcpup;
+		old_h_dentry = dinfo->di_hdentry[0 + bcpup].hd_dentry;
+		dinfo->di_hdentry[0 + bcpup].hd_dentry = hi_wh;
+		err = au_reopen_nondir(file);
+		dinfo->di_hdentry[0 + bcpup].hd_dentry = old_h_dentry;
+		dinfo->di_bstart = old_bstart;
+	}
+
+	sb = dentry->d_sb;
+	if (!err && inode->i_nlink > 1 && au_opt_test(au_mntflags(sb), PLINK))
+		au_plink_append(sb, inode, au_h_dptr(dentry, bcpup), bcpup);
+
+	AuTraceErr(err);
+	return err;
+}
+
+/*
+ * prepare the @file for writing.
+ */
+int au_ready_to_write(struct file *file, loff_t len, struct au_pin *pin)
+{
+	int err;
+	unsigned char pin_flags;
+	aufs_bindex_t bstart, bcpup;
+	struct dentry *dentry, *parent, *h_dentry;
+	struct inode *h_inode, *inode;
+	struct super_block *sb;
+
+	dentry = file->f_dentry;
+	LKTRTrace("%.*s, len %lld\n", AuDLNPair(dentry), len);
+	FiMustWriteLock(file);
+
+	sb = dentry->d_sb;
+	bstart = au_fbstart(file);
+	AuDebugOn(au_fbr(file, bstart) != au_sbr(sb, bstart));
+
+	inode = dentry->d_inode;
+	AuDebugOn(S_ISDIR(inode->i_mode));
+	LKTRTrace("rdonly %d, bstart %d\n",
+		  au_test_ro(sb, bstart, inode), bstart);
+
+	err = au_test_ro(sb, bstart, inode);
+	if (!err && (au_h_fptr(file, bstart)->f_mode & FMODE_WRITE)) {
+		err = au_pin(pin, dentry, bstart, /*flags*/0);
+		goto out;
+	}
+
+	/* need to cpup */
+	parent = dget_parent(dentry);
+	di_write_lock_parent(parent);
+	err = AuWbrCopyup(au_sbi(sb), dentry);
+	bcpup = err;
+	if (unlikely(err < 0))
+		goto out_dgrade;
+	err = 0;
+
+	if (!au_h_dptr(parent, bcpup)) {
+		err = au_cpup_dirs(dentry, bcpup);
+		if (unlikely(err))
+			goto out_dgrade;
+	}
+
+	pin_flags = AuPin_DI_LOCKED | AuPin_MNT_WRITE;
+	if (au_opt_test(au_mntflags(sb), UDBA_INOTIFY))
+		au_fset_pin(pin_flags, DO_GPARENT);
+	err = au_pin(pin, dentry, bcpup, pin_flags);
+	if (unlikely(err))
+		goto out_dgrade;
+
+	AuDebugOn(au_fbstart(file) != bstart);
+	h_dentry = au_h_fptr(file, bstart)->f_dentry;
+	h_inode = h_dentry->d_inode;
+	mutex_lock_nested(&h_inode->i_mutex, AuLsc_I_CHILD);
+	if (d_unhashed(dentry) /* || d_unhashed(h_dentry) */
+	    /* || !h_inode->i_nlink */) {
+		err = au_ready_to_write_wh(file, len, bcpup);
+		di_downgrade_lock(parent, AuLock_IR);
+	} else {
+		di_downgrade_lock(parent, AuLock_IR);
+		if (!au_h_dptr(dentry, bcpup))
+			err = au_sio_cpup_simple(dentry, bcpup, len,
+						 AuCpup_DTIME);
+		AuTraceErr(err);
+		if (!err)
+			err = au_reopen_nondir(file);
+		AuTraceErr(err);
+	}
+	mutex_unlock(&h_inode->i_mutex);
+
+	if (!err) {
+		au_unpin_gp(pin);
+		au_pin_set_parent_lflag(pin, /*lflag*/0);
+		goto out_dput; /* success */
+	}
+	au_unpin(pin);
+	goto out_unlock;
+
+ out_dgrade:
+	di_downgrade_lock(parent, AuLock_IR);
+ out_unlock:
+	di_read_unlock(parent, AuLock_IR);
+ out_dput:
+	dput(parent);
+ out:
+	AuTraceErr(err);
+	return err;
+}
+
+/* ---------------------------------------------------------------------- */
+
+static int au_file_refresh_by_inode(struct file *file, int *need_reopen)
+{
+	int err;
+	unsigned int mnt_flags;
+	unsigned char pin_flags;
+	aufs_bindex_t bstart, new_bstart, old_bstart;
+	struct au_pin pin;
+	struct au_finfo *finfo;
+	struct dentry *dentry, *parent, *old_h_dentry, *hi_wh;
+	struct inode *inode, *dir;
+	struct super_block *sb;
+	struct au_dinfo *dinfo;
+
+	dentry = file->f_dentry;
+	LKTRTrace("%.*s\n", AuDLNPair(dentry));
+	FiMustWriteLock(file);
+
+	err = 0;
+	finfo = au_fi(file);
+	inode = dentry->d_inode;
+	sb = dentry->d_sb;
+	mnt_flags = au_mntflags(sb);
+	pin_flags = AuPin_DI_LOCKED | AuPin_MNT_WRITE;
+	if (au_opt_test(mnt_flags, UDBA_INOTIFY))
+		au_fset_pin(pin_flags, DO_GPARENT);
+ again:
+	bstart = au_ibstart(inode);
+	if (bstart == finfo->fi_bstart)
+		goto out;
+
+	new_bstart = bstart;
+	parent = dget_parent(dentry);
+	dir = parent->d_inode;
+	if (au_test_ro(sb, bstart, inode)) {
+		di_read_lock_parent(parent, !AuLock_IR);
+		err = AuWbrCopyup(au_sbi(sb), dentry);
+		new_bstart = err;
+		di_read_unlock(parent, !AuLock_IR);
+		if (unlikely(err < 0))
+			goto out_dput;
+		err = 0;
+	}
+	/* someone else might change our inode while we were sleeping */
+	/* todo: test more? */
+	if (bstart != au_ibstart(inode)) {
+		err = 0;
+		dput(parent);
+		goto again;
+	}
+	di_read_lock_parent(parent, AuLock_IR);
+	bstart = new_bstart;
+
+	hi_wh = au_hi_wh(inode, bstart);
+	if (au_opt_test(mnt_flags, PLINK)
+	    && au_plink_test(sb, inode)
+	    && !d_unhashed(dentry)) {
+		err = au_test_and_cpup_dirs(dentry, bstart);
+		if (unlikely(err))
+			goto out_unlock;
+
+		/* always superio. */
+#if 1
+		err = au_pin(&pin, dentry, bstart, pin_flags);
+		if (!err)
+			err = au_sio_cpup_simple(dentry, bstart, -1,
+						 AuCpup_DTIME);
+		au_unpin(&pin);
+#else /* reserved for future use */
+		if (!au_test_wkq(current)) {
+			int wkq_err;
+			struct cpup_pseudo_link_args args = {
+				.errp		= &err,
+				.dentry		= dentry,
+				.bdst		= bstart,
+				.do_lock	= 1
+			};
+			wkq_err = au_wkq_wait(call_cpup_pseudo_link, &args);
+			if (unlikely(wkq_err))
+				err = wkq_err;
+		} else
+			err = cpup_pseudo_link(dentry, bstart, /*do_lock*/1);
+#endif
+	} else if (hi_wh) {
+		/* already copied-up after unlink */
+		dinfo = au_di(dentry);
+		old_bstart = dinfo->di_bstart;
+		dinfo->di_bstart = bstart;
+		old_h_dentry = dinfo->di_hdentry[0 + bstart].hd_dentry;
+		dinfo->di_hdentry[0 + bstart].hd_dentry = hi_wh;
+		err = au_reopen_nondir(file);
+		dinfo->di_hdentry[0 + bstart].hd_dentry = old_h_dentry;
+		dinfo->di_bstart = old_bstart;
+		*need_reopen = 0;
+	}
+
+ out_unlock:
+	di_read_unlock(parent, AuLock_IR);
+ out_dput:
+	dput(parent);
+ out:
+	AuTraceErr(err);
+	return err;
+}
+
+/*
+ * after branch manipulating, refresh the file.
+ */
+static int refresh_file(struct file *file, int (*reopen)(struct file *file))
+{
+	int err, new_sz, need_reopen;
+	struct dentry *dentry;
+	aufs_bindex_t bend, bindex, brid;
+	struct au_hfile *p;
+	struct au_finfo *finfo;
+	struct super_block *sb;
+	struct inode *inode;
+
+	dentry = file->f_dentry;
+	LKTRTrace("%.*s\n", AuDLNPair(dentry));
+	FiMustWriteLock(file);
+	DiMustAnyLock(dentry);
+	inode = dentry->d_inode;
+	IiMustAnyLock(inode);
+
+	err = -ENOMEM;
+	sb = dentry->d_sb;
+	finfo = au_fi(file);
+	new_sz = sizeof(*finfo->fi_hfile) * (au_sbend(sb) + 1);
+	p = au_kzrealloc(finfo->fi_hfile, sizeof(*p) * (finfo->fi_bend + 1),
+			 new_sz, GFP_NOFS);
+	if (unlikely(!p))
+		goto out;
+	finfo->fi_hfile = p;
+
+	p += finfo->fi_bstart;
+	brid = p->hf_br->br_id;
+	bend = finfo->fi_bend;
+	for (bindex = finfo->fi_bstart; bindex <= bend; bindex++, p++) {
+		struct au_hfile tmp, *q;
+		aufs_bindex_t new_bindex;
+
+		if (!p->hf_file)
+			continue;
+		new_bindex = au_find_bindex(sb, p->hf_br);
+		if (new_bindex == bindex)
+			continue;
+		/* todo: test more? */
+		if (new_bindex < 0) {
+			au_set_h_fptr(file, bindex, NULL);
+			continue;
+		}
+
+		/* swap two hidden inode, and loop again */
+		q = finfo->fi_hfile + new_bindex;
+		tmp = *q;
+		*q = *p;
+		*p = tmp;
+		if (tmp.hf_file) {
+			bindex--;
+			p--;
+		}
+	}
+	{
+		aufs_bindex_t s = finfo->fi_bstart, e = finfo->fi_bend;
+		finfo->fi_bstart = 0;
+		finfo->fi_bend = au_sbend(sb);
+		finfo->fi_bstart = s;
+		finfo->fi_bend = e;
+	}
+
+	p = finfo->fi_hfile;
+	if (!au_test_mmapped(file) && !d_unhashed(dentry)) {
+		bend = au_sbend(sb);
+		for (finfo->fi_bstart = 0; finfo->fi_bstart <= bend;
+		     finfo->fi_bstart++, p++)
+			if (p->hf_file) {
+				if (p->hf_file->f_dentry
+				    && p->hf_file->f_dentry->d_inode)
+					break;
+				else
+					au_hfput(p);
+			}
+	} else {
+		bend = au_br_index(sb, brid);
+		for (finfo->fi_bstart = 0; finfo->fi_bstart < bend;
+		     finfo->fi_bstart++, p++)
+			if (p->hf_file)
+				au_hfput(p);
+		bend = au_sbend(sb);
+	}
+
+	p = finfo->fi_hfile + bend;
+	for (finfo->fi_bend = bend; finfo->fi_bend >= finfo->fi_bstart;
+	     finfo->fi_bend--, p--)
+		if (p->hf_file) {
+			if (p->hf_file->f_dentry
+			    && p->hf_file->f_dentry->d_inode)
+				break;
+			else
+				au_hfput(p);
+		}
+	AuDebugOn(finfo->fi_bend < finfo->fi_bstart);
+
+	err = 0;
+	need_reopen = 1;
+	if (!au_test_mmapped(file))
+		err = au_file_refresh_by_inode(file, &need_reopen);
+	if (!err && need_reopen && !d_unhashed(dentry))
+		err = reopen(file);
+	if (!err) {
+		au_update_figen(file);
+		return 0; /* success */
+	}
+
+	/* error, close all hidden files */
+	bend = au_fbend(file);
+	for (bindex = au_fbstart(file); bindex <= bend; bindex++)
+		au_set_h_fptr(file, bindex, NULL);
+
+ out:
+	AuTraceErr(err);
+	return err;
+}
+
+/* common function to regular file and dir */
+int au_reval_and_lock_fdi(struct file *file, int (*reopen)(struct file *file),
+			  int wlock, int locked)
+{
+	int err;
+	struct dentry *dentry;
+	struct super_block *sb;
+	aufs_bindex_t bstart;
+	unsigned char pseudo_link;
+	au_gen_t sgen, fgen;
+
+	dentry = file->f_dentry;
+	LKTRTrace("%.*s, w %d, l %d\n", AuDLNPair(dentry), wlock, locked);
+	sb = dentry->d_sb;
+	SiMustAnyLock(sb);
+
+	err = 0;
+	sgen = au_sigen(sb);
+	fi_write_lock(file);
+	fgen = au_figen(file);
+	di_write_lock_child(dentry);
+	bstart = au_dbstart(dentry);
+	pseudo_link = (bstart != au_ibstart(dentry->d_inode));
+	if (sgen == fgen && !pseudo_link && au_fbstart(file) == bstart) {
+		if (!wlock) {
+			di_downgrade_lock(dentry, AuLock_IR);
+			fi_downgrade_lock(file);
+		}
+		goto out; /* success */
+	}
+
+	LKTRTrace("sgen %d, fgen %d\n", sgen, fgen);
+	if (sgen != au_digen(dentry)
+	    || sgen != au_iigen(dentry->d_inode)) {
+		/*
+		 * d_path() and path_lookup() is a simple and good approach
+		 * to revalidate. but si_rwsem in DEBUG_RWSEM will cause a
+		 * deadlock. removed the code.
+		 */
+		err = au_reval_dpath(dentry, sgen);
+		if (unlikely(err < 0))
+			goto out;
+		AuDebugOn(au_digen(dentry) != sgen
+			  || au_iigen(dentry->d_inode) != sgen);
+	}
+
+	err = refresh_file(file, reopen
+			   /* , au_opt_test(au_mnt_flags(sb), REFROF) */);
+	if (!err) {
+		if (!wlock) {
+			di_downgrade_lock(dentry, AuLock_IR);
+			fi_downgrade_lock(file);
+		}
+	} else {
+		di_write_unlock(dentry);
+		fi_write_unlock(file);
+	}
+
+ out:
+	AuTraceErr(err);
+	return err;
+}
+
+/* ---------------------------------------------------------------------- */
+
+/* cf. aufs_nopage() */
+/* for madvise(2) */
+static int aufs_readpage(struct file *file, struct page *page)
+{
+	AuTraceEnter();
+	unlock_page(page);
+	return 0;
+}
+
+/* they will never be called. */
+#ifdef CONFIG_AUFS_DEBUG
+static int aufs_prepare_write(struct file *file, struct page *page,
+			      unsigned from, unsigned to)
+{ AuUnsupport(); return 0; }
+static int aufs_commit_write(struct file *file, struct page *page,
+			     unsigned from, unsigned to)
+{ AuUnsupport(); return 0; }
+static int aufs_write_begin(struct file *file, struct address_space *mapping,
+			    loff_t pos, unsigned len, unsigned flags,
+			    struct page **pagep, void **fsdata)
+{ AuUnsupport(); return 0; }
+static int aufs_write_end(struct file *file, struct address_space *mapping,
+			  loff_t pos, unsigned len, unsigned copied,
+			  struct page *page, void *fsdata)
+{ AuUnsupport(); return 0; }
+static int aufs_writepage(struct page *page, struct writeback_control *wbc)
+{ AuUnsupport(); return 0; }
+static void aufs_sync_page(struct page *page)
+{ AuUnsupport(); }
+
+static int aufs_set_page_dirty(struct page *page)
+{ AuUnsupport(); return 0; }
+static void aufs_invalidatepage(struct page *page, unsigned long offset)
+{ AuUnsupport(); }
+static int aufs_releasepage(struct page *page, gfp_t gfp)
+{ AuUnsupport(); return 0; }
+static ssize_t aufs_direct_IO(int rw, struct kiocb *iocb,
+			      const struct iovec *iov, loff_t offset,
+			      unsigned long nr_segs)
+{ AuUnsupport(); return 0; }
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2, 6, 26)
+static struct page *aufs_get_xip_page(struct address_space *mapping,
+				      sector_t offset, int create)
+{ AuUnsupport(); return NULL; }
+#endif
+#endif /* CONFIG_AUFS_DEBUG */
+
+struct address_space_operations aufs_aop = {
+	.readpage	= aufs_readpage,
+#ifdef CONFIG_AUFS_DEBUG
+	.writepage	= aufs_writepage,
+	.sync_page	= aufs_sync_page,
+	.set_page_dirty	= aufs_set_page_dirty,
+	.prepare_write	= aufs_prepare_write,
+	.commit_write	= aufs_commit_write,
+	.write_begin	= aufs_write_begin,
+	.write_end	= aufs_write_end,
+	.invalidatepage	= aufs_invalidatepage,
+	.releasepage	= aufs_releasepage,
+	.direct_IO	= aufs_direct_IO,
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2, 6, 26)
+	.get_xip_page	= aufs_get_xip_page,
+#endif
+#endif /* CONFIG_AUFS_DEBUG */
+};
diff -Nurp linux-2.6.27.orig/fs/aufs/file.h linux-2.6.27/fs/aufs/file.h
--- linux-2.6.27.orig/fs/aufs/file.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.27/fs/aufs/file.h	2008-12-14 10:37:40.000000000 +0100
@@ -0,0 +1,257 @@
+/*
+ * Copyright (C) 2005-2008 Junjiro Okajima
+ *
+ * This program, aufs is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+ */
+
+/*
+ * file operations
+ *
+ * $Id: file.h,v 1.7 2008/12/08 06:11:54 sfjro Exp $
+ */
+
+#ifndef __AUFS_FILE_H__
+#define __AUFS_FILE_H__
+
+#ifdef __KERNEL__
+
+#include <linux/file.h>
+#include <linux/fs.h>
+#include <linux/mm.h>
+#include <linux/aufs_type.h>
+#include "dentry.h"
+#include "misc.h"
+#include "super.h"
+
+/* ---------------------------------------------------------------------- */
+
+struct au_branch;
+struct au_hfile {
+	struct file		*hf_file;
+	struct au_branch	*hf_br;
+};
+
+struct au_vdir;
+struct au_finfo {
+	atomic_t		fi_generation;
+
+	struct au_rwsem		fi_rwsem;
+	struct au_hfile		*fi_hfile;
+	aufs_bindex_t		fi_bstart, fi_bend;
+
+	union {
+		struct vm_operations_struct	*fi_h_vm_ops;
+		struct au_vdir			*fi_vdir_cache;
+	};
+};
+
+/* ---------------------------------------------------------------------- */
+
+/* file.c */
+extern struct address_space_operations aufs_aop;
+unsigned int au_file_roflags(unsigned int flags);
+struct file *au_h_open(struct dentry *dentry, aufs_bindex_t bindex, int flags,
+		       struct file *file);
+int au_do_open(struct inode *inode, struct file *file,
+	       int (*open)(struct file *file, int flags));
+int au_reopen_nondir(struct file *file);
+struct au_pin;
+int au_ready_to_write(struct file *file, loff_t len, struct au_pin *pin);
+int au_reval_and_lock_fdi(struct file *file, int (*reopen)(struct file *file),
+			  int wlock, int locked);
+
+/* f_op.c */
+extern struct file_operations aufs_file_fop;
+int aufs_flush(struct file *file, fl_owner_t id);
+
+/* finfo.c */
+struct au_finfo *au_fi(struct file *file);
+struct au_branch *au_fbr(struct file *file, aufs_bindex_t bindex);
+struct file *au_h_fptr(struct file *file, aufs_bindex_t bindex);
+
+void au_hfput(struct au_hfile *hf);
+void au_set_h_fptr(struct file *file, aufs_bindex_t bindex,
+		   struct file *h_file);
+
+void au_finfo_fin(struct file *file);
+int au_finfo_init(struct file *file);
+
+#ifdef CONFIG_AUFS_ROBR
+/* robr.c */
+struct file *au_robr_safe_file(struct vm_area_struct *vma);
+void au_robr_reset_file(struct vm_area_struct *vma, struct file *file);
+#else
+static inline struct file *au_robr_safe_file(struct vm_area_struct *vma)
+{
+	struct file *file;
+
+	file = vma->vm_file;
+	if (file->private_data && au_test_aufs(file->f_dentry->d_sb))
+		return file;
+	return NULL;
+}
+
+static inline
+void au_robr_reset_file(struct vm_area_struct *vma, struct file *file)
+{
+	vma->vm_file = file;
+	/* smp_mb(); */ /* flush vm_file */
+}
+#endif /* CONFIG_AUFS_ROBR */
+
+#if 0 /* reserved for future use */
+/* ioctl.c */
+long aufs_ioctl(struct file *file, unsigned int cmd, unsigned long arg);
+long aufs_ioctl_dir(struct file *file, unsigned int cmd, unsigned long arg);
+#endif
+
+/* ---------------------------------------------------------------------- */
+
+/* todo: memory barrier? */
+static inline au_gen_t au_figen(struct file *f)
+{
+	return atomic_read(&au_fi(f)->fi_generation);
+}
+
+static inline int au_test_mmapped(struct file *f)
+{
+	return !!(au_fi(f)->fi_h_vm_ops);
+}
+
+static inline int au_test_aufs_file(struct file *f)
+{
+	return !(f->f_dentry->d_inode->i_mode
+		 & (S_IFCHR | S_IFBLK | S_IFIFO | S_IFSOCK));
+}
+
+/* ---------------------------------------------------------------------- */
+
+#if !defined(CONFIG_AUFS_MODULE) || defined(CONFIG_AUFS_DENY_WRITE_ACCESS_PATCH)
+int au_store_fmode_exec(struct nameidata *nd, struct inode *inode);
+
+static inline int au_deny_write_access(struct file *h_file)
+{
+	LKTRTrace("%.*s\n", AuDLNPair(h_file->f_dentry));
+	return deny_write_access(h_file);
+}
+
+static inline void au_allow_write_access(struct file *h_file)
+{
+	allow_write_access(h_file);
+}
+
+#else
+
+static inline int au_store_fmode_exec(struct nameidata *nd, struct inode *inode)
+{
+	/* nothing */
+	return 0;
+}
+
+static inline int au_deny_write_access(struct file *h_file)
+{
+	/* nothing */
+	return 0;
+}
+
+static inline void au_allow_write_access(struct file *h_file)
+{
+	/* nothing */
+}
+#endif /* CONFIG_AUFS_DENY_WRITE_ACCESS_PATCH */
+
+/* ---------------------------------------------------------------------- */
+
+/*
+ * fi_read_lock, fi_write_lock,
+ * fi_read_unlock, fi_write_unlock, fi_downgrade_lock
+ */
+AuSimpleRwsemFuncs(fi, struct file *f, au_fi(f)->fi_rwsem);
+
+/* to debug easier, do not make them inlined functions */
+#define FiMustReadLock(f) do { \
+	SiMustAnyLock((f)->f_dentry->d_sb); \
+	AuRwMustReadLock(&au_fi(f)->fi_rwsem); \
+} while (0)
+
+#define FiMustWriteLock(f) do { \
+	SiMustAnyLock((f)->f_dentry->d_sb); \
+	AuRwMustWriteLock(&au_fi(f)->fi_rwsem); \
+} while (0)
+
+#define FiMustAnyLock(f) do { \
+	SiMustAnyLock((f)->f_dentry->d_sb); \
+	AuRwMustAnyLock(&au_fi(f)->fi_rwsem); \
+} while (0)
+
+#define FiMustNoWaiters(f)	AuRwMustNoWaiters(&au_fi(f)->fi_rwsem)
+
+/* ---------------------------------------------------------------------- */
+
+/* todo: hard/soft set? */
+static inline aufs_bindex_t au_fbstart(struct file *file)
+{
+	FiMustAnyLock(file);
+	return au_fi(file)->fi_bstart;
+}
+
+static inline aufs_bindex_t au_fbend(struct file *file)
+{
+	FiMustAnyLock(file);
+	return au_fi(file)->fi_bend;
+}
+
+static inline struct au_vdir *au_fvdir_cache(struct file *file)
+{
+#ifdef CONFIG_AUFS_EXPORT
+	AuRwMustAnyLock(&au_fi(file)->fi_rwsem);
+#else
+	FiMustAnyLock(file);
+#endif
+	return au_fi(file)->fi_vdir_cache;
+}
+
+static inline void au_set_fbstart(struct file *file, aufs_bindex_t bindex)
+{
+	FiMustWriteLock(file);
+	AuDebugOn(au_sbend(file->f_dentry->d_sb) < bindex);
+	au_fi(file)->fi_bstart = bindex;
+}
+
+static inline void au_set_fbend(struct file *file, aufs_bindex_t bindex)
+{
+	FiMustWriteLock(file);
+	AuDebugOn(au_sbend(file->f_dentry->d_sb) < bindex
+		  || bindex < au_fbstart(file));
+	au_fi(file)->fi_bend = bindex;
+}
+
+static inline void au_set_fvdir_cache(struct file *file,
+				      struct au_vdir *vdir_cache)
+{
+	FiMustWriteLock(file);
+	AuDebugOn(!S_ISDIR(file->f_dentry->d_inode->i_mode)
+		  || (au_fi(file)->fi_vdir_cache && vdir_cache));
+	au_fi(file)->fi_vdir_cache = vdir_cache;
+}
+
+static inline void au_update_figen(struct file *file)
+{
+	atomic_set(&au_fi(file)->fi_generation, au_digen(file->f_dentry));
+	/* smp_mb(); */ /* atomic_set */
+}
+
+#endif /* __KERNEL__ */
+#endif /* __AUFS_FILE_H__ */
diff -Nurp linux-2.6.27.orig/fs/aufs/finfo.c linux-2.6.27/fs/aufs/finfo.c
--- linux-2.6.27.orig/fs/aufs/finfo.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.27/fs/aufs/finfo.c	2008-09-29 05:43:22.000000000 +0200
@@ -0,0 +1,186 @@
+/*
+ * Copyright (C) 2005-2008 Junjiro Okajima
+ *
+ * This program, aufs is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+ */
+
+/*
+ * file private data
+ *
+ * $Id: finfo.c,v 1.5 2008/09/29 03:43:22 sfjro Exp $
+ */
+
+#include "aufs.h"
+
+struct au_finfo *au_fi(struct file *file)
+{
+	struct au_finfo *finfo = file->private_data;
+	AuDebugOn(!finfo
+		  || !finfo->fi_hfile
+		  || (0 < finfo->fi_bend
+		      && (/* au_sbi(file->f_dentry->d_sb)->si_bend
+			     < finfo->fi_bend
+			     || */ finfo->fi_bend < finfo->fi_bstart)));
+	return finfo;
+}
+
+struct au_branch *au_fbr(struct file *file, aufs_bindex_t bindex)
+{
+	struct au_finfo *finfo = au_fi(file);
+	struct au_hfile *hf;
+
+	FiMustAnyLock(file);
+	AuDebugOn(!finfo
+		  || finfo->fi_bstart < 0
+		  || bindex < finfo->fi_bstart
+		  || finfo->fi_bend < bindex);
+	hf = finfo->fi_hfile + bindex;
+	AuDebugOn(hf->hf_br && au_br_count(hf->hf_br) <= 0);
+	return hf->hf_br;
+}
+
+struct file *au_h_fptr(struct file *file, aufs_bindex_t bindex)
+{
+	struct au_finfo *finfo = au_fi(file);
+	struct au_hfile *hf;
+
+	FiMustAnyLock(file);
+	AuDebugOn(!finfo
+		  || finfo->fi_bstart < 0
+		  || bindex < finfo->fi_bstart
+		  || finfo->fi_bend < bindex);
+	hf = finfo->fi_hfile + bindex;
+	AuDebugOn(hf->hf_file
+		  && file_count(hf->hf_file) <= 0
+		  && au_br_count(hf->hf_br) <= 0);
+	return hf->hf_file;
+}
+
+void au_hfput(struct au_hfile *hf)
+{
+	if (hf->hf_file->f_mode & FMODE_EXEC)
+		au_allow_write_access(hf->hf_file);
+	fput(hf->hf_file);
+	hf->hf_file = NULL;
+	AuDebugOn(!hf->hf_br);
+	au_br_put(hf->hf_br);
+	hf->hf_br = NULL;
+}
+
+void au_set_h_fptr(struct file *file, aufs_bindex_t bindex, struct file *val)
+{
+	struct au_finfo *finfo = au_fi(file);
+	struct au_hfile *hf;
+
+	FiMustWriteLock(file);
+	AuDebugOn(!finfo
+		  || finfo->fi_bstart < 0
+		  || bindex < finfo->fi_bstart
+		  || finfo->fi_bend < bindex);
+	AuDebugOn(val && file_count(val) <= 0);
+	hf = finfo->fi_hfile + bindex;
+	AuDebugOn(val && hf->hf_file);
+	if (hf->hf_file)
+		au_hfput(hf);
+	if (val) {
+		hf->hf_file = val;
+		hf->hf_br = au_sbr(file->f_dentry->d_sb, bindex);
+	}
+}
+
+void au_finfo_fin(struct file *file)
+{
+	struct au_finfo *finfo;
+	struct dentry *dentry;
+	aufs_bindex_t bindex, bend;
+
+	dentry = file->f_dentry;
+	LKTRTrace("%.*s\n", AuDLNPair(dentry));
+	SiMustAnyLock(dentry->d_sb);
+
+	fi_write_lock(file);
+	bend = au_fbend(file);
+	bindex = au_fbstart(file);
+	if (bindex >= 0)
+		for (; bindex <= bend; bindex++)
+			au_set_h_fptr(file, bindex, NULL);
+
+	finfo = au_fi(file);
+#ifdef CONFIG_AUFS_DEBUG
+	if (finfo->fi_bstart >= 0) {
+		bend = au_fbend(file);
+		for (bindex = finfo->fi_bstart; bindex <= bend; bindex++) {
+			struct au_hfile *hf;
+			hf = finfo->fi_hfile + bindex;
+			AuDebugOn(hf->hf_file || hf->hf_br);
+		}
+	}
+#endif
+
+	kfree(finfo->fi_hfile);
+	fi_write_unlock(file);
+	au_rwsem_destroy(&finfo->fi_rwsem);
+	au_cache_free_finfo(finfo);
+}
+
+int au_finfo_init(struct file *file)
+{
+	struct au_finfo *finfo;
+	struct dentry *dentry;
+	union {
+		void *p;
+		unsigned long ul;
+	} u;
+
+	dentry = file->f_dentry;
+	LKTRTrace("%.*s\n", AuDLNPair(dentry));
+	AuDebugOn(!dentry->d_inode);
+
+	finfo = au_cache_alloc_finfo();
+	if (finfo) {
+		finfo->fi_hfile = kcalloc(au_sbend(dentry->d_sb) + 1,
+					  sizeof(*finfo->fi_hfile), GFP_NOFS);
+		if (finfo->fi_hfile) {
+			au_rw_init_wlock(&finfo->fi_rwsem);
+			//au_dbg_lock_fi_reg(file);
+			finfo->fi_bstart = -1;
+			finfo->fi_bend = -1;
+			atomic_set(&finfo->fi_generation, au_digen(dentry));
+			/* smp_mb(); */ /* atomic_set */
+
+			/*
+			 * a dirty trick for handling FMODE_EXEC and
+			 * deny_write_access().
+			 * because FMODE_EXEC flag is not passed to
+			 * f_op->open(),
+			 * aufs set it to file->private_data temporary in lookup
+			 * or dentry revalidation operations.
+			 * restore the flag to f_mode here.
+			 */
+			u.p = file->private_data;
+			if (u.ul & FMODE_EXEC) {
+				file->f_mode |= FMODE_EXEC;
+				smp_mb(); /* flush f_mode */
+			}
+
+			file->private_data = finfo;
+			return 0; /* success */
+		}
+		au_cache_free_finfo(finfo);
+	}
+
+	AuTraceErr(-ENOMEM);
+	return -ENOMEM;
+}
diff -Nurp linux-2.6.27.orig/fs/aufs/f_op.c linux-2.6.27/fs/aufs/f_op.c
--- linux-2.6.27.orig/fs/aufs/f_op.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.27/fs/aufs/f_op.c	2008-12-14 10:37:40.000000000 +0100
@@ -0,0 +1,673 @@
+/*
+ * Copyright (C) 2005-2008 Junjiro Okajima
+ *
+ * This program, aufs is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+ */
+
+/*
+ * file and vm operations
+ *
+ * $Id: f_op.c,v 1.15 2008/12/01 03:49:29 sfjro Exp $
+ */
+
+#include <linux/fs_stack.h>
+#include <linux/poll.h>
+#include "aufs.h"
+
+/* common function to regular file and dir */
+int aufs_flush(struct file *file, fl_owner_t id)
+{
+	int err;
+	struct dentry *dentry;
+	aufs_bindex_t bindex, bend;
+	struct file *h_file;
+
+	dentry = file->f_dentry;
+	LKTRTrace("%.*s\n", AuDLNPair(dentry));
+
+	si_noflush_read_lock(dentry->d_sb);
+	fi_read_lock(file);
+	di_read_lock_child(dentry, AuLock_IW);
+
+	err = 0;
+	bend = au_fbend(file);
+	for (bindex = au_fbstart(file); !err && bindex <= bend; bindex++) {
+		h_file = au_h_fptr(file, bindex);
+		if (h_file && h_file->f_op && h_file->f_op->flush) {
+			err = h_file->f_op->flush(h_file, id);
+			if (!err)
+				au_update_fuse_h_inode
+					(h_file->f_vfsmnt, h_file->f_dentry);
+			/*ignore*/
+		}
+	}
+	au_cpup_attr_timesizes(dentry->d_inode);
+
+	di_read_unlock(dentry, AuLock_IW);
+	fi_read_unlock(file);
+	si_read_unlock(dentry->d_sb);
+	AuTraceErr(err);
+	return err;
+}
+
+/* ---------------------------------------------------------------------- */
+
+static int do_open_nondir(struct file *file, int flags)
+{
+	int err;
+	aufs_bindex_t bindex;
+	struct super_block *sb;
+	struct file *h_file;
+	struct dentry *dentry;
+	struct inode *inode;
+	struct au_finfo *finfo;
+
+	dentry = file->f_dentry;
+	LKTRTrace("%.*s, flags 0%o\n", AuDLNPair(dentry), flags);
+	FiMustWriteLock(file);
+	inode = dentry->d_inode;
+	AuDebugOn(!inode || S_ISDIR(inode->i_mode));
+
+	err = 0;
+	finfo = au_fi(file);
+	finfo->fi_h_vm_ops = NULL;
+	sb = dentry->d_sb;
+	bindex = au_dbstart(dentry);
+	AuDebugOn(!au_h_dptr(dentry, bindex)->d_inode);
+	/* O_TRUNC is processed already */
+	BUG_ON(au_test_ro(sb, bindex, inode) && (flags & O_TRUNC));
+
+	h_file = au_h_open(dentry, bindex, flags, file);
+	if (IS_ERR(h_file))
+		err = PTR_ERR(h_file);
+	else {
+		au_set_fbstart(file, bindex);
+		au_set_fbend(file, bindex);
+		au_set_h_fptr(file, bindex, h_file);
+		au_update_figen(file);
+		/* todo: necessary? */
+		/* file->f_ra = h_file->f_ra; */
+		err = 0;
+	}
+	AuTraceErr(err);
+	return err;
+}
+
+static int aufs_open_nondir(struct inode *inode, struct file *file)
+{
+	LKTRTrace("i%lu, %.*s\n", inode->i_ino, AuDLNPair(file->f_dentry));
+
+	return au_do_open(inode, file, do_open_nondir);
+}
+
+static int aufs_release_nondir(struct inode *inode, struct file *file)
+{
+	struct super_block *sb = file->f_dentry->d_sb;
+
+	LKTRTrace("i%lu, %.*s\n", inode->i_ino, AuDLNPair(file->f_dentry));
+
+	si_noflush_read_lock(sb);
+	au_finfo_fin(file);
+	si_read_unlock(sb);
+	return 0;
+}
+
+/* ---------------------------------------------------------------------- */
+
+static ssize_t aufs_read(struct file *file, char __user *buf, size_t count,
+			 loff_t *ppos)
+{
+	ssize_t err;
+	struct dentry *dentry;
+	struct file *h_file;
+	struct super_block *sb;
+	struct inode *h_inode;
+
+	dentry = file->f_dentry;
+	LKTRTrace("%.*s, cnt %zu, pos %lld\n", AuDLNPair(dentry), count, *ppos);
+
+	sb = dentry->d_sb;
+	si_read_lock(sb, AuLock_FLUSH);
+	err = au_reval_and_lock_fdi(file, au_reopen_nondir, /*wlock*/0,
+				    /*locked*/0);
+	if (unlikely(err))
+		goto out;
+
+	/* support LSM and notify */
+	h_file = au_h_fptr(file, au_fbstart(file));
+	h_inode = h_file->f_dentry->d_inode;
+	err = vfsub_read_u(h_file, buf, count, ppos,
+			   au_test_dlgt(au_mntflags(sb)));
+	/* todo: necessary? */
+	/* file->f_ra = h_file->f_ra; */
+	fsstack_copy_attr_atime(dentry->d_inode, h_file->f_dentry->d_inode);
+
+	di_read_unlock(dentry, AuLock_IR);
+	fi_read_unlock(file);
+ out:
+	si_read_unlock(sb);
+	AuTraceErr(err);
+	return err;
+}
+
+static ssize_t aufs_write(struct file *file, const char __user *ubuf,
+			  size_t count, loff_t *ppos)
+{
+	ssize_t err;
+	struct dentry *dentry;
+	struct inode *inode;
+	struct super_block *sb;
+	unsigned int mnt_flags;
+	struct file *h_file;
+	char __user *buf = (char __user *)ubuf;
+	struct au_hin_ignore ign;
+	struct vfsub_args vargs;
+	aufs_bindex_t bstart;
+	int hinotify;
+	struct au_pin pin;
+
+	dentry = file->f_dentry;
+	LKTRTrace("%.*s, cnt %zu, pos %lld\n", AuDLNPair(dentry), count, *ppos);
+
+	inode = dentry->d_inode;
+	mutex_lock(&inode->i_mutex);
+	sb = dentry->d_sb;
+	si_read_lock(sb, AuLock_FLUSH);
+	mnt_flags = au_mntflags(sb);
+	hinotify = !!au_opt_test(mnt_flags, UDBA_INOTIFY);
+	vfsub_args_init(&vargs, &ign, au_test_dlgt(mnt_flags), 0);
+
+	err = au_reval_and_lock_fdi(file, au_reopen_nondir, /*wlock*/1,
+				    /*locked*/1);
+	if (unlikely(err))
+		goto out;
+	err = au_ready_to_write(file, -1, &pin);
+	di_downgrade_lock(dentry, AuLock_IR);
+	if (unlikely(err))
+		goto out_unlock;
+
+	bstart = au_fbstart(file);
+	h_file = au_h_fptr(file, bstart);
+	if (!hinotify) {
+		au_unpin(&pin);
+		err = vfsub_write_u(h_file, buf, count, ppos, &vargs);
+	} else {
+		vfsub_ign_hinode(&vargs, IN_MODIFY, au_pinned_hdir(&pin));
+		err = vfsub_write_u(h_file, buf, count, ppos, &vargs);
+		au_unpin(&pin);
+	}
+	au_cpup_attr_timesizes(inode);
+
+ out_unlock:
+	di_read_unlock(dentry, AuLock_IR);
+	fi_write_unlock(file);
+ out:
+	si_read_unlock(sb);
+	mutex_unlock(&inode->i_mutex);
+	AuTraceErr(err);
+	return err;
+}
+
+#ifdef CONFIG_AUFS_SPLICE_PATCH
+static int au_test_loopback(void)
+{
+	const char c = current->comm[4];
+	/* true if a kernel thread named 'loop[0-9].*' accesses a file */
+	const int loopback = (current->mm == NULL
+			      && '0' <= c && c <= '9'
+			      && strncmp(current->comm, "loop", 4) == 0);
+	return loopback;
+}
+
+static ssize_t aufs_splice_read(struct file *file, loff_t *ppos,
+				struct pipe_inode_info *pipe, size_t len,
+				unsigned int flags)
+{
+	ssize_t err;
+	struct file *h_file;
+	struct dentry *dentry;
+	struct super_block *sb;
+
+	dentry = file->f_dentry;
+	LKTRTrace("%.*s, pos %lld, len %zu\n", AuDLNPair(dentry), *ppos, len);
+
+	sb = dentry->d_sb;
+	si_read_lock(sb, AuLock_FLUSH);
+	err = au_reval_and_lock_fdi(file, au_reopen_nondir, /*wlock*/0,
+				    /*locked*/0);
+	if (unlikely(err))
+		goto out;
+
+	err = -EINVAL;
+	/* support LSM and notify */
+	h_file = au_h_fptr(file, au_fbstart(file));
+	if (au_test_loopback()) {
+		file->f_mapping = h_file->f_mapping;
+		smp_mb(); /* unnecessary? */
+	}
+	err = vfsub_splice_to(h_file, ppos, pipe, len, flags,
+			      au_test_dlgt(au_mntflags(sb)));
+	/* todo: necessasry? */
+	/* file->f_ra = h_file->f_ra; */
+	fsstack_copy_attr_atime(dentry->d_inode, h_file->f_dentry->d_inode);
+	di_read_unlock(dentry, AuLock_IR);
+	fi_read_unlock(file);
+
+ out:
+	si_read_unlock(sb);
+	AuTraceErr(err);
+	return err;
+}
+
+static ssize_t
+aufs_splice_write(struct pipe_inode_info *pipe, struct file *file, loff_t *ppos,
+		  size_t len, unsigned int flags)
+{
+	ssize_t err;
+	struct dentry *dentry;
+	struct inode *inode, *h_inode;
+	struct super_block *sb;
+	struct file *h_file;
+	/* struct au_hin_ignore ign; */
+	struct vfsub_args vargs;
+	unsigned int mnt_flags;
+	struct au_pin pin;
+
+	dentry = file->f_dentry;
+	LKTRTrace("%.*s, len %zu, pos %lld\n", AuDLNPair(dentry), len, *ppos);
+
+	inode = dentry->d_inode;
+	mutex_lock(&inode->i_mutex);
+	sb = dentry->d_sb;
+	si_read_lock(sb, AuLock_FLUSH);
+	mnt_flags = au_mntflags(sb);
+	vfsub_args_init(&vargs, /*&ign*/NULL, au_test_dlgt(mnt_flags), 0);
+
+	err = au_reval_and_lock_fdi(file, au_reopen_nondir, /*wlock*/1,
+				    /*locked*/1);
+	if (unlikely(err))
+		goto out;
+	err = au_ready_to_write(file, -1, &pin);
+	di_downgrade_lock(dentry, AuLock_IR);
+	if (unlikely(err))
+		goto out_unlock;
+
+	/* support LSM and notify */
+	/* current vfs_splice_from() doesn't fire up the inotify event */
+	h_file = au_h_fptr(file, au_fbstart(file));
+	h_inode = h_file->f_dentry->d_inode;
+	if (1 || !au_opt_test(mnt_flags, UDBA_INOTIFY)) {
+		au_unpin(&pin);
+		err = vfsub_splice_from(pipe, h_file, ppos, len, flags, &vargs);
+	}
+#if 0 /* reserved for future use */
+	else {
+		struct dentry *parent = dget_parent(dentry);
+		vfsub_ign_hinode(&vargs, IN_MODIFY, au_pinned_hdir(&pin));
+		err = vfsub_splice_from(pipe, h_file, ppos, len, flags, &vargs);
+		au_unpin(&pin);
+	}
+#endif
+	au_cpup_attr_timesizes(inode);
+
+ out_unlock:
+	di_read_unlock(dentry, AuLock_IR);
+	fi_write_unlock(file);
+ out:
+	si_read_unlock(sb);
+	mutex_unlock(&inode->i_mutex);
+	AuTraceErr(err);
+	return err;
+}
+#endif /* CONFIG_AUFS_SPLICE_PATCH */
+
+/* ---------------------------------------------------------------------- */
+
+static int aufs_fault(struct vm_area_struct *vma, struct vm_fault *vmf)
+{
+	int err;
+	struct dentry *dentry;
+	struct file *file, *h_file;
+	struct inode *inode;
+	static DECLARE_WAIT_QUEUE_HEAD(wq);
+	struct au_finfo *finfo;
+
+	AuTraceEnter();
+	AuDebugOn(!vma || !vma->vm_file);
+	/* todo: non-robr mode, user vm_file as it is? */
+	wait_event(wq, (file = au_robr_safe_file(vma)));
+	AuDebugOn(!au_test_aufs(file->f_dentry->d_sb));
+	dentry = file->f_dentry;
+	LKTRTrace("%.*s\n", AuDLNPair(dentry));
+	inode = dentry->d_inode;
+	AuDebugOn(!S_ISREG(inode->i_mode));
+
+	/* do not revalidate, no si lock */
+	finfo = au_fi(file);
+	h_file = finfo->fi_hfile[0 + finfo->fi_bstart].hf_file;
+	AuDebugOn(!h_file || !au_test_mmapped(file));
+	fi_write_lock(file);
+	vma->vm_file = h_file;
+	err = finfo->fi_h_vm_ops->fault(vma, vmf);
+	/* todo: necessary? */
+	/* file->f_ra = h_file->f_ra; */
+	au_robr_reset_file(vma, file);
+	fi_write_unlock(file);
+#if 0 /* def CONFIG_SMP */
+	/* wake_up_nr(&wq, online_cpu - 1); */
+	wake_up_all(&wq);
+#else
+	wake_up(&wq);
+#endif
+
+	if (!(err & VM_FAULT_ERROR)) {
+#if 0 /* debug */
+		struct page *page;
+		page = vmf->page;
+		AuDbg("%p, %d\n", page, page_mapcount(page));
+
+		page->mapping = file->f_mapping;
+		get_page(page);
+		file->f_mapping = h_file->f_mapping;
+		touch_atime(NULL, dentry);
+		inode->i_atime = h_file->f_dentry->d_inode->i_atime;
+#endif
+	}
+	AuTraceErr(err);
+	return err;
+}
+
+static struct vm_operations_struct aufs_vm_ops = {
+	.fault		= aufs_fault,
+#if 0 /* reserved for future use */
+	.open		= aufs_vmaopen,
+	.close		= aufs_vmaclose,
+	unsigned long (*nopfn)(struct vm_area_struct *area,
+			       unsigned long address);
+	page_mkwrite(struct vm_area_struct *vma, struct page *page)
+#endif
+};
+
+/* ---------------------------------------------------------------------- */
+
+static struct vm_operations_struct *au_vm_ops(struct file *h_file,
+					      struct vm_area_struct *vma)
+{
+	struct vm_operations_struct *vm_ops;
+	int err;
+
+	AuTraceEnter();
+
+	au_br_nfs_lockdep_off(h_file->f_vfsmnt->mnt_sb);
+	err = h_file->f_op->mmap(h_file, vma);
+	au_br_nfs_lockdep_on(h_file->f_vfsmnt->mnt_sb);
+	vm_ops = ERR_PTR(err);
+	if (unlikely(err))
+		goto out;
+	vm_ops = vma->vm_ops;
+	err = do_munmap(current->mm, vma->vm_start,
+			vma->vm_end - vma->vm_start);
+	if (unlikely(err)) {
+		AuIOErr("failed internal unmapping %.*s, %d\n",
+			AuDLNPair(h_file->f_dentry), err);
+		vm_ops = ERR_PTR(-EIO);
+	}
+
+ out:
+	AuTraceErrPtr(vm_ops);
+	return vm_ops;
+}
+
+static int aufs_mmap(struct file *file, struct vm_area_struct *vma)
+{
+	int err;
+	unsigned char wlock, mmapped;
+	struct dentry *dentry;
+	struct super_block *sb;
+	struct file *h_file;
+	struct vm_operations_struct *vm_ops;
+
+	dentry = file->f_dentry;
+	LKTRTrace("%.*s, %lx, len %lu\n",
+		  AuDLNPair(dentry), vma->vm_start,
+		  vma->vm_end - vma->vm_start);
+	AuDebugOn(!S_ISREG(dentry->d_inode->i_mode));
+	AuDebugOn(down_write_trylock(&vma->vm_mm->mmap_sem));
+
+	mmapped = au_test_mmapped(file); /* can be harmless race condition */
+	wlock = !!(file->f_mode & FMODE_WRITE);
+	sb = dentry->d_sb;
+	si_read_lock(sb, AuLock_FLUSH);
+	err = au_reval_and_lock_fdi(file, au_reopen_nondir, wlock | !mmapped,
+				/*locked*/0);
+	if (unlikely(err))
+		goto out;
+
+	if (wlock) {
+		struct au_pin pin;
+
+		err = au_ready_to_write(file, -1, &pin);
+		di_downgrade_lock(dentry, AuLock_IR);
+		if (unlikely(err))
+			goto out_unlock;
+		au_unpin(&pin);
+	} else if (!mmapped)
+		di_downgrade_lock(dentry, AuLock_IR);
+
+	h_file = au_h_fptr(file, au_fbstart(file));
+	if (au_test_fuse(h_file->f_dentry->d_sb)) {
+		/*
+		 * by this assignment, f_mapping will differs from aufs inode
+		 * i_mapping.
+		 * if someone else mixes the use of f_dentry->d_inode and
+		 * f_mapping->host, then a problem may arise.
+		 */
+		file->f_mapping = h_file->f_mapping;
+	}
+
+	if (0 && h_file->f_op->mmap == generic_file_mmap) {
+		err = generic_file_mmap(file, vma); /* instead of h_file */
+		if (unlikely(err))
+			goto out_unlock;
+		au_fi(file)->fi_h_vm_ops = vma->vm_ops;
+	} else {
+		vm_ops = NULL;
+		if (!mmapped) {
+			vm_ops = au_vm_ops(h_file, vma);
+			err = PTR_ERR(vm_ops);
+			if (IS_ERR(vm_ops))
+				goto out_unlock;
+		}
+
+		err = generic_file_mmap(file, vma);
+		if (unlikely(err))
+			goto out_unlock;
+		vma->vm_ops = &aufs_vm_ops;
+		/* test again */
+		if (!au_test_mmapped(file)) {
+			FiMustWriteLock(file);
+			au_fi(file)->fi_h_vm_ops = vm_ops;
+		}
+	}
+
+	file_accessed(h_file);
+	au_update_fuse_h_inode(h_file->f_vfsmnt, h_file->f_dentry); /*ignore*/
+	fsstack_copy_attr_atime(dentry->d_inode, h_file->f_dentry->d_inode);
+
+ out_unlock:
+	di_read_unlock(dentry, AuLock_IR);
+	if (!wlock && mmapped)
+		fi_read_unlock(file);
+	else
+		fi_write_unlock(file);
+ out:
+	si_read_unlock(sb);
+	AuTraceErr(err);
+	return err;
+}
+
+/* ---------------------------------------------------------------------- */
+
+static unsigned int aufs_poll(struct file *file, poll_table *wait)
+{
+	unsigned int mask;
+	struct file *h_file;
+	int err;
+	struct dentry *dentry;
+	struct super_block *sb;
+
+	dentry = file->f_dentry;
+	LKTRTrace("%.*s, wait %p\n", AuDLNPair(dentry), wait);
+	AuDebugOn(S_ISDIR(dentry->d_inode->i_mode));
+
+	/* We should pretend an error happened. */
+	mask = POLLERR /* | POLLIN | POLLOUT */;
+	sb = dentry->d_sb;
+	si_read_lock(sb, AuLock_FLUSH);
+	err = au_reval_and_lock_fdi(file, au_reopen_nondir, /*wlock*/0,
+				    /*locked*/0);
+	if (unlikely(err))
+		goto out;
+
+	/* it is not an error of hidden_file has no operation */
+	mask = DEFAULT_POLLMASK;
+	h_file = au_h_fptr(file, au_fbstart(file));
+	if (h_file->f_op && h_file->f_op->poll)
+		mask = h_file->f_op->poll(h_file, wait);
+	di_read_unlock(dentry, AuLock_IR);
+	fi_read_unlock(file);
+
+ out:
+	si_read_unlock(sb);
+	AuTraceErr((int)mask);
+	return mask;
+}
+
+static int aufs_fsync_nondir(struct file *file, struct dentry *dentry,
+			     int datasync)
+{
+	int err;
+	struct inode *inode;
+	struct file *h_file;
+	struct super_block *sb;
+	struct au_pin pin;
+
+	LKTRTrace("%.*s, %d\n", AuDLNPair(dentry), datasync);
+	inode = dentry->d_inode;
+
+	IMustLock(file->f_mapping->host);
+	if (inode != file->f_mapping->host) {
+		mutex_unlock(&file->f_mapping->host->i_mutex);
+		mutex_lock(&inode->i_mutex);
+	}
+	IMustLock(inode);
+
+	sb = dentry->d_sb;
+	si_read_lock(sb, AuLock_FLUSH);
+	err = 0; /* -EBADF; */ /* posix? */
+	if (unlikely(!(file->f_mode & FMODE_WRITE)))
+		goto out;
+	err = au_reval_and_lock_fdi(file, au_reopen_nondir, /*wlock*/1,
+				    /*locked*/1);
+	if (unlikely(err))
+		goto out;
+	err = au_ready_to_write(file, -1, &pin);
+	di_downgrade_lock(dentry, AuLock_IR);
+	if (unlikely(err))
+		goto out_unlock;
+	au_unpin(&pin);
+
+	err = -EINVAL;
+	h_file = au_h_fptr(file, au_fbstart(file));
+	if (h_file->f_op && h_file->f_op->fsync) {
+		struct mutex *h_mtx = &h_file->f_dentry->d_inode->i_mutex;
+
+		mutex_lock_nested(h_mtx, AuLsc_I_CHILD);
+		err = h_file->f_op->fsync(h_file, h_file->f_dentry, datasync);
+		if (!err)
+			au_update_fuse_h_inode(h_file->f_vfsmnt,
+					       h_file->f_dentry);
+		au_cpup_attr_timesizes(inode);
+		mutex_unlock(h_mtx);
+	}
+
+ out_unlock:
+	di_read_unlock(dentry, AuLock_IR);
+	fi_write_unlock(file);
+ out:
+	si_read_unlock(sb);
+	if (inode != file->f_mapping->host) {
+		mutex_unlock(&inode->i_mutex);
+		mutex_lock(&file->f_mapping->host->i_mutex);
+	}
+	AuTraceErr(err);
+	return err;
+}
+
+static int aufs_fasync(int fd, struct file *file, int flag)
+{
+	int err;
+	struct file *h_file;
+	struct dentry *dentry;
+	struct super_block *sb;
+
+	dentry = file->f_dentry;
+	LKTRTrace("%.*s, %d\n", AuDLNPair(dentry), flag);
+
+	sb = dentry->d_sb;
+	si_read_lock(sb, AuLock_FLUSH);
+	err = au_reval_and_lock_fdi(file, au_reopen_nondir, /*wlock*/0,
+				    /*locked*/0);
+	if (unlikely(err))
+		goto out;
+
+	h_file = au_h_fptr(file, au_fbstart(file));
+	if (h_file->f_op && h_file->f_op->fasync)
+		err = h_file->f_op->fasync(fd, h_file, flag);
+	di_read_unlock(dentry, AuLock_IR);
+	fi_read_unlock(file);
+
+ out:
+	si_read_unlock(sb);
+	AuTraceErr(err);
+	return err;
+}
+
+/* ---------------------------------------------------------------------- */
+
+struct file_operations aufs_file_fop = {
+	/*
+	 * while generic_file_llseek/_unlocked() don't use BKL,
+	 * don't use it since it operates file->f_mapping->host.
+	 * in aufs, it may be a real file and may confuse users by UDBA.
+	 */
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 27)
+	/* .llseek		= generic_file_llseek, */
+#endif
+	.read		= aufs_read,
+	.write		= aufs_write,
+	.poll		= aufs_poll,
+	/* .unlocked_ioctl	= aufs_ioctl, */
+	.mmap		= aufs_mmap,
+	.open		= aufs_open_nondir,
+	.flush		= aufs_flush,
+	.release	= aufs_release_nondir,
+	.fsync		= aufs_fsync_nondir,
+	.fasync		= aufs_fasync,
+#ifdef CONFIG_AUFS_SPLICE_PATCH
+	.splice_write	= aufs_splice_write,
+	.splice_read	= aufs_splice_read,
+#endif
+};
diff -Nurp linux-2.6.27.orig/fs/aufs/getattr.c linux-2.6.27/fs/aufs/getattr.c
--- linux-2.6.27.orig/fs/aufs/getattr.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.27/fs/aufs/getattr.c	2008-12-14 10:37:40.000000000 +0100
@@ -0,0 +1,133 @@
+/*
+ * Copyright (C) 2005-2008 Junjiro Okajima
+ *
+ * This program, aufs is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+ */
+
+/*
+ * inode attributes on NFS/FUSE branch or HINOTIFY
+ *
+ * $Id: getattr.c,v 1.4 2008/12/08 06:11:35 sfjro Exp $
+ */
+
+#include "aufs.h"
+
+static struct dentry *
+au_h_dget_any(struct dentry *dentry, aufs_bindex_t *bindex)
+{
+	struct dentry *h_dentry;
+	struct inode *inode, *h_inode;
+	struct super_block *sb;
+	aufs_bindex_t ib, db;
+
+	/* must be positive dentry */
+	inode = dentry->d_inode;
+	LKTRTrace("%.*s, i%lu\n", AuDLNPair(dentry), inode->i_ino);
+
+	sb = dentry->d_sb;
+	db = au_dbstart(dentry);
+	ib = au_ibstart(inode);
+	if (db == ib) {
+		*bindex = db;
+		h_dentry = dget(au_h_dptr(dentry, db));
+		if (h_dentry)
+			goto out; /* success */
+	}
+
+	*bindex = ib;
+	h_inode = au_h_iptr(inode, ib);
+	h_dentry = d_find_alias(h_inode);
+	if (h_dentry)
+		goto out; /* success */
+
+#if 0
+	if (au_opt_test(au_mntflags(sb), PLINK)
+	    && au_plink_test(sb, inode)) {
+		h_dentry = au_plink_lkup(sb, ib, inode);
+		if (IS_ERR(h_dentry))
+			goto out;
+		AuDebugOn(!h_dentry->d_inode);
+		goto out; /* success */
+	}
+#endif
+
+	h_dentry = dget(au_hi_wh(inode, ib));
+
+ out:
+	AuTraceErrPtr(h_dentry);
+	return h_dentry;
+}
+
+int aufs_getattr(struct vfsmount *mnt, struct dentry *dentry, struct kstat *st)
+{
+	int err;
+	unsigned int mnt_flags;
+	aufs_bindex_t bindex;
+	unsigned char did_lock;
+	struct inode *inode;
+	struct dentry *h_dentry;
+	struct super_block *sb, *h_sb;
+
+	LKTRTrace("%.*s\n", AuDLNPair(dentry));
+
+	err = 0;
+	sb = dentry->d_sb;
+	si_read_lock(sb, AuLock_FLUSH);
+	mnt_flags = au_mntflags(sb);
+	if (dentry != sb->s_root) {
+		di_read_lock_parent(dentry, AuLock_IR);
+		inode = dentry->d_inode;
+		did_lock = 1;
+
+		/* todo: test bit inotify option too? */
+		bindex = au_ibstart(inode);
+		h_sb = au_sbr_sb(sb, bindex);
+		/* todo: fix this condition */
+		if ((au_opt_test(mnt_flags, PLINK) && au_plink_test(sb, inode))
+		    /* au_iigen(inode) == au_sigen(sb) */
+		    || (!au_test_fuse(h_sb) && !au_test_nfs(h_sb)))
+			goto fill;
+
+		h_dentry = au_h_dget_any(dentry, &bindex);
+		err = PTR_ERR(h_dentry);
+		if (IS_ERR(h_dentry))
+			goto out;
+	} else {
+		/* lock free root dinfo */
+		did_lock = 0;
+		bindex = 0;
+		inode = dentry->d_inode;
+		h_dentry = dget(au_di(dentry)->di_hdentry->hd_dentry);
+	}
+
+	err = -EIO;
+	if (h_dentry && h_dentry->d_inode)
+		err = vfsub_getattr(au_sbr_mnt(sb, bindex), h_dentry, st,
+				    au_test_dlgt(mnt_flags));
+	dput(h_dentry);
+	if (!err) {
+		/* todo: I don't like this approach */
+		au_cpup_attr_all(inode, /*force*/0);
+	fill:
+		generic_fillattr(inode, st);
+	}
+
+ out:
+	if (did_lock)
+		di_read_unlock(dentry, AuLock_IR);
+	si_read_unlock(sb);
+	AuTraceErr(err);
+	return err;
+}
diff -Nurp linux-2.6.27.orig/fs/aufs/hinode.h linux-2.6.27/fs/aufs/hinode.h
--- linux-2.6.27.orig/fs/aufs/hinode.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.27/fs/aufs/hinode.h	2008-10-06 02:30:02.000000000 +0200
@@ -0,0 +1,175 @@
+/*
+ * Copyright (C) 2005-2008 Junjiro Okajima
+ *
+ * This program, aufs is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+ */
+
+/*
+ * lower (branch filesystem) inode and setting inotify
+ *
+ * $Id: hinode.h,v 1.11 2008/10/06 00:30:02 sfjro Exp $
+ */
+
+#ifndef __AUFS_HINODE_H__
+#define __AUFS_HINODE_H__
+
+#ifdef __KERNEL__
+
+#include <linux/fs.h>
+#include <linux/inotify.h>
+#include <linux/aufs_type.h>
+#include "super.h"
+#include "vfsub.h"
+
+/* ---------------------------------------------------------------------- */
+
+struct au_hinotify {
+#ifdef CONFIG_AUFS_HINOTIFY
+	struct au_splhead	hin_ignore;
+	struct inotify_watch	hin_watch;
+	struct inode		*hin_aufs_inode;	/* no get/put */
+#endif
+};
+
+struct au_hinode {
+	struct inode		*hi_inode;
+	aufs_bindex_t		hi_id;
+#ifdef CONFIG_AUFS_HINOTIFY
+	struct au_hinotify	*hi_notify;
+#endif
+
+	/* reference to the copied-up whiteout with get/put */
+	struct dentry		*hi_whdentry;
+};
+
+struct au_hin_ignore {
+#ifdef CONFIG_AUFS_HINOTIFY
+	struct list_head	ign_list;
+
+	pid_t			ign_pid;
+	__u32			ign_events, ign_handled;
+	struct au_hinode	*ign_hinode;
+#endif
+};
+
+/* ---------------------------------------------------------------------- */
+
+#ifdef CONFIG_AUFS_HINOTIFY
+/* inotify events */
+static const __u32 AuInMask = (IN_MOVE | IN_DELETE | IN_CREATE
+			       /* | IN_ACCESS */
+			       | IN_MODIFY | IN_ATTRIB
+			       /* | IN_DELETE_SELF | IN_MOVE_SELF */
+	);
+
+static inline
+void au_hin_init(struct au_hinode *hinode, struct au_hinotify *val)
+{
+	hinode->hi_notify = val;
+}
+
+/* hinotify.c */
+int au_hin_alloc(struct au_hinode *hinode, struct inode *inode,
+		 struct inode *h_inode);
+void au_hin_free(struct au_hinode *hinode);
+void au_hin_ctl(struct au_hinode *hinode, const __u32 mask);
+void au_reset_hinotify(struct inode *inode, unsigned int flags);
+
+int au_hin_verify_gen(struct dentry *dentry);
+
+int __init au_inotify_init(void);
+void au_inotify_fin(void);
+
+static inline void au_hin_suspend(struct au_hinode *hinode)
+{
+	au_hin_ctl(hinode, 0);
+}
+
+static inline void au_hin_resume(struct au_hinode *hinode)
+{
+	au_hin_ctl(hinode, AuInMask);
+}
+
+#else
+
+static inline
+void au_hin_init(struct au_hinode *hinode, struct au_hinotify *val)
+{
+	/* empty */
+}
+
+static inline
+int au_hin_alloc(struct au_hinode *hinode, struct inode *inode,
+		 struct inode *h_inode)
+{
+	return -EOPNOTSUPP;
+}
+
+static inline void au_hin_free(struct au_hinode *hinode)
+{
+	/* nothing */
+}
+
+static inline void au_reset_hinotify(struct inode *inode, unsigned int flags)
+{
+	/* nothing */
+}
+
+static inline int au_hin_verify_gen(struct dentry *dentry)
+{
+	return 0;
+}
+
+static inline int au_inotify_init(void)
+{
+	return 0;
+}
+
+#define au_inotify_fin()	do {} while (0)
+
+static inline void au_hin_suspend(struct au_hinode *hinode)
+{
+	/* empty */
+}
+
+static inline void au_hin_resume(struct au_hinode *hinode)
+{
+	/* empty */
+}
+#endif /* CONFIG_AUFS_HINOTIFY */
+
+#if defined(CONFIG_AUFS_HINOTIFY) && defined(CONFIG_AUFS_DEBUG)
+static inline void au_hin_list_del(struct list_head *e)
+{
+	list_del_init(e);
+}
+
+void au_dbg_hin_list(struct vfsub_args *vargs);
+#else
+static inline void au_hin_list_del(struct list_head *e)
+{
+	list_del(e);
+}
+
+static inline void au_dbg_hin_list(struct vfsub_args *vargs)
+{
+	/* empty */
+}
+#endif /* CONFIG_AUFS_DEBUG */
+
+/* ---------------------------------------------------------------------- */
+
+#endif /* __KERNEL__ */
+#endif /* __AUFS_HINODE_H__ */
diff -Nurp linux-2.6.27.orig/fs/aufs/hin_or_dlgt.c linux-2.6.27/fs/aufs/hin_or_dlgt.c
--- linux-2.6.27.orig/fs/aufs/hin_or_dlgt.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.27/fs/aufs/hin_or_dlgt.c	2008-12-14 10:37:40.000000000 +0100
@@ -0,0 +1,736 @@
+/*
+ * Copyright (C) 2005-2008 Junjiro Okajima
+ *
+ * This program, aufs is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+ */
+
+/*
+ * sub-routines for vfs in hinotify or dlgt mode
+ *
+ * $Id: hin_or_dlgt.c,v 1.8 2008/12/01 03:49:29 sfjro Exp $
+ */
+
+#include <linux/uaccess.h>
+#include "aufs.h"
+
+#if !defined(CONFIG_AUFS_HINOTIFY) && !defined(CONFIG_AUFS_DLGT)
+#error mis-configuraion or Makefile
+#endif
+
+/* ---------------------------------------------------------------------- */
+
+struct permission_args {
+	int *errp;
+	struct inode *inode;
+	int mask;
+	struct nameidata *nd;
+};
+
+static void call_permission(void *args)
+{
+	struct permission_args *a = args;
+	*a->errp = do_vfsub_permission(a->inode, a->mask, a->nd);
+}
+
+int vfsub_permission(struct inode *inode, int mask, struct nameidata *nd,
+		     int dlgt)
+{
+	if (!dlgt)
+		return do_vfsub_permission(inode, mask, nd);
+	else {
+		int err, wkq_err;
+		struct permission_args args = {
+			.errp	= &err,
+			.inode	= inode,
+			.mask	= mask,
+			.nd	= nd
+		};
+		wkq_err = au_wkq_wait(call_permission, &args, /*dlgt*/1);
+		if (unlikely(wkq_err))
+			err = wkq_err;
+		return err;
+	}
+}
+
+/* ---------------------------------------------------------------------- */
+
+struct create_args {
+	int *errp;
+	struct inode *dir;
+	struct dentry *dentry;
+	int mode;
+	struct nameidata *nd;
+	struct vfsub_args *vargs;
+};
+
+static void call_create(void *args)
+{
+	struct create_args *a = args;
+	vfsub_ignore(a->vargs);
+	*a->errp = do_vfsub_create(a->dir, a->dentry, a->mode, a->nd);
+	if (unlikely(*a->errp))
+		vfsub_unignore(a->vargs);
+	au_dbg_hin_list(a->vargs);
+}
+
+int vfsub_create(struct inode *dir, struct dentry *dentry, int mode,
+		 struct nameidata *nd, struct vfsub_args *vargs)
+{
+	int err;
+	struct create_args args = {
+		.errp	= &err,
+		.dir	= dir,
+		.dentry	= dentry,
+		.mode	= mode,
+		.nd	= nd,
+		.vargs	= vargs
+	};
+
+	if (!vfsub_ftest(vargs->flags, DLGT))
+		call_create(&args);
+	else {
+		int wkq_err;
+		wkq_err = au_wkq_wait(call_create, &args, /*dlgt*/1);
+		if (unlikely(wkq_err))
+			err = wkq_err;
+	}
+	return err;
+}
+
+struct symlink_args {
+	int *errp;
+	struct inode *dir;
+	struct dentry *dentry;
+	const char *symname;
+	int mode;
+	struct vfsub_args *vargs;
+};
+
+static void call_symlink(void *args)
+{
+	struct symlink_args *a = args;
+	vfsub_ignore(a->vargs);
+	*a->errp = do_vfsub_symlink(a->dir, a->dentry, a->symname, a->mode);
+	if (unlikely(*a->errp))
+		vfsub_unignore(a->vargs);
+	au_dbg_hin_list(a->vargs);
+}
+
+int vfsub_symlink(struct inode *dir, struct dentry *dentry, const char *symname,
+		  int mode, struct vfsub_args *vargs)
+{
+	int err;
+	struct symlink_args args = {
+		.errp		= &err,
+		.dir		= dir,
+		.dentry		= dentry,
+		.symname	= symname,
+		.mode		= mode,
+		.vargs		= vargs
+	};
+
+	if (!vfsub_ftest(vargs->flags, DLGT))
+		call_symlink(&args);
+	else {
+		int wkq_err;
+		wkq_err = au_wkq_wait(call_symlink, &args, /*dlgt*/1);
+		if (unlikely(wkq_err))
+			err = wkq_err;
+	}
+	return err;
+}
+
+struct mknod_args {
+	int *errp;
+	struct inode *dir;
+	struct dentry *dentry;
+	int mode;
+	dev_t dev;
+	struct vfsub_args *vargs;
+};
+
+static void call_mknod(void *args)
+{
+	struct mknod_args *a = args;
+	vfsub_ignore(a->vargs);
+	*a->errp = do_vfsub_mknod(a->dir, a->dentry, a->mode, a->dev);
+	if (unlikely(*a->errp))
+		vfsub_unignore(a->vargs);
+	au_dbg_hin_list(a->vargs);
+}
+
+int vfsub_mknod(struct inode *dir, struct dentry *dentry, int mode, dev_t dev,
+		struct vfsub_args *vargs)
+{
+	int err;
+	struct mknod_args args = {
+		.errp	= &err,
+		.dir	= dir,
+		.dentry	= dentry,
+		.mode	= mode,
+		.dev	= dev,
+		.vargs	= vargs
+	};
+
+	if (!vfsub_ftest(vargs->flags, DLGT))
+		call_mknod(&args);
+	else {
+		int wkq_err;
+		wkq_err = au_wkq_wait(call_mknod, &args, /*dlgt*/1);
+		if (unlikely(wkq_err))
+			err = wkq_err;
+	}
+	return err;
+}
+
+struct mkdir_args {
+	int *errp;
+	struct inode *dir;
+	struct dentry *dentry;
+	int mode;
+	struct vfsub_args *vargs;
+};
+
+static void call_mkdir(void *args)
+{
+	struct mkdir_args *a = args;
+	vfsub_ignore(a->vargs);
+	*a->errp = do_vfsub_mkdir(a->dir, a->dentry, a->mode);
+	if (unlikely(*a->errp))
+		vfsub_unignore(a->vargs);
+	au_dbg_hin_list(a->vargs);
+}
+
+int vfsub_mkdir(struct inode *dir, struct dentry *dentry, int mode,
+		struct vfsub_args *vargs)
+{
+	int err;
+	struct mkdir_args args = {
+		.errp	= &err,
+		.dir	= dir,
+		.dentry	= dentry,
+		.mode	= mode,
+		.vargs	= vargs
+	};
+
+	if (!vfsub_ftest(vargs->flags, DLGT))
+		call_mkdir(&args);
+	else {
+		int wkq_err;
+		wkq_err = au_wkq_wait(call_mkdir, &args, /*dlgt*/1);
+		if (unlikely(wkq_err))
+			err = wkq_err;
+	}
+	return err;
+}
+
+/* ---------------------------------------------------------------------- */
+
+struct link_args {
+	int *errp;
+	struct inode *dir;
+	struct dentry *src_dentry, *dentry;
+	struct vfsub_args *vargs;
+};
+
+static void call_link(void *args)
+{
+	struct link_args *a = args;
+	vfsub_ignore(a->vargs);
+	*a->errp = do_vfsub_link(a->src_dentry, a->dir, a->dentry);
+	if (unlikely(*a->errp))
+		vfsub_unignore(a->vargs);
+	au_dbg_hin_list(a->vargs);
+}
+
+int vfsub_link(struct dentry *src_dentry, struct inode *dir,
+	       struct dentry *dentry, struct vfsub_args *vargs)
+{
+	int err;
+	struct link_args args = {
+		.errp		= &err,
+		.src_dentry	= src_dentry,
+		.dir		= dir,
+		.dentry		= dentry,
+		.vargs		= vargs
+	};
+
+	if (!vfsub_ftest(vargs->flags, DLGT))
+		call_link(&args);
+	else {
+		int wkq_err;
+		wkq_err = au_wkq_wait(call_link, &args, /*dlgt*/1);
+		if (unlikely(wkq_err))
+			err = wkq_err;
+	}
+	return err;
+}
+
+struct rename_args {
+	int *errp;
+	struct inode *src_dir, *dir;
+	struct dentry *src_dentry, *dentry;
+	struct vfsub_args *vargs;
+};
+
+static void call_rename(void *args)
+{
+	struct rename_args *a = args;
+	vfsub_ignore(a->vargs);
+	*a->errp = do_vfsub_rename(a->src_dir, a->src_dentry, a->dir,
+				   a->dentry);
+	if (unlikely(*a->errp))
+		vfsub_unignore(a->vargs);
+	au_dbg_hin_list(a->vargs);
+}
+
+int vfsub_rename(struct inode *src_dir, struct dentry *src_dentry,
+		 struct inode *dir, struct dentry *dentry,
+		 struct vfsub_args *vargs)
+{
+	int err;
+	struct rename_args args = {
+		.errp		= &err,
+		.src_dir	= src_dir,
+		.src_dentry	= src_dentry,
+		.dir		= dir,
+		.dentry		= dentry,
+		.vargs		= vargs
+	};
+
+	if (!vfsub_ftest(vargs->flags, DLGT))
+		call_rename(&args);
+	else {
+		int wkq_err;
+		wkq_err = au_wkq_wait(call_rename, &args, /*dlgt*/1);
+		if (unlikely(wkq_err))
+			err = wkq_err;
+	}
+	return err;
+}
+
+struct rmdir_args {
+	int *errp;
+	struct inode *dir;
+	struct dentry *dentry;
+	struct vfsub_args *vargs;
+};
+
+static void call_rmdir(void *args)
+{
+	struct rmdir_args *a = args;
+	vfsub_ignore(a->vargs);
+	*a->errp = do_vfsub_rmdir(a->dir, a->dentry);
+	if (unlikely(*a->errp))
+		vfsub_unignore(a->vargs);
+	au_dbg_hin_list(a->vargs);
+}
+
+int vfsub_rmdir(struct inode *dir, struct dentry *dentry,
+		struct vfsub_args *vargs)
+{
+	int err;
+	struct rmdir_args args = {
+		.errp	= &err,
+		.dir	= dir,
+		.dentry	= dentry,
+		.vargs	= vargs
+	};
+
+	if (!vfsub_ftest(vargs->flags, DLGT))
+		call_rmdir(&args);
+	else {
+		int wkq_err;
+		wkq_err = au_wkq_wait(call_rmdir, &args, /*dlgt*/1);
+		if (unlikely(wkq_err))
+			err = wkq_err;
+	}
+	return err;
+}
+
+/* ---------------------------------------------------------------------- */
+
+struct read_args {
+	ssize_t *errp;
+	struct file *file;
+	union {
+		void *kbuf;
+		char __user *ubuf;
+	};
+	size_t count;
+	loff_t *ppos;
+};
+
+static void call_read_k(void *args)
+{
+	struct read_args *a = args;
+	LKTRTrace("%.*s, cnt %zu, pos %lld\n",
+		  AuDLNPair(a->file->f_dentry), a->count, *a->ppos);
+	*a->errp = do_vfsub_read_k(a->file, a->kbuf, a->count, a->ppos);
+}
+
+ssize_t vfsub_read_u(struct file *file, char __user *ubuf, size_t count,
+		     loff_t *ppos, int dlgt)
+{
+	if (!dlgt)
+		return do_vfsub_read_u(file, ubuf, count, ppos);
+	else {
+		int wkq_err;
+		ssize_t err, read;
+		struct read_args args = {
+			.errp	= &err,
+			.file	= file,
+			.count	= count,
+			.ppos	= ppos
+		};
+
+		if (!count)
+			return 0;
+
+		/*
+		 * workaround an application bug.
+		 * generally, read(2) or write(2) may return the value shorter
+		 * than requested. But many applications don't support it,
+		 * for example bash.
+		 */
+		err = -ENOMEM;
+		if (args.count > PAGE_SIZE)
+			args.count = PAGE_SIZE;
+		args.kbuf = kmalloc(args.count, GFP_NOFS);
+		if (unlikely(!args.kbuf))
+			goto out;
+
+		read = 0;
+		do {
+			wkq_err = au_wkq_wait(call_read_k, &args, /*dlgt*/1);
+			if (unlikely(wkq_err))
+				err = wkq_err;
+			if (unlikely(err > 0
+				     && copy_to_user(ubuf, args.kbuf, err))) {
+				err = -EFAULT;
+				goto out_free;
+			} else if (!err)
+				break;
+			else if (unlikely(err < 0))
+				goto out_free;
+			count -= err;
+			/* do not read too much because of file i/o pointer */
+			if (count < args.count)
+				args.count = count;
+			ubuf += err;
+			read += err;
+		} while (count);
+		smp_mb(); /* flush ubuf */
+		err = read;
+
+	out_free:
+		kfree(args.kbuf);
+	out:
+		return err;
+	}
+}
+
+ssize_t vfsub_read_k(struct file *file, void *kbuf, size_t count, loff_t *ppos,
+		     int dlgt)
+{
+	if (!dlgt)
+		return do_vfsub_read_k(file, kbuf, count, ppos);
+	else {
+		ssize_t err;
+		int wkq_err;
+		struct read_args args = {
+			.errp	= &err,
+			.file	= file,
+			.count	= count,
+			.ppos	= ppos
+		};
+		args.kbuf = kbuf;
+		wkq_err = au_wkq_wait(call_read_k, &args, /*dlgt*/1);
+		if (unlikely(wkq_err))
+			err = wkq_err;
+		return err;
+	}
+}
+
+struct write_args {
+	ssize_t *errp;
+	struct file *file;
+	union {
+		void *kbuf;
+		const char __user *ubuf;
+	};
+	size_t count;
+	loff_t *ppos;
+	struct vfsub_args *vargs;
+};
+
+static void call_write_k(void *args)
+{
+	struct write_args *a = args;
+	vfsub_ignore(a->vargs);
+	*a->errp = do_vfsub_write_k(a->file, a->kbuf, a->count, a->ppos);
+	if (unlikely(*a->errp <= 0))
+		vfsub_unignore(a->vargs);
+	au_dbg_hin_list(a->vargs);
+}
+
+ssize_t vfsub_write_u(struct file *file, const char __user *ubuf, size_t count,
+		      loff_t *ppos, struct vfsub_args *vargs)
+{
+	ssize_t err;
+
+	if (!vfsub_ftest(vargs->flags, DLGT)) {
+		vfsub_ignore(vargs);
+		err = do_vfsub_write_u(file, ubuf, count, ppos);
+		if (unlikely(err <= 0))
+			vfsub_unignore(vargs);
+		au_dbg_hin_list(vargs);
+	} else {
+		ssize_t written;
+		int wkq_err;
+		struct write_args args = {
+			.errp	= &err,
+			.file	= file,
+			.count	= count,
+			.ppos	= ppos,
+			.vargs	= vargs
+		};
+
+		if (!count)
+			return 0;
+
+		/*
+		 * workaround an application bug.
+		 * generally, read(2) or write(2) may return the value shorter
+		 * than requested. But many applications don't support it,
+		 * for example bash.
+		 */
+		err = -ENOMEM;
+		if (args.count > PAGE_SIZE)
+			args.count = PAGE_SIZE;
+		args.kbuf = kmalloc(args.count, GFP_NOFS);
+		if (unlikely(!args.kbuf))
+			goto out;
+
+		written = 0;
+		do {
+			if (unlikely(copy_from_user(args.kbuf, ubuf,
+						    args.count))) {
+				err = -EFAULT;
+				goto out_free;
+			}
+
+			wkq_err = au_wkq_wait(call_write_k, &args, /*dlgt*/1);
+			if (unlikely(wkq_err))
+				err = wkq_err;
+			if (err > 0) {
+				count -= err;
+				if (count < args.count)
+					args.count = count;
+				ubuf += err;
+				written += err;
+			} else if (!err)
+				break;
+			else if (unlikely(err < 0))
+				goto out_free;
+		} while (count);
+		err = written;
+
+	out_free:
+		kfree(args.kbuf);
+	}
+ out:
+	return err;
+}
+
+ssize_t vfsub_write_k(struct file *file, void *kbuf, size_t count, loff_t *ppos,
+		      struct vfsub_args *vargs)
+{
+	ssize_t err;
+	struct write_args args = {
+		.errp	= &err,
+		.file	= file,
+		.count	= count,
+		.ppos	= ppos,
+		.vargs	= vargs
+	};
+
+	args.kbuf = kbuf;
+	if (!vfsub_ftest(vargs->flags, DLGT))
+		call_write_k(&args);
+	else {
+		int wkq_err;
+		wkq_err = au_wkq_wait(call_write_k, &args, /*dlgt*/1);
+		if (unlikely(wkq_err))
+			err = wkq_err;
+	}
+	return err;
+}
+
+struct readdir_args {
+	int *errp;
+	struct file *file;
+	filldir_t filldir;
+	void *arg;
+};
+
+static void call_readdir(void *args)
+{
+	struct readdir_args *a = args;
+	*a->errp = do_vfsub_readdir(a->file, a->filldir, a->arg);
+}
+
+int vfsub_readdir(struct file *file, filldir_t filldir, void *arg, int dlgt)
+{
+	if (!dlgt)
+		return do_vfsub_readdir(file, filldir, arg);
+	else {
+		int err, wkq_err;
+		struct readdir_args args = {
+			.errp		= &err,
+			.file		= file,
+			.filldir	= filldir,
+			.arg		= arg
+		};
+		wkq_err = au_wkq_wait(call_readdir, &args, /*dlgt*/1);
+		if (unlikely(wkq_err))
+			err = wkq_err;
+		return err;
+	}
+}
+
+/* ---------------------------------------------------------------------- */
+
+struct splice_to_args {
+	long *errp;
+	struct file *in;
+	loff_t *ppos;
+	struct pipe_inode_info *pipe;
+	size_t len;
+	unsigned int flags;
+};
+
+static void call_splice_to(void *args)
+{
+	struct splice_to_args *a = args;
+	*a->errp = do_vfsub_splice_to(a->in, a->ppos, a->pipe, a->len,
+				      a->flags);
+}
+
+long vfsub_splice_to(struct file *in, loff_t *ppos,
+		     struct pipe_inode_info *pipe, size_t len,
+		     unsigned int flags, int dlgt)
+{
+	if (!dlgt)
+		return do_vfsub_splice_to(in, ppos, pipe, len, flags);
+	else {
+		long err;
+		int wkq_err;
+		struct splice_to_args args = {
+			.errp	= &err,
+			.in	= in,
+			.ppos	= ppos,
+			.pipe	= pipe,
+			.len	= len,
+			.flags	= flags
+		};
+		wkq_err = au_wkq_wait(call_splice_to, &args, /*dlgt*/1);
+		if (unlikely(wkq_err))
+			err = wkq_err;
+		return err;
+	}
+}
+
+struct splice_from_args {
+	long *errp;
+	struct pipe_inode_info *pipe;
+	struct file *out;
+	loff_t *ppos;
+	size_t len;
+	unsigned int flags;
+	struct vfsub_args *vargs;
+};
+
+static void call_splice_from(void *args)
+{
+	struct splice_from_args *a = args;
+	vfsub_ignore(a->vargs);
+	*a->errp = do_vfsub_splice_from(a->pipe, a->out, a->ppos, a->len,
+					a->flags);
+	if (unlikely(*a->errp < 0))
+		vfsub_unignore(a->vargs);
+	au_dbg_hin_list(a->vargs);
+}
+
+long vfsub_splice_from(struct pipe_inode_info *pipe, struct file *out,
+		       loff_t *ppos, size_t len, unsigned int flags,
+		       struct vfsub_args *vargs)
+{
+	long err;
+	struct splice_from_args args = {
+		.errp	= &err,
+		.pipe	= pipe,
+		.out	= out,
+		.ppos	= ppos,
+		.len	= len,
+		.flags	= flags,
+		.vargs	= vargs
+	};
+
+	if (!vfsub_ftest(vargs->flags, DLGT))
+		call_splice_from(&args);
+	else {
+		int wkq_err;
+		wkq_err = au_wkq_wait(call_splice_from, &args, /*dlgt*/1);
+		if (unlikely(wkq_err))
+			err = wkq_err;
+	}
+	return err;
+}
+
+/* ---------------------------------------------------------------------- */
+
+struct getattr_args {
+	int *errp;
+	struct vfsmount *mnt;
+	struct dentry *dentry;
+	struct kstat *st;
+};
+
+static void call_getattr(void *args)
+{
+	struct getattr_args *a = args;
+	*a->errp = do_vfsub_getattr(a->mnt, a->dentry, a->st);
+}
+
+int vfsub_getattr(struct vfsmount *mnt, struct dentry *dentry, struct kstat *st,
+		  int dlgt)
+{
+	if (!dlgt)
+		return do_vfsub_getattr(mnt, dentry, st);
+	else {
+		int err, wkq_err;
+		struct getattr_args args = {
+			.errp	= &err,
+			.mnt	= mnt,
+			.dentry	= dentry,
+			.st	= st
+		};
+		wkq_err = au_wkq_wait(call_getattr, &args, /*dlgt*/1);
+		if (unlikely(wkq_err))
+			err = wkq_err;
+		return err;
+	}
+}
diff -Nurp linux-2.6.27.orig/fs/aufs/hinotify.c linux-2.6.27/fs/aufs/hinotify.c
--- linux-2.6.27.orig/fs/aufs/hinotify.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.27/fs/aufs/hinotify.c	2008-12-14 10:37:40.000000000 +0100
@@ -0,0 +1,1146 @@
+/*
+ * Copyright (C) 2005-2008 Junjiro Okajima
+ *
+ * This program, aufs is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+ */
+
+/*
+ * internal/hidden inotify handler
+ *
+ * $Id: hinotify.c,v 1.22 2008/12/08 06:11:59 sfjro Exp $
+ */
+
+#include "aufs.h"
+
+/*
+#ifdef DbgInotify
+#define AuDbgHin(args...)	AuDbg(##args)
+#else
+#define AuDbgHin(args...)	do {} while ()
+#endif
+*/
+
+static struct inotify_handle *in_handle;
+
+AuCacheFuncs(hinotify, AuCache_HINOTIFY);
+
+int au_hin_alloc(struct au_hinode *hinode, struct inode *inode,
+		 struct inode *h_inode)
+{
+	int err;
+	struct au_hinotify *hin;
+	s32 wd;
+
+	LKTRTrace("i%lu, hi%lu\n", inode->i_ino, h_inode->i_ino);
+
+	err = -ENOMEM;
+	hin = au_cache_alloc_hinotify();
+	if (hin) {
+		AuDebugOn(hinode->hi_notify);
+		hinode->hi_notify = hin;
+		au_spl_init(&hin->hin_ignore);
+		hin->hin_aufs_inode = inode;
+
+		inotify_init_watch(&hin->hin_watch);
+		wd = inotify_add_watch(in_handle, &hin->hin_watch, h_inode,
+				       AuInMask);
+		if (wd >= 0)
+			return 0; /* success */
+
+		err = wd;
+		put_inotify_watch(&hin->hin_watch);
+		au_cache_free_hinotify(hin);
+		hinode->hi_notify = NULL;
+	}
+
+	AuTraceErr(err);
+	return err;
+}
+
+void au_hin_free(struct au_hinode *hinode)
+{
+	int err;
+	struct au_hinotify *hin;
+
+	AuTraceEnter();
+
+	hin = hinode->hi_notify;
+	if (hin) {
+		err = 0;
+		if (atomic_read(&hin->hin_watch.count))
+			err = inotify_rm_watch(in_handle, &hin->hin_watch);
+		if (unlikely(err))
+			/* it means the watch is already removed */
+			LKTRTrace("failed inotify_rm_watch() %d\n", err);
+		au_cache_free_hinotify(hin);
+		hinode->hi_notify = NULL;
+	}
+}
+
+/* ---------------------------------------------------------------------- */
+
+void au_hin_ctl(struct au_hinode *hinode, const __u32 mask)
+{
+	struct inode *h_inode;
+	struct inotify_watch *watch;
+
+	h_inode = hinode->hi_inode;
+	LKTRTrace("hi%lu, sb %p, 0x%x\n", h_inode->i_ino, h_inode->i_sb, mask);
+	IMustLock(h_inode);
+	if (!hinode->hi_notify)
+		return;
+
+	watch = &hinode->hi_notify->hin_watch;
+#if 0 /* reserved for future use */
+	{
+		u32 wd;
+		wd = inotify_find_update_watch(in_handle, h_inode, mask);
+		AuTraceErr(wd);
+		/* ignore an err; */
+	}
+#else
+	/* struct inotify_handle is hidden */
+	mutex_lock(&h_inode->inotify_mutex);
+	/* mutex_lock(&watch->ih->mutex); */
+	watch->mask = mask;
+	/* mutex_unlock(&watch->ih->mutex); */
+	mutex_unlock(&h_inode->inotify_mutex);
+#endif
+	LKTRTrace("watch %p, mask %u\n", watch, watch->mask);
+}
+
+void au_reset_hinotify(struct inode *inode, unsigned int flags)
+{
+	aufs_bindex_t bindex, bend;
+	struct inode *hi;
+	struct dentry *iwhdentry;
+
+	LKTRTrace("i%lu, 0x%x\n", inode->i_ino, flags);
+
+	bend = au_ibend(inode);
+	for (bindex = au_ibstart(inode); bindex <= bend; bindex++) {
+		hi = au_h_iptr(inode, bindex);
+		if (hi) {
+			/* mutex_lock_nested(&hi->i_mutex, AuLsc_I_CHILD); */
+			iwhdentry = au_hi_wh(inode, bindex);
+			if (iwhdentry)
+				dget(iwhdentry);
+			au_igrab(hi);
+			au_set_h_iptr(inode, bindex, NULL, 0);
+			au_set_h_iptr(inode, bindex, au_igrab(hi),
+				      flags & ~AuHi_XINO);
+			iput(hi);
+			dput(iwhdentry);
+			/* mutex_unlock(&hi->i_mutex); */
+		}
+	}
+}
+
+/* ---------------------------------------------------------------------- */
+
+void au_unpin_gp(struct au_pin *args)
+{
+	struct au_pin1 *gp;
+
+	gp = au_pin_gp(args);
+	AuDebugOn(!gp);
+	if (gp->dentry)
+		LKTRTrace("%.*s\n", AuDLNPair(gp->dentry));
+	else
+		AuTraceEnter();
+
+	au_do_unpin(gp, NULL);
+}
+
+int au_hin_verify_gen(struct dentry *dentry)
+{
+	struct super_block *sb = dentry->d_sb;
+	au_gen_t sigen;
+	struct inode *inode;
+
+	if (!au_opt_test(au_mntflags(sb), UDBA_INOTIFY))
+		return 0;
+
+	sigen = au_sigen(dentry->d_sb);
+	inode = dentry->d_inode;
+	return au_digen(dentry) != sigen
+		|| (inode && au_iigen(inode) != sigen);
+}
+
+/* ---------------------------------------------------------------------- */
+
+/* cf. fsnotify_change() */
+__u32 vfsub_events_notify_change(struct iattr *ia)
+{
+	__u32 events;
+	const unsigned int amtime = (ATTR_ATIME | ATTR_MTIME);
+
+	events = 0;
+	if ((ia->ia_valid & (ATTR_UID | ATTR_GID | ATTR_MODE))
+	    || (ia->ia_valid & amtime) == amtime)
+		events |= IN_ATTRIB;
+	if ((ia->ia_valid & ATTR_SIZE)
+	    || (ia->ia_valid & amtime) == ATTR_MTIME)
+		events |= IN_MODIFY;
+	return events;
+}
+
+void vfsub_ign_hinode(struct vfsub_args *vargs, __u32 events,
+		      struct au_hinode *hinode)
+{
+	struct au_hinotify *hin;
+	struct super_block *sb;
+	struct au_hin_ignore *ign;
+
+	if (!hinode)
+		return;
+
+	hin = hinode->hi_notify;
+	if (!hin || !hin->hin_watch.mask)
+		return;
+
+	sb = hin->hin_aufs_inode->i_sb;
+	AuDebugOn(!au_opt_test(au_mntflags(sb), UDBA_INOTIFY));
+
+	ign = vargs->ignore + vargs->nignore++;
+	ign->ign_events = events;
+	ign->ign_handled = 0;
+	ign->ign_hinode = hinode;
+
+	{
+		struct inode *h_inode;
+		h_inode = hinode->hi_inode;
+		if (!mutex_is_locked(&h_inode->i_mutex))
+			au_dbg_blocked();
+		IMustLock(h_inode);
+	}
+}
+
+static void au_hin_ignore(struct au_hin_ignore *ign)
+{
+	struct au_hinode *hinode;
+	__u32 events;
+	struct au_hinotify *hin;
+	struct inode *h_inode;
+
+	hinode = ign->ign_hinode;
+	events = ign->ign_events;
+	LKTRTrace("0x%x\n", events);
+	AuDebugOn(!hinode || !events);
+
+	hin = hinode->hi_notify;
+	h_inode = hinode->hi_inode;
+	if (h_inode && hin) {
+		LKTRTrace("hi%lu\n", h_inode->i_ino);
+#ifdef DbgInotify
+		AuDbg("hi%lu, 0x%x\n", h_inode->i_ino, events);
+#endif
+
+		au_spl_add(&ign->ign_list, &hin->hin_ignore);
+		/* AuDbg("list_add %p, 0x%x\n", ign, events); */
+	}
+#if 1 /* todo: test dlgt */
+	else
+		/*
+		 * it may happen by this scenario.
+		 * - a file and its parent dir exist on two branches
+		 * - a file on the upper branch is opened
+		 * - the parent dir and the file are removed by udba
+		 * - the parent is re-accessed, and new dentry/inode in
+		 *   aufs is generated for it, based upon the one on the lower
+		 *   branch
+		 * - the opened file is re-accessed, re-validated, and it may be
+		 *   re-connected to the new parent dentry
+		 * it means the file in aufs cannot get the actual removed
+		 * parent dir on the branch.
+		 */
+		INIT_LIST_HEAD(&ign->ign_list);
+#endif
+}
+
+static void au_hin_unignore(struct au_hin_ignore *ign)
+{
+	struct au_hinode *hinode;
+	__u32 events;
+	struct au_hinotify *hin;
+	struct inode *h_inode;
+
+	hinode = ign->ign_hinode;
+	events = ign->ign_events;
+	LKTRTrace("0x%x\n", events);
+	/* AuDbg("0x%x\n", events); */
+	AuDebugOn(!hinode || !events);
+
+	hin = hinode->hi_notify;
+	h_inode = hinode->hi_inode;
+	if (!h_inode || !hin)
+		return;
+	LKTRTrace("hi%lu\n", h_inode->i_ino);
+#ifdef DbgInotify
+	AuDbg("hi%lu, 0x%x\n", h_inode->i_ino, events);
+#endif
+
+	spin_lock(&hin->hin_ignore.spin);
+	au_hin_list_del(&ign->ign_list);
+	spin_unlock(&hin->hin_ignore.spin);
+	/* AuDbg("list_del %p, 0x%x\n", ign, events); */
+}
+
+static int au_hin_test_ignore(u32 mask, struct au_hinotify *hin)
+{
+	int do_ignore;
+	u32 events;
+	struct au_hin_ignore *ign, *tmp;
+	struct list_head *head;
+
+	do_ignore = 0;
+	head = &hin->hin_ignore.head;
+	spin_lock(&hin->hin_ignore.spin);
+	list_for_each_entry_safe(ign, tmp, head, ign_list) {
+		/* AuDbg("ign %p\n", ign); */
+		if (ign->ign_pid == current->pid) {
+			events = (mask & ign->ign_events);
+			if (events) {
+				do_ignore = 1;
+				ign->ign_handled |= events;
+				if (ign->ign_events == ign->ign_handled) {
+					list_del_init(&ign->ign_list);
+					/*
+					AuDbg("list_del %p, 0x%x\n",
+					      ign, events);
+					*/
+				}
+				break;
+			}
+		}
+	}
+	spin_unlock(&hin->hin_ignore.spin);
+
+	return do_ignore;
+}
+
+void vfsub_ignore(struct vfsub_args *vargs)
+{
+	int n;
+	struct au_hin_ignore *ign;
+	struct super_block *sb;
+	struct au_hinode *hinode;
+	struct inode *h_inode;
+
+	n = vargs->nignore;
+	if (!n)
+		return;
+
+	ign = vargs->ignore;
+	hinode = ign->ign_hinode;
+	sb = hinode->hi_notify->hin_aufs_inode->i_sb;
+	h_inode = hinode->hi_inode;
+	if (au_opt_test(au_mntflags(sb), UDBA_INOTIFY)) {
+		if (!mutex_is_locked(&h_inode->i_mutex))
+			au_dbg_blocked();
+		IMustLock(h_inode);
+	}
+	while (n-- > 0) {
+		ign->ign_pid = current->pid;
+		au_hin_ignore(ign++);
+	}
+}
+
+void vfsub_unignore(struct vfsub_args *vargs)
+{
+	int n;
+	struct au_hin_ignore *ign;
+
+	n = vargs->nignore;
+	if (!n)
+		return;
+
+	ign = vargs->ignore;
+	while (n-- > 0)
+		au_hin_unignore(ign++);
+}
+
+#ifdef CONFIG_AUFS_DEBUG
+void au_dbg_hin_list(struct vfsub_args *vargs)
+{
+	int n;
+	struct au_hin_ignore *ign;
+
+	n = vargs->nignore;
+	if (!n)
+		return;
+
+	ign = vargs->ignore;
+	while (n-- > 0) {
+		/* AuDebugOn(!list_empty(&ign++->ign_list)); */
+		if (list_empty(&ign++->ign_list))
+			continue;
+		ign--;
+		AuDbg("%d: pid %d, 0x%x\n",
+		      n + 1, ign->ign_pid, ign->ign_events);
+		au_hin_unignore(ign);
+		ign++;
+		au_dbg_blocked();
+	}
+}
+#endif
+
+/* ---------------------------------------------------------------------- */
+
+static char *in_name(u32 mask)
+{
+#ifdef CONFIG_AUFS_DEBUG
+#define test_ret(flag)	if (mask & flag) \
+				return #flag;
+	test_ret(IN_ACCESS);
+	test_ret(IN_MODIFY);
+	test_ret(IN_ATTRIB);
+	test_ret(IN_CLOSE_WRITE);
+	test_ret(IN_CLOSE_NOWRITE);
+	test_ret(IN_OPEN);
+	test_ret(IN_MOVED_FROM);
+	test_ret(IN_MOVED_TO);
+	test_ret(IN_CREATE);
+	test_ret(IN_DELETE);
+	test_ret(IN_DELETE_SELF);
+	test_ret(IN_MOVE_SELF);
+	test_ret(IN_UNMOUNT);
+	test_ret(IN_Q_OVERFLOW);
+	test_ret(IN_IGNORED);
+	return "";
+#undef test_ret
+#else
+	return "??";
+#endif
+}
+
+/* ---------------------------------------------------------------------- */
+
+static struct dentry *lookup_wlock_by_name(char *name, unsigned int nlen,
+					   struct inode *dir)
+{
+	struct dentry *dentry, *d, *parent;
+	struct qstr *dname;
+
+	LKTRTrace("%.*s, dir%lu\n", nlen, name, dir->i_ino);
+
+	parent = d_find_alias(dir);
+	if (!parent)
+		return NULL;
+
+	dentry = NULL;
+	spin_lock(&dcache_lock);
+	list_for_each_entry(d, &parent->d_subdirs, d_u.d_child) {
+		LKTRTrace("%.*s\n", AuDLNPair(d));
+		dname = &d->d_name;
+		if (dname->len != nlen || memcmp(dname->name, name, nlen))
+			continue;
+		if (!atomic_read(&d->d_count) || !d->d_fsdata) {
+			spin_lock(&d->d_lock);
+			__d_drop(d);
+			spin_unlock(&d->d_lock);
+			continue;
+		}
+
+		dentry = dget(d);
+		break;
+	}
+	spin_unlock(&dcache_lock);
+	dput(parent);
+
+	if (dentry) {
+#if 0
+	lktr_set_pid(current->pid, LktrArrayPid);
+	AuDbgDentry(dentry);
+	lktr_clear_pid(current->pid, LktrArrayPid);
+#endif
+		di_write_lock_child(dentry);
+	}
+	return dentry;
+}
+
+static struct inode *lookup_wlock_by_ino(struct super_block *sb,
+					 aufs_bindex_t bindex, ino_t h_ino)
+{
+	struct inode *inode;
+	struct au_xino_entry xinoe;
+	int err;
+
+	LKTRTrace("b%d, hi%lu\n", bindex, (unsigned long)h_ino);
+	AuDebugOn(!au_opt_test_xino(au_mntflags(sb)));
+
+	inode = NULL;
+	err = au_xino_read(sb, bindex, h_ino, &xinoe);
+	if (!err && xinoe.ino)
+		inode = ilookup(sb, xinoe.ino);
+	if (!inode)
+		goto out;
+	if (unlikely(inode->i_ino == AUFS_ROOT_INO)) {
+		AuWarn("wrong root branch\n");
+		iput(inode);
+		inode = NULL;
+		goto out;
+	}
+
+	ii_write_lock_child(inode);
+
+ out:
+	return inode;
+}
+
+static int hin_xino(struct inode *inode, struct inode *h_inode)
+{
+	int err;
+	aufs_bindex_t bindex, bend, bfound, bstart;
+	struct inode *h_i;
+
+	LKTRTrace("i%lu, hi%lu\n", inode->i_ino, h_inode->i_ino);
+
+	err = 0;
+	if (unlikely(inode->i_ino == AUFS_ROOT_INO)) {
+		AuWarn("branch root dir was changed\n");
+		goto out;
+	}
+
+	bfound = -1;
+	bend = au_ibend(inode);
+	bstart = au_ibstart(inode);
+#if 0 /* reserved for future use */
+	if (bindex == bend) {
+		/* keep this ino in rename case */
+		goto out;
+	}
+#endif
+	for (bindex = bstart; bindex <= bend; bindex++) {
+		if (au_h_iptr(inode, bindex) == h_inode) {
+			bfound = bindex;
+			break;
+		}
+	}
+	if (bfound < 0)
+		goto out;
+
+	for (bindex = bstart; bindex <= bend; bindex++) {
+		h_i = au_h_iptr(inode, bindex);
+		if (h_i)
+			err = au_xino_write0(inode->i_sb, bindex, h_i->i_ino,
+					     0);
+		/* ignore this error */
+		/* bad action? */
+	}
+
+	/* children inode number will be broken */
+
+ out:
+	AuTraceErr(err);
+	return err;
+}
+
+static int hin_gen_tree(struct dentry *dentry)
+{
+	int err, i, j, ndentry;
+	struct au_dcsub_pages dpages;
+	struct au_dpage *dpage;
+	struct dentry **dentries;
+
+	LKTRTrace("%.*s\n", AuDLNPair(dentry));
+
+	err = au_dpages_init(&dpages, GFP_NOFS);
+	if (unlikely(err))
+		goto out;
+	err = au_dcsub_pages(&dpages, dentry, NULL, NULL);
+	if (unlikely(err))
+		goto out_dpages;
+
+	for (i = 0; i < dpages.ndpage; i++) {
+		dpage = dpages.dpages + i;
+		dentries = dpage->dentries;
+		ndentry = dpage->ndentry;
+		for (j = 0; j < ndentry; j++) {
+			struct dentry *d;
+			d = dentries[j];
+			LKTRTrace("%.*s\n", AuDLNPair(d));
+			if (IS_ROOT(d))
+				continue;
+
+			d_drop(d);
+			au_digen_dec(d);
+			if (d->d_inode)
+				/* todo: reset children xino?
+				   cached children only? */
+				au_iigen_dec(d->d_inode);
+		}
+	}
+
+ out_dpages:
+	au_dpages_free(&dpages);
+
+	/* discard children */
+	dentry_unhash(dentry);
+	dput(dentry);
+ out:
+	AuTraceErr(err);
+	return err;
+}
+
+/*
+ * return 0 if processed.
+ */
+static int hin_gen_by_inode(char *name, unsigned int nlen, struct inode *inode,
+			    const unsigned int isdir)
+{
+	int err;
+	struct dentry *d;
+	struct qstr *dname;
+
+	LKTRTrace("%.*s, i%lu\n", nlen, name, inode->i_ino);
+
+	err = 1;
+	if (unlikely(inode->i_ino == AUFS_ROOT_INO)) {
+		AuWarn("branch root dir was changed\n");
+		err = 0;
+		goto out;
+	}
+
+	if (!isdir) {
+		AuDebugOn(!name);
+		au_iigen_dec(inode);
+		spin_lock(&dcache_lock);
+		list_for_each_entry(d, &inode->i_dentry, d_alias) {
+			dname = &d->d_name;
+			if (dname->len != nlen
+			    && memcmp(dname->name, name, nlen))
+				continue;
+			err = 0;
+			spin_lock(&d->d_lock);
+			__d_drop(d);
+			au_digen_dec(d);
+			spin_unlock(&d->d_lock);
+			break;
+		}
+		spin_unlock(&dcache_lock);
+	} else {
+		au_fset_si(au_sbi(inode->i_sb), FAILED_REFRESH_DIRS);
+		d = d_find_alias(inode);
+		if (!d) {
+			au_iigen_dec(inode);
+			goto out;
+		}
+
+		dname = &d->d_name;
+		if (dname->len == nlen && !memcmp(dname->name, name, nlen))
+			err = hin_gen_tree(d);
+		dput(d);
+	}
+
+ out:
+	AuTraceErr(err);
+	return err;
+}
+
+static int hin_gen_by_name(struct dentry *dentry, const unsigned int isdir)
+{
+	int err;
+	struct inode *inode;
+
+	LKTRTrace("%.*s\n", AuDLNPair(dentry));
+
+	inode = dentry->d_inode;
+	if (IS_ROOT(dentry)
+	    /* || (inode && inode->i_ino == AUFS_ROOT_INO) */
+		) {
+		AuWarn("branch root dir was changed\n");
+		return 0;
+	}
+
+	err = 0;
+	if (!isdir) {
+		d_drop(dentry);
+		au_digen_dec(dentry);
+		if (inode)
+			au_iigen_dec(inode);
+	} else {
+		au_fset_si(au_sbi(dentry->d_sb), FAILED_REFRESH_DIRS);
+		if (inode)
+			err = hin_gen_tree(dentry);
+	}
+
+	AuTraceErr(err);
+	return err;
+}
+
+static void hin_attr(struct inode *inode, struct inode *h_inode)
+{
+	struct dentry *h_dentry;
+
+	LKTRTrace("i%lu, hi%lu\n", inode->i_ino, h_inode->i_ino);
+
+	if (au_h_iptr(inode, au_ibstart(inode)) != h_inode)
+		return;
+
+	h_dentry = d_find_alias(h_inode);
+	if (h_dentry) {
+		au_update_fuse_h_inode(NULL, h_dentry);
+		/* ignore an error*/
+		dput(h_dentry);
+	}
+
+	au_cpup_attr_all(inode, /*force*/1);
+}
+
+/* ---------------------------------------------------------------------- */
+
+/* hinotify job flags */
+#define AuHinJob_XINO0	1
+#define AuHinJob_GEN	(1 << 1)
+#define AuHinJob_DIRENT	(1 << 2)
+#define AuHinJob_ATTR	(1 << 3)
+#define AuHinJob_ISDIR	(1 << 4)
+#define AuHinJob_TRYXINO0 (1 << 5)
+#define AuHinJob_MNTPNT	(1 << 6)
+#define au_ftest_hinjob(flags, name)	((flags) & AuHinJob_##name)
+#define au_fset_hinjob(flags, name)	{ (flags) |= AuHinJob_##name; }
+#define au_fclr_hinjob(flags, name)	{ (flags) &= ~AuHinJob_##name; }
+
+struct hin_job_args {
+	unsigned int flags;
+	struct inode *inode, *h_inode, *dir, *h_dir;
+	struct dentry *dentry;
+	char *h_name;
+	int h_nlen;
+};
+
+static int hin_job(struct hin_job_args *a)
+{
+	const unsigned int isdir = au_ftest_hinjob(a->flags, ISDIR);
+
+	/* reset xino */
+	if (au_ftest_hinjob(a->flags, XINO0) && a->inode)
+		hin_xino(a->inode, a->h_inode);
+	/* ignore this error */
+
+	if (au_ftest_hinjob(a->flags, TRYXINO0)
+	    && a->inode
+	    && a->h_inode) {
+		mutex_lock_nested(&a->h_inode->i_mutex, AuLsc_I_CHILD);
+		if (!a->h_inode->i_nlink)
+			hin_xino(a->inode, a->h_inode);
+		/* ignore this error */
+		mutex_unlock(&a->h_inode->i_mutex);
+	}
+
+	/* make the generation obsolete */
+	if (au_ftest_hinjob(a->flags, GEN)) {
+		int err = -1;
+		if (a->inode)
+			err = hin_gen_by_inode(a->h_name, a->h_nlen, a->inode,
+					       isdir);
+		if (err && a->dentry)
+			hin_gen_by_name(a->dentry, isdir);
+		/* ignore this error */
+	}
+
+	/* make dir entries obsolete */
+	if (au_ftest_hinjob(a->flags, DIRENT) && a->inode) {
+		struct au_vdir *vdir;
+		IiMustWriteLock(a->inode);
+		vdir = au_ivdir(a->inode);
+		if (vdir)
+			vdir->vd_jiffy = 0;
+		/* IMustLock(a->inode); */
+		/* a->inode->i_version++; */
+	}
+
+	/* update the attr */
+	if (au_ftest_hinjob(a->flags, ATTR) && a->inode && a->h_inode) {
+		mutex_lock_nested(&a->h_inode->i_mutex, AuLsc_I_CHILD);
+		hin_attr(a->inode, a->h_inode);
+		mutex_unlock(&a->h_inode->i_mutex);
+	}
+
+	/* can do nothing but warn */
+	if (au_ftest_hinjob(a->flags, MNTPNT)
+	    && a->dentry
+	    && d_mountpoint(a->dentry))
+		AuWarn("mount-point %.*s is removed or renamed\n",
+		       AuDLNPair(a->dentry));
+
+	return 0;
+}
+
+/* ---------------------------------------------------------------------- */
+
+enum { CHILD, PARENT };
+struct postproc_args {
+	struct inode *h_dir, *dir, *h_child_inode;
+	u32 mask;
+	unsigned int flags[2];
+	unsigned int h_child_nlen;
+	char h_child_name[];
+};
+
+static void postproc(void *_args)
+{
+	struct postproc_args *a = _args;
+	struct super_block *sb;
+	aufs_bindex_t bindex, bend, bfound;
+	unsigned char xino, try_iput;
+	int err;
+	struct inode *inode;
+	ino_t h_ino;
+	struct hin_job_args args;
+	struct dentry *dentry;
+	struct au_sbinfo *sbinfo;
+
+	AuDebugOn(!_args);
+	AuDebugOn(!a->h_dir);
+	AuDebugOn(!a->dir);
+	AuDebugOn(!a->mask);
+	LKTRTrace("mask 0x%x %s, i%lu, hi%lu, hci%lu\n",
+		  a->mask, in_name(a->mask), a->dir->i_ino, a->h_dir->i_ino,
+		  a->h_child_inode ? a->h_child_inode->i_ino : 0);
+
+	inode = NULL;
+	dentry = NULL;
+	/*
+	 * do not lock a->dir->i_mutex here
+	 * because of d_revalidate() may cause a deadlock.
+	 */
+#if 0
+	/*
+	 * just wait for the dir becoming non-busy.
+	 * for instance, prevent NFSD lookup from "nlink == 0" message.
+	 * but it is not guranteed.
+	 */
+	mutex_lock(&a->dir->i_mutex);
+	mutex_unlock(&a->dir->i_mutex);
+#endif
+
+	sb = a->dir->i_sb;
+	AuDebugOn(!sb);
+	sbinfo = au_sbi(sb);
+	AuDebugOn(!sbinfo);
+	/* big aufs lock */
+	si_noflush_write_lock(sb);
+
+	ii_read_lock_parent(a->dir);
+	bfound = -1;
+	bend = au_ibend(a->dir);
+	for (bindex = au_ibstart(a->dir); bindex <= bend; bindex++)
+		if (au_h_iptr(a->dir, bindex) == a->h_dir) {
+			bfound = bindex;
+			break;
+		}
+	ii_read_unlock(a->dir);
+	if (unlikely(bfound < 0))
+		goto out;
+
+	xino = !!au_opt_test_xino(au_mntflags(sb));
+	h_ino = 0;
+	if (a->h_child_inode)
+		h_ino = a->h_child_inode->i_ino;
+
+	if (a->h_child_nlen
+	    && (au_ftest_hinjob(a->flags[CHILD], GEN)
+		|| au_ftest_hinjob(a->flags[CHILD], MNTPNT)))
+		dentry = lookup_wlock_by_name(a->h_child_name, a->h_child_nlen,
+					      a->dir);
+	try_iput = 0;
+	if (dentry)
+		inode = dentry->d_inode;
+	if (xino && !inode && h_ino
+	    && (au_ftest_hinjob(a->flags[CHILD], XINO0)
+		|| au_ftest_hinjob(a->flags[CHILD], TRYXINO0)
+		|| au_ftest_hinjob(a->flags[CHILD], GEN)
+		|| au_ftest_hinjob(a->flags[CHILD], ATTR))) {
+		inode = lookup_wlock_by_ino(sb, bfound, h_ino);
+		try_iput = 1;
+	    }
+
+	args.flags = a->flags[CHILD];
+	args.dentry = dentry;
+	args.inode = inode;
+	args.h_inode = a->h_child_inode;
+	args.dir = a->dir;
+	args.h_dir = a->h_dir;
+	args.h_name = a->h_child_name;
+	args.h_nlen = a->h_child_nlen;
+	err = hin_job(&args);
+	if (dentry) {
+		if (dentry->d_fsdata)
+			di_write_unlock(dentry);
+		dput(dentry);
+	}
+	if (inode && try_iput) {
+		ii_write_unlock(inode);
+		iput(inode);
+	}
+
+	ii_write_lock_parent(a->dir);
+	args.flags = a->flags[PARENT];
+	args.dentry = NULL;
+	args.inode = a->dir;
+	args.h_inode = a->h_dir;
+	args.dir = NULL;
+	args.h_dir = NULL;
+	args.h_name = NULL;
+	args.h_nlen = 0;
+	err = hin_job(&args);
+	ii_write_unlock(a->dir);
+
+ out:
+	au_nwt_done(&sbinfo->si_nowait);
+	si_write_unlock(sb);
+
+	iput(a->h_child_inode);
+	iput(a->h_dir);
+	iput(a->dir);
+	kfree(a);
+}
+
+static void aufs_inotify(struct inotify_watch *watch, u32 wd, u32 mask,
+			 u32 cookie, const char *h_child_name,
+			 struct inode *h_child_inode)
+{
+	struct au_hinotify *hinotify;
+	struct postproc_args *args;
+	int len, wkq_err;
+	unsigned char isdir, isroot, wh;
+	char *p;
+	struct inode *dir;
+	unsigned int flags[2];
+
+	LKTRTrace("i%lu, wd %d, mask 0x%x %s, cookie 0x%x, hcname %s, hi%lu\n",
+		  watch->inode->i_ino, wd, mask, in_name(mask), cookie,
+		  h_child_name ? h_child_name : "",
+		  h_child_inode ? h_child_inode->i_ino : 0);
+
+	/* if IN_UNMOUNT happens, there must be another bug */
+	if (mask & (IN_IGNORED | IN_UNMOUNT)) {
+		put_inotify_watch(watch);
+		return;
+	}
+
+#ifdef DbgInotify
+	if (!h_child_name || strcmp(h_child_name, AUFS_XINO_FNAME))
+		AuDbg("i%lu, wd %d, mask 0x%x %s, cookie 0x%x, hcname %s,"
+		      " hi%lu\n",
+		      watch->inode->i_ino, wd, mask, in_name(mask), cookie,
+		      h_child_name ? h_child_name : "",
+		      h_child_inode ? h_child_inode->i_ino : 0);
+#endif
+
+	hinotify = container_of(watch, struct au_hinotify, hin_watch);
+	AuDebugOn(!hinotify || !hinotify->hin_aufs_inode);
+	if (au_hin_test_ignore(mask, hinotify)) {
+#ifdef DbgInotify
+		AuDbg("ignored\n");
+#endif
+		return;
+	}
+#if 0 /* tmp debug */
+	if (h_child_name && !strcmp(h_child_name, AUFS_XINO_FNAME)) {
+	AuDbg("i%lu, wd %d, mask 0x%x %s, cookie 0x%x, hcname %s, hi%lu\n",
+		  watch->inode->i_ino, wd, mask, in_name(mask), cookie,
+		  h_child_name ? h_child_name : "",
+		  h_child_inode ? h_child_inode->i_ino : 0);
+	//au_dbg_blocked();
+	}
+#endif
+
+	dir = igrab(hinotify->hin_aufs_inode);
+	if (!dir)
+		return;
+	isroot = (dir->i_ino == AUFS_ROOT_INO);
+	len = 0;
+	wh = 0;
+	if (h_child_name) {
+		len = strlen(h_child_name);
+		if (!memcmp(h_child_name, AUFS_WH_PFX, AUFS_WH_PFX_LEN)) {
+			h_child_name += AUFS_WH_PFX_LEN;
+			len -= AUFS_WH_PFX_LEN;
+			wh = 1;
+		}
+	}
+
+	isdir = 0;
+	if (h_child_inode)
+		isdir = !!S_ISDIR(h_child_inode->i_mode);
+	flags[PARENT] = AuHinJob_ISDIR;
+	flags[CHILD] = 0;
+	if (isdir)
+		flags[CHILD] = AuHinJob_ISDIR;
+	switch (mask & IN_ALL_EVENTS) {
+	case IN_MODIFY:
+		/*FALLTHROUGH*/
+	case IN_ATTRIB:
+		if (h_child_inode) {
+			if (!wh)
+				au_fset_hinjob(flags[CHILD], ATTR);
+		} else
+			au_fset_hinjob(flags[PARENT], ATTR);
+		break;
+
+		/* IN_MOVED_FROM is the first event in rename(2) */
+	case IN_MOVED_FROM:
+	case IN_MOVED_TO:
+		AuDebugOn(!h_child_name || !h_child_inode);
+		au_fset_hinjob(flags[CHILD], GEN);
+		au_fset_hinjob(flags[CHILD], ATTR);
+		if (1 || isdir)
+			au_fset_hinjob(flags[CHILD], XINO0);
+		au_fset_hinjob(flags[CHILD], MNTPNT);
+
+		au_fset_hinjob(flags[PARENT], ATTR);
+		au_fset_hinjob(flags[PARENT], DIRENT);
+		break;
+
+	case IN_CREATE:
+		AuDebugOn(!h_child_name || !h_child_inode);
+		au_fset_hinjob(flags[PARENT], ATTR);
+		au_fset_hinjob(flags[PARENT], DIRENT);
+		au_fset_hinjob(flags[CHILD], GEN);
+		/* hard link */
+		if (!isdir && h_child_inode->i_nlink > 1)
+			au_fset_hinjob(flags[CHILD], ATTR);
+		break;
+
+	case IN_DELETE:
+		/*
+		 * aufs never be able to get this child inode.
+		 * revalidation should be in d_revalidate()
+		 * by checking i_nlink, i_generation or d_unhashed().
+		 */
+		AuDebugOn(!h_child_name);
+		au_fset_hinjob(flags[PARENT], ATTR);
+		au_fset_hinjob(flags[PARENT], DIRENT);
+		au_fset_hinjob(flags[CHILD], GEN);
+		au_fset_hinjob(flags[CHILD], TRYXINO0);
+		au_fset_hinjob(flags[CHILD], MNTPNT);
+		break;
+
+	case IN_DELETE_SELF:
+#if 0
+		if (!isroot)
+			au_fset_hinjob(flags[PARENT], GEN);
+		/*FALLTHROUGH*/
+#endif
+
+	case IN_MOVE_SELF:
+#if 0
+		/*
+		 * when an inotify is set to an aufs inode,
+		 * such inode can be isolated and this event can be fired
+		 * solely.
+		 */
+		AuDebugOn(h_child_name || h_child_inode);
+		if (unlikely(isroot)) {
+			AuWarn("root branch was moved\n");
+			iput(dir);
+			return;
+		}
+		au_fset_hinjob(flags[PARENT], XINO0);
+		au_fset_hinjob(flags[PARENT], GEN);
+		au_fset_hinjob(flags[PARENT], ATTR);
+		au_fset_hinjob(flags[PARENT], DIRENT);
+		/* au_fset_hinjob(flags[PARENT], MNTPNT); */
+		break;
+#endif
+
+	case IN_ACCESS:
+	default:
+		AuDebugOn(1);
+	}
+
+	if (wh)
+		h_child_inode = NULL;
+
+	/* iput() and kfree() will be called in postproc() */
+	/*
+	 * inotify_mutex is already acquired and kmalloc/prune_icache may lock
+	 * iprune_mutex. strange.
+	 */
+	lockdep_off();
+	args = kmalloc(sizeof(*args) + len + 1, GFP_NOFS);
+	lockdep_on();
+	if (unlikely(!args)) {
+		AuErr1("no memory\n");
+		iput(dir);
+		return;
+	}
+	args->flags[PARENT] = flags[PARENT];
+	args->flags[CHILD] = flags[CHILD];
+	args->mask = mask;
+	args->dir = dir;
+	args->h_dir = igrab(watch->inode);
+	if (h_child_inode)
+		h_child_inode = igrab(h_child_inode); /* can be NULL */
+	args->h_child_inode = h_child_inode;
+	args->h_child_nlen = len;
+	if (len) {
+		p = (void *)args;
+		p += sizeof(*args);
+		memcpy(p, h_child_name, len + 1);
+	}
+
+	lockdep_off();
+	wkq_err = au_wkq_nowait(postproc, args, dir->i_sb, /*dlgt*/0);
+	lockdep_on();
+	if (unlikely(wkq_err))
+		AuErr("wkq %d\n", wkq_err);
+}
+
+static void aufs_inotify_destroy(struct inotify_watch *watch)
+{
+	return;
+}
+
+static struct inotify_operations aufs_inotify_ops = {
+	.handle_event	= aufs_inotify,
+	.destroy_watch	= aufs_inotify_destroy
+};
+
+/* ---------------------------------------------------------------------- */
+
+static void au_hin_destroy_cache(void)
+{
+	kmem_cache_destroy(au_cachep[AuCache_HINOTIFY]);
+	au_cachep[AuCache_HINOTIFY] = NULL;
+}
+
+int __init au_inotify_init(void)
+{
+	int err;
+
+	err = -ENOMEM;
+	au_cachep[AuCache_HINOTIFY] = AuCache(au_hinotify);
+	if (au_cachep[AuCache_HINOTIFY]) {
+		err = 0;
+		in_handle = inotify_init(&aufs_inotify_ops);
+		if (IS_ERR(in_handle)) {
+			err = PTR_ERR(in_handle);
+			au_hin_destroy_cache();
+		}
+	}
+	AuTraceErr(err);
+	return err;
+}
+
+void au_inotify_fin(void)
+{
+	inotify_destroy(in_handle);
+	if (au_cachep[AuCache_HINOTIFY])
+		au_hin_destroy_cache();
+}
diff -Nurp linux-2.6.27.orig/fs/aufs/iinfo.c linux-2.6.27/fs/aufs/iinfo.c
--- linux-2.6.27.orig/fs/aufs/iinfo.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.27/fs/aufs/iinfo.c	2008-12-14 10:37:40.000000000 +0100
@@ -0,0 +1,284 @@
+/*
+ * Copyright (C) 2005-2008 Junjiro Okajima
+ *
+ * This program, aufs is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+ */
+
+/*
+ * inode private data
+ *
+ * $Id: iinfo.c,v 1.12 2008/12/08 06:12:15 sfjro Exp $
+ */
+
+#include "aufs.h"
+
+struct au_iinfo *au_ii(struct inode *inode)
+{
+	struct au_iinfo *iinfo;
+
+	iinfo = &(container_of(inode, struct aufs_icntnr, vfs_inode)->iinfo);
+	/* bad_inode case */
+	if (unlikely(!iinfo->ii_hinode))
+		return NULL;
+	AuDebugOn(!iinfo->ii_hinode
+		  /* || au_sbi(inode->i_sb)->si_bend < iinfo->ii_bend */
+		  || iinfo->ii_bend < iinfo->ii_bstart);
+	return iinfo;
+}
+
+struct inode *au_h_iptr(struct inode *inode, aufs_bindex_t bindex)
+{
+	struct inode *hidden_inode;
+
+	/* lock free root dinfo/inode */
+	if (inode->i_ino != AUFS_ROOT_INO) {
+		IiMustAnyLock(inode);
+		AuDebugOn(bindex < 0 || au_ibend(inode) < bindex);
+	} else {
+		SiMustAnyLock(inode->i_sb);
+		AuDebugOn(bindex < 0 || au_sbend(inode->i_sb) < bindex);
+	}
+	hidden_inode = au_ii(inode)->ii_hinode[0 + bindex].hi_inode;
+	AuDebugOn(hidden_inode && atomic_read(&hidden_inode->i_count) <= 0);
+	return hidden_inode;
+}
+
+aufs_bindex_t au_ii_br_id(struct inode *inode, aufs_bindex_t bindex)
+{
+	IiMustAnyLock(inode);
+	AuDebugOn(bindex < 0
+		  || au_ibend(inode) < bindex
+		  || !au_ii(inode)->ii_hinode[0 + bindex].hi_inode);
+	return au_ii(inode)->ii_hinode[0 + bindex].hi_id;
+}
+
+/* todo: hard/soft set? */
+void au_set_ibstart(struct inode *inode, aufs_bindex_t bindex)
+{
+	struct au_iinfo *iinfo = au_ii(inode);
+	struct inode *h_inode;
+
+	IiMustWriteLock(inode);
+	AuDebugOn(au_sbend(inode->i_sb) < bindex);
+	iinfo->ii_bstart = bindex;
+	h_inode = iinfo->ii_hinode[bindex + 0].hi_inode;
+	if (h_inode)
+		au_cpup_igen(inode, h_inode);
+}
+
+unsigned int au_hi_flags(struct inode *inode, int isdir)
+{
+	unsigned int flags;
+	const unsigned int mnt_flags = au_mntflags(inode->i_sb);
+
+	flags = 0;
+	if (au_opt_test_xino(mnt_flags))
+		au_fset_hi(flags, XINO);
+	if (isdir && au_opt_test(mnt_flags, UDBA_INOTIFY))
+		au_fset_hi(flags, NOTIFY);
+	return flags;
+}
+
+void au_set_h_iptr(struct inode *inode, aufs_bindex_t bindex,
+		   struct inode *h_inode, unsigned int flags)
+{
+	struct au_hinode *hinode;
+	struct inode *hi;
+	struct au_iinfo *iinfo = au_ii(inode);
+
+	LKTRTrace("i%lu, b%d, hi%lu, flags 0x%x\n",
+		  inode->i_ino, bindex, h_inode ? h_inode->i_ino : 0, flags);
+	IiMustWriteLock(inode);
+	hinode = iinfo->ii_hinode + bindex;
+	hi = hinode->hi_inode;
+	AuDebugOn(bindex < au_ibstart(inode) || au_ibend(inode) < bindex);
+	AuDebugOn(h_inode && atomic_read(&h_inode->i_count) <= 0);
+	AuDebugOn(h_inode && hi);
+
+	if (hi)
+		au_hiput(hinode);
+	hinode->hi_inode = h_inode;
+	if (h_inode) {
+		int err;
+		struct super_block *sb = inode->i_sb;
+
+		if (bindex == iinfo->ii_bstart)
+			au_cpup_igen(inode, h_inode);
+		hinode->hi_id = au_sbr_id(sb, bindex);
+		if (au_ftest_hi(flags, XINO)) {
+			struct au_xino_entry xinoe = {
+				.ino	= inode->i_ino,
+				/* .h_gen	= h_inode->i_generation */
+			};
+			err = au_xino_write(sb, bindex, h_inode->i_ino, &xinoe);
+			if (unlikely(err))
+				AuIOErr1("failed au_xino_write() %d\n", err);
+		}
+
+		if (au_ftest_hi(flags, NOTIFY)
+		    && au_br_hinotifyable(au_sbr_perm(sb, bindex))) {
+			err = au_hin_alloc(hinode, inode, h_inode);
+			if (unlikely(err))
+				AuIOErr1("au_hin_alloc() %d\n", err);
+		}
+	}
+}
+
+void au_set_hi_wh(struct inode *inode, aufs_bindex_t bindex,
+		  struct dentry *h_wh)
+{
+	struct au_hinode *hinode;
+
+	IiMustWriteLock(inode);
+	hinode = au_ii(inode)->ii_hinode + bindex;
+	AuDebugOn(hinode->hi_whdentry);
+	hinode->hi_whdentry = h_wh;
+}
+
+void au_update_iigen(struct inode *inode)
+{
+	AuDebugOn(!inode->i_sb);
+	atomic_set(&au_ii(inode)->ii_generation, au_sigen(inode->i_sb));
+	/* smp_mb(); */ /* atomic_set */
+}
+
+/* it may be called at remount time, too */
+void au_update_brange(struct inode *inode, int do_put_zero)
+{
+	struct au_iinfo *iinfo;
+
+	LKTRTrace("i%lu, %d\n", inode->i_ino, do_put_zero);
+	IiMustWriteLock(inode);
+
+	iinfo = au_ii(inode);
+	if (!iinfo || iinfo->ii_bstart < 0)
+		return;
+
+	if (do_put_zero) {
+		aufs_bindex_t bindex;
+		for (bindex = iinfo->ii_bstart; bindex <= iinfo->ii_bend;
+		     bindex++) {
+			struct inode *h_i;
+			h_i = iinfo->ii_hinode[0 + bindex].hi_inode;
+			if (h_i && !h_i->i_nlink)
+				au_set_h_iptr(inode, bindex, NULL, 0);
+		}
+	}
+
+	iinfo->ii_bstart = -1;
+	while (++iinfo->ii_bstart <= iinfo->ii_bend)
+		if (iinfo->ii_hinode[0 + iinfo->ii_bstart].hi_inode)
+			break;
+	if (iinfo->ii_bstart > iinfo->ii_bend) {
+		iinfo->ii_bstart = -1;
+		iinfo->ii_bend = -1;
+		return;
+	}
+
+	iinfo->ii_bend++;
+	while (0 <= --iinfo->ii_bend)
+		if (iinfo->ii_hinode[0 + iinfo->ii_bend].hi_inode)
+			break;
+	AuDebugOn(iinfo->ii_bstart > iinfo->ii_bend || iinfo->ii_bend < 0);
+}
+
+/* ---------------------------------------------------------------------- */
+
+int au_iinfo_init(struct inode *inode)
+{
+	struct au_iinfo *iinfo;
+	struct super_block *sb;
+	int nbr, i;
+
+	sb = inode->i_sb;
+	AuDebugOn(!sb);
+	iinfo = &(container_of(inode, struct aufs_icntnr, vfs_inode)->iinfo);
+	AuDebugOn(iinfo->ii_hinode);
+	nbr = au_sbend(sb) + 1;
+	if (nbr <= 0)
+		nbr = 1;
+	iinfo->ii_hinode = kcalloc(nbr, sizeof(*iinfo->ii_hinode), GFP_NOFS);
+	if (iinfo->ii_hinode) {
+		for (i = 0; i < nbr; i++)
+			iinfo->ii_hinode[i].hi_id = -1;
+		atomic_set(&iinfo->ii_generation, au_sigen(sb));
+		/* smp_mb(); */ /* atomic_set */
+		au_rw_init_nolock(&iinfo->ii_rwsem);
+		iinfo->ii_bstart = -1;
+		iinfo->ii_bend = -1;
+		iinfo->ii_vdir = NULL;
+		return 0;
+	}
+	return -ENOMEM;
+}
+
+static int au_iinfo_write0(struct super_block *sb, struct au_hinode *hinode,
+			   ino_t ino)
+{
+	int err, locked;
+	aufs_bindex_t bindex;
+
+	err = 0;
+	locked = si_noflush_read_trylock(sb); /* crucio! */
+	bindex = au_br_index(sb, hinode->hi_id);
+	if (bindex >= 0)
+		err = au_xino_write0(sb, bindex, hinode->hi_inode->i_ino, ino);
+	/* error action? */
+	if (locked)
+		si_read_unlock(sb);
+	return err;
+}
+
+void au_iinfo_fin(struct inode *inode)
+{
+	struct au_iinfo *iinfo;
+	aufs_bindex_t bend;
+	unsigned char unlinked;
+	struct au_hinode *hi;
+	struct super_block *sb;
+	ino_t ino;
+
+	iinfo = au_ii(inode);
+	/* bad_inode case */
+	if (!iinfo)
+		return;
+
+	if (iinfo->ii_vdir)
+		au_vdir_free(iinfo->ii_vdir);
+
+	if (iinfo->ii_bstart >= 0) {
+		sb = inode->i_sb;
+		unlinked = !inode->i_nlink;
+		ino = 0;
+		if (unlinked)
+			ino = inode->i_ino;
+		hi = iinfo->ii_hinode + iinfo->ii_bstart;
+		bend = iinfo->ii_bend;
+		while (iinfo->ii_bstart++ <= bend) {
+			if (hi->hi_inode) {
+				if (unlinked || !hi->hi_inode->i_nlink) {
+					au_iinfo_write0(sb, hi, ino);
+					/* ignore this error */
+					ino = 0;
+				}
+				au_hiput(hi);
+			}
+			hi++;
+		}
+	}
+
+	kfree(iinfo->ii_hinode);
+	au_rwsem_destroy(&iinfo->ii_rwsem);
+}
diff -Nurp linux-2.6.27.orig/fs/aufs/inode.c linux-2.6.27/fs/aufs/inode.c
--- linux-2.6.27.orig/fs/aufs/inode.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.27/fs/aufs/inode.c	2008-12-14 10:37:40.000000000 +0100
@@ -0,0 +1,421 @@
+/*
+ * Copyright (C) 2005-2008 Junjiro Okajima
+ *
+ * This program, aufs is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+ */
+
+/*
+ * inode functions
+ *
+ * $Id: inode.c,v 1.17 2008/12/01 03:49:29 sfjro Exp $
+ */
+
+#include "aufs.h"
+
+int au_refresh_hinode_self(struct inode *inode)
+{
+	int err, new_sz, update;
+	struct inode *first;
+	struct au_hinode *p, *q, tmp;
+	struct super_block *sb;
+	struct au_iinfo *iinfo;
+	aufs_bindex_t bindex, bend, new_bindex;
+
+	LKTRTrace("i%lu\n", inode->i_ino);
+	IiMustWriteLock(inode);
+
+	err = -ENOMEM;
+	update = 0;
+	sb = inode->i_sb;
+	bend = au_sbend(sb);
+	new_sz = sizeof(*iinfo->ii_hinode) * (bend + 1);
+	iinfo = au_ii(inode);
+	p = au_kzrealloc(iinfo->ii_hinode, sizeof(*p) * (iinfo->ii_bend + 1),
+			 new_sz, GFP_NOFS);
+	if (unlikely(!p))
+		goto out;
+
+	iinfo->ii_hinode = p;
+	p = iinfo->ii_hinode + iinfo->ii_bstart;
+	first = p->hi_inode;
+	err = 0;
+	for (bindex = iinfo->ii_bstart; bindex <= iinfo->ii_bend;
+	     bindex++, p++) {
+		if (!p->hi_inode)
+			continue;
+
+		new_bindex = au_br_index(sb, p->hi_id);
+		if (new_bindex == bindex)
+			continue;
+		if (new_bindex < 0) {
+			update++;
+			au_hiput(p);
+			p->hi_inode = NULL;
+			continue;
+		}
+
+		if (new_bindex < iinfo->ii_bstart)
+			iinfo->ii_bstart = new_bindex;
+		if (iinfo->ii_bend < new_bindex)
+			iinfo->ii_bend = new_bindex;
+		/* swap two hidden inode, and loop again */
+		q = iinfo->ii_hinode + new_bindex;
+		tmp = *q;
+		*q = *p;
+		*p = tmp;
+		if (tmp.hi_inode) {
+			bindex--;
+			p--;
+		}
+	}
+	au_update_brange(inode, /*do_put_zero*/0);
+
+	if (unlikely(err))
+		goto out;
+
+	if (1 || first != au_h_iptr(inode, iinfo->ii_bstart))
+		au_cpup_attr_all(inode, /*force*/0);
+	if (update && S_ISDIR(inode->i_mode))
+		inode->i_version++;
+	au_update_iigen(inode);
+
+ out:
+	AuTraceErr(err);
+	return err;
+}
+
+int au_refresh_hinode(struct inode *inode, struct dentry *dentry)
+{
+	int err, update;
+	struct inode *first;
+	struct au_hinode *p;
+	struct super_block *sb;
+	struct au_iinfo *iinfo;
+	aufs_bindex_t bindex, bend;
+	unsigned char isdir;
+	unsigned int flags;
+
+	LKTRTrace("%.*s\n", AuDLNPair(dentry));
+	IiMustWriteLock(inode);
+
+	err = au_refresh_hinode_self(inode);
+	if (unlikely(err))
+		goto out;
+
+	sb = dentry->d_sb;
+	bend = au_sbend(sb);
+	iinfo = au_ii(inode);
+	update = 0;
+	p = iinfo->ii_hinode + iinfo->ii_bstart;
+	first = p->hi_inode;
+	isdir = S_ISDIR(inode->i_mode);
+	flags = au_hi_flags(inode, isdir);
+	bend = au_dbend(dentry);
+	for (bindex = au_dbstart(dentry); bindex <= bend; bindex++) {
+		struct inode *hi;
+		struct dentry *hd;
+
+		hd = au_h_dptr(dentry, bindex);
+		if (!hd || !hd->d_inode)
+			continue;
+
+		if (iinfo->ii_bstart <= bindex && bindex <= iinfo->ii_bend) {
+			hi = au_h_iptr(inode, bindex);
+			if (hi) {
+				if (hi == hd->d_inode)
+					continue;
+				err = -ESTALE;
+				break;
+			}
+		}
+		if (bindex < iinfo->ii_bstart)
+			iinfo->ii_bstart = bindex;
+		if (iinfo->ii_bend < bindex)
+			iinfo->ii_bend = bindex;
+		au_set_h_iptr(inode, bindex, au_igrab(hd->d_inode), flags);
+		update++;
+	}
+	au_update_brange(inode, /*do_put_zero*/0);
+
+	if (unlikely(err))
+		goto out;
+
+	if (1 || first != au_h_iptr(inode, iinfo->ii_bstart))
+		au_cpup_attr_all(inode, /*force*/0);
+	if (update && isdir)
+		inode->i_version++;
+	au_update_iigen(inode);
+
+ out:
+	AuTraceErr(err);
+	return err;
+}
+
+static int set_inode(struct inode *inode, struct dentry *dentry)
+{
+	int err;
+	struct dentry *h_dentry;
+	struct inode *h_inode;
+	umode_t mode;
+	aufs_bindex_t bindex, bstart, btail;
+	unsigned char isdir;
+	struct au_iinfo *iinfo;
+	unsigned int flags;
+
+	LKTRTrace("i%lu, %.*s\n", inode->i_ino, AuDLNPair(dentry));
+	AuDebugOn(!(inode->i_state & I_NEW));
+	IiMustWriteLock(inode);
+	bstart = au_dbstart(dentry);
+	h_dentry = au_h_dptr(dentry, bstart);
+	AuDebugOn(!h_dentry);
+	h_inode = h_dentry->d_inode;
+	AuDebugOn(!h_inode);
+
+	err = 0;
+	isdir = 0;
+	mode = h_inode->i_mode;
+	switch (mode & S_IFMT) {
+	case S_IFREG:
+		btail = au_dbtail(dentry);
+		inode->i_op = &aufs_iop;
+		inode->i_fop = &aufs_file_fop;
+		inode->i_mapping->a_ops = &aufs_aop;
+		break;
+	case S_IFDIR:
+		isdir = 1;
+		btail = au_dbtaildir(dentry);
+		inode->i_op = &aufs_dir_iop;
+		inode->i_fop = &aufs_dir_fop;
+		break;
+	case S_IFLNK:
+		btail = au_dbtail(dentry);
+		inode->i_op = &aufs_symlink_iop;
+		/* inode->i_fop = &aufs_file_fop; */
+		break;
+	case S_IFBLK:
+	case S_IFCHR:
+	case S_IFIFO:
+	case S_IFSOCK:
+		btail = au_dbtail(dentry);
+		inode->i_op = &aufs_iop;
+		init_special_inode(inode, mode,
+				   au_h_rdev(h_inode, /*h_mnt*/NULL, h_dentry));
+		break;
+	default:
+		AuIOErr("Unknown file type 0%o\n", mode);
+		err = -EIO;
+		goto out;
+	}
+
+	/* do not set inotify for whiteouted dirs (SHWH mode) */
+	flags = au_hi_flags(inode, isdir);
+	if (au_opt_test(au_mntflags(dentry->d_sb), SHWH)
+	    && au_ftest_hi(flags, NOTIFY)
+	    && dentry->d_name.len > AUFS_WH_PFX_LEN
+	    && !memcmp(dentry->d_name.name, AUFS_WH_PFX, AUFS_WH_PFX_LEN))
+		au_fclr_hi(flags, NOTIFY);
+	iinfo = au_ii(inode);
+	iinfo->ii_bstart = bstart;
+	iinfo->ii_bend = btail;
+	for (bindex = bstart; bindex <= btail; bindex++) {
+		h_dentry = au_h_dptr(dentry, bindex);
+		if (!h_dentry)
+			continue;
+		AuDebugOn(!h_dentry->d_inode);
+		au_set_h_iptr(inode, bindex, au_igrab(h_dentry->d_inode),
+			      flags);
+	}
+	au_cpup_attr_all(inode, /*force*/1);
+
+ out:
+	AuTraceErr(err);
+	return err;
+}
+
+/* successful returns with iinfo write_locked */
+/* todo: return with unlocked? */
+static int reval_inode(struct inode *inode, struct dentry *dentry, int *matched)
+{
+	int err;
+	struct inode *h_inode, *h_dinode;
+	aufs_bindex_t bindex, bend;
+
+	LKTRTrace("i%lu, %.*s\n", inode->i_ino, AuDLNPair(dentry));
+
+	*matched = 0;
+
+	/*
+	 * before this function, if aufs got any iinfo lock, it must be only
+	 * one, the parent dir.
+	 * it can happen by UDBA and the obsoleted inode number.
+	 */
+	err = -EIO;
+	if (unlikely(inode->i_ino == parent_ino(dentry)))
+		goto out;
+
+	h_dinode = au_h_dptr(dentry, au_dbstart(dentry))->d_inode;
+	/* mutex_lock_nested(&inode->i_mutex, AuLsc_I_CHILD); */
+	ii_write_lock_new_child(inode);
+	/* it happend */
+	if (unlikely(IS_DEADDIR(inode)))
+		goto out_unlock;
+
+	err = 0;
+	bend = au_ibend(inode);
+	for (bindex = au_ibstart(inode); bindex <= bend; bindex++) {
+		h_inode = au_h_iptr(inode, bindex);
+		if (h_inode && h_inode == h_dinode) {
+			/* && (ibs != bstart
+			   || !au_test_higen(inode, h_inode))); */
+			*matched = 1;
+			err = 0;
+			if (au_iigen(inode) != au_digen(dentry))
+				err = au_refresh_hinode(inode, dentry);
+			break;
+		}
+	}
+
+ out_unlock:
+	if (unlikely(err))
+		ii_write_unlock(inode);
+	/* mutex_unlock(&inode->i_mutex); */
+ out:
+	AuTraceErr(err);
+	return err;
+}
+
+/* successful returns with iinfo write_locked */
+/* todo: return with unlocked? */
+struct inode *au_new_inode(struct dentry *dentry, int must_new)
+{
+	struct inode *inode, *h_inode;
+	struct dentry *h_dentry;
+	struct super_block *sb;
+	ino_t h_ino;
+	int err, match;
+	aufs_bindex_t bstart;
+	struct au_xino_entry xinoe;
+
+	LKTRTrace("%.*s\n", AuDLNPair(dentry));
+	sb = dentry->d_sb;
+	bstart = au_dbstart(dentry);
+	h_dentry = au_h_dptr(dentry, bstart);
+	AuDebugOn(!h_dentry);
+	h_inode = h_dentry->d_inode;
+	AuDebugOn(!h_inode);
+
+	h_ino = h_inode->i_ino;
+	err = au_xino_read(sb, bstart, h_ino, &xinoe);
+	inode = ERR_PTR(err);
+	if (unlikely(err))
+		goto out;
+ new_ino:
+	if (!xinoe.ino) {
+		xinoe.ino = au_xino_new_ino(sb);
+		if (!xinoe.ino) {
+			inode = ERR_PTR(-EIO);
+			goto out;
+		}
+	}
+
+	LKTRTrace("i%lu\n", (unsigned long)xinoe.ino);
+	inode = au_iget_locked(sb, xinoe.ino);
+	err = PTR_ERR(inode);
+	if (IS_ERR(inode))
+		goto out;
+
+	LKTRTrace("%lx, new %d\n", inode->i_state, !!(inode->i_state & I_NEW));
+	if (inode->i_state & I_NEW) {
+		ii_write_lock_new_child(inode);
+		err = set_inode(inode, dentry);
+		unlock_new_inode(inode);
+		if (!err)
+			goto out; /* success */
+		iget_failed(inode);
+		ii_write_unlock(inode);
+		goto out_iput;
+	} else if (!must_new) {
+		AuDebugOn(inode->i_state & I_LOCK);
+		err = reval_inode(inode, dentry, &match);
+		if (!err)
+			goto out; /* success */
+		else if (match)
+			goto out_iput;
+	}
+
+	if (unlikely(au_test_unique_ino(h_dentry, h_ino)))
+		AuWarn1("Un-notified UDBA or repeatedly renamed dir,"
+			" b%d, %s, %.*s, hi%lu, i%lu.\n",
+			bstart, au_sbtype(h_dentry->d_sb), AuDLNPair(dentry),
+			(unsigned long)h_ino, (unsigned long)xinoe.ino);
+	xinoe.ino = 0;
+	err = au_xino_write0(sb, bstart, h_ino, 0);
+	if (!err) {
+		iput(inode);
+		goto new_ino;
+	}
+	/* force noxino? */
+
+ out_iput:
+	iput(inode);
+	inode = ERR_PTR(err);
+ out:
+	AuTraceErrPtr(inode);
+	return inode;
+}
+
+/* ---------------------------------------------------------------------- */
+
+int au_test_ro(struct super_block *sb, aufs_bindex_t bindex,
+	       struct inode *inode)
+{
+	int err;
+
+	err = au_br_rdonly(au_sbr(sb, bindex));
+
+	/* pseudo-link after flushed may out of bounds */
+	if (!err
+	    && inode
+	    && au_ibstart(inode) <= bindex
+	    && bindex <= au_ibend(inode)) {
+		/*
+		 * permission check is unnecessary since vfsub routine
+		 * will be called later
+		 */
+		struct inode *hi = au_h_iptr(inode, bindex);
+		if (hi)
+			err = IS_IMMUTABLE(hi) ? -EROFS : 0;
+	}
+
+	AuTraceErr(err);
+	return err;
+}
+
+int au_test_h_perm(struct inode *h_inode, int mask, int dlgt)
+{
+	if (!current->fsuid)
+		return 0;
+	/* todo: fake nameidata? */
+	return vfsub_permission(h_inode, mask, NULL, dlgt);
+}
+
+int au_test_h_perm_sio(struct inode *h_inode, int mask, int dlgt)
+{
+	if (au_test_nfs(h_inode->i_sb)
+	    && (mask & MAY_WRITE)
+	    && S_ISDIR(h_inode->i_mode))
+		mask |= MAY_READ; /* force permission check */
+	return au_test_h_perm(h_inode, mask, dlgt);
+}
diff -Nurp linux-2.6.27.orig/fs/aufs/inode.h linux-2.6.27/fs/aufs/inode.h
--- linux-2.6.27.orig/fs/aufs/inode.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.27/fs/aufs/inode.h	2008-12-14 10:37:40.000000000 +0100
@@ -0,0 +1,595 @@
+/*
+ * Copyright (C) 2005-2008 Junjiro Okajima
+ *
+ * This program, aufs is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+ */
+
+/*
+ * inode operations
+ *
+ * $Id: inode.h,v 1.19 2008/12/08 06:12:15 sfjro Exp $
+ */
+
+#ifndef __AUFS_INODE_H__
+#define __AUFS_INODE_H__
+
+#ifdef __KERNEL__
+
+#include <linux/fs.h>
+#include <linux/namei.h>
+#include <linux/security.h>
+#include <linux/aufs_type.h>
+#include "hinode.h"
+#include "misc.h"
+#include "super.h"
+
+struct au_hinode;
+struct au_vdir;
+struct au_iinfo {
+	atomic_t		ii_generation;
+	struct super_block	*ii_hsb1;	/* no get/put */
+
+	struct au_rwsem		ii_rwsem;
+	aufs_bindex_t		ii_bstart, ii_bend;
+	__u32			ii_higen;
+	struct au_hinode	*ii_hinode;
+	struct au_vdir		*ii_vdir;
+};
+
+struct aufs_icntnr {
+	struct au_iinfo iinfo;
+	struct inode vfs_inode;
+};
+
+/* au_pin flags */
+#define AuPin_DI_LOCKED		1
+#define AuPin_DO_GPARENT	(1 << 1)
+#define AuPin_MNT_WRITE		(1 << 2)
+#define AuPin_VFS_RENAME	(1 << 3)
+/* will be set automatically */
+#define AuPin_VERIFY		(1 << 4)
+#define au_ftest_pin(flags, name)	((flags) & AuPin_##name)
+#define au_fset_pin(flags, name)	{ (flags) |= AuPin_##name; }
+#define au_fclr_pin(flags, name)	{ (flags) &= ~AuPin_##name; }
+
+struct au_pin1 {
+	/* input */
+	struct dentry *dentry;
+	unsigned char lsc_di, lsc_hi, flags;
+	aufs_bindex_t bindex;
+
+	/* output */
+	struct dentry *parent;
+	struct inode *h_dir;
+};
+
+enum {AuPin_PARENT, AuPin_GPARENT};
+struct au_pin {
+#ifdef CONFIG_AUFS_HINOTIFY
+	struct au_pin1 pin[2];
+#else
+	struct au_pin1 pin[1]; /* no grand parent */
+#endif
+};
+
+/* ---------------------------------------------------------------------- */
+
+/* inode.c */
+int au_refresh_hinode_self(struct inode *inode);
+int au_refresh_hinode(struct inode *inode, struct dentry *dentry);
+struct inode *au_new_inode(struct dentry *dentry, int must_new);
+int au_test_ro(struct super_block *sb, aufs_bindex_t bindex,
+	       struct inode *inode);
+int au_test_h_perm(struct inode *h_inode, int mask, int dlgt);
+int au_test_h_perm_sio(struct inode *h_inode, int mask, int dlgt);
+
+/* i_op.c */
+extern struct inode_operations aufs_iop, aufs_symlink_iop, aufs_dir_iop;
+
+/* au_wr_dir flags */
+#define AuWrDir_ADD_ENTRY	1
+#define AuWrDir_ISDIR		(1 << 1)
+#define au_ftest_wrdir(flags, name)	((flags) & AuWrDir_##name)
+#define au_fset_wrdir(flags, name)	{ (flags) |= AuWrDir_##name; }
+#define au_fclr_wrdir(flags, name)	{ (flags) &= ~AuWrDir_##name; }
+
+struct au_wr_dir_args {
+	aufs_bindex_t force_btgt;
+	unsigned char flags;
+};
+int au_wr_dir(struct dentry *dentry, struct dentry *src_dentry,
+	      struct au_wr_dir_args *args);
+
+void au_pin_init(struct au_pin *args, struct dentry *dentry,
+		 aufs_bindex_t bindex, int lsc_di, int lsc_hi,
+		 unsigned char flags);
+int au_pin(struct au_pin *args, struct dentry *dentry, aufs_bindex_t bindex,
+	   unsigned char flags) __must_check;
+int au_do_pin(struct au_pin1 *p, struct au_pin1 *gp) __must_check;
+void au_do_unpin(struct au_pin1 *p, struct au_pin1 *gp);
+
+/* i_op_add.c */
+struct au_ndx;
+int au_may_add(struct dentry *dentry, aufs_bindex_t bindex,
+	       struct dentry *h_parent, int isdir, struct au_ndx *ndx);
+int aufs_mknod(struct inode *dir, struct dentry *dentry, int mode, dev_t dev);
+int aufs_symlink(struct inode *dir, struct dentry *dentry, const char *symname);
+int aufs_create(struct inode *dir, struct dentry *dentry, int mode,
+		struct nameidata *nd);
+int aufs_link(struct dentry *src_dentry, struct inode *dir,
+	      struct dentry *dentry);
+int aufs_mkdir(struct inode *dir, struct dentry *dentry, int mode);
+
+/* i_op_del.c */
+int au_wr_dir_need_wh(struct dentry *dentry, int isdir, aufs_bindex_t *bcpup);
+int au_may_del(struct dentry *dentry, aufs_bindex_t bindex,
+	       struct dentry *h_parent, int isdir, struct au_ndx *ndx);
+int aufs_unlink(struct inode *dir, struct dentry *dentry);
+int aufs_rmdir(struct inode *dir, struct dentry *dentry);
+
+/* i_op_ren.c */
+int au_wbr(struct dentry *dentry, aufs_bindex_t btgt);
+int aufs_rename(struct inode *src_dir, struct dentry *src_dentry,
+		struct inode *dir, struct dentry *dentry);
+
+#ifdef CONFIG_AUFS_DLGT
+/* dlgt.c */
+int au_security_inode_permission(struct inode *h_inode, int mask,
+				 struct nameidata *fake_nd, int dlgt);
+#else
+static inline
+int au_security_inode_permission(struct inode *h_inode, int mask,
+				 struct nameidata *fake_nd, int dlgt)
+{
+	return vfsub_security_inode_permission(h_inode, mask, fake_nd);
+}
+#endif /* CONFIG_AUFS_DLGT */
+
+#ifdef CONFIG_AUFS_GETATTR
+/* getattr.c */
+int aufs_getattr(struct vfsmount *mnt, struct dentry *dentry, struct kstat *st);
+#endif
+
+#if 0 /* reserved for future use */
+/* xattr.c */
+int aufs_setxattr(struct dentry *dentry, const char *name, const void *value,
+		  size_t sz, int flags);
+ssize_t aufs_getxattr(struct dentry *dentry, const char *name, void *value,
+		      size_t sz);
+ssize_t aufs_listxattr(struct dentry *dentry, char *list, size_t sz);
+int aufs_removexattr(struct dentry *dentry, const char *name);
+#endif
+
+/* iinfo.c */
+struct au_iinfo *au_ii(struct inode *inode);
+struct inode *au_h_iptr(struct inode *inode, aufs_bindex_t bindex);
+aufs_bindex_t au_ii_br_id(struct inode *inode, aufs_bindex_t bindex);
+
+void au_set_ibstart(struct inode *inode, aufs_bindex_t bindex);
+void au_set_hi_wh(struct inode *inode, aufs_bindex_t bindex,
+		  struct dentry *h_wh);
+unsigned int au_hi_flags(struct inode *inode, int isdir);
+
+/* hinode flags */
+#define AuHi_XINO	1
+#define AuHi_NOTIFY	(1 << 1)
+#define au_ftest_hi(flags, name)	((flags) & AuHi_##name)
+#define au_fset_hi(flags, name)		{ (flags) |= AuHi_##name; }
+#define au_fclr_hi(flags, name)		{ (flags) &= ~AuHi_##name; }
+#ifndef CONFIG_AUFS_HINOTIFY
+#undef AuHi_NOTIFY
+#define AuHi_NOTIFY	0
+#endif
+
+void au_set_h_iptr(struct inode *inode, aufs_bindex_t bindex,
+		   struct inode *h_inode, unsigned int flags);
+
+void au_update_iigen(struct inode *inode);
+void au_update_brange(struct inode *inode, int do_put_zero);
+
+int au_iinfo_init(struct inode *inode);
+void au_iinfo_fin(struct inode *inode);
+
+/* plink.c */
+#ifdef CONFIG_AUFS_DEBUG
+void au_plink_list(struct super_block *sb);
+#else
+static inline void au_plink_list(struct super_block *sb)
+{
+	/* nothing */
+}
+#endif
+int au_plink_test(struct super_block *sb, struct inode *inode);
+struct dentry *au_plink_lkup(struct super_block *sb, aufs_bindex_t bindex,
+			     struct inode *inode);
+void au_plink_append(struct super_block *sb, struct inode *inode,
+		     struct dentry *h_dentry, aufs_bindex_t bindex);
+void au_plink_put(struct super_block *sb);
+void au_plink_half_refresh(struct super_block *sb, aufs_bindex_t br_id);
+
+/* ---------------------------------------------------------------------- */
+
+/* lock subclass for iinfo */
+enum {
+	AuLsc_II_CHILD,		/* child first */
+	AuLsc_II_CHILD2,	/* rename(2), link(2), and cpup at hinotify */
+	AuLsc_II_CHILD3,	/* copyup dirs */
+	AuLsc_II_PARENT,	/* see AuLsc_I_PARENT in vfsub.h */
+	AuLsc_II_PARENT2,
+	AuLsc_II_PARENT3,
+	AuLsc_II_PARENT4,
+	AuLsc_II_NEW_CHILD,
+};
+
+/*
+ * ii_read_lock_child, ii_write_lock_child,
+ * ii_read_lock_child2, ii_write_lock_child2,
+ * ii_read_lock_child3, ii_write_lock_child3,
+ * ii_read_lock_parent, ii_write_lock_parent,
+ * ii_read_lock_parent2, ii_write_lock_parent2,
+ * ii_read_lock_parent3, ii_write_lock_parent3,
+ * ii_read_lock_parent4, ii_write_lock_parent4,
+ * ii_read_lock_new_child, ii_write_lock_new_child,
+ */
+#define AuReadLockFunc(name, lsc) \
+static inline void ii_read_lock_##name(struct inode *i) \
+{ \
+	au_dbg_locking_ii_reg(i, 0, AuLsc_II_##lsc); \
+	au_rw_read_lock_nested(&au_ii(i)->ii_rwsem, AuLsc_II_##lsc); \
+	au_dbg_locking_ii_unreg(i, 0); \
+	au_dbg_locked_ii_reg(i, 0, AuLsc_II_##lsc); \
+}
+
+#define AuWriteLockFunc(name, lsc) \
+static inline void ii_write_lock_##name(struct inode *i) \
+{ \
+	au_dbg_locking_ii_reg(i, 1, AuLsc_II_##lsc); \
+	au_rw_write_lock_nested(&au_ii(i)->ii_rwsem, AuLsc_II_##lsc); \
+	au_dbg_locking_ii_unreg(i, 1); \
+	au_dbg_locked_ii_reg(i, 1, AuLsc_II_##lsc); \
+}
+
+#define AuRWLockFuncs(name, lsc) \
+	AuReadLockFunc(name, lsc) \
+	AuWriteLockFunc(name, lsc)
+
+AuRWLockFuncs(child, CHILD);
+AuRWLockFuncs(child2, CHILD2);
+AuRWLockFuncs(child3, CHILD3);
+AuRWLockFuncs(parent, PARENT);
+AuRWLockFuncs(parent2, PARENT2);
+AuRWLockFuncs(parent3, PARENT3);
+AuRWLockFuncs(parent4, PARENT4);
+AuRWLockFuncs(new_child, NEW_CHILD);
+
+#undef AuReadLockFunc
+#undef AuWriteLockFunc
+#undef AuRWLockFuncs
+
+/*
+ * ii_read_unlock, ii_write_unlock, ii_downgrade_lock
+ */
+AuSimpleUnlockRwsemFuncs(ii_do, struct inode *i, au_ii(i)->ii_rwsem);
+static inline void ii_read_unlock(struct inode *i)
+{
+	ii_do_read_unlock(i);
+	au_dbg_locked_ii_unreg(i, 0);
+}
+
+static inline void ii_write_unlock(struct inode *i)
+{
+	ii_do_write_unlock(i);
+	au_dbg_locked_ii_unreg(i, 0);
+}
+
+static inline void ii_downgrade_lock(struct inode *i)
+{
+	ii_do_downgrade_lock(i);
+}
+
+/* to debug easier, do not make them inlined functions */
+#define IiMustReadLock(i) do { \
+	SiMustAnyLock((i)->i_sb); \
+	AuRwMustReadLock(&au_ii(i)->ii_rwsem); \
+} while (0)
+
+#define IiMustWriteLock(i) do { \
+	SiMustAnyLock((i)->i_sb); \
+	AuRwMustWriteLock(&au_ii(i)->ii_rwsem); \
+} while (0)
+
+#define IiMustAnyLock(i) do { \
+	SiMustAnyLock((i)->i_sb); \
+	AuRwMustAnyLock(&au_ii(i)->ii_rwsem); \
+} while (0)
+
+#define IiMustNoWaiters(i)	AuRwMustNoWaiters(&au_ii(i)->ii_rwsem)
+
+/* ---------------------------------------------------------------------- */
+
+static inline struct inode *au_igrab(struct inode *inode)
+{
+	if (inode) {
+		AuDebugOn(!atomic_read(&inode->i_count));
+		atomic_inc_return(&inode->i_count);
+	}
+	return inode;
+}
+
+/* ---------------------------------------------------------------------- */
+
+static inline aufs_bindex_t au_ibstart(struct inode *inode)
+{
+	/* lock free root dinfo/inode */
+	if (inode->i_ino != AUFS_ROOT_INO)
+		IiMustAnyLock(inode);
+	else
+		SiMustAnyLock(inode->i_sb);
+	return au_ii(inode)->ii_bstart;
+}
+
+static inline aufs_bindex_t au_ibend(struct inode *inode)
+{
+	/* lock free root dinfo/inode */
+	if (inode->i_ino != AUFS_ROOT_INO)
+		IiMustAnyLock(inode);
+	else
+		SiMustAnyLock(inode->i_sb);
+	return au_ii(inode)->ii_bend;
+}
+
+static inline struct au_vdir *au_ivdir(struct inode *inode)
+{
+	IiMustAnyLock(inode);
+	AuDebugOn(!S_ISDIR(inode->i_mode));
+	return au_ii(inode)->ii_vdir;
+}
+
+static inline struct dentry *au_hi_wh(struct inode *inode, aufs_bindex_t bindex)
+{
+	struct au_hinode *hinode;
+	IiMustAnyLock(inode);
+	hinode = au_ii(inode)->ii_hinode + bindex;
+	return hinode->hi_whdentry;
+}
+
+static inline void au_set_ibend(struct inode *inode, aufs_bindex_t bindex)
+{
+	IiMustWriteLock(inode);
+	AuDebugOn(au_sbend(inode->i_sb) < bindex || bindex < au_ibstart(inode));
+	au_ii(inode)->ii_bend = bindex;
+}
+
+static inline void au_set_ivdir(struct inode *inode, struct au_vdir *vdir)
+{
+	IiMustWriteLock(inode);
+	AuDebugOn(!S_ISDIR(inode->i_mode) || (au_ii(inode)->ii_vdir && vdir));
+	au_ii(inode)->ii_vdir = vdir;
+}
+
+static inline void au_hiput(struct au_hinode *hinode)
+{
+	au_hin_free(hinode);
+	dput(hinode->hi_whdentry);
+	iput(hinode->hi_inode);
+}
+
+static inline struct au_hinode *au_hi(struct inode *inode, aufs_bindex_t bindex)
+{
+	/* todo: this lock check causes some unnecessary locks in callers. */
+	IiMustAnyLock(inode);
+	return au_ii(inode)->ii_hinode + bindex;
+}
+
+/* tiny test for inode number */
+/* tmpfs generation is too rough */
+static inline int au_test_higen(struct inode *inode, struct inode *h_inode)
+{
+	struct au_iinfo *iinfo;
+
+	IiMustAnyLock(inode);
+
+	iinfo = au_ii(inode);
+	return !(iinfo->ii_hsb1 == h_inode->i_sb
+		 && iinfo->ii_higen == h_inode->i_generation);
+}
+
+static inline au_gen_t au_iigen(struct inode *inode)
+{
+	return atomic_read(&au_ii(inode)->ii_generation);
+}
+
+#ifdef CONFIG_AUFS_HINOTIFY
+static inline au_gen_t au_iigen_dec(struct inode *inode)
+{
+	/* AuDbg("i%lu\n", inode->i_ino); */
+	return atomic_dec_return(&au_ii(inode)->ii_generation);
+}
+#endif
+
+/* ---------------------------------------------------------------------- */
+
+#ifdef CONFIG_AUFS_HINOTIFY
+static inline struct au_pin1 *au_pin_gp(struct au_pin *args)
+{
+	return args->pin + AuPin_GPARENT;
+}
+
+/* hinotify.c */
+void au_unpin_gp(struct au_pin *args);
+
+#else
+
+static inline struct au_pin1 *au_pin_gp(struct au_pin *args)
+{
+	return NULL;
+}
+
+static inline void au_unpin_gp(struct au_pin *args)
+{
+	/* empty */
+}
+#endif /* HINOTIFY */
+
+static inline void au_unpin(struct au_pin *args)
+{
+	au_do_unpin(args->pin + AuPin_PARENT, au_pin_gp(args));
+}
+
+static inline
+struct au_hinode *au_do_pinned_hdir(struct au_pin1 *pin)
+{
+	if (pin && pin->parent)
+		return au_hi(pin->parent->d_inode, pin->bindex);
+	return NULL;
+}
+
+struct dentry *au_do_pinned_h_parent(struct au_pin1 *pin);
+
+static inline struct dentry *au_do_pinned_parent(struct au_pin1 *pin)
+{
+	if (pin)
+		return pin->parent;
+	return NULL;
+}
+
+static inline struct inode *au_do_pinned_h_dir(struct au_pin1 *pin)
+{
+	if (pin)
+		return pin->h_dir;
+	return NULL;
+}
+
+static inline
+void au_pin_do_set_dentry(struct au_pin1 *pin, struct dentry *dentry)
+{
+	if (pin)
+		pin->dentry = dentry;
+}
+
+static inline
+void au_pin_do_set_parent(struct au_pin1 *pin, struct dentry *parent)
+{
+	if (pin) {
+		dput(pin->parent);
+		pin->parent = dget(parent);
+	}
+}
+
+static inline void au_pin_do_set_h_dir(struct au_pin1 *pin, struct inode *h_dir)
+{
+	if (pin) {
+		iput(pin->h_dir);
+		pin->h_dir = au_igrab(h_dir);
+	}
+}
+
+static inline
+void au_pin_do_set_parent_lflag(struct au_pin1 *pin, unsigned char lflag)
+{
+	if (pin) {
+		/* dirty macros require brackets */
+		if (lflag) {
+			au_fset_pin(pin->flags, DI_LOCKED);
+		} else {
+			au_fclr_pin(pin->flags, DI_LOCKED);
+		}
+	}
+}
+
+static inline
+struct au_hinode *au_pinned_hdir(struct au_pin *args)
+{
+	return au_do_pinned_hdir(args->pin + AuPin_PARENT);
+}
+
+static inline
+struct au_hinode *au_pinned_hgdir(struct au_pin *args)
+{
+	return au_do_pinned_hdir(au_pin_gp(args));
+}
+
+static inline
+struct dentry *au_pinned_h_parent(struct au_pin *args)
+{
+	return au_do_pinned_h_parent(args->pin + AuPin_PARENT);
+}
+
+#if 0 /* reserved for future use */
+static inline
+struct dentry *au_pinned_h_gparent(struct au_pin *args)
+{
+	return au_do_pinned_h_parent(au_pin_gp(args));
+}
+#endif
+
+static inline
+struct dentry *au_pinned_parent(struct au_pin *args)
+{
+	return au_do_pinned_parent(args->pin + AuPin_PARENT);
+}
+
+static inline
+struct dentry *au_pinned_gparent(struct au_pin *args)
+{
+	return au_do_pinned_parent(au_pin_gp(args));
+}
+
+static inline
+struct inode *au_pinned_h_dir(struct au_pin *args)
+{
+	return au_do_pinned_h_dir(args->pin + AuPin_PARENT);
+}
+
+static inline
+struct inode *au_pinned_h_gdir(struct au_pin *args)
+{
+	return au_do_pinned_h_dir(au_pin_gp(args));
+}
+
+static inline void au_pin_set_parent(struct au_pin *args, struct dentry *d)
+{
+	au_pin_do_set_parent(args->pin + AuPin_PARENT, d);
+}
+
+static inline void au_pin_set_gparent(struct au_pin *args, struct dentry *d)
+{
+	au_pin_do_set_parent(au_pin_gp(args), d);
+}
+
+static inline void au_pin_set_h_dir(struct au_pin *args, struct inode *h_dir)
+{
+	au_pin_do_set_h_dir(args->pin + AuPin_PARENT, h_dir);
+}
+
+static inline void au_pin_set_h_gdir(struct au_pin *args, struct inode *h_dir)
+{
+	au_pin_do_set_h_dir(au_pin_gp(args), h_dir);
+}
+
+static inline
+void au_pin_set_parent_lflag(struct au_pin *args, unsigned char lflag)
+{
+	au_pin_do_set_parent_lflag(args->pin + AuPin_PARENT, lflag);
+}
+
+static inline
+void au_pin_set_gparent_lflag(struct au_pin *args, unsigned char lflag)
+{
+	au_pin_do_set_parent_lflag(au_pin_gp(args), lflag);
+}
+
+#endif /* __KERNEL__ */
+#endif /* __AUFS_INODE_H__ */
diff -Nurp linux-2.6.27.orig/fs/aufs/i_op_add.c linux-2.6.27/fs/aufs/i_op_add.c
--- linux-2.6.27.orig/fs/aufs/i_op_add.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.27/fs/aufs/i_op_add.c	2008-12-14 10:37:40.000000000 +0100
@@ -0,0 +1,759 @@
+/*
+ * Copyright (C) 2005-2008 Junjiro Okajima
+ *
+ * This program, aufs is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+ */
+
+/*
+ * inode operations (add entry)
+ *
+ * $Id: i_op_add.c,v 1.20 2008/12/08 06:12:07 sfjro Exp $
+ */
+
+#include "aufs.h"
+
+/*
+ * final procedure of adding a new entry, except link(2).
+ * remove whiteout, instantiate, copyup the parent dir's times and size
+ * and update version.
+ * if it failed, re-create the removed whiteout.
+ */
+static int epilog(struct inode *dir, aufs_bindex_t bindex,
+		  struct dentry *wh_dentry, struct dentry *dentry)
+{
+	int err, rerr;
+	aufs_bindex_t bwh;
+	struct inode *inode, *h_dir;
+	struct dentry *wh;
+	struct au_ndx ndx;
+	struct super_block *sb;
+
+	LKTRTrace("wh %p, %.*s\n", wh_dentry, AuDLNPair(dentry));
+
+	sb = dentry->d_sb;
+	bwh = -1;
+	if (wh_dentry) {
+		h_dir = wh_dentry->d_parent->d_inode; /* dir inode is locked */
+		IMustLock(h_dir);
+		AuDebugOn(au_h_iptr(dir, bindex) != h_dir);
+		bwh = au_dbwh(dentry);
+		err = au_wh_unlink_dentry(au_hi(dir, bindex), wh_dentry, dentry,
+					  /*dlgt*/0);
+		if (unlikely(err))
+			goto out;
+	}
+
+	inode = au_new_inode(dentry, /*must_new*/1);
+	if (!IS_ERR(inode)) {
+		d_instantiate(dentry, inode);
+		dir = dentry->d_parent->d_inode; /* dir inode is locked */
+		IMustLock(dir);
+		/* or always cpup dir mtime? */
+		if (au_ibstart(dir) == au_dbstart(dentry))
+			au_cpup_attr_timesizes(dir);
+		dir->i_version++;
+		return 0; /* success */
+	}
+
+	err = PTR_ERR(inode);
+	if (!wh_dentry)
+		goto out;
+
+	/* revert */
+	ndx.flags = 0;
+	if (au_test_dlgt(au_mntflags(sb)))
+		au_fset_ndx(ndx.flags, DLGT);
+	ndx.nfsmnt = au_nfsmnt(sb, bwh);
+	ndx.nd = NULL;
+	/* ndx.br = NULL; */
+	/* dir inode is locked */
+	wh = au_wh_create(dentry, bwh, wh_dentry->d_parent, &ndx);
+	rerr = PTR_ERR(wh);
+	if (IS_ERR(wh)) {
+		AuIOErr("%.*s reverting whiteout failed(%d, %d)\n",
+			AuDLNPair(dentry), err, rerr);
+		err = -EIO;
+	} else {
+		err = 0;
+		dput(wh);
+	}
+
+ out:
+	AuTraceErr(err);
+	return err;
+}
+
+/*
+ * simple tests for the adding inode operations.
+ * following the checks in vfs, plus the parent-child relationship.
+ */
+int au_may_add(struct dentry *dentry, aufs_bindex_t bindex,
+	       struct dentry *h_parent, int isdir, struct au_ndx *ndx)
+{
+	int err, exist;
+	struct dentry *h_dentry;
+	struct inode *h_inode;
+	umode_t h_mode;
+
+	LKTRTrace("%.*s/%.*s, b%d, dir %d\n",
+		  AuDLNPair(h_parent), AuDLNPair(dentry), bindex, isdir);
+
+	exist = !!dentry->d_inode;
+	h_dentry = au_h_dptr(dentry, bindex);
+	h_inode = h_dentry->d_inode;
+	if (!exist) {
+		err = -EEXIST;
+		if (unlikely(h_inode))
+			goto out;
+	} else {
+		/* rename(2) case */
+		err = -EIO;
+		if (unlikely(!h_inode || !h_inode->i_nlink))
+			goto out;
+
+		h_mode = h_inode->i_mode;
+		if (!isdir) {
+			err = -EISDIR;
+			if (unlikely(S_ISDIR(h_mode)))
+				goto out;
+		} else if (unlikely(!S_ISDIR(h_mode))) {
+			err = -ENOTDIR;
+			goto out;
+		}
+	}
+
+	err = -EIO;
+	/* expected parent dir is locked */
+	if (unlikely(h_parent != h_dentry->d_parent))
+		goto out;
+	err = 0;
+
+	if (au_opt_test(au_mntflags(dentry->d_sb), UDBA_INOTIFY)) {
+		struct dentry *h_latest;
+		struct qstr *qstr = &dentry->d_name;
+
+		err = -EACCES;
+		if (unlikely(au_test_h_perm
+			     (h_parent->d_inode, MAY_EXEC | MAY_WRITE,
+			      au_ftest_ndx(ndx->flags, DLGT))))
+			goto out;
+
+		h_latest = au_sio_lkup_one(qstr->name, h_parent, qstr->len,
+					   ndx);
+		err = PTR_ERR(h_latest);
+		if (IS_ERR(h_latest))
+			goto out;
+		err = -EIO;
+		dput(h_latest);
+		/* fuse d_revalidate always return 0 for negative dentries */
+		if (h_latest == h_dentry || au_test_fuse(h_dentry->d_sb))
+			err = 0;
+	}
+
+ out:
+	AuTraceErr(err);
+	return err;
+}
+
+/*
+ * initial procedure of adding a new entry.
+ * prepare writable branch and the parent dir, lock it,
+ * lookup whiteout for the new entry.
+ */
+static struct dentry*
+lock_hdir_lkup_wh(struct dentry *dentry, struct au_dtime *dt,
+		  struct dentry *src_dentry, struct au_pin *pin,
+		  struct au_wr_dir_args *wr_dir_args)
+{
+	struct dentry *wh_dentry, *h_parent;
+	struct super_block *sb;
+	int err;
+	unsigned int mnt_flags;
+	unsigned char pin_flags;
+	aufs_bindex_t bstart, bcpup;
+	struct au_ndx ndx;
+
+	LKTRTrace("%.*s, src %p\n", AuDLNPair(dentry), src_dentry);
+
+	bstart = au_dbstart(dentry);
+	err = au_wr_dir(dentry, src_dentry, wr_dir_args);
+	bcpup = err;
+	wh_dentry = ERR_PTR(err);
+	if (unlikely(err < 0))
+		goto out;
+
+	sb = dentry->d_sb;
+	mnt_flags = au_mntflags(sb);
+	pin_flags = AuPin_DI_LOCKED | AuPin_MNT_WRITE;
+	if (dt && au_opt_test(mnt_flags, UDBA_INOTIFY))
+		au_fset_pin(pin_flags, DO_GPARENT);
+	err = au_pin(pin, dentry, bcpup, pin_flags);
+	wh_dentry = ERR_PTR(err);
+	if (unlikely(err))
+		goto out;
+
+	ndx.nfsmnt = au_nfsmnt(sb, bcpup);
+	ndx.flags = 0;
+	if (au_test_dlgt(mnt_flags))
+		au_fset_ndx(ndx.flags, DLGT);
+	ndx.nd = NULL;
+	/* ndx.br = NULL; */
+	/* ndx.nd_file = NULL; */
+
+	h_parent = au_pinned_h_parent(pin);
+	if (!au_opt_test(mnt_flags, UDBA_NONE) && au_dbstart(dentry) == bcpup) {
+		struct nameidata nd;
+
+		if (ndx.nfsmnt) {
+			/* todo: dirty? */
+			ndx.nd = &nd;
+			ndx.br = au_sbr(sb, bcpup);
+			memset(&nd, 0, sizeof(nd));
+			nd.flags = LOOKUP_CREATE;
+			nd.intent.open.flags = O_EXCL;
+		}
+		err = au_may_add(dentry, bcpup, h_parent,
+				 au_ftest_wrdir(wr_dir_args->flags, ISDIR),
+				 &ndx);
+		wh_dentry = ERR_PTR(err);
+		if (unlikely(err))
+			goto out_unpin;
+		ndx.nd = NULL;
+		ndx.br = NULL;
+	}
+
+	if (dt)
+		au_dtime_store(dt, au_pinned_parent(pin), h_parent,
+			       au_pinned_hdir(pin), au_pinned_hgdir(pin));
+
+	wh_dentry = NULL;
+	if (/* bcpup != bstart || */ bcpup != au_dbwh(dentry))
+		goto out; /* success */
+
+	wh_dentry = au_wh_lkup(h_parent, &dentry->d_name, &ndx);
+
+ out_unpin:
+	if (IS_ERR(wh_dentry))
+		au_unpin(pin);
+ out:
+	AuTraceErrPtr(wh_dentry);
+	return wh_dentry;
+}
+
+/* ---------------------------------------------------------------------- */
+
+enum { Mknod, Symlink, Creat };
+struct simple_arg {
+	int type;
+	union {
+		struct {
+			int mode;
+			struct nameidata *nd;
+		} c;
+		struct {
+			const char *symname;
+		} s;
+		struct {
+			int mode;
+			dev_t dev;
+		} m;
+	} u;
+};
+
+static int add_simple(struct inode *dir, struct dentry *dentry,
+		      struct simple_arg *arg)
+{
+	int err;
+	struct dentry *h_dentry, *wh_dentry, *parent;
+	struct inode *h_dir;
+	struct au_dtime dt;
+	struct vfsub_args vargs;
+	struct super_block *sb;
+	aufs_bindex_t bstart;
+	unsigned char created;
+	struct au_hin_ignore ign;
+	struct au_pin pin;
+	struct au_wr_dir_args wr_dir_args = {
+		.force_btgt	= -1,
+		.flags		= AuWrDir_ADD_ENTRY
+	};
+
+	LKTRTrace("type %d, %.*s\n", arg->type, AuDLNPair(dentry));
+	IMustLock(dir);
+
+	sb = dir->i_sb;
+	parent = dentry->d_parent; /* dir inode is locked */
+	aufs_read_lock(dentry, AuLock_DW);
+	vfsub_args_init(&vargs, &ign, !!au_test_dlgt(au_mntflags(sb)), 0);
+	di_write_lock_parent(parent);
+	wh_dentry = lock_hdir_lkup_wh(dentry, &dt, /*src_dentry*/NULL, &pin,
+				      &wr_dir_args);
+	err = PTR_ERR(wh_dentry);
+	if (IS_ERR(wh_dentry))
+		goto out;
+
+	bstart = au_dbstart(dentry);
+	h_dentry = au_h_dptr(dentry, bstart);
+	h_dir = au_pinned_h_dir(&pin);
+	vfsub_ign_hinode(&vargs, IN_CREATE, au_pinned_hdir(&pin));
+
+	switch (arg->type) {
+	case Creat:
+		AuDebugOn(au_test_nfs(h_dir->i_sb) && !arg->u.c.nd);
+		err = au_h_create(h_dir, h_dentry, arg->u.c.mode, &vargs,
+				  arg->u.c.nd, au_nfsmnt(sb, bstart));
+		break;
+	case Symlink:
+		err = vfsub_symlink(h_dir, h_dentry, arg->u.s.symname,
+				    S_IALLUGO, &vargs);
+		break;
+	case Mknod:
+		err = vfsub_mknod(h_dir, h_dentry, arg->u.m.mode, arg->u.m.dev,
+				  &vargs);
+		break;
+	default:
+		BUG();
+	}
+	created = !err;
+	if (!err)
+		err = epilog(dir, bstart, wh_dentry, dentry);
+
+	/* revert */
+	if (unlikely(created && err && h_dentry->d_inode)) {
+		int rerr;
+		vfsub_args_reinit(&vargs);
+		vfsub_ign_hinode(&vargs, IN_DELETE, au_pinned_hdir(&pin));
+		rerr = vfsub_unlink(h_dir, h_dentry, &vargs);
+		if (rerr) {
+			AuIOErr("%.*s revert failure(%d, %d)\n",
+				AuDLNPair(dentry), err, rerr);
+			err = -EIO;
+		}
+		/* todo: inotify will be fired to the grand parent dir? */
+		au_dtime_revert(&dt);
+		d_drop(dentry);
+	}
+
+	au_unpin(&pin);
+	dput(wh_dentry);
+
+ out:
+	if (unlikely(err)) {
+		au_update_dbstart(dentry);
+		d_drop(dentry);
+	}
+	di_write_unlock(parent);
+	aufs_read_unlock(dentry, AuLock_DW);
+	AuTraceErr(err);
+	if (unlikely(err == -EBUSY && au_test_nfsd(current)))
+		err = -ESTALE;
+	return err;
+}
+
+int aufs_mknod(struct inode *dir, struct dentry *dentry, int mode, dev_t dev)
+{
+	struct simple_arg arg = {
+		.type = Mknod,
+		.u.m = {
+			.mode	= mode,
+			.dev	= dev
+		}
+	};
+	return add_simple(dir, dentry, &arg);
+}
+
+int aufs_symlink(struct inode *dir, struct dentry *dentry, const char *symname)
+{
+	struct simple_arg arg = {
+		.type = Symlink,
+		.u.s.symname = symname
+	};
+	return add_simple(dir, dentry, &arg);
+}
+
+int aufs_create(struct inode *dir, struct dentry *dentry, int mode,
+		struct nameidata *nd)
+{
+	struct simple_arg arg = {
+		.type = Creat,
+		.u.c = {
+			.mode	= mode,
+			.nd	= nd
+		}
+	};
+	return add_simple(dir, dentry, &arg);
+}
+
+/* ---------------------------------------------------------------------- */
+
+struct au_link_args {
+	unsigned int mnt_flags;
+	unsigned char pin_flags;
+	aufs_bindex_t bdst, bsrc;
+	struct vfsub_args vargs;
+	struct au_pin pin;
+	struct au_hin_ignore ign;
+	struct dentry *h_dentry;
+	struct dentry *src_parent, *parent;
+};
+
+static int au_cpup_before_link(struct dentry *src_dentry, struct inode *dir,
+			       struct dentry *dentry, struct au_link_args *a)
+{
+	int err;
+	const int hinotify = au_opt_test(a->mnt_flags, UDBA_INOTIFY);
+	struct mutex *h_mtx;
+
+	LKTRTrace("src %.*s, i%lu, dst %.*s\n",
+		  AuDLNPair(src_dentry), dir->i_ino, AuDLNPair(dentry));
+
+	di_read_lock_parent(a->src_parent, AuLock_IR);
+	err = au_test_and_cpup_dirs(src_dentry, a->bdst);
+	if (unlikely(err))
+		goto out;
+
+	AuDebugOn(au_dbstart(src_dentry) != a->bsrc);
+	h_mtx = &au_h_dptr(src_dentry, a->bsrc)->d_inode->i_mutex;
+	a->pin_flags = AuPin_DI_LOCKED | AuPin_MNT_WRITE;
+	if (hinotify)
+		au_fset_pin(a->pin_flags, DO_GPARENT);
+	err = au_pin(&a->pin, src_dentry, a->bdst, a->pin_flags);
+	if (unlikely(err))
+		goto out;
+	mutex_lock_nested(h_mtx, AuLsc_I_CHILD);
+	/* todo: no KEEPLINO because of noplink? */
+	err = au_sio_cpup_simple(src_dentry, a->bdst, -1,
+				 AuCpup_DTIME /* | AuCpup_KEEPLINO */);
+	mutex_unlock(h_mtx);
+	au_unpin(&a->pin);
+
+ out:
+	di_read_unlock(a->src_parent, AuLock_IR);
+	AuTraceErr(err);
+	return err;
+}
+
+static int au_cpup_or_link(struct dentry *src_dentry, struct au_link_args *a)
+{
+	int err;
+	struct inode *h_inode;
+	aufs_bindex_t bstart;
+	struct dentry *h_src_dentry;
+
+	AuTraceEnter();
+	AuDebugOn(au_dbstart(src_dentry) != a->bsrc);
+
+	bstart = au_ibstart(src_dentry->d_inode);
+	h_inode = NULL;
+	if (bstart <= a->bdst)
+		h_inode = au_h_iptr(src_dentry->d_inode, a->bdst);
+	if (!h_inode || !h_inode->i_nlink) {
+		/* copyup src_dentry as the name of dentry. */
+		au_set_dbstart(src_dentry, a->bdst);
+		au_set_h_dptr(src_dentry, a->bdst, dget(a->h_dentry));
+		h_inode = au_h_dptr(src_dentry, a->bsrc)->d_inode;
+		mutex_lock_nested(&h_inode->i_mutex, AuLsc_I_CHILD);
+		err = au_sio_cpup_single(src_dentry, a->bdst, a->bsrc, -1,
+					 AuCpup_KEEPLINO, a->parent);
+		mutex_unlock(&h_inode->i_mutex);
+		au_set_h_dptr(src_dentry, a->bdst, NULL);
+		au_set_dbstart(src_dentry, a->bsrc);
+	} else {
+		/* the inode of src_dentry already exists on a.bdst branch */
+		h_src_dentry = d_find_alias(h_inode);
+		if (h_src_dentry) {
+			/* vfsub_args_reinit(&a->vargs); */
+			vfsub_ign_hinode(&a->vargs, IN_CREATE,
+					 au_pinned_hdir(&a->pin));
+			err = vfsub_link(h_src_dentry, au_pinned_h_dir(&a->pin),
+					 a->h_dentry, &a->vargs);
+			dput(h_src_dentry);
+		} else {
+			AuIOErr("no dentry found for i%lu on b%d\n",
+				h_inode->i_ino, a->bdst);
+			err = -EIO;
+		}
+	}
+
+	if (!err)
+		au_plink_append(src_dentry->d_sb, src_dentry->d_inode,
+				a->h_dentry, a->bdst);
+
+	AuTraceErr(err);
+	return err;
+}
+
+int aufs_link(struct dentry *src_dentry, struct inode *dir,
+	      struct dentry *dentry)
+{
+	int err, rerr;
+	struct au_dtime dt;
+	struct super_block *sb;
+	struct au_link_args *a;
+	struct au_wr_dir_args wr_dir_args = {
+		/* .force_btgt	= -1, */
+		.flags		= AuWrDir_ADD_ENTRY
+	};
+	struct dentry *wh_dentry, *h_src_dentry;
+	struct inode *inode;
+
+	LKTRTrace("src %.*s, i%lu, dst %.*s\n",
+		  AuDLNPair(src_dentry), dir->i_ino, AuDLNPair(dentry));
+	IMustLock(dir);
+	inode = src_dentry->d_inode;
+	IMustLock(inode);
+	AuDebugOn(S_ISDIR(inode->i_mode));
+
+	err = -ENOMEM;
+	a = kzalloc(sizeof(*a), GFP_NOFS);
+	if (unlikely(!a))
+		goto out;
+
+	sb = dentry->d_sb;
+	a->parent = dentry->d_parent; /* dir inode is locked */
+	aufs_read_and_write_lock2(dentry, src_dentry, /*AuLock_FLUSH*/0);
+	a->src_parent = dget_parent(src_dentry);
+	wr_dir_args.force_btgt = au_dbstart(src_dentry);
+	a->mnt_flags = au_mntflags(sb);
+	vfsub_args_init(&a->vargs, &a->ign, au_test_dlgt(a->mnt_flags), 0);
+
+	di_write_lock_parent(a->parent);
+	wr_dir_args.force_btgt = au_wbr(dentry, wr_dir_args.force_btgt);
+	wh_dentry = lock_hdir_lkup_wh(dentry, &dt, src_dentry, &a->pin,
+				      &wr_dir_args);
+	err = PTR_ERR(wh_dentry);
+	if (IS_ERR(wh_dentry))
+		goto out_unlock;
+	err = 0;
+
+	a->bdst = au_dbstart(dentry);
+	a->h_dentry = au_h_dptr(dentry, a->bdst);
+
+	/* todo: minor optimize,
+	   their sb may be same while their bindex differs? */
+	a->bsrc = au_dbstart(src_dentry);
+	if (au_opt_test(a->mnt_flags, PLINK)) {
+		if (a->bdst < a->bsrc
+		    /* && h_src_dentry->d_sb != a->h_dentry->d_sb */)
+			err = au_cpup_or_link(src_dentry, a);
+		else {
+			h_src_dentry = au_h_dptr(src_dentry, a->bdst);
+			AuDebugOn(!h_src_dentry);
+			AuDebugOn(!h_src_dentry->d_inode);
+			vfsub_ign_hinode(&a->vargs, IN_CREATE,
+					 au_pinned_hdir(&a->pin));
+			err = vfsub_link(h_src_dentry, au_pinned_h_dir(&a->pin),
+					 a->h_dentry, &a->vargs);
+		}
+	} else {
+		/*
+		 * copyup src_dentry to the branch we process,
+		 * and then link(2) to it.
+		 */
+		if (a->bdst < a->bsrc
+		    /* && h_src_dentry->d_sb != a->h_dentry->d_sb */) {
+			au_unpin(&a->pin);
+			di_write_unlock(a->parent);
+			err = au_cpup_before_link(src_dentry, dir, dentry, a);
+			if (!err) {
+				a->pin_flags
+					= AuPin_DI_LOCKED | AuPin_MNT_WRITE;
+				if (au_opt_test(a->mnt_flags, UDBA_INOTIFY))
+					au_fset_pin(a->pin_flags, DO_GPARENT);
+				di_write_lock_parent(a->parent);
+				err = au_pin(&a->pin, dentry, a->bdst,
+					     a->pin_flags);
+				if (unlikely(err))
+					goto out_wh;
+			}
+		}
+		if (!err) {
+			/* vfsub_args_reinit(&a->vargs); */
+			vfsub_ign_hinode(&a->vargs, IN_CREATE,
+					 au_pinned_hdir(&a->pin));
+			h_src_dentry = au_h_dptr(src_dentry, a->bdst);
+			err = vfsub_link(h_src_dentry, au_pinned_h_dir(&a->pin),
+					 a->h_dentry, &a->vargs);
+		}
+	}
+	if (unlikely(err))
+		goto out_unpin;
+
+	if (wh_dentry) {
+		err = au_wh_unlink_dentry(au_pinned_hdir(&a->pin), wh_dentry,
+					  dentry, /*dlgt*/0);
+		if (unlikely(err))
+			goto out_revert;
+	}
+
+#if 0 /* cannot support it */
+	/* fuse has different memory inode for the same inode number */
+	if (au_test_fuse(a->h_dentry->d_sb)) {
+		LKTRLabel(here);
+		d_drop(a->h_dentry);
+		/*d_drop(h_src_dentry);
+		  d_drop(src_dentry);*/
+		inc_nlink(a->inode);
+		a->inode->i_ctime = dir->i_ctime;
+	}
+#endif
+
+	dir->i_version++;
+	if (au_ibstart(dir) == au_dbstart(dentry))
+		au_cpup_attr_timesizes(dir);
+	if (!d_unhashed(a->h_dentry)
+	    /* || h_old_inode->i_nlink <= nlink */
+	    /* || SB_NFS(h_src_dentry->d_sb) */) {
+		d_instantiate(dentry, au_igrab(inode));
+		inc_nlink(inode);
+		inode->i_ctime = dir->i_ctime;
+	} else
+		/* nfs case (< 2.6.15) */
+		d_drop(dentry);
+	goto out_unpin; /* success */
+
+ out_revert:
+	vfsub_args_reinit(&a->vargs);
+	vfsub_ign_hinode(&a->vargs, IN_DELETE, au_pinned_hdir(&a->pin));
+	rerr = vfsub_unlink(au_pinned_h_dir(&a->pin), a->h_dentry, &a->vargs);
+	if (!rerr)
+		goto out_dt;
+	AuIOErr("%.*s reverting failed(%d, %d)\n",
+		AuDLNPair(dentry), err, rerr);
+	err = -EIO;
+ out_dt:
+	d_drop(dentry);
+	au_dtime_revert(&dt);
+ out_unpin:
+	au_unpin(&a->pin);
+ out_wh:
+	dput(wh_dentry);
+ out_unlock:
+	if (unlikely(err)) {
+		au_update_dbstart(dentry);
+		d_drop(dentry);
+	}
+	di_write_unlock(a->parent);
+	dput(a->src_parent);
+	aufs_read_and_write_unlock2(dentry, src_dentry);
+	kfree(a);
+ out:
+	AuTraceErr(err);
+	if (unlikely(err == -EBUSY && au_test_nfsd(current)))
+		err = -ESTALE;
+	return err;
+}
+
+int aufs_mkdir(struct inode *dir, struct dentry *dentry, int mode)
+{
+	int err, rerr;
+	struct dentry *h_dentry, *wh_dentry, *parent, *opq_dentry;
+	struct mutex *h_mtx;
+	struct au_dtime dt;
+	aufs_bindex_t bindex;
+	unsigned char diropq, dlgt;
+	unsigned int mnt_flags;
+	struct au_hin_ignore ign;
+	struct vfsub_args vargs;
+	struct au_pin pin;
+	struct au_wr_dir_args wr_dir_args = {
+		.force_btgt	= -1,
+		.flags		= AuWrDir_ADD_ENTRY | AuWrDir_ISDIR
+	};
+
+	LKTRTrace("i%lu, %.*s, mode 0%o\n",
+		  dir->i_ino, AuDLNPair(dentry), mode);
+	IMustLock(dir);
+
+	aufs_read_lock(dentry, AuLock_DW);
+	parent = dentry->d_parent; /* dir inode is locked */
+	mnt_flags = au_mntflags(dentry->d_sb);
+	dlgt = !!au_test_dlgt(mnt_flags);
+	vfsub_args_init(&vargs, &ign, dlgt, 0);
+
+	di_write_lock_parent(parent);
+	wh_dentry = lock_hdir_lkup_wh(dentry, &dt, /*src_dentry*/NULL, &pin,
+				      &wr_dir_args);
+	err = PTR_ERR(wh_dentry);
+	if (IS_ERR(wh_dentry))
+		goto out;
+
+	bindex = au_dbstart(dentry);
+	h_dentry = au_h_dptr(dentry, bindex);
+	vfsub_ign_hinode(&vargs, IN_CREATE, au_pinned_hdir(&pin));
+	err = vfsub_mkdir(au_pinned_h_dir(&pin), h_dentry, mode, &vargs);
+	if (unlikely(err))
+		goto out_unlock;
+
+	/* make the dir opaque */
+	diropq = 0;
+	h_mtx = &h_dentry->d_inode->i_mutex;
+	if (wh_dentry || au_opt_test(mnt_flags, ALWAYS_DIROPQ)) {
+		mutex_lock_nested(h_mtx, AuLsc_I_CHILD);
+		opq_dentry = au_diropq_create(dentry, bindex, /*dlgt*/0);
+		mutex_unlock(h_mtx);
+		err = PTR_ERR(opq_dentry);
+		if (IS_ERR(opq_dentry))
+			goto out_dir;
+		dput(opq_dentry);
+		diropq = 1;
+	}
+
+	err = epilog(dir, bindex, wh_dentry, dentry);
+	if (!err) {
+		inc_nlink(dir);
+		goto out_unlock; /* success */
+	}
+
+	/* revert */
+	if (diropq) {
+		LKTRLabel(revert opq);
+		mutex_lock_nested(h_mtx, AuLsc_I_CHILD);
+		rerr = au_diropq_remove(dentry, bindex, dlgt);
+		mutex_unlock(h_mtx);
+		if (rerr) {
+			AuIOErr("%.*s reverting diropq failed(%d, %d)\n",
+				AuDLNPair(dentry), err, rerr);
+			err = -EIO;
+		}
+	}
+
+ out_dir:
+	LKTRLabel(revert dir);
+	vfsub_args_reinit(&vargs);
+	vfsub_ign_hinode(&vargs, IN_DELETE, au_pinned_hdir(&pin));
+	rerr = vfsub_rmdir(au_pinned_h_dir(&pin), h_dentry, &vargs);
+	if (rerr) {
+		AuIOErr("%.*s reverting dir failed(%d, %d)\n",
+			AuDLNPair(dentry), err, rerr);
+		err = -EIO;
+	}
+	d_drop(dentry);
+	au_dtime_revert(&dt);
+ out_unlock:
+	au_unpin(&pin);
+	dput(wh_dentry);
+ out:
+	if (unlikely(err)) {
+		au_update_dbstart(dentry);
+		d_drop(dentry);
+	}
+	di_write_unlock(parent);
+	aufs_read_unlock(dentry, AuLock_DW);
+	AuTraceErr(err);
+	if (unlikely(err == -EBUSY && au_test_nfsd(current)))
+		err = -ESTALE;
+	return err;
+}
diff -Nurp linux-2.6.27.orig/fs/aufs/i_op.c linux-2.6.27/fs/aufs/i_op.c
--- linux-2.6.27.orig/fs/aufs/i_op.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.27/fs/aufs/i_op.c	2008-12-14 10:37:40.000000000 +0100
@@ -0,0 +1,1049 @@
+/*
+ * Copyright (C) 2005-2008 Junjiro Okajima
+ *
+ * This program, aufs is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+ */
+
+/*
+ * inode operations (except add/del/rename)
+ *
+ * $Id: i_op.c,v 1.27 2008/12/08 06:12:31 sfjro Exp $
+ */
+
+#include <linux/fs_stack.h>
+#include <linux/uaccess.h>
+#include "aufs.h"
+
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 27)
+static int h_permission(struct inode *h_inode, int mask,
+			struct vfsmount *h_mnt, int brperm, int dlgt)
+{
+	int err, submask;
+	const int write_mask = (mask & (MAY_WRITE | MAY_APPEND));
+
+	LKTRTrace("ino %lu, mask 0x%x, brperm 0x%x\n",
+		  h_inode->i_ino, mask, brperm);
+
+	err = -EACCES;
+	if ((write_mask && IS_IMMUTABLE(h_inode))
+	    || ((mask & MAY_EXEC) && S_ISREG(h_inode->i_mode)
+		&& (h_mnt->mnt_flags & MNT_NOEXEC)))
+		goto out;
+
+	/*
+	 * - skip hidden fs test in the case of write to ro branch.
+	 * - nfs dir permission write check is optimized, but a policy for
+	 *   link/rename requires a real check.
+	 */
+	submask = mask & ~MAY_APPEND;
+	if ((write_mask && !au_br_writable(brperm))
+	    || (au_test_nfs(h_inode->i_sb) && S_ISDIR(h_inode->i_mode)
+		&& write_mask && !(mask & MAY_READ))
+	    || !h_inode->i_op
+	    || !h_inode->i_op->permission) {
+		/* LKTRLabel(generic_permission); */
+		err = generic_permission(h_inode, submask, NULL);
+	} else {
+		/* LKTRLabel(h_inode->permission); */
+		err = h_inode->i_op->permission(h_inode, submask);
+		AuTraceErr(err);
+	}
+
+#if 1 /* todo: export? */
+	if (!err)
+		err = au_security_inode_permission(h_inode, mask, NULL,
+						   dlgt);
+#endif
+
+ out:
+	AuTraceErr(err);
+	return err;
+}
+
+static int aufs_permission(struct inode *inode, int mask)
+{
+	int err;
+	aufs_bindex_t bindex, bend;
+	unsigned char dlgt;
+	const unsigned char isdir = S_ISDIR(inode->i_mode);
+	struct inode *h_inode;
+	struct super_block *sb;
+	unsigned int mnt_flags;
+	const int write_mask = (mask & (MAY_WRITE | MAY_APPEND));
+
+	LKTRTrace("ino %lu, mask 0x%x, isdir %d, write_mask %d\n",
+		  inode->i_ino, mask, isdir, write_mask);
+
+	sb = inode->i_sb;
+	si_read_lock(sb, AuLock_FLUSH);
+	ii_read_lock_child(inode);
+	mnt_flags = au_mntflags(sb);
+	dlgt = !!au_test_dlgt(mnt_flags);
+
+	if (!isdir || write_mask || au_test_dirperm1(mnt_flags)) {
+		h_inode = au_h_iptr(inode, au_ibstart(inode));
+		AuDebugOn(!h_inode
+			  || ((h_inode->i_mode & S_IFMT)
+			      != (inode->i_mode & S_IFMT)));
+		err = 0;
+		bindex = au_ibstart(inode);
+		LKTRTrace("b%d\n", bindex);
+		err = h_permission(h_inode, mask, au_sbr_mnt(sb, bindex),
+				   au_sbr_perm(sb, bindex), dlgt);
+
+		if (write_mask && !err) {
+			/* test whether the upper writable branch exists */
+			err = -EROFS;
+			for (; bindex >= 0; bindex--)
+				if (!au_br_rdonly(au_sbr(sb, bindex))) {
+					err = 0;
+					break;
+				}
+		}
+		goto out;
+	}
+
+	/* non-write to dir */
+	err = 0;
+	bend = au_ibend(inode);
+	for (bindex = au_ibstart(inode); !err && bindex <= bend; bindex++) {
+		h_inode = au_h_iptr(inode, bindex);
+		if (!h_inode)
+			continue;
+		AuDebugOn(!S_ISDIR(h_inode->i_mode));
+
+		LKTRTrace("b%d\n", bindex);
+		err = h_permission(h_inode, mask, au_sbr_mnt(sb, bindex),
+				   au_sbr_perm(sb, bindex), dlgt);
+	}
+
+ out:
+	ii_read_unlock(inode);
+	si_read_unlock(sb);
+	AuTraceErr(err);
+	if (unlikely(err == -EBUSY && au_test_nfsd(current)))
+		err = -ESTALE;
+	return err;
+}
+#else
+
+static int silly_lock(struct inode *inode, struct nameidata *nd)
+{
+	int locked = 0;
+	struct super_block *sb = inode->i_sb;
+
+	LKTRTrace("i%lu, nd %p\n", inode->i_ino, nd);
+
+	if (!nd || !nd->path.dentry) {
+		si_read_lock(sb, AuLock_FLUSH);
+		ii_read_lock_child(inode);
+	} else if (nd->path.dentry->d_inode != inode) {
+		locked = 1;
+		/* lock child first, then parent */
+		si_read_lock(sb, AuLock_FLUSH);
+		ii_read_lock_child(inode);
+		di_read_lock_parent(nd->path.dentry, 0);
+	} else {
+		locked = 2;
+		aufs_read_lock(nd->path.dentry, AuLock_FLUSH | AuLock_IR);
+	}
+	return locked;
+}
+
+static void silly_unlock(int locked, struct inode *inode, struct nameidata *nd)
+{
+	struct super_block *sb = inode->i_sb;
+
+	LKTRTrace("locked %d, i%lu, nd %p\n", locked, inode->i_ino, nd);
+
+	switch (locked) {
+	case 0:
+		ii_read_unlock(inode);
+		si_read_unlock(sb);
+		break;
+	case 1:
+		di_read_unlock(nd->path.dentry, 0);
+		ii_read_unlock(inode);
+		si_read_unlock(sb);
+		break;
+	case 2:
+		aufs_read_unlock(nd->path.dentry, AuLock_IR);
+		break;
+	default:
+		BUG();
+	}
+}
+
+static int h_permission(struct inode *h_inode, int mask,
+			struct nameidata *fake_nd, int brperm, int dlgt)
+{
+	int err, submask;
+	const int write_mask = (mask & (MAY_WRITE | MAY_APPEND));
+
+	LKTRTrace("ino %lu, mask 0x%x, brperm 0x%x\n",
+		  h_inode->i_ino, mask, brperm);
+
+	err = -EACCES;
+	if ((write_mask && IS_IMMUTABLE(h_inode))
+	    || ((mask & MAY_EXEC) && S_ISREG(h_inode->i_mode)
+		&& fake_nd && fake_nd->path.mnt
+		&& (fake_nd->path.mnt->mnt_flags & MNT_NOEXEC)))
+		goto out;
+
+	/*
+	 * - skip hidden fs test in the case of write to ro branch.
+	 * - nfs dir permission write check is optimized, but a policy for
+	 *   link/rename requires a real check.
+	 */
+	submask = mask & ~MAY_APPEND;
+	if ((write_mask && !au_br_writable(brperm))
+	    || (au_test_nfs(h_inode->i_sb) && S_ISDIR(h_inode->i_mode)
+		&& write_mask && !(mask & MAY_READ))
+	    || !h_inode->i_op
+	    || !h_inode->i_op->permission) {
+		/* LKTRLabel(generic_permission); */
+		err = generic_permission(h_inode, submask, NULL);
+	} else {
+		/* LKTRLabel(h_inode->permission); */
+		err = h_inode->i_op->permission(h_inode, submask, fake_nd);
+		AuTraceErr(err);
+	}
+
+#if 1 /* todo: export? */
+	if (!err)
+		err = au_security_inode_permission(h_inode, mask, fake_nd,
+						   dlgt);
+#endif
+
+ out:
+	AuTraceErr(err);
+	return err;
+}
+
+static int aufs_permission(struct inode *inode, int mask, struct nameidata *nd)
+{
+	int err;
+	aufs_bindex_t bindex, bend;
+	unsigned char locked, dlgt, do_nd;
+	const unsigned char isdir = S_ISDIR(inode->i_mode);
+	struct inode *h_inode;
+	struct super_block *sb;
+	unsigned int mnt_flags;
+	struct path path;
+	const int write_mask = (mask & (MAY_WRITE | MAY_APPEND));
+
+	LKTRTrace("ino %lu, mask 0x%x, isdir %d, write_mask %d, "
+		  "nd %d{%d, %d}\n",
+		  inode->i_ino, mask, isdir, write_mask,
+		  !!nd, nd ? !!nd->path.dentry : 0, nd ? !!nd->path.mnt : 0);
+
+	sb = inode->i_sb;
+	locked = silly_lock(inode, nd);
+	do_nd = (nd && locked >= 1);
+	mnt_flags = au_mntflags(sb);
+	dlgt = !!au_test_dlgt(mnt_flags);
+
+	if (!isdir || write_mask || au_test_dirperm1(mnt_flags)) {
+		h_inode = au_h_iptr(inode, au_ibstart(inode));
+		AuDebugOn(!h_inode
+			  || ((h_inode->i_mode & S_IFMT)
+			      != (inode->i_mode & S_IFMT)));
+		err = 0;
+		bindex = au_ibstart(inode);
+		LKTRTrace("b%d\n", bindex);
+		if (do_nd) {
+			path = nd->path;
+			nd->path.mnt = au_sbr_mnt(sb, bindex);
+			nd->path.dentry = au_h_dptr(nd->path.dentry, bindex);
+			path_get(&nd->path);
+			err = h_permission(h_inode, mask, nd,
+					   au_sbr_perm(sb, bindex), dlgt);
+			path_put(&nd->path);
+			nd->path = path;
+		} else {
+			AuDebugOn(nd && nd->path.mnt);
+			err = h_permission(h_inode, mask, nd,
+					   au_sbr_perm(sb, bindex), dlgt);
+		}
+
+		if (write_mask && !err) {
+			/* test whether the upper writable branch exists */
+			err = -EROFS;
+			for (; bindex >= 0; bindex--)
+				if (!au_br_rdonly(au_sbr(sb, bindex))) {
+					err = 0;
+					break;
+				}
+		}
+		goto out;
+	}
+
+	/* non-write to dir */
+	if (do_nd)
+		path = nd->path;
+	else {
+		path.mnt = NULL;
+		path.dentry = NULL;
+	}
+	err = 0;
+	bend = au_ibend(inode);
+	for (bindex = au_ibstart(inode); !err && bindex <= bend; bindex++) {
+		h_inode = au_h_iptr(inode, bindex);
+		if (!h_inode)
+			continue;
+		AuDebugOn(!S_ISDIR(h_inode->i_mode));
+
+		LKTRTrace("b%d\n", bindex);
+		if (do_nd) {
+			nd->path.mnt = au_sbr_mnt(sb, bindex);
+			nd->path.dentry = au_h_dptr(path.dentry, bindex);
+			path_get(&nd->path);
+			err = h_permission(h_inode, mask, nd,
+					   au_sbr_perm(sb, bindex), dlgt);
+			path_put(&nd->path);
+		} else {
+			AuDebugOn(nd && nd->path.mnt);
+			err = h_permission(h_inode, mask, nd,
+					   au_sbr_perm(sb, bindex), dlgt);
+		}
+	}
+	if (do_nd)
+		nd->path = path;
+
+ out:
+	silly_unlock(locked, inode, nd);
+	AuTraceErr(err);
+	if (unlikely(err == -EBUSY && au_test_nfsd(current)))
+		err = -ESTALE;
+	return err;
+}
+#endif /* KERNEL_VERSION(2, 6, 27) */
+
+/* ---------------------------------------------------------------------- */
+
+static struct dentry *aufs_lookup(struct inode *dir, struct dentry *dentry,
+				  struct nameidata *nd)
+{
+	struct dentry *ret, *parent;
+	int err, npositive;
+	struct inode *inode, *h_inode;
+	struct nameidata tmp_nd, *ndp;
+	aufs_bindex_t bstart;
+	struct mutex *mtx;
+	struct super_block *sb;
+
+	LKTRTrace("dir %lu, %.*s, nd{0x%x}\n",
+		  dir->i_ino, AuDLNPair(dentry), nd ? nd->flags : 0);
+	AuDebugOn(IS_ROOT(dentry));
+	IMustLock(dir);
+
+	sb = dir->i_sb;
+	si_read_lock(sb, AuLock_FLUSH);
+	err = au_alloc_dinfo(dentry);
+	ret = ERR_PTR(err);
+	if (unlikely(err))
+		goto out;
+
+	/* nd can be NULL */
+	ndp = au_dup_nd(au_sbi(sb), &tmp_nd, nd);
+	parent = dentry->d_parent; /* dir inode is locked */
+	di_read_lock_parent(parent, AuLock_IR);
+	npositive = au_lkup_dentry(dentry, au_dbstart(parent), /*type*/0, ndp);
+	di_read_unlock(parent, AuLock_IR);
+	err = npositive;
+	ret = ERR_PTR(err);
+	if (unlikely(err < 0))
+		goto out_unlock;
+
+	inode = NULL;
+	if (npositive) {
+		bstart = au_dbstart(dentry);
+		h_inode = au_h_dptr(dentry, bstart)->d_inode;
+		AuDebugOn(!h_inode);
+		if (!S_ISDIR(h_inode->i_mode)) {
+			/*
+			 * stop 'race'-ing between hardlinks under different
+			 * parents.
+			 */
+			mtx = &au_sbr(sb, bstart)->br_xino.xi_nondir_mtx;
+			mutex_lock(mtx);
+			inode = au_new_inode(dentry, /*must_new*/0);
+			mutex_unlock(mtx);
+		} else
+			inode = au_new_inode(dentry, /*must_new*/0);
+		ret = (void *)inode;
+	}
+	if (!IS_ERR(inode)) {
+		ret = d_splice_alias(inode, dentry);
+		if (unlikely(IS_ERR(ret) && inode))
+			ii_write_unlock(inode);
+		AuDebugOn(nd
+			  && (nd->flags & LOOKUP_OPEN)
+			  && nd->intent.open.file
+			  && nd->intent.open.file->f_dentry);
+		au_store_fmode_exec(nd, inode);
+	}
+
+ out_unlock:
+	di_write_unlock(dentry);
+ out:
+	si_read_unlock(sb);
+	AuTraceErrPtr(ret);
+	if (unlikely(err == -EBUSY && au_test_nfsd(current)))
+		err = -ESTALE;
+	return ret;
+}
+
+/* ---------------------------------------------------------------------- */
+
+/*
+ * decide the branch and the parent dir where we will create a new entry.
+ * returns new bindex or an error.
+ * copyup the parent dir if needed.
+ */
+int au_wr_dir(struct dentry *dentry, struct dentry *src_dentry,
+	      struct au_wr_dir_args *args)
+{
+	int err;
+	aufs_bindex_t bcpup, bstart, src_bstart;
+	struct super_block *sb;
+	struct dentry *parent;
+	struct au_sbinfo *sbinfo;
+	const int add_entry = au_ftest_wrdir(args->flags, ADD_ENTRY);
+
+	LKTRTrace("%.*s, src %p, {%d, 0x%x}\n",
+		  AuDLNPair(dentry), src_dentry, args->force_btgt, args->flags);
+
+	sb = dentry->d_sb;
+	sbinfo = au_sbi(sb);
+	parent = dget_parent(dentry);
+	bstart = au_dbstart(dentry);
+	bcpup = bstart;
+	if (args->force_btgt < 0) {
+		if (src_dentry) {
+			src_bstart = au_dbstart(src_dentry);
+			if (src_bstart < bstart)
+				bcpup = src_bstart;
+		} else if (add_entry) {
+			err = AuWbrCreate(sbinfo, dentry,
+					  au_ftest_wrdir(args->flags, ISDIR));
+			bcpup = err;
+		}
+
+		if (bcpup < 0 || au_test_ro(sb, bcpup, dentry->d_inode)) {
+			if (add_entry)
+				err = AuWbrCopyup(sbinfo, dentry);
+			else {
+				if (!IS_ROOT(dentry)) {
+					di_read_lock_parent(parent, !AuLock_IR);
+					err = AuWbrCopyup(sbinfo, dentry);
+					di_read_unlock(parent, !AuLock_IR);
+				} else
+					err = AuWbrCopyup(sbinfo, dentry);
+			}
+			bcpup = err;
+			if (unlikely(err < 0))
+				goto out;
+		}
+	} else {
+		bcpup = args->force_btgt;
+		AuDebugOn(au_test_ro(sb, bcpup, dentry->d_inode));
+	}
+	LKTRTrace("bstart %d, bcpup %d\n", bstart, bcpup);
+	if (bstart < bcpup)
+		au_update_dbrange(dentry, /*do_put_zero*/1);
+
+	err = bcpup;
+	if (bcpup == bstart)
+		goto out; /* success */
+
+	/* copyup the new parent into the branch we process */
+	if (add_entry) {
+		au_update_dbstart(dentry);
+		IMustLock(parent->d_inode);
+		DiMustWriteLock(parent);
+		IiMustWriteLock(parent->d_inode);
+	} else
+		di_write_lock_parent(parent);
+
+	err = 0;
+	if (!au_h_dptr(parent, bcpup)) {
+		if (bstart < bcpup)
+			err = au_cpdown_dirs(dentry, bcpup);
+		else
+			err = au_cpup_dirs(dentry, bcpup);
+	}
+	if (!err && add_entry) {
+		struct dentry *h_parent;
+		struct inode *h_dir;
+
+		h_parent = au_h_dptr(parent, bcpup);
+		AuDebugOn(!h_parent);
+		h_dir = h_parent->d_inode;
+		AuDebugOn(!h_dir);
+		mutex_lock_nested(&h_dir->i_mutex, AuLsc_I_PARENT);
+		err = au_lkup_neg(dentry, bcpup);
+		mutex_unlock(&h_dir->i_mutex);
+		if (bstart < bcpup && au_dbstart(dentry) < 0) {
+			au_set_dbstart(dentry, 0);
+			au_update_dbrange(dentry, /*do_put_zero*/0);
+		}
+	}
+
+	if (!add_entry)
+		di_write_unlock(parent);
+	if (!err)
+		err = bcpup; /* success */
+ out:
+	dput(parent);
+	LKTRTrace("err %d\n", err);
+	AuTraceErr(err);
+	return err;
+}
+
+/* ---------------------------------------------------------------------- */
+
+struct dentry *au_do_pinned_h_parent(struct au_pin1 *pin)
+{
+	if (pin && pin->parent)
+		return au_h_dptr(pin->parent, pin->bindex);
+	return NULL;
+}
+
+void au_do_unpin(struct au_pin1 *p, struct au_pin1 *gp)
+{
+	if (p->dentry)
+		LKTRTrace("%.*s\n", AuDLNPair(p->dentry));
+	LKTRTrace("p{%d, %d, %d, %d, 0x%x}, gp %p\n",
+		  p->lsc_di, p->lsc_hi, !!p->parent, !!p->h_dir, p->flags, gp);
+
+	if (au_ftest_pin(p->flags, MNT_WRITE))
+		au_br_drop_write(au_sbr(p->dentry->d_sb, p->bindex));
+	if (au_ftest_pin(p->flags, VFS_RENAME))
+		vfsub_unlock_rename_mutex(au_sbr_sb(p->dentry->d_sb,
+						    p->bindex));
+	if (!p->h_dir)
+		return;
+
+	mutex_unlock(&p->h_dir->i_mutex);
+	if (gp)
+		au_do_unpin(gp, NULL);
+	if (!au_ftest_pin(p->flags, DI_LOCKED))
+		di_read_unlock(p->parent, AuLock_IR);
+	iput(p->h_dir);
+	dput(p->parent);
+	p->parent = NULL;
+	p->h_dir = NULL;
+}
+
+int au_do_pin(struct au_pin1 *p, struct au_pin1 *gp)
+{
+	int err;
+	struct dentry *h_dentry;
+
+	LKTRTrace("%.*s, %d, b%d, 0x%x\n",
+		  AuDLNPair(p->dentry), !!gp, p->bindex, p->flags);
+	AuDebugOn(au_ftest_pin(p->flags, DO_GPARENT) && !gp);
+	/* AuDebugOn(!do_gp && gp); */
+
+	err = 0;
+	if (IS_ROOT(p->dentry)) {
+		if (au_ftest_pin(p->flags, VFS_RENAME))
+			vfsub_lock_rename_mutex(au_sbr_sb(p->dentry->d_sb,
+							  p->bindex));
+		if (au_ftest_pin(p->flags, MNT_WRITE)) {
+			err = au_br_want_write(au_sbr(p->dentry->d_sb,
+						      p->bindex));
+			if (unlikely(err))
+				au_fclr_pin(p->flags, MNT_WRITE);
+		}
+		goto out;
+	}
+
+	h_dentry = NULL;
+	if (p->bindex <= au_dbend(p->dentry))
+		h_dentry = au_h_dptr(p->dentry, p->bindex);
+
+	p->parent = dget_parent(p->dentry);
+	if (!au_ftest_pin(p->flags, DI_LOCKED))
+		di_read_lock(p->parent, AuLock_IR, p->lsc_di);
+	else
+		DiMustAnyLock(p->parent);
+	AuDebugOn(!p->parent->d_inode);
+	p->h_dir = au_igrab(au_h_iptr(p->parent->d_inode, p->bindex));
+	/* udba case */
+	if (unlikely(au_ftest_pin(p->flags, VERIFY) && !p->h_dir)) {
+		err = -EIO;
+		if (!au_ftest_pin(p->flags, DI_LOCKED))
+			di_read_unlock(p->parent, AuLock_IR);
+		dput(p->parent);
+		p->parent = NULL;
+		goto out;
+	}
+
+	if (au_ftest_pin(p->flags, DO_GPARENT)) {
+		gp->dentry = p->parent;
+		err = au_do_pin(gp, NULL);
+		if (unlikely(err))
+			gp->dentry = NULL;
+	}
+	if (au_ftest_pin(p->flags, VFS_RENAME))
+		vfsub_lock_rename_mutex(p->h_dir->i_sb);
+	mutex_lock_nested(&p->h_dir->i_mutex, p->lsc_hi);
+	if (!err) {
+		/* todo: call d_revalidate() here? */
+#if 0
+		if (h_dentry && h_dentry->d_op && h_dentry->d_op->d_revalidate
+		    && !h_dentry->d_op->d_revalidate(h_dentry, NULL))
+			err = -EIO;
+#endif
+		if (!h_dentry
+		    || !au_ftest_pin(p->flags, VERIFY)
+		    || !au_verify_parent(h_dentry, p->h_dir)) {
+			if (au_ftest_pin(p->flags, MNT_WRITE)) {
+				err = au_br_want_write(au_sbr(p->dentry->d_sb,
+							      p->bindex));
+				if (unlikely(err))
+					au_fclr_pin(p->flags, MNT_WRITE);
+			}
+			if (!err)
+				goto out; /* success */
+		} else
+			err = -EIO;
+	}
+
+	AuDbgDentry(p->dentry);
+	AuDbgDentry(h_dentry);
+	AuDbgDentry(p->parent);
+	AuDbgInode(p->h_dir);
+	if (h_dentry)
+		AuDbgDentry(h_dentry->d_parent);
+
+	au_do_unpin(p, gp);
+	if (au_ftest_pin(p->flags, DO_GPARENT))
+		gp->dentry = NULL;
+
+ out:
+	AuTraceErr(err);
+	return err;
+}
+
+void au_pin_init(struct au_pin *args, struct dentry *dentry,
+		 aufs_bindex_t bindex, int lsc_di, int lsc_hi,
+		 unsigned char flags)
+{
+	struct au_pin1 *p;
+	unsigned char f;
+
+	AuTraceEnter();
+
+	memset(args, 0, sizeof(*args));
+	p = args->pin + AuPin_PARENT;
+	p->dentry = dentry;
+	p->lsc_di = lsc_di;
+	p->lsc_hi = lsc_hi;
+	p->flags = flags;
+	p->bindex = bindex;
+	if (!au_opt_test(au_mntflags(dentry->d_sb), UDBA_NONE))
+		au_fset_pin(p->flags, VERIFY);
+	if (!au_ftest_pin(flags, DO_GPARENT))
+		return;
+
+	f = p->flags;
+	p = au_pin_gp(args);
+	if (p) {
+		p->lsc_di = lsc_di + 1; /* child first */
+		p->lsc_hi = lsc_hi - 1; /* parent first */
+		p->bindex = bindex;
+		p->flags = f & ~(AuPin_MNT_WRITE
+				| AuPin_DO_GPARENT
+				| AuPin_DI_LOCKED);
+	}
+}
+
+int au_pin(struct au_pin *args, struct dentry *dentry, aufs_bindex_t bindex,
+	   unsigned char flags)
+{
+	LKTRTrace("%.*s, b%d, 0x%x\n",
+		  AuDLNPair(dentry), bindex, flags);
+
+	au_pin_init(args, dentry, bindex, AuLsc_DI_PARENT, AuLsc_I_PARENT2,
+		    flags);
+	return au_do_pin(args->pin + AuPin_PARENT, au_pin_gp(args));
+}
+
+/* ---------------------------------------------------------------------- */
+
+struct au_icpup_args {
+	unsigned char isdir, hinotify, did_cpup; /* flags */
+	unsigned char pin_flags;
+	aufs_bindex_t btgt;
+	struct au_pin pin;
+	struct au_hin_ignore ign[2];
+	struct vfsub_args vargs;
+	struct dentry *h_dentry;
+	struct inode *h_inode;
+};
+
+/* todo: refine it */
+static int au_lock_and_icpup(struct dentry *dentry, loff_t sz,
+			     struct au_icpup_args *a)
+{
+	int err;
+	aufs_bindex_t bstart;
+	struct super_block *sb;
+	struct dentry *hi_wh, *parent;
+	struct inode *inode;
+	struct au_wr_dir_args wr_dir_args = {
+		.force_btgt	= -1,
+		.flags		= 0
+	};
+
+	LKTRTrace("%.*s, %lld\n", AuDLNPair(dentry), sz);
+
+	di_write_lock_child(dentry);
+	bstart = au_dbstart(dentry);
+	sb = dentry->d_sb;
+	inode = dentry->d_inode;
+	a->isdir = !!S_ISDIR(inode->i_mode);
+	if (a->isdir)
+		au_fset_wrdir(wr_dir_args.flags, ISDIR);
+	/* plink or hi_wh() */
+	if (bstart != au_ibstart(inode))
+		wr_dir_args.force_btgt = au_ibstart(inode);
+	err = au_wr_dir(dentry, /*src_dentry*/NULL, &wr_dir_args);
+	if (unlikely(err < 0))
+		goto out_dentry;
+	a->btgt = err;
+	a->did_cpup = (err != bstart);
+	err = 0;
+
+	/* crazy udba locks */
+	a->pin_flags = AuPin_MNT_WRITE;
+	a->hinotify = !!au_opt_test(au_mntflags(sb), UDBA_INOTIFY);
+	if (a->hinotify)
+		au_fset_pin(a->pin_flags, DO_GPARENT);
+	parent = NULL;
+	if (!IS_ROOT(dentry)) {
+		au_fset_pin(a->pin_flags, DI_LOCKED);
+		parent = dget_parent(dentry);
+		di_write_lock_parent(parent);
+	}
+	err = au_pin(&a->pin, dentry, a->btgt, a->pin_flags);
+	if (unlikely(err)) {
+		if (parent) {
+			di_write_unlock(parent);
+			dput(parent);
+		}
+		goto out_dentry;
+	}
+	a->h_dentry = au_h_dptr(dentry, bstart);
+	a->h_inode = a->h_dentry->d_inode;
+	AuDebugOn(!a->h_inode);
+	mutex_lock_nested(&a->h_inode->i_mutex, AuLsc_I_CHILD);
+	if (!a->did_cpup) {
+		au_unpin_gp(&a->pin);
+		if (parent) {
+			au_pin_set_parent_lflag(&a->pin, /*lflag*/0);
+			di_downgrade_lock(parent, AuLock_IR);
+			dput(parent);
+		}
+		goto out; /* success */
+	}
+
+	hi_wh = NULL;
+	if (!d_unhashed(dentry)) {
+		if (parent) {
+			au_pin_set_parent_lflag(&a->pin, /*lflag*/0);
+			di_downgrade_lock(parent, AuLock_IR);
+			dput(parent);
+		}
+		err = au_sio_cpup_simple(dentry, a->btgt, sz, AuCpup_DTIME);
+		if (!err)
+			a->h_dentry = au_h_dptr(dentry, a->btgt);
+	} else {
+		hi_wh = au_hi_wh(inode, a->btgt);
+		if (!hi_wh) {
+			err = au_sio_cpup_wh(dentry, a->btgt, sz,
+					     /*file*/NULL);
+			if (!err)
+				hi_wh = au_hi_wh(inode, a->btgt);
+			/* todo: revalidate hi_wh? */
+		}
+		if (parent) {
+			au_pin_set_parent_lflag(&a->pin, /*lflag*/0);
+			di_downgrade_lock(parent, AuLock_IR);
+			dput(parent);
+		}
+		if (!hi_wh)
+			a->h_dentry = au_h_dptr(dentry, a->btgt);
+		else
+			a->h_dentry = hi_wh; /* do not dget here */
+	}
+
+	mutex_unlock(&a->h_inode->i_mutex);
+	a->h_inode = a->h_dentry->d_inode;
+	AuDebugOn(!a->h_inode);
+	if (!err) {
+		mutex_lock_nested(&a->h_inode->i_mutex, AuLsc_I_CHILD);
+		au_unpin_gp(&a->pin);
+		goto out; /* success */
+	}
+
+	au_unpin(&a->pin);
+
+ out_dentry:
+	di_write_unlock(dentry);
+ out:
+	AuTraceErr(err);
+	return err;
+}
+
+static int aufs_setattr(struct dentry *dentry, struct iattr *ia)
+{
+	int err;
+	struct inode *inode;
+	struct super_block *sb;
+	__u32 events;
+	struct file *file;
+	loff_t sz;
+	struct au_icpup_args *a;
+
+	LKTRTrace("%.*s\n", AuDLNPair(dentry));
+	inode = dentry->d_inode;
+	IMustLock(inode);
+
+	err = -ENOMEM;
+	a = kzalloc(sizeof(*a), GFP_NOFS);
+	if (unlikely(!a))
+		goto out;
+
+	file = NULL;
+	sb = dentry->d_sb;
+	si_read_lock(sb, AuLock_FLUSH);
+	vfsub_args_init(&a->vargs, a->ign, au_test_dlgt(au_mntflags(sb)), 0);
+
+	if (ia->ia_valid & ATTR_FILE) {
+		/* currently ftruncate(2) only */
+		file = ia->ia_file;
+		fi_write_lock(file);
+		ia->ia_file = au_h_fptr(file, au_fbstart(file));
+	}
+
+	sz = -1;
+	if ((ia->ia_valid & ATTR_SIZE)
+	    && ia->ia_size < i_size_read(inode))
+		sz = ia->ia_size;
+	err = au_lock_and_icpup(dentry, sz, a);
+	if (unlikely(err < 0))
+		goto out_si;
+	if (a->did_cpup) {
+		ia->ia_file = NULL;
+		ia->ia_valid &= ~ATTR_FILE;
+	}
+
+	if ((ia->ia_valid & ATTR_SIZE)
+	    && ia->ia_size < i_size_read(inode)) {
+		err = vmtruncate(inode, ia->ia_size);
+		if (unlikely(err))
+			goto out_unlock;
+	}
+
+	if (ia->ia_valid & (ATTR_KILL_SUID | ATTR_KILL_SGID))
+		ia->ia_valid &= ~ATTR_MODE;
+
+	events = 0;
+	if (a->hinotify) {
+		events = vfsub_events_notify_change(ia);
+		if (events) {
+			if (a->isdir)
+				vfsub_ign_hinode(&a->vargs, events,
+						 au_hi(inode, a->btgt));
+			vfsub_ign_hinode(&a->vargs, events,
+					 au_pinned_hdir(&a->pin));
+		}
+	}
+	err = vfsub_notify_change(a->h_dentry, ia, &a->vargs);
+	if (!err)
+		au_cpup_attr_changeable(inode);
+
+ out_unlock:
+	mutex_unlock(&a->h_inode->i_mutex);
+	au_unpin(&a->pin);
+	di_write_unlock(dentry);
+ out_si:
+	if (file) {
+		fi_write_unlock(file);
+		ia->ia_file = file;
+		ia->ia_valid |= ATTR_FILE;
+	}
+	si_read_unlock(sb);
+	kfree(a);
+ out:
+	AuTraceErr(err);
+	if (unlikely(err == -EBUSY && au_test_nfsd(current)))
+		err = -ESTALE;
+	return err;
+}
+
+/* ---------------------------------------------------------------------- */
+
+static int h_readlink(struct dentry *dentry, int bindex, char __user *buf,
+		      int bufsiz)
+{
+	struct super_block *sb;
+	struct dentry *h_dentry;
+
+	LKTRTrace("%.*s, b%d, %d\n", AuDLNPair(dentry), bindex, bufsiz);
+
+	h_dentry = au_h_dptr(dentry, bindex);
+	if (unlikely(/* !h_dentry
+			|| !h_dentry->d_inode
+			|| */
+		    !h_dentry->d_inode->i_op
+		    || !h_dentry->d_inode->i_op->readlink))
+		return -EINVAL;
+
+	sb = dentry->d_sb;
+	if (!au_test_ro(sb, bindex, dentry->d_inode)) {
+		touch_atime(au_sbr_mnt(sb, bindex), h_dentry);
+		au_update_fuse_h_inode(NULL, h_dentry); /*ignore*/
+		fsstack_copy_attr_atime(dentry->d_inode, h_dentry->d_inode);
+	}
+	return h_dentry->d_inode->i_op->readlink(h_dentry, buf, bufsiz);
+}
+
+static int aufs_readlink(struct dentry *dentry, char __user *buf, int bufsiz)
+{
+	int err;
+
+	LKTRTrace("%.*s, %d\n", AuDLNPair(dentry), bufsiz);
+
+	aufs_read_lock(dentry, AuLock_IR);
+	err = h_readlink(dentry, au_dbstart(dentry), buf, bufsiz);
+	aufs_read_unlock(dentry, AuLock_IR);
+	AuTraceErr(err);
+	if (unlikely(err == -EBUSY && au_test_nfsd(current)))
+		err = -ESTALE;
+	return err;
+}
+
+static void *aufs_follow_link(struct dentry *dentry, struct nameidata *nd)
+{
+	int err;
+	char *buf;
+	mm_segment_t old_fs;
+
+	LKTRTrace("%.*s, nd %.*s\n",
+		  AuDLNPair(dentry), AuDLNPair(nd->path.dentry));
+
+	err = -ENOMEM;
+	buf = __getname();
+	if (unlikely(!buf))
+		goto out;
+
+	aufs_read_lock(dentry, AuLock_IR);
+	old_fs = get_fs();
+	set_fs(KERNEL_DS);
+	err = h_readlink(dentry, au_dbstart(dentry), (char __user *)buf,
+			 PATH_MAX);
+	set_fs(old_fs);
+	aufs_read_unlock(dentry, AuLock_IR);
+
+	if (err >= 0) {
+		buf[err] = 0;
+		/* will be freed by put_link */
+		nd_set_link(nd, buf);
+		return NULL; /* success */
+	}
+	__putname(buf);
+
+ out:
+	path_put(&nd->path);
+	AuTraceErr(err);
+	if (unlikely(err == -EBUSY && au_test_nfsd(current)))
+		err = -ESTALE;
+	return ERR_PTR(err);
+}
+
+static void aufs_put_link(struct dentry *dentry, struct nameidata *nd,
+			  void *cookie)
+{
+	LKTRTrace("%.*s\n", AuDLNPair(dentry));
+	__putname(nd_get_link(nd));
+}
+
+/* ---------------------------------------------------------------------- */
+
+static void aufs_truncate_range(struct inode *inode, loff_t start, loff_t end)
+{
+	AuUnsupport();
+}
+
+/* ---------------------------------------------------------------------- */
+
+struct inode_operations aufs_symlink_iop = {
+	.permission	= aufs_permission,
+	.setattr	= aufs_setattr,
+#ifdef CONFIG_AUFS_GETATTR
+	.getattr	= aufs_getattr,
+#endif
+
+	.readlink	= aufs_readlink,
+	.follow_link	= aufs_follow_link,
+	.put_link	= aufs_put_link
+};
+
+struct inode_operations aufs_dir_iop = {
+	.create		= aufs_create,
+	.lookup		= aufs_lookup,
+	.link		= aufs_link,
+	.unlink		= aufs_unlink,
+	.symlink	= aufs_symlink,
+	.mkdir		= aufs_mkdir,
+	.rmdir		= aufs_rmdir,
+	.mknod		= aufs_mknod,
+	.rename		= aufs_rename,
+
+	.permission	= aufs_permission,
+	.setattr	= aufs_setattr,
+#ifdef CONFIG_AUFS_GETATTR
+	.getattr	= aufs_getattr,
+#endif
+
+#if 0 /* reserved for future use */
+	.setxattr	= aufs_setxattr,
+	.getxattr	= aufs_getxattr,
+	.listxattr	= aufs_listxattr,
+	.removexattr	= aufs_removexattr
+#endif
+};
+
+struct inode_operations aufs_iop = {
+	.permission	= aufs_permission,
+	.setattr	= aufs_setattr,
+#ifdef CONFIG_AUFS_GETATTR
+	.getattr	= aufs_getattr,
+#endif
+
+#if 0 /* reserved for future use */
+	.setxattr	= aufs_setxattr,
+	.getxattr	= aufs_getxattr,
+	.listxattr	= aufs_listxattr,
+	.removexattr	= aufs_removexattr,
+#endif
+
+	.truncate_range	= aufs_truncate_range
+};
diff -Nurp linux-2.6.27.orig/fs/aufs/i_op_del.c linux-2.6.27/fs/aufs/i_op_del.c
--- linux-2.6.27.orig/fs/aufs/i_op_del.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.27/fs/aufs/i_op_del.c	2008-12-14 10:37:40.000000000 +0100
@@ -0,0 +1,566 @@
+/*
+ * Copyright (C) 2005-2008 Junjiro Okajima
+ *
+ * This program, aufs is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+ */
+
+/*
+ * inode operations (del entry)
+ *
+ * $Id: i_op_del.c,v 1.16 2008/12/08 06:12:07 sfjro Exp $
+ */
+
+#include "aufs.h"
+
+/* returns,
+ * 0: wh is unnecessary
+ * plus: wh is necessary
+ * minus: error
+ */
+int au_wr_dir_need_wh(struct dentry *dentry, int isdir, aufs_bindex_t *bcpup)
+{
+	int need_wh, err;
+	aufs_bindex_t bstart;
+	struct dentry *h_dentry;
+	struct super_block *sb;
+
+	LKTRTrace("%.*s, isdir %d, *bcpup %d\n",
+		  AuDLNPair(dentry), isdir, *bcpup);
+	sb = dentry->d_sb;
+
+	bstart = au_dbstart(dentry);
+	LKTRTrace("bcpup %d, bstart %d\n", *bcpup, bstart);
+	h_dentry = au_h_dptr(dentry, bstart);
+	if (*bcpup < 0) {
+		*bcpup = bstart;
+		if (au_test_ro(sb, bstart, dentry->d_inode)) {
+			err = AuWbrCopyup(au_sbi(sb), dentry);
+			*bcpup = err;
+			if (unlikely(err < 0))
+				goto out;
+		}
+	} else
+		AuDebugOn(bstart < *bcpup
+			  || au_test_ro(sb, *bcpup, dentry->d_inode));
+	LKTRTrace("bcpup %d, bstart %d\n", *bcpup, bstart);
+
+	if (*bcpup != bstart) {
+		err = au_cpup_dirs(dentry, *bcpup);
+		if (unlikely(err))
+			goto out;
+		need_wh = 1;
+	} else {
+		aufs_bindex_t old_bend, new_bend, bdiropq = -1;
+		old_bend = au_dbend(dentry);
+		if (isdir) {
+			bdiropq = au_dbdiropq(dentry);
+			au_set_dbdiropq(dentry, -1);
+		}
+		need_wh = au_lkup_dentry(dentry, bstart + 1, /*type*/0,
+					 /*nd*/NULL);
+		err = need_wh;
+		if (isdir)
+			au_set_dbdiropq(dentry, bdiropq);
+		if (unlikely(err < 0))
+			goto out;
+		new_bend = au_dbend(dentry);
+		if (!need_wh && old_bend != new_bend) {
+			au_set_h_dptr(dentry, new_bend, NULL);
+			au_set_dbend(dentry, old_bend);
+#if 0 /* todo: remove this? */
+		} else if (!au_h_dptr(dentry, new_bend)->d_inode) {
+			LKTRTrace("negative\n");
+			au_set_h_dptr(dentry, new_bend, NULL);
+			au_set_dbend(dentry, old_bend);
+			need_wh = 0;
+#endif
+		}
+	}
+	LKTRTrace("need_wh %d\n", need_wh);
+	err = need_wh;
+
+ out:
+	AuTraceErr(err);
+	return err;
+}
+
+/*
+ * simple tests for the removal inode operations.
+ * following the checks in vfs, plus the parent-child relationship.
+ */
+int au_may_del(struct dentry *dentry, aufs_bindex_t bindex,
+	       struct dentry *h_parent, int isdir, struct au_ndx *ndx)
+{
+	int err, exist;
+	struct super_block *sb;
+	struct dentry *h_dentry;
+	struct inode *h_inode;
+	umode_t h_mode;
+
+	LKTRTrace("%.*s/%.*s, b%d, dir %d\n",
+		  AuDLNPair(h_parent), AuDLNPair(dentry), bindex, isdir);
+
+	sb = dentry->d_sb;
+	exist = !!dentry->d_inode;
+	h_dentry = au_h_dptr(dentry, bindex);
+	h_inode = h_dentry->d_inode;
+	if (exist) {
+		err = -ENOENT;
+		if (unlikely(!h_inode || !h_inode->i_nlink))
+			goto out;
+
+		h_mode = h_inode->i_mode;
+		if (!isdir) {
+			err = -EISDIR;
+			if (unlikely(S_ISDIR(h_mode)))
+				goto out;
+		} else if (unlikely(!S_ISDIR(h_mode))) {
+			err = -ENOTDIR;
+			goto out;
+		}
+	} else {
+		/* rename(2) case */
+		err = -EIO;
+		if (unlikely(h_inode))
+			goto out;
+	}
+
+	err = -ENOENT;
+	/* expected parent dir is locked */
+	if (unlikely(h_parent != h_dentry->d_parent))
+		goto out;
+	err = 0;
+
+	/*
+	 * some filesystem may unlink a dir and corrupt its consistency.
+	 * so let's try heavy test.
+	 */
+	if (1 /*au_opt_test(au_mntflags(sb), UDBA_INOTIFY)*/) {
+		struct dentry *h_latest;
+		struct qstr *qstr = &dentry->d_name;
+
+		err = -EACCES;
+		if (unlikely(au_test_h_perm(h_parent->d_inode,
+					    MAY_EXEC | MAY_WRITE,
+					    au_ftest_ndx(ndx->flags, DLGT))))
+			goto out;
+
+		h_latest = au_sio_lkup_one(qstr->name, h_parent, qstr->len,
+					   ndx);
+		err = -EIO;
+		if (IS_ERR(h_latest))
+			goto out;
+		dput(h_latest);
+		if (h_latest == h_dentry)
+			err = 0;
+	}
+
+ out:
+	AuTraceErr(err);
+	return err;
+}
+
+static struct dentry *
+lock_hdir_create_wh(struct dentry *dentry, int isdir, aufs_bindex_t *rbcpup,
+		    struct au_dtime *dt, struct au_pin *pin)
+{
+	struct dentry *wh_dentry, *h_parent;
+	struct super_block *sb;
+	int err, need_wh;
+	unsigned int mnt_flags;
+	unsigned char pin_flags;
+	aufs_bindex_t bcpup;
+	struct au_ndx ndx;
+
+	LKTRTrace("%.*s, isdir %d\n", AuDLNPair(dentry), isdir);
+
+	need_wh = au_wr_dir_need_wh(dentry, isdir, rbcpup);
+	err = need_wh;
+	wh_dentry = ERR_PTR(err);
+	if (unlikely(err < 0))
+		goto out;
+
+	sb = dentry->d_sb;
+	mnt_flags = au_mntflags(sb);
+	bcpup = *rbcpup;
+	pin_flags = AuPin_DI_LOCKED | AuPin_MNT_WRITE;
+	if (au_opt_test(mnt_flags, UDBA_INOTIFY))
+		au_fset_pin(pin_flags, DO_GPARENT);
+	err = au_pin(pin, dentry, bcpup, pin_flags);
+	wh_dentry = ERR_PTR(err);
+	if (unlikely(err))
+		goto out;
+	h_parent = au_pinned_h_parent(pin);
+	if (!au_opt_test(mnt_flags, UDBA_NONE) && au_dbstart(dentry) == bcpup) {
+		ndx.nfsmnt = au_nfsmnt(sb, bcpup);
+		ndx.flags = 0;
+		if (au_test_dlgt(mnt_flags))
+			au_fset_ndx(ndx.flags, DLGT);
+		ndx.nd = NULL;
+		/* ndx.br = au_sbr(sb, bcpup); */
+		/* ndx.nd_file = NULL; */
+		err = au_may_del(dentry, bcpup, h_parent, isdir, &ndx);
+		wh_dentry = ERR_PTR(err);
+		if (unlikely(err))
+			goto out_unpin;
+	}
+
+	au_dtime_store(dt, au_pinned_parent(pin), h_parent, au_pinned_hdir(pin),
+		       au_pinned_hgdir(pin));
+	wh_dentry = NULL;
+	if (!need_wh)
+		goto out; /* success, no need to create whiteout */
+
+	ndx.nfsmnt = au_nfsmnt(sb, bcpup);
+	ndx.flags = 0;
+	if (au_test_dlgt(mnt_flags))
+		au_fset_ndx(ndx.flags, DLGT);
+	ndx.nd = NULL;
+	/* ndx.br = NULL; */
+	wh_dentry = au_wh_create(dentry, bcpup, h_parent, &ndx);
+	if (!IS_ERR(wh_dentry))
+		goto out; /* success */
+	/* returns with the parent is locked and wh_dentry is DGETed */
+
+ out_unpin:
+	au_unpin(pin);
+ out:
+	AuTraceErrPtr(wh_dentry);
+	return wh_dentry;
+}
+
+static int renwh_and_rmdir(struct dentry *dentry, aufs_bindex_t bindex,
+			   struct au_nhash *whlist, struct inode *dir)
+{
+	int rmdir_later, err;
+	struct dentry *h_dentry;
+	struct inode *inode, *h_inode;
+	struct super_block *sb;
+
+	LKTRTrace("%.*s, b%d\n", AuDLNPair(dentry), bindex);
+
+	inode = NULL;
+	h_inode = NULL;
+	sb = dentry->d_sb;
+	if (au_opt_test(au_mntflags(sb), UDBA_INOTIFY)) {
+		inode = dentry->d_inode;
+		h_inode = au_h_iptr(inode, bindex);
+		mutex_lock_nested(&h_inode->i_mutex, AuLsc_I_CHILD);
+	}
+	h_dentry = au_h_dptr(dentry, bindex);
+	err = au_whtmp_ren(dir, bindex, h_dentry);
+	if (inode) {
+		/* todo: bad approach? */
+		if (!err)
+			au_hin_suspend(au_hi(inode, bindex));
+		mutex_unlock(&h_inode->i_mutex);
+	}
+	if (unlikely(err))
+		goto out;
+
+	if (!au_test_nfs(h_dentry->d_sb)) {
+		const int dirwh = au_sbi(sb)->si_dirwh;
+		rmdir_later = (dirwh <= 1);
+		if (!rmdir_later)
+			rmdir_later = au_nhash_test_longer_wh(whlist, bindex,
+							      dirwh);
+		if (rmdir_later)
+			return rmdir_later;
+	}
+
+	err = au_whtmp_rmdir(dir, bindex, h_dentry, whlist);
+	if (unlikely(err)) {
+		AuIOErr("rmdir %.*s, b%d failed, %d. ignored\n",
+			AuDLNPair(h_dentry), bindex, err);
+		/* we do not revert the inotify watch */
+		err = 0;
+	}
+
+ out:
+	AuTraceErr(err);
+	return err;
+}
+
+static void epilog(struct inode *dir, struct dentry *dentry,
+		   aufs_bindex_t bindex)
+{
+	/* todo: unnecessary? */
+	d_drop(dentry);
+	dentry->d_inode->i_ctime = dir->i_ctime;
+
+	if (atomic_read(&dentry->d_count) == 1) {
+		au_set_h_dptr(dentry, au_dbstart(dentry), NULL);
+		au_update_dbstart(dentry);
+	}
+	if (au_ibstart(dir) == bindex)
+		au_cpup_attr_timesizes(dir);
+	dir->i_version++;
+}
+
+/* revert flags */
+#define AuRev_DLGT	1
+#define au_ftest_rev(flags, name)	((flags) & AuRev_##name)
+#define au_fset_rev(flags, name)	{ (flags) |= AuRev_##name; }
+#define au_fclr_rev(flags, name)	{ (flags) &= ~AuRev_##name; }
+#ifndef CONFIG_AUFS_DLGT
+#undef AuRev_DLGT
+#define AuRev_DLGT	0
+#endif
+
+static int do_revert(int err, struct inode *dir, aufs_bindex_t bwh,
+		     struct dentry *wh_dentry, struct dentry *dentry,
+		     struct au_dtime *dt, unsigned int flags)
+{
+	int rerr;
+
+	rerr = au_wh_unlink_dentry(au_hi(dir, bwh), wh_dentry, dentry,
+				   au_ftest_rev(flags, DLGT));
+	if (!rerr) {
+		au_set_dbwh(dentry, bwh);
+		au_dtime_revert(dt);
+		return 0;
+	}
+
+	AuIOErr("%.*s reverting whiteout failed(%d, %d)\n",
+		AuDLNPair(dentry), err, rerr);
+	return -EIO;
+}
+
+/* ---------------------------------------------------------------------- */
+
+int aufs_unlink(struct inode *dir, struct dentry *dentry)
+{
+	int err;
+	struct inode *inode, *h_dir;
+	struct dentry *parent, *wh_dentry, *h_dentry;
+	struct au_dtime dt;
+	aufs_bindex_t bwh, bindex, bstart;
+	unsigned char dlgt;
+	struct super_block *sb;
+	struct au_hin_ignore ign;
+	struct vfsub_args vargs;
+	struct au_pin pin;
+
+	LKTRTrace("i%lu, %.*s\n", dir->i_ino, AuDLNPair(dentry));
+	IMustLock(dir);
+	inode = dentry->d_inode;
+	if (unlikely(!inode))
+		return -ENOENT; /* possible? */
+	IMustLock(inode);
+
+	aufs_read_lock(dentry, AuLock_DW);
+	parent = dentry->d_parent; /* dir inode is locked */
+	di_write_lock_parent(parent);
+
+	bstart = au_dbstart(dentry);
+	bwh = au_dbwh(dentry);
+	bindex = -1;
+	wh_dentry = lock_hdir_create_wh(dentry, /*isdir*/0, &bindex, &dt, &pin);
+	err = PTR_ERR(wh_dentry);
+	if (IS_ERR(wh_dentry))
+		goto out;
+
+	sb = dir->i_sb;
+	dlgt = !!au_test_dlgt(au_mntflags(sb));
+	AuDebugOn(au_dbstart(dentry) != bstart);
+	h_dentry = au_h_dptr(dentry, bstart);
+	dget(h_dentry);
+
+	if (bindex == bstart) {
+		vfsub_args_init(&vargs, &ign, dlgt, 0);
+		vfsub_ign_hinode(&vargs, IN_DELETE, au_pinned_hdir(&pin));
+		h_dir = au_pinned_h_dir(&pin);
+		err = vfsub_unlink(h_dir, h_dentry, &vargs);
+	} else {
+		/* dir inode is locked */
+		AuDebugOn(!wh_dentry
+			  || wh_dentry->d_parent != au_h_dptr(parent, bindex));
+		h_dir = wh_dentry->d_parent->d_inode;
+		IMustLock(h_dir);
+		err = 0;
+	}
+
+	if (!err) {
+		drop_nlink(inode);
+#if 0 /* todo: update plink? */
+		if (!inode->i_nlink
+		    && au_opt_test(p->a.mnt_flags, PLINK)
+		    && au_plink_test(sb, inode)
+		    /* && atomic_read(&inode->i_count) == 2) */) {
+			au_debug_on();
+			DbgInode(inode);
+			au_debug_off();
+		}
+#endif
+		/*
+		 * although this is not a dir,
+		 * set it here since we need to detect the dead inode.
+		 */
+		if (!inode->i_nlink)
+			inode->i_flags |= S_DEAD;
+		epilog(dir, dentry, bindex);
+
+		/* update target timestamps */
+		if (bindex == bstart) {
+			au_update_fuse_h_inode(NULL, h_dentry); /*ignore*/
+			inode->i_ctime = h_dentry->d_inode->i_ctime;
+		} else
+			/* todo: this timestamp may be reverted later */
+			inode->i_ctime = h_dir->i_ctime;
+		goto out_unlock; /* success */
+	}
+
+	/* revert */
+	if (wh_dentry) {
+		int rerr;
+		unsigned int rev_flags;
+
+		rev_flags = 0;
+		if (dlgt)
+			au_fset_rev(rev_flags, DLGT);
+		rerr = do_revert(err, dir, bwh, wh_dentry, dentry, &dt,
+				 rev_flags);
+		if (rerr)
+			err = rerr;
+	}
+
+ out_unlock:
+	au_unpin(&pin);
+	dput(wh_dentry);
+	dput(h_dentry);
+ out:
+	di_write_unlock(parent);
+	aufs_read_unlock(dentry, AuLock_DW);
+	AuTraceErr(err);
+	if (unlikely(err == -EBUSY && au_test_nfsd(current)))
+		err = -ESTALE;
+	return err;
+}
+
+int aufs_rmdir(struct inode *dir, struct dentry *dentry)
+{
+	int err, rmdir_later;
+	struct inode *inode;
+	struct dentry *parent, *wh_dentry, *h_dentry;
+	struct au_dtime dt;
+	aufs_bindex_t bwh, bindex, bstart;
+	struct au_whtmp_rmdir_args *args;
+	struct au_nhash *whlist;
+	struct super_block *sb;
+	unsigned int mnt_flags;
+	struct au_pin pin;
+
+	LKTRTrace("i%lu, %.*s\n", dir->i_ino, AuDLNPair(dentry));
+	IMustLock(dir);
+	inode = dentry->d_inode;
+	err = -ENOENT; /* possible? */
+	if (unlikely(!inode))
+		goto out;
+	IMustLock(inode);
+
+	whlist = au_nhash_new(GFP_NOFS);
+	err = PTR_ERR(whlist);
+	if (IS_ERR(whlist))
+		goto out;
+
+	err = -ENOMEM;
+	args = kmalloc(sizeof(*args), GFP_NOFS);
+	if (unlikely(!args))
+		goto out_whlist;
+
+	aufs_read_lock(dentry, AuLock_DW);
+	parent = dentry->d_parent; /* dir inode is locked */
+	di_write_lock_parent(parent);
+	err = au_test_empty(dentry, whlist);
+	if (unlikely(err))
+		goto out_args;
+
+	bstart = au_dbstart(dentry);
+	bwh = au_dbwh(dentry);
+	bindex = -1;
+	wh_dentry = lock_hdir_create_wh(dentry, /*isdir*/1, &bindex, &dt, &pin);
+	err = PTR_ERR(wh_dentry);
+	if (IS_ERR(wh_dentry))
+		goto out_args;
+
+	AuDebugOn(au_dbstart(dentry) != bstart);
+	h_dentry = au_h_dptr(dentry, bstart);
+	dget(h_dentry);
+
+	rmdir_later = 0;
+	if (bindex == bstart) {
+		err = renwh_and_rmdir(dentry, bstart, whlist, dir);
+		if (err > 0) {
+			rmdir_later = err;
+			err = 0;
+		}
+	} else {
+		/* dir inode is locked */
+		AuDebugOn(!wh_dentry
+			  || wh_dentry->d_parent != au_h_dptr(parent, bindex));
+		IMustLock(wh_dentry->d_parent->d_inode);
+		err = 0;
+	}
+
+	sb = dentry->d_sb;
+	mnt_flags = au_mntflags(sb);
+	if (!err) {
+		if (au_opt_test(mnt_flags, UDBA_INOTIFY) && rmdir_later)
+			au_reset_hinotify(inode, /*flags*/0);
+		clear_nlink(inode);
+		inode->i_flags |= S_DEAD;
+		au_set_dbdiropq(dentry, -1);
+		epilog(dir, dentry, bindex);
+
+		if (rmdir_later) {
+			au_whtmp_kick_rmdir(dir, bstart, h_dentry, whlist,
+					    args);
+			args = NULL;
+		}
+
+		goto out_unlock; /* success */
+	}
+
+	/* revert */
+	LKTRLabel(revert);
+	if (wh_dentry) {
+		int rerr;
+		unsigned int rev_flags;
+
+		rev_flags = 0;
+		if (au_test_dlgt(mnt_flags))
+			au_fset_rev(rev_flags, DLGT);
+		rerr = do_revert(err, dir, bwh, wh_dentry, dentry, &dt,
+				 rev_flags);
+		if (rerr)
+			err = rerr;
+	}
+
+ out_unlock:
+	au_unpin(&pin);
+	dput(wh_dentry);
+	dput(h_dentry);
+ out_args:
+	di_write_unlock(parent);
+	aufs_read_unlock(dentry, AuLock_DW);
+	kfree(args);
+ out_whlist:
+	au_nhash_del(whlist);
+ out:
+	AuTraceErr(err);
+	if (unlikely(err == -EBUSY && au_test_nfsd(current)))
+		err = -ESTALE;
+	return err;
+}
diff -Nurp linux-2.6.27.orig/fs/aufs/i_op_ren.c linux-2.6.27/fs/aufs/i_op_ren.c
--- linux-2.6.27.orig/fs/aufs/i_op_ren.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.27/fs/aufs/i_op_ren.c	2008-12-14 10:37:40.000000000 +0100
@@ -0,0 +1,1261 @@
+/*
+ * Copyright (C) 2005-2008 Junjiro Okajima
+ *
+ * This program, aufs is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+ */
+
+/*
+ * inode operation (rename entry)
+ * todo: this is crazy monster
+ *
+ * $Id: i_op_ren.c,v 1.19 2008/12/08 06:12:11 sfjro Exp $
+ */
+
+#include "aufs.h"
+
+enum { SRC, DST };
+
+#define AuRen_ISDIR	1
+#define AuRen_ISSAMEDIR	(1 << 1)
+#define AuRen_WHSRC	(1 << 2)
+#define AuRen_WHDST	(1 << 3)
+#define AuRen_DLGT	(1 << 4)
+#define AuRen_VFSLOCK	(1 << 5)
+#define AuRen_PINNED	(1 << 6)
+#define AuRen_MNT_WRITE	(1 << 7)
+#define au_ftest_ren(flags, name)	((flags) & AuRen_##name)
+#define au_fset_ren(flags, name)	{ (flags) |= AuRen_##name; }
+#define au_fclr_ren(flags, name)	{ (flags) &= ~AuRen_##name; }
+#ifndef CONFIG_AUFS_DLGT
+#undef AuRen_DLGT
+#define AuRen_DLGT	0
+#endif
+
+struct au_ren_args {
+	/* original args */
+	struct dentry *src_dentry, *dentry;
+	struct inode *src_dir, *dir;
+
+	struct dentry *h_dentry[2], *h_parent[2], *h_trap, *h_locked[2];
+	/* todo: remove them */
+	struct dentry *parent[2], *gparent[2];
+	struct au_pin pin[2];
+	struct au_nhash whlist;
+	aufs_bindex_t btgt, bstart[2];
+	/* do_rename() only */
+	unsigned char need_diropq, bycpup;
+	struct super_block *sb;
+	unsigned int flags;
+	unsigned int mnt_flags;
+	struct au_ndx ndx;
+
+	/* do_rename() only */
+#ifdef CONFIG_AUFS_BR_NFS
+	struct au_hin_ignore ign[3];
+#else
+	struct au_hin_ignore ign[2];
+#endif
+	struct vfsub_args vargs;
+	struct au_whtmp_rmdir_args *thargs;
+	struct dentry *wh_dentry[2], *h_dst, *h_src;
+};
+
+/* ---------------------------------------------------------------------- */
+
+#define RevertFailure(fmt, args...) do { \
+		AuIOErrWhck("revert failure: " fmt " (%d, %d)\n", \
+			    ##args, err, rerr); \
+		err = -EIO; \
+	} while (0)
+
+static noinline_for_stack
+void au_ren_rev_diropq(int err, struct au_ren_args *a)
+{
+	int rerr;
+	struct mutex *h_mtx;
+
+	/* lock inode simply since inotify is not set to h_inode. */
+	h_mtx = &au_h_dptr(a->src_dentry, a->btgt)->d_inode->i_mutex;
+	mutex_lock_nested(h_mtx, AuLsc_I_CHILD);
+	rerr = au_diropq_remove(a->src_dentry, a->btgt,
+				au_ftest_ren(a->flags, DLGT));
+	mutex_unlock(h_mtx);
+	if (rerr)
+		RevertFailure("remove diropq %.*s", AuDLNPair(a->src_dentry));
+}
+
+static noinline_for_stack
+void au_ren_rev_rename(int err, struct au_ren_args *a)
+{
+	int rerr;
+	struct dentry *h_d;
+	struct qstr *name = &a->src_dentry->d_name;
+
+	h_d = au_lkup_one(name->name, a->h_parent[SRC], name->len, &a->ndx);
+	rerr = PTR_ERR(h_d);
+	if (IS_ERR(h_d)) {
+		RevertFailure("au_lkup_one %.*s", AuDLNPair(a->src_dentry));
+		return;
+	}
+
+	AuDebugOn(h_d->d_inode);
+	vfsub_args_reinit(&a->vargs);
+	vfsub_ign_hinode(&a->vargs, IN_MOVED_FROM,
+			 au_pinned_hdir(a->pin + DST));
+	vfsub_ign_hinode(&a->vargs, IN_MOVED_TO, au_pinned_hdir(a->pin + SRC));
+	rerr = vfsub_rename(au_pinned_h_dir(a->pin + DST),
+			    au_h_dptr(a->src_dentry, a->btgt),
+			    au_pinned_h_dir(a->pin + SRC), h_d, &a->vargs);
+	d_drop(h_d);
+	dput(h_d);
+	/* au_set_h_dptr(a->src_dentry, a->btgt, NULL); */
+	if (rerr)
+		RevertFailure("rename %.*s", AuDLNPair(a->src_dentry));
+}
+
+static noinline_for_stack
+void au_ren_rev_cpup(int err, struct au_ren_args *a)
+{
+	int rerr;
+
+	vfsub_args_reinit(&a->vargs);
+	vfsub_ign_hinode(&a->vargs, IN_DELETE, au_pinned_hdir(a->pin + DST));
+	rerr = vfsub_unlink(au_pinned_h_dir(a->pin + DST), a->h_dentry[DST],
+			    &a->vargs);
+	au_set_h_dptr(a->src_dentry, a->btgt, NULL);
+	au_set_dbstart(a->src_dentry, a->bstart[SRC]);
+	if (rerr)
+		RevertFailure("unlink %.*s", AuDLNPair(a->h_dentry[DST]));
+}
+
+static noinline_for_stack
+void au_ren_rev_whtmp(int err, struct au_ren_args *a)
+{
+	int rerr;
+	struct dentry *h_d;
+	struct mutex *h_mtx;
+	struct qstr *name = &a->dentry->d_name;
+
+	h_d = au_lkup_one(name->name, a->h_parent[DST], name->len, &a->ndx);
+	rerr = PTR_ERR(h_d);
+	if (IS_ERR(h_d)) {
+		RevertFailure("lookup %.*s", AuLNPair(name));
+		return;
+	}
+	if (h_d->d_inode) {
+		d_drop(h_d);
+		dput(h_d);
+		return;
+	}
+
+	h_mtx = &a->h_dst->d_inode->i_mutex;
+	mutex_lock_nested(h_mtx, AuLsc_I_CHILD);
+	au_hin_resume(au_hi(a->src_dentry->d_inode, a->btgt));
+	mutex_unlock(h_mtx);
+	vfsub_args_reinit(&a->vargs);
+	vfsub_ign_hinode(&a->vargs, IN_MOVED_TO | IN_MOVED_FROM,
+			 au_pinned_hdir(a->pin + DST));
+	rerr = vfsub_rename(au_pinned_h_dir(a->pin + DST), a->h_dst,
+			    au_pinned_h_dir(a->pin + DST), h_d, &a->vargs);
+	d_drop(h_d);
+	dput(h_d);
+	if (!rerr) {
+		au_set_h_dptr(a->dentry, a->btgt, NULL);
+		au_set_h_dptr(a->dentry, a->btgt, dget(a->h_dst));
+	} else
+		RevertFailure("rename %.*s", AuDLNPair(a->h_dst));
+}
+
+static noinline_for_stack
+void au_ren_rev_whsrc(int err, struct au_ren_args *a)
+{
+	int rerr;
+
+	rerr = au_wh_unlink_dentry(au_pinned_hdir(a->pin + SRC),
+				   a->wh_dentry[SRC], a->src_dentry, /*dlgt*/0);
+	if (rerr)
+		RevertFailure("unlink %.*s", AuDLNPair(a->wh_dentry[SRC]));
+}
+#undef RevertFailure
+
+/* ---------------------------------------------------------------------- */
+
+static /* noinline_for_stack */
+int au_ren_or_cpup(struct au_ren_args *a)
+{
+	int err;
+
+	AuTraceEnter();
+
+	if (au_dbstart(a->src_dentry) == a->btgt) {
+		if (a->need_diropq && au_dbdiropq(a->src_dentry) == a->btgt)
+			a->need_diropq = 0;
+		vfsub_ign_hinode(&a->vargs, IN_MOVED_FROM,
+				 au_pinned_hdir(a->pin + SRC));
+		vfsub_ign_hinode(&a->vargs, IN_MOVED_TO,
+				 au_pinned_hdir(a->pin + DST));
+		/* nfs_rename() calls d_delete() */
+		if (au_test_nfs(au_pinned_h_dir(a->pin + DST)->i_sb)
+		    && a->h_dentry[DST]->d_inode
+		    && (S_ISDIR(a->h_dentry[DST]->d_inode->i_mode)
+			|| atomic_read(&a->h_dentry[DST]->d_count) <= 2))
+			vfsub_ign_hinode(&a->vargs, IN_DELETE,
+					 au_pinned_hdir(a->pin + DST));
+		AuDebugOn(au_dbstart(a->src_dentry) != a->btgt);
+		err = vfsub_rename(au_pinned_h_dir(a->pin + SRC),
+				   au_h_dptr(a->src_dentry, a->btgt),
+				   au_pinned_h_dir(a->pin + DST),
+				   a->h_dentry[DST], &a->vargs);
+	} else {
+		struct mutex *h_mtx = &a->h_dentry[SRC]->d_inode->i_mutex;
+
+		a->bycpup = 1;
+		mutex_lock_nested(h_mtx, AuLsc_I_CHILD);
+		au_set_dbstart(a->src_dentry, a->btgt);
+		au_set_h_dptr(a->src_dentry, a->btgt, dget(a->h_dentry[DST]));
+		err = au_sio_cpup_single(a->src_dentry, a->btgt, a->bstart[SRC],
+					 -1, !AuCpup_DTIME, a->parent[DST]);
+		if (unlikely(err)) {
+			au_set_h_dptr(a->src_dentry, a->btgt, NULL);
+			au_set_dbstart(a->src_dentry, a->bstart[SRC]);
+		}
+		mutex_unlock(h_mtx);
+	}
+
+	return err;
+}
+
+static /* noinline_for_stack */
+int au_ren_del_whtmp(struct au_ren_args *a)
+{
+	int err;
+
+	AuTraceEnter();
+
+	if (au_test_nfs(a->h_dst->d_sb)
+	    || !au_nhash_test_longer_wh(&a->whlist, a->btgt,
+					au_sbi(a->sb)->si_dirwh)) {
+		err = au_whtmp_rmdir(a->dir, a->btgt, a->h_dst, &a->whlist);
+		if (unlikely(err))
+			AuWarn("failed removing whtmp dir %.*s (%d), "
+			       "ignored.\n", AuDLNPair(a->h_dst), err);
+	} else {
+		au_whtmp_kick_rmdir(a->dir, a->btgt, a->h_dst, &a->whlist,
+				    a->thargs);
+		dput(a->h_dst);
+		a->thargs = NULL;
+	}
+
+	return 0;
+}
+
+static /* noinline_for_stack */
+int au_ren_diropq(struct au_ren_args *a)
+{
+	int err;
+	struct dentry *diropq;
+	struct mutex *h_mtx;
+
+	AuTraceEnter();
+
+	err = 0;
+	h_mtx = &au_h_dptr(a->src_dentry, a->btgt)->d_inode->i_mutex;
+	mutex_lock_nested(h_mtx, AuLsc_I_CHILD);
+	diropq = au_diropq_create(a->src_dentry, a->btgt,
+				  au_ftest_ren(a->flags, DLGT));
+	mutex_unlock(h_mtx);
+	if (IS_ERR(diropq))
+		err = PTR_ERR(diropq);
+	dput(diropq);
+
+	return err;
+}
+
+static /* noinline_for_stack */
+int do_rename(struct au_ren_args *a)
+{
+	int err;
+	aufs_bindex_t bindex, bend;
+	struct dentry *h_d;
+
+	LKTRTrace("%.*s/%.*s, %.*s/%.*s, "
+		  "hd{%p, %p}, hp{%p, %p}, wh %p, btgt %d, bstart{%d, %d}, "
+		  "flags 0x%x\n",
+		  AuDLNPair(a->parent[SRC]), AuDLNPair(a->src_dentry),
+		  AuDLNPair(a->parent[DST]), AuDLNPair(a->dentry),
+		  a->h_dentry[SRC], a->h_dentry[DST],
+		  a->h_parent[SRC], a->h_parent[DST],
+		  &a->whlist, a->btgt,
+		  a->bstart[SRC], a->bstart[DST],
+		  a->flags);
+
+	/* prepare workqueue args */
+	if (au_ftest_ren(a->flags, ISDIR) && a->h_dentry[DST]->d_inode) {
+		err = -ENOMEM;
+		a->thargs = kmalloc(sizeof(*a->thargs), GFP_NOFS);
+		if (unlikely(!a->thargs))
+			goto out;
+		a->h_dst = dget(a->h_dentry[DST]);
+	}
+
+	a->ndx.nfsmnt = au_nfsmnt(a->sb, a->btgt);
+	if (au_ftest_ren(a->flags, DLGT))
+		au_fset_ndx(a->ndx.flags, DLGT);
+
+	/* create whiteout for src_dentry */
+	if (au_ftest_ren(a->flags, WHSRC)) {
+		a->wh_dentry[SRC] = au_wh_create(a->src_dentry, a->btgt,
+						 a->h_parent[SRC], &a->ndx);
+		err = PTR_ERR(a->wh_dentry[SRC]);
+		if (IS_ERR(a->wh_dentry[SRC]))
+			goto out_thargs;
+	}
+
+	/* lookup whiteout for dentry */
+	if (au_ftest_ren(a->flags, WHDST)) {
+		h_d = au_wh_lkup(a->h_parent[DST], &a->dentry->d_name, &a->ndx);
+		err = PTR_ERR(h_d);
+		if (IS_ERR(h_d))
+			goto out_whsrc;
+		if (!h_d->d_inode)
+			dput(h_d);
+		else
+			a->wh_dentry[DST] = h_d;
+	}
+
+	/* rename dentry to tmpwh */
+	if (a->thargs) {
+		struct au_hinode *hinode;
+
+		AuDbgDentry(a->h_dentry[DST]);
+		err = au_whtmp_ren(a->dir, a->btgt, a->h_dentry[DST]);
+		if (unlikely(err))
+			goto out_whdst;
+		AuDbgDentry(a->h_dentry[DST]);
+		hinode = au_hi(a->dentry->d_inode, a->btgt);
+		/* todo: bad approach? */
+		mutex_lock_nested(&hinode->hi_inode->i_mutex, AuLsc_I_CHILD);
+		au_hin_suspend(hinode);
+		mutex_unlock(&hinode->hi_inode->i_mutex);
+		au_set_h_dptr(a->dentry, a->btgt, NULL);
+		AuDbgDentry(a->h_dentry[DST]);
+		err = au_lkup_neg(a->dentry, a->btgt);
+		if (unlikely(err))
+			goto out_whtmp;
+		a->h_dentry[DST] = au_h_dptr(a->dentry, a->btgt);
+	}
+
+	/* cpup src */
+	if (a->h_dentry[DST]->d_inode && a->bstart[SRC] != a->btgt) {
+		struct mutex *h_mtx = &a->h_dentry[SRC]->d_inode->i_mutex;
+
+		mutex_lock_nested(h_mtx, AuLsc_I_CHILD);
+		err = au_sio_cpup_simple(a->src_dentry, a->btgt, -1,
+					 !AuCpup_DTIME);
+		mutex_unlock(h_mtx);
+		if (unlikely(err))
+			goto out_whtmp;
+	}
+
+	/* rename by vfs_rename or cpup */
+	a->need_diropq = au_ftest_ren(a->flags, ISDIR)
+		&& (a->wh_dentry[DST]
+		    || au_dbdiropq(a->dentry) == a->btgt
+		    /* hide the lower to keep xino */
+		    || a->btgt < au_dbend(a->dentry)
+		    || au_opt_test(a->mnt_flags, ALWAYS_DIROPQ));
+	a->bycpup = 0;
+	vfsub_args_init(&a->vargs, a->ign, au_ftest_ren(a->flags, DLGT), 0);
+	err = au_ren_or_cpup(a);
+	if (unlikely(err))
+		goto out_whtmp;
+
+	/* make dir opaque */
+	if (a->need_diropq) {
+		err = au_ren_diropq(a);
+		if (unlikely(err))
+			goto out_rename;
+	}
+
+	/* update target timestamps */
+	AuDebugOn(au_dbstart(a->src_dentry) != a->btgt);
+	a->h_src = au_h_dptr(a->src_dentry, a->btgt);
+	au_update_fuse_h_inode(NULL, a->h_src); /*ignore*/
+	/*
+	 * fsstack_copy_attr_atime(a->src_dentry->d_inode, a->h_src->d_inode);
+	 */
+	a->src_dentry->d_inode->i_ctime = a->h_src->d_inode->i_ctime;
+
+	/* remove whiteout for dentry */
+	if (a->wh_dentry[DST]) {
+		err = au_wh_unlink_dentry(au_pinned_hdir(a->pin + DST),
+					  a->wh_dentry[DST], a->dentry,
+					  /*dlgt*/0);
+		if (unlikely(err))
+			goto out_diropq;
+	}
+
+	/* remove whtmp */
+	if (a->thargs)
+		/* ignore this error */
+		au_ren_del_whtmp(a);
+
+	err = 0;
+	goto out_success;
+
+ out_diropq:
+	if (a->need_diropq)
+		au_ren_rev_diropq(err, a);
+ out_rename:
+	if (!a->bycpup)
+		au_ren_rev_rename(err, a);
+	else
+		au_ren_rev_cpup(err, a);
+ out_whtmp:
+	if (a->thargs)
+		au_ren_rev_whtmp(err, a);
+ out_whdst:
+	dput(a->wh_dentry[DST]);
+	a->wh_dentry[DST] = NULL;
+ out_whsrc:
+	if (a->wh_dentry[SRC])
+		au_ren_rev_whsrc(err, a);
+	d_drop(a->src_dentry);
+	bend = au_dbend(a->src_dentry);
+	for (bindex = au_dbstart(a->src_dentry); bindex <= bend; bindex++) {
+		h_d = au_h_dptr(a->src_dentry, bindex);
+		if (h_d)
+			d_drop(h_d);
+	}
+	d_drop(a->dentry);
+	bend = au_dbend(a->dentry);
+	for (bindex = au_dbstart(a->dentry); bindex <= bend; bindex++) {
+		h_d = au_h_dptr(a->dentry, bindex);
+		if (h_d)
+			d_drop(h_d);
+	}
+	au_update_dbstart(a->dentry);
+	if (a->thargs)
+		d_drop(a->h_dst);
+ out_success:
+	dput(a->wh_dentry[SRC]);
+	dput(a->wh_dentry[DST]);
+ out_thargs:
+	if (a->thargs) {
+		dput(a->h_dst);
+		kfree(a->thargs);
+	}
+ out:
+	AuTraceErr(err);
+	return err;
+}
+
+/*
+ * test if @dentry dir can be rename destination or not.
+ * success means, it is a logically empty dir.
+ */
+static int may_rename_dstdir(struct dentry *dentry, aufs_bindex_t btgt,
+			     struct au_nhash *whlist)
+{
+	LKTRTrace("%.*s\n", AuDLNPair(dentry));
+
+	return au_test_empty(dentry, whlist);
+}
+
+/*
+ * test if @dentry dir can be rename source or not.
+ * if it can, return 0 and @children is filled.
+ * success means,
+ * - or, it is a logically empty dir.
+ * - or, it exists on writable branch and has no children including whiteouts
+ *       on the lower branch.
+ */
+static int may_rename_srcdir(struct dentry *dentry, aufs_bindex_t btgt)
+{
+	int err;
+	aufs_bindex_t bstart;
+
+	LKTRTrace("%.*s\n", AuDLNPair(dentry));
+
+	bstart = au_dbstart(dentry);
+	if (bstart != btgt) {
+		struct au_nhash *whlist;
+
+		whlist = au_nhash_new(GFP_NOFS);
+		err = PTR_ERR(whlist);
+		if (IS_ERR(whlist))
+			goto out;
+		err = au_test_empty(dentry, whlist);
+		au_nhash_del(whlist);
+		goto out;
+	}
+
+	if (bstart == au_dbtaildir(dentry))
+		return 0; /* success */
+
+	err = au_test_empty_lower(dentry);
+
+ out:
+	if (/* unlikely */(err == -ENOTEMPTY)) {
+		AuWarn1("renaming dir who has child(ren) on multiple branches,"
+			" is not supported\n");
+		err = -EXDEV;
+	}
+	AuTraceErr(err);
+	return err;
+}
+
+/* mainly for link(2) and rename(2) */
+int au_wbr(struct dentry *dentry, aufs_bindex_t btgt)
+{
+	aufs_bindex_t bdiropq, bwh;
+	struct dentry *parent;
+
+	LKTRTrace("%.*s, b%d\n", AuDLNPair(dentry), btgt);
+	parent = dentry->d_parent;
+	IMustLock(parent->d_inode); /* dir is locked */
+
+	bdiropq = au_dbdiropq(parent);
+	bwh = au_dbwh(dentry);
+	if (au_br_rdonly(au_sbr(dentry->d_sb, btgt))
+		     || (0 <= bdiropq && bdiropq < btgt)
+		     || (0 <= bwh && bwh < btgt))
+		btgt = -1;
+
+	LKTRTrace("btgt %d\n", btgt);
+	return btgt;
+}
+
+/*
+ * simple tests for rename.
+ * following the checks in vfs, plus the parent-child relationship.
+ */
+static int au_may_ren(struct au_ren_args *a)
+{
+	int err;
+	struct inode *h_inode;
+
+	AuTraceEnter();
+
+	if (a->bstart[SRC] == a->btgt) {
+		err = au_may_del(a->src_dentry, a->btgt, a->h_parent[SRC],
+				 au_ftest_ren(a->flags, ISDIR), &a->ndx);
+		if (unlikely(err))
+			goto out;
+		err = -EINVAL;
+		if (unlikely(a->h_dentry[SRC] == a->h_trap))
+			goto out;
+	}
+
+	err = 0;
+	if (a->bstart[DST] != a->btgt)
+		goto out;
+
+	err = -EIO;
+	h_inode = a->h_dentry[DST]->d_inode;
+	if (!a->dentry->d_inode) {
+		if (unlikely(h_inode))
+			goto out;
+		err = au_may_add(a->dentry, a->btgt, a->h_parent[DST],
+				 au_ftest_ren(a->flags, ISDIR), &a->ndx);
+	} else {
+		if (unlikely(!h_inode || !h_inode->i_nlink))
+			goto out;
+		err = au_may_del(a->dentry, a->btgt, a->h_parent[DST],
+				 au_ftest_ren(a->flags, ISDIR), &a->ndx);
+		if (unlikely(err))
+			goto out;
+		err = -ENOTEMPTY;
+		if (unlikely(a->h_dentry[DST] == a->h_trap))
+			goto out;
+		err = 0;
+	}
+
+ out:
+	if (unlikely(err == -ENOENT || err == -EEXIST))
+		err = -EIO;
+	AuTraceErr(err);
+	return err;
+}
+
+/*
+ * locking order
+ * (VFS)
+ * - src_dir and dir by lock_rename()
+ * - inode if exitsts
+ * (aufs)
+ * - lock all
+ *   + src_dentry and dentry by aufs_read_and_write_lock2() which calls,
+ *     + si_read_lock
+ *     + di_write_lock2_child()
+ *       + di_write_lock_child()
+ *	   + ii_write_lock_child()
+ *       + di_write_lock_child2()
+ *	   + ii_write_lock_child2()
+ *     + src_parent and parent
+ *       + di_write_lock_parent()
+ *	   + ii_write_lock_parent()
+ *       + di_write_lock_parent2()
+ *	   + ii_write_lock_parent2()
+ *   + if udab=inotify is specified, lock grand parents (crazy)
+ *     + di_read_lock_gparent()
+ *       + ii_read_lock_gparent()
+ *     + di_read_lock_gparent2()
+ *       + ii_read_lock_gparent2()
+ *     + mutex_lock(s_vfs_rename_mutex)
+ *     + mutex_lock_gparent()
+ *     + mutex_lock_gparent2()
+ *     + mutex_lock_parent()
+ *     + mutex_lock_parent2()
+ *   + else lower src_dir and dir by vfsub_lock_rename()
+ *   + verify the every relations between child, parent and grand parent. if any
+ *     of them failed, unlock all and return -EBUSY.
+ */
+static void au_ren_pin_init(struct au_pin *first, struct dentry *d1,
+			    struct au_pin *next, struct dentry *d2,
+			    aufs_bindex_t bindex)
+{
+	AuTraceEnter();
+
+	/* AuLsc_DI_PARENT3 is for higher gparent initially */
+	au_pin_init(first, d1, bindex, AuLsc_DI_PARENT2, AuLsc_I_PARENT2,
+		    AuPin_DI_LOCKED | AuPin_DO_GPARENT);
+	/* AuLsc_DI_PARENT4 is for lower gparent initially */
+	au_pin_init(next, d2, bindex, AuLsc_DI_PARENT3, AuLsc_I_PARENT4,
+		    AuPin_DI_LOCKED | AuPin_DO_GPARENT);
+}
+
+static void au_ren_fake_pin(struct au_ren_args *a)
+{
+	int i;
+	struct au_pin1 *p;
+	struct inode *h_i;
+
+	AuTraceEnter();
+
+	/* they increment the ref counter */
+	for (i = 0; i < 2; i++) {
+		p = a->pin[i].pin + AuPin_PARENT;
+		au_pin_set_parent(a->pin + i, a->parent[i]);
+		dput(a->parent[i]);
+		h_i = a->h_parent[i]->d_inode;
+		au_pin_set_h_dir(a->pin + i, h_i);
+		iput(h_i);
+
+		if (!a->gparent[i]) {
+			au_pin_set_gparent(a->pin + i, NULL);
+			au_pin_set_h_gdir(a->pin + i, NULL);
+		} else {
+			au_pin_set_gparent(a->pin + i, a->gparent[i]);
+			dput(a->gparent[i]);
+			h_i = au_h_iptr(a->gparent[i]->d_inode, a->btgt);
+			au_pin_set_h_gdir(a->pin + i, h_i);
+			iput(h_i);
+		}
+	}
+}
+
+/* crazy */
+/* cf. i_op.c: au_do_pin() */
+static int au_ren_pin4(int higher, int lower, struct au_ren_args *a)
+{
+	int err, i, lsc;
+	struct au_pin *p;
+	struct au_pin1 *p4[4];
+	struct inode *h_dir;
+
+#if 0
+	lktr_set_pid(current->pid, LktrArrayPid);
+	LKTRTrace("i%lu, %.*s, i%lu, %.*s\n",
+		  a->src_dir->i_ino, AuDLNPair(a->src_dentry),
+		  a->dir->i_ino, AuDLNPair(a->dentry));
+	lktr_clear_pid(current->pid, LktrArrayPid);
+#endif
+	LKTRTrace("%d, %d\n", higher, lower);
+
+	err = 0;
+	p = a->pin + higher;
+	p4[0] = au_pin_gp(p); /* highest */
+	p4[1] = p->pin + AuPin_PARENT;
+	p = a->pin + lower;
+	p4[2] = au_pin_gp(p);
+	p4[3] = p->pin + AuPin_PARENT;
+
+	if (a->gparent[higher]) {
+		au_pin_do_set_parent(p4[0], a->gparent[higher]);
+		au_pin_do_set_dentry(p4[0], a->parent[higher]);
+	}
+	au_pin_do_set_parent(p4[1], a->parent[higher]);
+	if (a->gparent[lower]) {
+		au_pin_do_set_parent(p4[2], a->gparent[lower]);
+		au_pin_do_set_dentry(p4[2], a->parent[lower]);
+	}
+	au_pin_do_set_parent(p4[3], a->parent[lower]);
+
+#if 0
+	lktr_set_pid(current->pid, LktrArrayPid);
+	for (i = 0; i < 4; i++)
+		AuDbgDentry(p4[i]->parent);
+#endif
+	DiMustWriteLock(p4[3]->parent);
+	di_write_unlock(p4[1]->parent);
+	if (p4[2]->parent)
+		di_read_lock_parent2(p4[2]->parent, AuLock_IR);
+	di_write_lock_parent3(p4[1]->parent);
+	if (p4[0]->parent)
+		di_read_lock_parent4(p4[0]->parent, AuLock_IR);
+	//lktr_clear_pid(current->pid, LktrArrayPid);
+
+	vfsub_lock_rename_mutex(au_sbr_sb(a->dentry->d_sb, a->btgt));
+	au_fset_ren(a->flags, VFSLOCK);
+
+	lsc = AuLsc_I_PARENT;
+	for (i = 0; i < 4; i++, lsc++) {
+		if (p4[i]->parent) {
+			h_dir = au_h_iptr(p4[i]->parent->d_inode, a->btgt);
+			au_pin_do_set_h_dir(p4[i], h_dir);
+			mutex_lock_nested(&h_dir->i_mutex, lsc);
+		}
+	}
+
+	AuTraceErr(err);
+	return err;
+}
+
+static struct dentry *au_ren_pin3(int higher, int lower, struct au_ren_args *a)
+{
+	struct dentry *h_trap;
+	struct au_pin *p;
+	int err;
+
+	LKTRTrace("%d, %d\n", higher, lower);
+
+	p = a->pin + higher;
+	AuDebugOn(!au_pin_gp(p));
+	au_fset_pin(au_pin_gp(p)->flags, VFS_RENAME);
+	err = au_do_pin(p->pin + AuPin_PARENT, au_pin_gp(p));
+	h_trap = ERR_PTR(err);
+	if (unlikely(err))
+		goto out;
+	p = a->pin + lower;
+	au_fclr_pin(p->pin[AuPin_PARENT].flags, DO_GPARENT);
+	err = au_do_pin(p->pin + AuPin_PARENT, NULL);
+	h_trap = ERR_PTR(err);
+	if (unlikely(err)) {
+		p = a->pin + higher;
+		au_do_unpin(p->pin + AuPin_PARENT, au_pin_gp(p));
+		goto out;
+	}
+	h_trap = au_pinned_h_parent(p);
+
+ out:
+	AuTraceErrPtr(h_trap);
+	return h_trap;
+}
+
+static struct dentry *au_ren_pin(struct au_ren_args *a)
+{
+	struct dentry *h_trap;
+	struct inode *h_gdir;
+	int err, i, same_gp;
+
+	//lktr_set_pid(current->pid, LktrArrayPid);
+	AuTraceEnter();
+	AuDebugOn(!au_opt_test(a->mnt_flags, UDBA_INOTIFY));
+
+	/* gdir is not locked */
+	same_gp = 0;
+	if (!IS_ROOT(a->parent[SRC]))
+		a->gparent[SRC] = dget_parent(a->parent[SRC]);
+	if (!IS_ROOT(a->parent[DST])) {
+		a->gparent[DST] = dget_parent(a->parent[DST]);
+		same_gp = (a->gparent[SRC] == a->gparent[DST]);
+	}
+
+	/*
+	 * patterns
+	 * - gparent[SRC] is parent[DST]
+	 * - parent[SRC] is gparent[DST]
+	 * - gparent[SRC] is gparent[DST]
+	 * - gparent[SRC] is a descendant of parent[DST]
+	 * - parent[SRC] is an ancestor of gparent[DST]
+	 * - not within grand parent range
+	 */
+	err = 0;
+	h_trap = ERR_PTR(-EBUSY);
+	if (a->gparent[SRC] == a->parent[DST]) {
+		//AuDbg("here\n");
+		LKTRLabel(here);
+		au_ren_pin_init(a->pin + DST, a->dentry, a->pin + SRC,
+				a->src_dentry, a->btgt);
+		h_trap = au_ren_pin3(DST, SRC, a);
+		if (!IS_ERR(h_trap)) {
+			h_gdir = au_pinned_h_dir(a->pin + DST);
+			err = au_verify_parent(a->h_parent[SRC], h_gdir);
+			if (unlikely(err))
+				h_trap = ERR_PTR(-EBUSY);
+		}
+	} else if (a->parent[SRC] == a->gparent[DST] || same_gp) {
+		//AuDbg("here\n");
+		LKTRLabel(here);
+		au_ren_pin_init(a->pin + SRC, a->src_dentry, a->pin + DST,
+				a->dentry, a->btgt);
+		h_trap = au_ren_pin3(SRC, DST, a);
+		if (!IS_ERR(h_trap)) {
+			if (!same_gp)
+				h_gdir = au_pinned_h_dir(a->pin + SRC);
+			else
+				h_gdir = au_pinned_h_gdir(a->pin + SRC);
+			err = au_verify_parent(a->h_parent[DST], h_gdir);
+			if (unlikely(err))
+				h_trap = ERR_PTR(-EBUSY);
+		}
+	} else if (a->gparent[SRC]
+		   && (h_trap = au_test_subdir(a->gparent[SRC],
+					       a->parent[DST]))) {
+		//AuDbg("here\n");
+		LKTRLabel(here);
+		au_ren_pin_init(a->pin + DST, a->dentry, a->pin + SRC,
+				a->src_dentry, a->btgt);
+		if (a->gparent[DST]) {
+			err = au_ren_pin4(DST, SRC, a);
+			if (unlikely(err))
+				h_trap = ERR_PTR(err);
+		} else {
+			struct dentry *t;
+			t = au_ren_pin3(DST, SRC, a);
+			AuDebugOn(t == h_trap);
+		}
+#if 1
+	} else if (a->gparent[DST]
+		   && (h_trap = au_test_subdir(a->gparent[DST],
+					       a->parent[SRC]))) {
+		/* todo: is this really necessary? */
+		//AuDbg("here\n");
+		LKTRLabel(here);
+		au_ren_pin_init(a->pin + SRC, a->src_dentry, a->pin + DST,
+				a->dentry, a->btgt);
+		if (a->gparent[SRC]) {
+			err = au_ren_pin4(SRC, DST, a);
+			if (unlikely(err))
+				h_trap = ERR_PTR(err);
+		} else {
+			struct dentry *t;
+			t = au_ren_pin3(SRC, DST, a);
+			AuDebugOn(t == h_trap);
+		}
+#endif
+	} else /* if (a->gparent[DST]
+		  && (h_trap = au_test_subdir(a->gparent[DST],
+		  a->parent[SRC]))) */ {
+		//AuDbg("here\n");
+		LKTRLabel(here);
+		h_trap = NULL;
+		if (a->gparent[DST])
+			h_trap = au_test_subdir(a->gparent[DST],
+						a->parent[SRC]);
+		au_ren_pin_init(a->pin + SRC, a->src_dentry, a->pin + DST,
+				a->dentry, a->btgt);
+		err = au_ren_pin4(SRC, DST, a);
+		if (unlikely(err))
+			h_trap = ERR_PTR(err);
+	}
+	au_fset_ren(a->flags, PINNED);
+
+	if (!IS_ERR(h_trap)) {
+		err = 0;
+		for (i = 0; !err && i < 2; i++) {
+			h_gdir = au_pinned_h_gdir(a->pin + i);
+			if (h_gdir)
+				err = au_verify_parent(a->h_parent[i], h_gdir);
+		}
+		if (unlikely(err)) {
+			h_trap = ERR_PTR(err);
+			//AuDbg("here\n");
+		}
+	}
+
+	dput(a->gparent[SRC]);
+	dput(a->gparent[DST]);
+	memset(a->gparent, 0, sizeof(a->gparent));
+	AuTraceErrPtr(h_trap);
+	//lktr_clear_pid(current->pid, LktrArrayPid);
+	return h_trap;
+}
+
+static void au_ren_unlock(struct au_ren_args *a)
+{
+	int i;
+
+	AuTraceEnter();
+
+	if (au_ftest_ren(a->flags, MNT_WRITE))
+		au_mnt_drop_write(au_sbr_mnt(a->dentry->d_sb, a->btgt));
+	if (a->h_locked[0])
+		vfsub_unlock_rename(a->h_locked[0], a->h_locked[1]);
+	if (au_ftest_ren(a->flags, PINNED)) {
+		au_unpin(a->pin + SRC);
+		au_unpin(a->pin + DST);
+		memset(a->gparent, 0, sizeof(a->gparent));
+	}
+	if (au_ftest_ren(a->flags, VFSLOCK))
+		vfsub_unlock_rename_mutex(au_sbr_sb(a->dentry->d_sb, a->btgt));
+	for (i = 0; i < 2; i++)
+		if (a->gparent[i]) {
+			di_read_unlock(a->gparent[i], AuLock_IR);
+			dput(a->gparent[i]);
+		}
+}
+
+static int au_ren_lock(struct au_ren_args *a)
+{
+	int err;
+	const int hinotify = au_opt_test(a->mnt_flags, UDBA_INOTIFY);
+
+	AuTraceEnter();
+
+	err = 0;
+	if (!hinotify
+	    || (au_ftest_ren(a->flags, ISSAMEDIR) && IS_ROOT(a->parent[SRC]))) {
+		au_ren_pin_init(a->pin + SRC, a->src_dentry, a->pin + DST,
+				a->dentry, a->btgt);
+		LKTRLabel(here);
+		a->h_locked[0] = a->h_parent[SRC];
+		a->h_locked[1] = a->h_parent[DST];
+		a->h_trap = vfsub_lock_rename(a->h_locked[0], a->h_locked[1]);
+		au_ren_fake_pin(a);
+	} else if (au_ftest_ren(a->flags, ISSAMEDIR)
+		   && !IS_ROOT(a->parent[SRC])) {
+		/* this and next block should not be compiled when
+		   hinotify is disabled */
+		/* irregular/tricky rename lock */
+		LKTRLabel(here);
+		au_ren_pin_init(a->pin + SRC, a->src_dentry, a->pin + DST,
+				a->dentry, a->btgt);
+		a->gparent[SRC] = dget_parent(a->parent[SRC]);
+		di_read_lock_parent2(a->gparent[SRC], AuLock_IR);
+		a->h_locked[0] = a->h_parent[SRC];
+		a->h_locked[1] = dget_parent(a->h_parent[SRC]);
+		a->h_trap = vfsub_lock_rename(a->h_locked[0], a->h_locked[1]);
+		err = au_verify_parent(a->h_parent[SRC],
+				       a->h_locked[1]->d_inode);
+		dput(a->h_locked[1]);
+		if (!err)
+			au_ren_fake_pin(a);
+	} else {
+		/* 3 or 4 dir locks. crazy */
+		LKTRLabel(here);
+		a->h_trap = au_ren_pin(a);
+		if (IS_ERR(a->h_trap))
+			err = PTR_ERR(a->h_trap);
+	}
+
+	if (!err && au_dbstart(a->src_dentry) == a->btgt)
+		err = au_verify_parent(a->h_dentry[SRC],
+				       a->h_parent[SRC]->d_inode);
+	if (!err && au_dbstart(a->dentry) == a->btgt)
+		err = au_verify_parent(a->h_dentry[DST],
+				       a->h_parent[DST]->d_inode);
+	if (!err) {
+		err = au_br_want_write(au_sbr(a->dentry->d_sb, a->btgt));
+		if (unlikely(err))
+			goto out_unlock;
+		au_fset_ren(a->flags, MNT_WRITE);
+		goto out; /* success */
+	}
+
+	err = -EBUSY;
+
+ out_unlock:
+	au_ren_unlock(a);
+ out:
+	AuTraceErr(err);
+	return err;
+}
+
+int aufs_rename(struct inode *src_dir, struct dentry *src_dentry,
+		struct inode *dir, struct dentry *dentry)
+{
+	int err;
+	aufs_bindex_t bend, bindex;
+	unsigned char do_dt_dstdir, hinotify;
+	struct inode *inode[2];
+	enum { PARENT, CHILD };
+	/* reduce stack space */
+	struct {
+		struct au_ren_args a;
+		struct au_dtime dt[2][2];
+	} *p;
+	struct au_wr_dir_args wr_dir_args = {
+		/* .force_btgt	= -1, */
+		.flags		= AuWrDir_ADD_ENTRY
+	};
+
+	LKTRTrace("i%lu, %.*s, i%lu, %.*s\n",
+		  src_dir->i_ino, AuDLNPair(src_dentry),
+		  dir->i_ino, AuDLNPair(dentry));
+	AuDebugOn(IS_ROOT(src_dentry) || IS_ROOT(dentry));
+	IMustLock(src_dir);
+	IMustLock(dir);
+	inode[DST] = dentry->d_inode;
+	if (inode[DST]) {
+		IMustLock(inode[DST]);
+		au_igrab(inode[DST]);
+	}
+
+	err = -ENOMEM;
+	BUILD_BUG_ON(sizeof(*p) > PAGE_SIZE);
+	p = kzalloc(sizeof(*p), GFP_NOFS);
+	if (unlikely(!p))
+		goto out;
+
+	err = -ENOTDIR;
+	p->a.src_dir = src_dir;
+	p->a.src_dentry = src_dentry;
+	p->a.dir = dir;
+	p->a.dentry = dentry;
+	p->a.sb = src_dentry->d_sb;
+	inode[SRC] = src_dentry->d_inode;
+	p->a.flags = 0;
+	if (S_ISDIR(inode[SRC]->i_mode)) {
+		au_fset_ren(p->a.flags, ISDIR);
+		if (unlikely(inode[DST] && !S_ISDIR(inode[DST]->i_mode)))
+			goto out_free;
+		aufs_read_and_write_lock2(dentry, src_dentry, AuLock_DIR);
+	} else
+		aufs_read_and_write_lock2(dentry, src_dentry, 0);
+
+	p->a.mnt_flags = au_mntflags(p->a.sb);
+	if (au_test_dlgt(p->a.mnt_flags))
+		au_fset_ren(p->a.flags, DLGT);
+	p->a.parent[SRC] = src_dentry->d_parent; /* dir inode is locked */
+	p->a.parent[DST] = dentry->d_parent; /* dir inode is locked */
+	au_fset_ren(p->a.flags, ISSAMEDIR); /* temporary */
+	di_write_lock_parent(p->a.parent[DST]);
+
+	/* which branch we process */
+	p->a.bstart[SRC] = au_dbstart(src_dentry);
+	p->a.bstart[DST] = au_dbstart(dentry);
+	if (au_ftest_ren(p->a.flags, ISDIR))
+		au_fset_wrdir(wr_dir_args.flags, ISDIR);
+	wr_dir_args.force_btgt = p->a.bstart[SRC];
+	if (dentry->d_inode && p->a.bstart[DST] < p->a.bstart[SRC])
+		wr_dir_args.force_btgt = p->a.bstart[DST];
+	wr_dir_args.force_btgt = au_wbr(dentry, wr_dir_args.force_btgt);
+	err = au_wr_dir(dentry, src_dentry, &wr_dir_args);
+	p->a.btgt = err;
+	if (unlikely(err < 0))
+		goto out_unlock;
+
+	/* are they available to be renamed */
+	err = 0;
+	au_nhash_init(&p->a.whlist);
+	if (au_ftest_ren(p->a.flags, ISDIR) && inode[DST]) {
+		au_set_dbstart(dentry, p->a.bstart[DST]);
+		err = may_rename_dstdir(dentry, p->a.btgt, &p->a.whlist);
+		au_set_dbstart(dentry, p->a.btgt);
+	}
+	p->a.h_dentry[DST] = au_h_dptr(dentry, au_dbstart(dentry));
+	if (unlikely(err))
+		goto out_unlock;
+	/* todo: minor optimize,
+	   their sb may be same while their bindex differs? */
+	p->a.h_dentry[SRC] = au_h_dptr(src_dentry, au_dbstart(src_dentry));
+	if (au_ftest_ren(p->a.flags, ISDIR)) {
+		err = may_rename_srcdir(src_dentry, p->a.btgt);
+		if (unlikely(err))
+			goto out_children;
+	}
+
+	/* prepare the writable parent dir on the same branch */
+	if (p->a.bstart[DST] == p->a.btgt) {
+		au_fset_ren(p->a.flags, WHDST);
+	} else {
+		err = au_cpup_dirs(dentry, p->a.btgt);
+		if (unlikely(err))
+			goto out_children;
+	}
+
+	if (src_dir != dir) {
+		/*
+		 * this temporary unlock is safe,
+		 * because both dir->i_mutex are locked.
+		 */
+		di_write_unlock(p->a.parent[DST]);
+		di_write_lock_parent(p->a.parent[SRC]);
+		err = au_wr_dir_need_wh
+			(src_dentry, au_ftest_ren(p->a.flags, ISDIR),
+			 &p->a.btgt);
+		di_write_unlock(p->a.parent[SRC]);
+		di_write_lock2_parent(p->a.parent[SRC], p->a.parent[DST],
+				      /*isdir*/1);
+		au_fclr_ren(p->a.flags, ISSAMEDIR);
+	} else
+		err = au_wr_dir_need_wh
+			(src_dentry, au_ftest_ren(p->a.flags, ISDIR),
+			 &p->a.btgt);
+	if (unlikely(err < 0))
+		goto out_children;
+	if (err)
+		au_fset_ren(p->a.flags, WHSRC);
+
+	hinotify = au_opt_test(p->a.mnt_flags, UDBA_INOTIFY);
+	p->a.h_parent[SRC] = au_h_dptr(p->a.parent[SRC], p->a.btgt);
+	p->a.h_parent[DST] = au_h_dptr(p->a.parent[DST], p->a.btgt);
+	err = au_ren_lock(&p->a);
+	if (unlikely(err))
+		goto out_children;
+
+	if (!au_opt_test(p->a.mnt_flags, UDBA_NONE)) {
+		p->a.ndx.nfsmnt	= au_nfsmnt(p->a.sb, p->a.btgt);
+		if (au_ftest_ren(p->a.flags, DLGT))
+			au_fset_ndx(p->a.ndx.flags, DLGT);
+		err = au_may_ren(&p->a);
+		if (unlikely(err))
+			goto out_hdir;
+		memset(&p->a.ndx, 0, sizeof(p->a.ndx));
+	}
+
+	/* store timestamps to be revertible */
+	au_dtime_store(p->dt[PARENT] + SRC, p->a.parent[SRC],
+		       p->a.h_parent[SRC], au_pinned_hdir(p->a.pin + SRC),
+		       au_pinned_hgdir(p->a.pin + SRC)
+		       /* hgdir[SRC] */);
+	if (!au_ftest_ren(p->a.flags, ISSAMEDIR))
+		au_dtime_store(p->dt[PARENT] + DST, p->a.parent[DST],
+			       p->a.h_parent[DST],
+			       au_pinned_hdir(p->a.pin + DST),
+			       au_pinned_hgdir(p->a.pin + DST)
+			       /* hgdir[DST] */);
+	do_dt_dstdir = 0;
+	if (au_ftest_ren(p->a.flags, ISDIR)) {
+		au_dtime_store(p->dt[CHILD] + SRC, src_dentry,
+			       p->a.h_dentry[SRC], au_hi(inode[SRC], p->a.btgt),
+			       au_pinned_hdir(p->a.pin + SRC));
+		if (p->a.h_dentry[DST]->d_inode) {
+			do_dt_dstdir = 1;
+			au_dtime_store(p->dt[CHILD] + DST, dentry,
+				       p->a.h_dentry[DST],
+				       au_hi(inode[DST], p->a.btgt),
+				       au_pinned_hdir(p->a.pin + DST));
+		}
+	}
+
+	err = do_rename(&p->a);
+	if (unlikely(err))
+		goto out_dt;
+
+	/* update dir attributes */
+	dir->i_version++;
+	if (au_ftest_ren(p->a.flags, ISDIR)) {
+		/* is this updating defined in POSIX? */
+		/* mutex_lock(&inode[SRC]->i_mutex); */
+		au_cpup_attr_timesizes(inode[SRC]);
+		/* mutex_unlock(&inode[SRC]->i_mutex); */
+
+		au_cpup_attr_nlink(dir, /*force*/1);
+		if (inode[DST]) {
+			clear_nlink(inode[DST]);
+			au_cpup_attr_timesizes(inode[DST]);
+		}
+	}
+	if (au_ibstart(dir) == p->a.btgt)
+		au_cpup_attr_timesizes(dir);
+
+	if (!au_ftest_ren(p->a.flags, ISSAMEDIR)) {
+		src_dir->i_version++;
+		if (au_ftest_ren(p->a.flags, ISDIR))
+			au_cpup_attr_nlink(src_dir, /*force*/1);
+		if (au_ibstart(src_dir) == p->a.btgt)
+			au_cpup_attr_timesizes(src_dir);
+	}
+
+	/* todo: simple d_drop(src_dentry) is not enough? */
+	/* dput/iput all lower dentries */
+	au_set_dbwh(src_dentry, -1);
+	bend = au_dbend(src_dentry);
+	for (bindex = p->a.btgt + 1; bindex <= bend; bindex++) {
+		struct dentry *hd;
+		hd = au_h_dptr(src_dentry, bindex);
+		if (hd)
+			au_set_h_dptr(src_dentry, bindex, NULL);
+	}
+	au_set_dbend(src_dentry, p->a.btgt);
+
+	if (au_opt_test(p->a.mnt_flags, PLINK)
+	    && au_plink_test(src_dentry->d_sb, inode[SRC]))
+		goto out_hdir; /* success */
+	bend = au_ibend(inode[SRC]);
+	for (bindex = p->a.btgt + 1; bindex <= bend; bindex++) {
+		struct inode *hi;
+		hi = au_h_iptr(inode[SRC], bindex);
+		if (hi) {
+			au_xino_write0(p->a.sb, bindex, hi->i_ino, 0);
+			/* ignore this error */
+			au_set_h_iptr(inode[SRC], bindex, NULL, 0);
+		}
+	}
+	au_set_ibend(inode[SRC], p->a.btgt);
+	goto out_hdir; /* success */
+
+ out_dt:
+	au_dtime_revert(p->dt[PARENT] + SRC);
+	if (!au_ftest_ren(p->a.flags, ISSAMEDIR))
+		au_dtime_revert(p->dt[PARENT] + DST);
+	if (au_ftest_ren(p->a.flags, ISDIR) && err != -EIO) {
+		struct dentry *hd;
+
+		hd = p->dt[CHILD][SRC].dt_h_dentry;
+		mutex_lock_nested(&hd->d_inode->i_mutex, AuLsc_I_CHILD);
+		au_dtime_revert(p->dt[CHILD] + SRC);
+		mutex_unlock(&hd->d_inode->i_mutex);
+		if (do_dt_dstdir) {
+			hd = p->dt[CHILD][DST].dt_h_dentry;
+			mutex_lock_nested(&hd->d_inode->i_mutex, AuLsc_I_CHILD);
+			au_dtime_revert(p->dt[CHILD] + DST);
+			mutex_unlock(&hd->d_inode->i_mutex);
+		}
+	}
+ out_hdir:
+	au_ren_unlock(&p->a);
+ out_children:
+	au_nhash_fin(&p->a.whlist);
+ out_unlock:
+	if (unlikely(err && au_ftest_ren(p->a.flags, ISDIR))) {
+		au_update_dbstart(dentry);
+		d_drop(dentry);
+	}
+	if (!err) {
+		d_move(src_dentry, dentry);
+		if (inode[DST]
+		    && (inode[DST]->i_nlink == 1
+			|| au_ftest_ren(p->a.flags, ISDIR)))
+				inode[DST]->i_flags |= S_DEAD;
+	}
+	if (au_ftest_ren(p->a.flags, ISSAMEDIR))
+		di_write_unlock(p->a.parent[DST]);
+	else
+		di_write_unlock2(p->a.parent[SRC], p->a.parent[DST]);
+	aufs_read_and_write_unlock2(dentry, src_dentry);
+ out_free:
+	kfree(p);
+ out:
+	iput(inode[DST]);
+	AuTraceErr(err);
+	//lktr_clear_pid(current->pid, LktrArrayPid);
+	if (unlikely(err == -EBUSY && au_test_nfsd(current)))
+		err = -ESTALE;
+	return err;
+}
diff -Nurp linux-2.6.27.orig/fs/aufs/Kconfig linux-2.6.27/fs/aufs/Kconfig
--- linux-2.6.27.orig/fs/aufs/Kconfig	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.27/fs/aufs/Kconfig	2008-12-14 11:07:07.000000000 +0100
@@ -0,0 +1,283 @@
+config AUFS
+	tristate "Another unionfs"
+	help
+	Aufs is a stackable unification filesystem such as Unionfs,
+	which unifies several directories and provides a merged single
+	directory.
+	In the early days, aufs was entirely re-designed and
+	re-implemented Unionfs Version 1.x series. After many original
+	ideas, approaches and improvements, it becomes totally
+	different from Unionfs while keeping the basic features.
+	See Unionfs for the basic features.
+if AUFS
+comment "These options are for 2.6.27"
+choice
+	prompt "Maximum number of branches"
+	default AUFS_BRANCH_MAX_127
+	help
+	Specifies the maximum number of branches (or member directories) in a single aufs. The larger value consumes more system resources and has an impact to performance.
+config AUFS_BRANCH_MAX_127
+	bool "127"
+	help
+	Specifies the maximum number of branches (or member directories) in a single aufs. The larger value consumes more system resources and has an impact to performance.
+config AUFS_BRANCH_MAX_511
+	bool "511"
+	help
+	Specifies the maximum number of branches (or member directories) in a single aufs. The larger value consumes more system resources and has an impact to performance.
+config AUFS_BRANCH_MAX_1023
+	bool "1023"
+	help
+	Specifies the maximum number of branches (or member directories) in a single aufs. The larger value consumes more system resources and has an impact to performance.
+config AUFS_BRANCH_MAX_32767
+	bool "32767"
+	help
+	Specifies the maximum number of branches (or member directories) in a single aufs. The larger value consumes more system resources and has an impact to performance.
+endchoice
+config AUFS_STAT
+	bool "Use <sysfs>/fs/aufs/stat"
+	depends on SYSFS
+	help
+	Shows some statistic data via <sysfs>/fs/aufs/stat.
+	See detail in aufs.5.
+comment "SYSFS and AUFS_STAT are disabled"
+	depends on SYSFS = n
+config AUFS_HINOTIFY
+	bool "Use inotify to detect actions on a branch"
+	depends on INOTIFY
+	help
+	If you want to modify files on branches directly, eg. bypassing aufs,
+	and want aufs to detect the changes of them fully, then enable this
+	option and use 'udba=inotify' mount option.
+	It will have a negative impact to the performance.
+	See detail in aufs.5.
+comment "INOTIFY and AUFS_HINOTIFY are disabled"
+	depends on INOTIFY = n
+config AUFS_EXPORT
+	bool "NFS-exportable aufs"
+	depends on (AUFS = y && EXPORTFS = y) || (AUFS = m && EXPORTFS)
+	help
+	If you want to export your mounted aufs, then enable this
+	option. There are several requirements for this configuration.
+	See detail in aufs.5.
+comment "EXPORTFS and AUFS_EXPORT are disabled"
+	depends on EXPORTFS = n
+comment "AUFS_EXPORT is disabled since EXPORTFS is a module but AUFS"
+	depends on EXPORTFS = m && AUFS = y
+config AUFS_INO_T_64
+	bool
+	depends on 64BIT && !(ALPHA || S390)
+	default y
+config AUFS_ROBR
+	bool "Aufs as an readonly branch of another aufs mount"
+	help
+	If you want make your aufs to be a part of another aufs, then
+	enable this option. In other words, you can specify your aufs
+	path in 'br:' mount option for another aufs, but cannot
+	specify 'rw' as the branch permission.
+	It will have a negative impact to the performance.
+	See detail in aufs.5.
+config AUFS_DLGT
+	bool "Delegate the internal branch access the kernel thread"
+	help
+	If you want aufs to delegate
+	the internal access to the branches which is made by aufs, to
+	the kernel thread, in order to hide the access issued by your
+	application from your LSM or something or make your
+	application to be traced strictly by the task I/O accounting,
+	then enable this option and use 'dlgt' mount option.
+	It will have a negative impact to the performance.
+	See detail in aufs.5.
+config AUFS_HIN_OR_DLGT
+	bool
+	depends on AUFS_HINOTIFY || AUFS_DLGT
+	default y
+	help
+	Automatic configuration for internal use.
+config AUFS_SHWH
+	bool "Show whiteouts"
+	help
+	If you want to make the whiteouts in aufs visible, then enable
+	this option and specify 'shwh' mount option. Although it may
+	sounds like philosophy or something, but in technically it
+	simply shows the name of whiteout with keeping its behaviour.
+config AUFS_RR_SQUASHFS
+	bool "Make squashfs branch RR (real readonly) by default"
+	default y
+	help
+	If you use squashfs or LZMA patched squashfs as an aufs branch
+	and want to set '=rr' to it by default, then enable this
+	configuration.
+	'rr' stands for real readonly and it optimizes some aspects of
+	'ro.'
+	See detail in aufs.5.
+config AUFS_SEC_PERM_PATCH
+	bool "sec_perm-2.6.24.patch was applied or not"
+	depends on AUFS = m
+	depends on SECURITY
+	help
+	If you build aufs as a module and enabled CONFIG_SECURITY,
+	then you need to apply the patch
+	'CVS_TREE/aufs/patch/sec_perm-2.6.24.patch' to your kernel
+	source, and enable this configuration.
+	The sec_perm-2.6.24.patch exports a kernel function
+	security_inode_permission() to modules.
+comment "SECURITY and AUFS_SEC_PERM_PATCH are disabled"
+	depends on SECURITY = n
+config AUFS_SPLICE_PATCH
+	bool "splice.patch for sendfile(2) and splice(2)"
+	help
+	If you use 'loopback mount' on a fs-image file, or use
+	splice(2) or sendfile(2) systemcall in aufs, then you need to
+	apply the patch 'CVS_TREE/aufs/patch/splice.patch' to your
+	kernel source, and enable this configuration.
+	The splice.patch makes the kernel function do_splice_to/from()
+	global and exports them to modules.
+config AUFS_LHASH_PATCH
+	bool "lhash.patch for NFS branch"
+	depends on NFS_FS
+	help
+	If you use mounted NFS as an aufs branch filesystem, then you
+	need to apply the patch 'CVS_TREE/aufs/patch/lhash.patch' (or
+	lhash-2.6.22.patch for linux-2.6.22 and later) to your kernel
+	source, and enable this configuration.
+	The patch file makes the kernel function __lookup_hash() global
+	and exports it to modules.
+comment "NFS_FS and AUFS_LHASH_PATCH are disabled"
+	depends on NFS_FS = n
+config AUFS_PUT_FILP_PATCH
+	bool "put_filp.patch for 'atomic open'"
+	depends on AUFS = m && NFS_V4
+	help
+	If you build aufs as a module and use a filesystem which
+	operates 'atomic open' (for instance NFSv4) as an aufs branch
+	filesystem, then you need to apply the patch
+	'CVS_TREE/aufs/patch/put_filp.patch' to your kernel source,
+	and enable this configuration.
+	The put_filp.patch exports a kernel function put_filp() to
+	modules.
+comment "NFS_V4 and AUFS_PUT_FILP_PATCH are disabled"
+	depends on NFS_V4 = n
+config AUFS_BR_NFS
+	bool
+	depends on NFS_FS
+	depends on AUFS_LHASH_PATCH
+	default y
+	help
+	Automatic configuration for internal use.
+	When aufs supports NFS branch, enabled automatically.
+config AUFS_BR_NFS_V4
+	bool
+	depends on NFS_V4 && AUFS_BR_NFS
+	depends on AUFS = y || (AUFS = m && AUFS_PUT_FILP_PATCH)
+	default y
+	help
+	Automatic configuration for internal use.
+	When aufs supports a branch filesystem which operates
+	'atomic_open', for instance NFSv4, this configuration is enabled
+	automatically.
+config AUFS_BR_XFS
+	bool
+	depends on XFS_FS
+	default y
+	help
+	Automatic configuration for internal use.
+	When aufs supports XFS branch, enabled automatically.
+config AUFS_FSYNC_SUPER_PATCH
+	bool "fsync_super-2.6.xx.patch was applied or not"
+	depends on AUFS = m
+	help
+	If you build aufs as a module and want to flush everything for
+	branch filesystems which are not marked as 'rr' nor 'rr+wh' at
+	umount or remount time, then you need to apply the patch
+	'CVS_TREE/aufs/patch/fsync_super-2.6.16.patch' or
+	'...-2.6.19.patch' to your kernel source, and enable this
+	configuration.
+	It may be helpful at shutdown time in case of your aufs is a
+	root filesystem. But this behaviour will not guarantee the
+	consistency of branch filesystems. To guarantee it, try the
+	approach described in the aufs manual, and do not forget
+	installing auplink script.
+	The fsync_super-2.6.xx.patch does nothing but exports a kernel
+	function fsync_super() to modules.
+config AUFS_DENY_WRITE_ACCESS_PATCH
+	bool "deny_write_access.patch was applied or not"
+	depends on AUFS = m
+	help
+	A security enhancement to deny writing to a running executable
+	which exists on an aufs branch filesystem and executed through
+	aufs. If you applied
+	'CVS_TREE/aufs/patch/deny_write_access.patch' to your kernel
+	and you are compiling aufs as a module, then enable this
+	option.
+	The write_deny_access.patch does nothing but export the
+	function.
+config AUFS_WORKAROUND_FUSE
+	bool "Special handling for FUSE-based filesystem"
+	depends on FUSE_FS
+	help
+	A FUSE-based filesystem may not initialize its inode
+	attributes and the FUSE developer thinks the inode attributes
+	in a positive dentry which is returned by VFS lookup operation
+	are not reliable.
+	If you use a FUSE-based filesystem as an aufs branch, and it
+	customizes the inode attribute on it without overriding
+	fuse_lowlevel_ops.lookup, probably you need to enable this
+	configuration.
+	If you enable this configuration, aufs calls getattr operation
+	in every lookup and revalidate operation for the FUSE-based
+	filesystem branch.
+	It will have a negative impact to the performance even if you do
+	not use a FUSE-based filesystem branch.
+config AUFS_GETATTR
+	bool
+	depends on AUFS_HINOTIFY || AUFS_WORKAROUND_FUSE || AUFS_BR_NFS
+	default y
+	help
+	Automatic configuration for internal use.
+config AUFS_DEBUG
+	bool "Debug aufs"
+	default y
+	help
+	Enable this to compile aufs internal debug code.
+	It will have a negative impact to the performance.
+config AUFS_MAGIC_SYSRQ
+	bool
+	depends on AUFS_DEBUG && MAGIC_SYSRQ
+	default y
+	help
+	Automatic configuration for internal use.
+	When aufs supports Magic SysRq, enabled automatically.
+config AUFS_DEBUG_LOCK
+	bool "Show lock status in Magic SysRq"
+	depends on AUFS_MAGIC_SYSRQ
+	help
+	For developers only. Sometimes it is useful when a deadlock
+	occurs in aufs. Trace every aufs lock acquire and release, and
+	print them when Magic SysRq-<AUFS> key is pressed.
+	It will have a huge negative impact to the performance.
+config AUFS_COMPAT
+	bool "Compatibility with Unionfs (obsolete)"
+	help
+	This makes aufs compatible with unionfs-style mount options and some
+	behaviours.
+	The dirs= mount option and =nfsro branch permission flag are always
+	interpreted as br: mount option and =ro flag respectively. The
+	'debug', 'delete' and 'imap' mount options are ignored.
+	If you disable this option, you will get,
+	- aufs issues a warning about the ignored mount options
+	- the default branch permission flag is set. RW for the first branch,
+	  and RO for the rests.
+	- the name of a internal file which represents the directory is
+	  'opaque', becomes '.wh..wh..opq'
+	- the 'diropq=w' mount option is set by default
+config AUFS_UNIONFS22_PATCH
+	bool "Unionfs-2.2 or later patch is applied or not (obsolete)"
+	help
+	Unionfs version 2.2 (and later) patch introduces some changes in VFS layer which has an impact to aufs. If you have applied such patch to your kernel, you need to enable this configuration even if you disabled CONFIG_UNIONFS.
+config AUFS_UNIONFS23_PATCH
+	bool "Unionfs-2.3 or later patch is applied or not (obsolete)"
+	select AUFS_SPLICE_PATCH
+	select AUFS_UNIONFS22_PATCH
+	help
+	Unionfs version 2.3 (and later) patch introduces some changes in VFS layer which has an impact to aufs. If you have applied such patch to your kernel, you need to enable this configuration even if you disabled CONFIG_UNIONFS.
+endif
diff -Nurp linux-2.6.27.orig/fs/aufs/Makefile linux-2.6.27/fs/aufs/Makefile
--- linux-2.6.27.orig/fs/aufs/Makefile	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.27/fs/aufs/Makefile	2008-10-20 03:47:24.000000000 +0200
@@ -0,0 +1,74 @@
+# AUFS Makefile for the Linux 2.6.25 and later
+# $Id: Makefile,v 1.10 2008/10/20 01:47:24 sfjro Exp $
+
+# the environment variables are not inherited since 2.6.23
+ifdef AUFS_EXTRA_CFLAGS
+ccflags-y += ${AUFS_EXTRA_CFLAGS}
+endif
+
+########################################
+
+ifdef CONFIG_AUFS_RR_SQUASHFS
+# cf. squashfs3.2-r2 and sqlzma patch.
+ccflags-y += -DSQUASHFS_MAGIC=0x73717368
+ccflags-y += -DSQUASHFS_MAGIC_SWAP=0x68737173
+ccflags-y += -DSQUASHFS_MAGIC_LZMA=0x71736873
+ccflags-y += -DSQUASHFS_MAGIC_LZMA_SWAP=0x73687371
+endif
+
+# defined in ${srctree}/fs/fuse/inode.c
+ccflags-$(CONFIG_AUFS_WORKAROUND_FUSE) += -DFUSE_SUPER_MAGIC=0x65735546
+
+# defined in ${srctree}/fs/xfs/xfs_sb.h
+# tristate
+ifdef CONFIG_XFS_FS
+ccflags-y += -DXFS_SB_MAGIC=0x58465342
+endif
+
+# defined in ${srctree}/mm/shmem.c
+# tristate
+ifdef CONFIG_TMPFS
+ccflags-y += -DTMPFS_MAGIC=0x01021994
+endif
+
+# defined in ${srctree}fs/sysfs/mount.c
+# bool
+ccflags-$(CONFIG_SYSFS) += -DSYSFS_MAGIC=0x62656572
+
+ifndef EXTRAVERSION
+EXTRAVERSION = $(shell echo ${KERNELVERSION} | cut -f3- -d. | cut -f2- -d-)
+endif
+# for -mm tree, support the latest version only
+ifneq ($(strip $(shell echo ${EXTRAVERSION} | fgrep -- mm)),)
+ccflags-y += -DCONFIG_AUFS_UNIONFS22_PATCH -DCONFIG_AUFS_UNIONFS23_PATCH
+endif
+
+-include $(dir $(lastword ${MAKEFILE_LIST}))priv.mk
+#$(warning ${ccflags-y})
+
+########################################
+
+obj-$(CONFIG_AUFS) += aufs.o
+aufs-y := module.o super.o sbinfo.o branch.o xino.o sysaufs.o opts.o \
+	wkq.o vfsub.o dcsub.o \
+	cpup.o whout.o plink.o wbr_policy.o \
+	dentry.o dinfo.o \
+	file.o f_op.o finfo.o \
+	dir.o vdir.o \
+	inode.o i_op.o i_op_add.o i_op_del.o i_op_ren.o iinfo.o \
+	misc.o
+
+aufs-$(CONFIG_SYSFS) += sysfs.o
+aufs-$(CONFIG_AUFS_BR_NFS) += br_nfs.o
+aufs-$(CONFIG_AUFS_BR_XFS) += br_xfs.o
+aufs-$(CONFIG_AUFS_WORKAROUND_FUSE) += br_fuse.o
+aufs-$(CONFIG_AUFS_DLGT) += dlgt.o
+aufs-$(CONFIG_AUFS_HINOTIFY) += hinotify.o
+aufs-$(CONFIG_AUFS_HIN_OR_DLGT) += hin_or_dlgt.o
+aufs-$(CONFIG_AUFS_GETATTR) += getattr.o
+aufs-$(CONFIG_AUFS_EXPORT) += export.o
+aufs-$(CONFIG_AUFS_ROBR) += robr.o
+# reserved for future use
+#aufs-$(CONFIG_AUFS_XATTR) += xattr.o
+aufs-$(CONFIG_AUFS_DEBUG) += debug.o
+aufs-$(CONFIG_AUFS_MAGIC_SYSRQ) += sysrq.o
diff -Nurp linux-2.6.27.orig/fs/aufs/misc.c linux-2.6.27/fs/aufs/misc.c
--- linux-2.6.27.orig/fs/aufs/misc.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.27/fs/aufs/misc.c	2008-12-14 10:37:40.000000000 +0100
@@ -0,0 +1,308 @@
+/*
+ * Copyright (C) 2005-2008 Junjiro Okajima
+ *
+ * This program, aufs is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+ */
+
+/*
+ * $Id: misc.c,v 1.19 2008/12/01 03:50:17 sfjro Exp $
+ */
+
+#include "aufs.h"
+
+void *au_kzrealloc(void *p, unsigned int nused, unsigned int new_sz, gfp_t gfp)
+{
+	void *q;
+
+	LKTRTrace("p %p, nused %d, sz %d\n", p, nused, new_sz);
+	AuDebugOn(new_sz <= 0);
+	if (new_sz <= nused)
+		return p;
+
+	q = krealloc(p, new_sz, gfp);
+	if (q)
+		memset(q + nused, 0, new_sz - nused);
+	return q;
+}
+
+/* ---------------------------------------------------------------------- */
+
+struct nameidata *au_dup_nd(struct au_sbinfo *sbinfo, struct nameidata *dst,
+			    struct nameidata *src)
+{
+	LKTRTrace("src %p\n", src);
+
+	if (src) {
+		*dst = *src;
+		dst->flags &= ~LOOKUP_PARENT;
+		if (sbinfo->si_wbr_create == AuWbrCreate_TDP) {
+			if ((dst->flags & LOOKUP_CREATE)
+			    && !(dst->intent.open.flags & O_CREAT))
+				dst->flags &= ~LOOKUP_CREATE;
+		} else {
+			dst->flags &= ~LOOKUP_CREATE;
+			dst->intent.open.flags &= ~O_CREAT;
+		}
+	} else
+		dst = NULL;
+
+	return dst;
+}
+
+struct nameidata *au_fake_dm(struct nameidata *fake_nd, struct nameidata *nd,
+			     struct super_block *sb, aufs_bindex_t bindex)
+{
+	LKTRTrace("nd %p, b%d\n", nd, bindex);
+
+	if (!nd)
+		return NULL;
+
+	DiMustAnyLock(nd->path.dentry);
+
+	fake_nd->path.dentry = NULL;
+	fake_nd->path.mnt = NULL;
+
+	if (bindex <= au_dbend(nd->path.dentry))
+		fake_nd->path.dentry = au_h_dptr(nd->path.dentry, bindex);
+	if (fake_nd->path.dentry) {
+		fake_nd->path.mnt = au_sbr_mnt(sb, bindex);
+		AuDebugOn(!fake_nd->path.mnt);
+		path_get(&fake_nd->path);
+	} else
+		fake_nd = ERR_PTR(-ENOENT);
+
+	AuTraceErrPtr(fake_nd);
+	return fake_nd;
+}
+
+void au_fake_dm_release(struct nameidata *fake_nd)
+{
+	if (fake_nd)
+		path_put(&fake_nd->path);
+}
+
+int au_h_create(struct inode *h_dir, struct dentry *h_dentry, int mode,
+		struct vfsub_args *vargs, struct nameidata *nd,
+		struct vfsmount *nfsmnt)
+{
+	int err;
+
+	LKTRTrace("hi%lu, %.*s, 0%o, nd %d, nfsmnt %d\n",
+		  h_dir->i_ino, AuDLNPair(h_dentry), mode, !!nd, !!nfsmnt);
+
+	err = -ENOSYS;
+	if (!nfsmnt)
+		err = vfsub_create(h_dir, h_dentry, mode, /*nd*/NULL, vargs);
+	else {
+		struct nameidata fake_nd;
+
+		if (nd)
+			fake_nd = *nd;
+		else
+			memset(&fake_nd, 0, sizeof(fake_nd));
+		fake_nd.path.dentry = h_dentry;
+		fake_nd.path.mnt = nfsmnt;
+		path_get(&fake_nd.path);
+		fake_nd.flags = LOOKUP_CREATE;
+		fake_nd.intent.open.flags = O_CREAT | FMODE_READ;
+		fake_nd.intent.open.create_mode = mode;
+
+		err = vfsub_create(h_dir, h_dentry, mode, &fake_nd, vargs);
+		path_put(&fake_nd.path);
+	}
+
+	AuTraceErr(err);
+	return err;
+}
+
+/* ---------------------------------------------------------------------- */
+
+/* empty_zero_page is not exported on PPC before 2.6.26 */
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2, 6, 26) \
+	&& (defined(CONFIG_PPC) || defined(CONFIG_PPC64))
+static char *au_zp_alloc(void)
+{
+	return (void *)get_zeroed_page(GFP_NOFS);
+}
+
+static void au_zp_free(char *p)
+{
+	if (p)
+		free_page((unsigned long)p);
+}
+#else
+static char *au_zp_alloc(void)
+{
+	return page_address(ZERO_PAGE(0));
+}
+
+static void au_zp_free(char *p)
+{
+	/* empty */
+}
+#endif
+
+int au_copy_file(struct file *dst, struct file *src, loff_t len,
+		 struct au_hinode *hdir, struct super_block *sb,
+		 struct vfsub_args *vargs)
+{
+	int err, all_zero, do_kfree;
+	unsigned long blksize;
+	char *buf, *zp;
+	/* reduce stack usage */
+	struct iattr *ia;
+
+	LKTRTrace("%.*s, %.*s\n",
+		  AuDLNPair(dst->f_dentry), AuDLNPair(src->f_dentry));
+	AuDebugOn(!(dst->f_mode & FMODE_WRITE));
+#ifdef CONFIG_AUFS_DEBUG
+	{
+		struct dentry *parent;
+		parent = dget_parent(dst->f_dentry);
+		IMustLock(parent->d_inode);
+		dput(parent);
+	}
+#endif
+
+	err = -ENOMEM;
+	zp = au_zp_alloc();
+	if (unlikely(!zp))
+		goto out;
+	blksize = dst->f_dentry->d_sb->s_blocksize;
+	if (!blksize || PAGE_SIZE < blksize)
+		blksize = PAGE_SIZE;
+	LKTRTrace("blksize %lu\n", blksize);
+	do_kfree = (blksize != PAGE_SIZE && blksize >= sizeof(*ia));
+	if (do_kfree)
+		buf = kmalloc(blksize, GFP_NOFS);
+	else
+		buf = (void *)__get_free_page(GFP_NOFS);
+	if (unlikely(!buf))
+		goto out;
+
+#ifdef CONFIG_AUFS_DEBUG
+	if (len > (1 << 22))
+		AuWarn("copying a large file %lld\n", (long long)len);
+#endif
+	err = 0;
+	all_zero = 0;
+	src->f_pos = 0;
+	dst->f_pos = 0;
+	while (len) {
+		size_t sz, rbytes, wbytes;
+		char *p;
+
+		LKTRTrace("len %lld\n", len);
+		sz = blksize;
+		if (len < blksize)
+			sz = len;
+
+		/* support LSM and notify */
+		rbytes = 0;
+		/* todo: signal_pending? */
+		while (!rbytes || err == -EAGAIN || err == -EINTR) {
+			rbytes = vfsub_read_k(src, buf, sz, &src->f_pos,
+					      vfsub_ftest(vargs->flags, DLGT));
+			err = rbytes;
+		}
+		if (unlikely(err < 0))
+			break;
+
+		all_zero = 0;
+		if (len >= rbytes && rbytes == blksize) {
+#if 1
+			all_zero = !memcmp(buf, zp, rbytes);
+#else /* reserved for future use */
+			unsigned long long *ullp;
+			size_t n, i;
+
+			all_zero = 1;
+			ullp = (void *)buf;
+			n = rbytes / sizeof(*ullp);
+			i = n;
+			while (n-- > 0 && all_zero)
+				all_zero = !*ullp++;
+			p = (void *)ullp;
+			i *= sizeof(*ullp);
+			for (; all_zero && i < rbytes; i++)
+				all_zero = !*p++;
+#endif
+		}
+		if (!all_zero) {
+			wbytes = rbytes;
+			p = buf;
+			while (wbytes) {
+				size_t b;
+				/* support LSM and notify */
+				vfsub_args_reinit(vargs);
+				vfsub_ign_hinode(vargs, IN_MODIFY, hdir);
+				b = vfsub_write_k(dst, p, wbytes, &dst->f_pos,
+						  vargs);
+				err = b;
+				/* todo: signal_pending? */
+				if (unlikely(err == -EAGAIN || err == -EINTR))
+					continue;
+				if (unlikely(err < 0))
+					break;
+				wbytes -= b;
+				p += b;
+			}
+		} else {
+			loff_t res;
+			LKTRLabel(hole);
+			res = vfsub_llseek(dst, rbytes, SEEK_CUR);
+			err = res;
+			if (unlikely(res < 0))
+				break;
+		}
+		len -= rbytes;
+		err = 0;
+	}
+
+	/* the last block may be a hole */
+	if (!err && all_zero) {
+		struct dentry *h_d = dst->f_dentry;
+		struct inode *h_i = h_d->d_inode;
+
+		LKTRLabel(last hole);
+		do {
+			/* todo: signal_pending? */
+			vfsub_args_reinit(vargs);
+			vfsub_ign_hinode(vargs, IN_MODIFY, hdir);
+			err = vfsub_write_k(dst, "\0", 1, &dst->f_pos, vargs);
+		} while (err == -EAGAIN || err == -EINTR);
+		if (err == 1) {
+			ia = (void *)buf;
+			ia->ia_size = dst->f_pos;
+			ia->ia_valid = ATTR_SIZE | ATTR_FILE;
+			ia->ia_file = dst;
+			vfsub_args_reinit(vargs);
+			vfsub_ign_hinode(vargs, vfsub_events_notify_change(ia),
+					 hdir);
+			mutex_lock_nested(&h_i->i_mutex, AuLsc_I_CHILD2);
+			err = vfsub_notify_change(h_d, ia, vargs);
+			mutex_unlock(&h_i->i_mutex);
+		}
+	}
+	if (do_kfree)
+		kfree(buf);
+	else
+		free_page((unsigned long)buf);
+
+ out:
+	au_zp_free(zp);
+	AuTraceErr(err);
+	return err;
+}
diff -Nurp linux-2.6.27.orig/fs/aufs/misc.h linux-2.6.27/fs/aufs/misc.h
--- linux-2.6.27.orig/fs/aufs/misc.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.27/fs/aufs/misc.h	2008-12-14 10:37:40.000000000 +0100
@@ -0,0 +1,244 @@
+/*
+ * Copyright (C) 2005-2008 Junjiro Okajima
+ *
+ * This program, aufs is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+ */
+
+/*
+ * $Id: misc.h,v 1.10 2008/12/08 06:12:34 sfjro Exp $
+ */
+
+#ifndef __AUFS_MISC_H__
+#define __AUFS_MISC_H__
+
+#ifdef __KERNEL__
+
+#include <linux/fs.h>
+#include <linux/namei.h>
+#include <linux/aufs_type.h>
+
+/* ---------------------------------------------------------------------- */
+
+typedef unsigned int au_gen_t;
+/* see linux/include/linux/jiffies.h */
+#define AuGenYounger(a, b)	((int)(b) - (int)(a) < 0)
+#define AuGenOlder(a, b)	AufsGenYounger(b, a)
+
+/* ---------------------------------------------------------------------- */
+
+struct au_splhead {
+	spinlock_t		spin;
+	struct list_head	head;
+};
+
+static inline void au_spl_init(struct au_splhead *spl)
+{
+	spin_lock_init(&spl->spin);
+	INIT_LIST_HEAD(&spl->head);
+}
+
+static inline void au_spl_add(struct list_head *list, struct au_splhead *spl)
+{
+	spin_lock(&spl->spin);
+	list_add(list, &spl->head);
+	spin_unlock(&spl->spin);
+}
+
+static inline void au_spl_del(struct list_head *list, struct au_splhead *spl)
+{
+	spin_lock(&spl->spin);
+	list_del(list);
+	spin_unlock(&spl->spin);
+}
+
+/* ---------------------------------------------------------------------- */
+
+struct au_rwsem {
+	struct rw_semaphore	rwsem;
+#ifdef CONFIG_AUFS_DEBUG
+	atomic_t		rcnt;
+#endif
+};
+
+#ifdef CONFIG_AUFS_DEBUG
+#define AuDbgRcntInit(rw) do { \
+	atomic_set(&(rw)->rcnt, 0); \
+	smp_mb(); /* atomic set */ \
+} while (0)
+
+#define AuDbgRcntInc(rw)	atomic_inc_return(&(rw)->rcnt)
+#define AuDbgRcntDec(rw)	WARN_ON(atomic_dec_return(&(rw)->rcnt) < 0)
+#else
+#define AuDbgRcntInit(rw)	do {} while (0)
+#define AuDbgRcntInc(rw)	do {} while (0)
+#define AuDbgRcntDec(rw)	do {} while (0)
+#endif /* CONFIG_AUFS_DEBUG */
+
+#define au_rwsem_destroy(rw)	AuDebugOn(rwsem_is_locked(&(rw)->rwsem))
+
+static inline void au_rw_init_nolock(struct au_rwsem *rw)
+{
+	AuDbgRcntInit(rw);
+	init_rwsem(&rw->rwsem);
+}
+
+static inline void au_rw_init_wlock(struct au_rwsem *rw)
+{
+	au_rw_init_nolock(rw);
+	down_write(&rw->rwsem);
+}
+
+static inline void au_rw_init_wlock_nested(struct au_rwsem *rw,
+					   unsigned int lsc)
+{
+	au_rw_init_nolock(rw);
+	down_write_nested(&rw->rwsem, lsc);
+}
+
+static inline void au_rw_read_lock(struct au_rwsem *rw)
+{
+	down_read(&rw->rwsem);
+	AuDbgRcntInc(rw);
+}
+
+static inline void au_rw_read_lock_nested(struct au_rwsem *rw, unsigned int lsc)
+{
+	down_read_nested(&rw->rwsem, lsc);
+	AuDbgRcntInc(rw);
+}
+
+static inline void au_rw_read_unlock(struct au_rwsem *rw)
+{
+	AuDbgRcntDec(rw);
+	up_read(&rw->rwsem);
+}
+
+static inline void au_rw_dgrade_lock(struct au_rwsem *rw)
+{
+	AuDbgRcntInc(rw);
+	downgrade_write(&rw->rwsem);
+}
+
+static inline void au_rw_write_lock(struct au_rwsem *rw)
+{
+	down_write(&rw->rwsem);
+}
+
+static inline void au_rw_write_lock_nested(struct au_rwsem *rw,
+					   unsigned int lsc)
+{
+	down_write_nested(&rw->rwsem, lsc);
+}
+
+static inline void au_rw_write_unlock(struct au_rwsem *rw)
+{
+	up_write(&rw->rwsem);
+}
+
+/* why is not _nested version defined */
+static inline int au_rw_read_trylock(struct au_rwsem *rw)
+{
+	int ret = down_read_trylock(&rw->rwsem);
+	if (ret)
+		AuDbgRcntInc(rw);
+	return ret;
+}
+
+static inline int au_rw_write_trylock(struct au_rwsem *rw)
+{
+	return down_write_trylock(&rw->rwsem);
+}
+
+#undef AuDbgRcntInit
+#undef AuDbgRcntInc
+#undef AuDbgRcntDec
+
+/* to debug easier, do not make them inlined functions */
+#define AuRwMustNoWaiters(rw)	AuDebugOn(!list_empty(&(rw)->rwsem.wait_list))
+#define AuRwMustAnyLock(rw)	AuDebugOn(down_write_trylock(&(rw)->rwsem))
+#ifdef CONFIG_AUFS_DEBUG
+#define AuRwMustReadLock(rw) do { \
+	AuRwMustAnyLock(rw); \
+	AuDebugOn(!atomic_read(&(rw)->rcnt)); \
+} while (0)
+
+#define AuRwMustWriteLock(rw) do { \
+	AuRwMustAnyLock(rw); \
+	AuDebugOn(atomic_read(&(rw)->rcnt)); \
+} while (0)
+#else
+#define AuRwMustReadLock(rw)	AuRwMustAnyLock(rw)
+#define AuRwMustWriteLock(rw)	AuRwMustAnyLock(rw)
+#endif /* CONFIG_AUFS_DEBUG */
+
+#define AuSimpleLockRwsemFuncs(prefix, param, rwsem) \
+static inline void prefix##_read_lock(param) \
+{ au_rw_read_lock(&(rwsem)); } \
+static inline void prefix##_write_lock(param) \
+{ au_rw_write_lock(&(rwsem)); } \
+static inline int prefix##_read_trylock(param) \
+{ return au_rw_read_trylock(&(rwsem)); } \
+static inline int prefix##_write_trylock(param) \
+{ return au_rw_write_trylock(&(rwsem)); }
+/* static inline void prefix##_read_trylock_nested(param, lsc)
+{au_rw_read_trylock_nested(&(rwsem, lsc));}
+static inline void prefix##_write_trylock_nestd(param, lsc)
+{au_rw_write_trylock_nested(&(rwsem), nested);} */
+
+#define AuSimpleUnlockRwsemFuncs(prefix, param, rwsem) \
+static inline void prefix##_read_unlock(param) \
+{ au_rw_read_unlock(&(rwsem)); } \
+static inline void prefix##_write_unlock(param) \
+{ au_rw_write_unlock(&(rwsem)); } \
+static inline void prefix##_downgrade_lock(param) \
+{ au_rw_dgrade_lock(&(rwsem)); }
+
+#define AuSimpleRwsemFuncs(prefix, param, rwsem) \
+	AuSimpleLockRwsemFuncs(prefix, param, rwsem) \
+	AuSimpleUnlockRwsemFuncs(prefix, param, rwsem)
+
+/* ---------------------------------------------------------------------- */
+
+void *au_kzrealloc(void *p, unsigned int nused, unsigned int new_sz, gfp_t gfp);
+
+struct au_nd_store {
+	unsigned int		flags;
+	struct path		path;
+	struct open_intent	intent;
+};
+struct au_sbinfo;
+void au_nd_store(struct au_nd_store *store, struct nameidata *nd,
+		 struct au_sbinfo *sbinfo);
+void au_nd_revert(struct au_nd_store *store, struct nameidata *nd,
+		  struct au_sbinfo *sbinfo);
+
+struct nameidata *au_dup_nd(struct au_sbinfo *sbinfo, struct nameidata *dst,
+			    struct nameidata *src);
+
+struct nameidata *au_fake_dm(struct nameidata *fake_nd, struct nameidata *nd,
+			     struct super_block *sb, aufs_bindex_t bindex);
+void au_fake_dm_release(struct nameidata *fake_nd);
+struct vfsub_args;
+int au_h_create(struct inode *h_dir, struct dentry *h_dentry, int mode,
+		struct vfsub_args *vargs, struct nameidata *nd,
+		struct vfsmount *nfsmnt);
+
+struct au_hinode;
+int au_copy_file(struct file *dst, struct file *src, loff_t len,
+		 struct au_hinode *hdir, struct super_block *sb,
+		 struct vfsub_args *vargs);
+
+#endif /* __KERNEL__ */
+#endif /* __AUFS_MISC_H__ */
diff -Nurp linux-2.6.27.orig/fs/aufs/module.c linux-2.6.27/fs/aufs/module.c
--- linux-2.6.27.orig/fs/aufs/module.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.27/fs/aufs/module.c	2008-12-14 10:37:40.000000000 +0100
@@ -0,0 +1,269 @@
+/*
+ * Copyright (C) 2005-2008 Junjiro Okajima
+ *
+ * This program, aufs is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+ */
+
+/*
+ * module global variables and operations
+ *
+ * $Id: module.c,v 1.12 2008/11/03 01:07:13 sfjro Exp $
+ */
+
+#include <linux/module.h>
+#include "aufs.h"
+
+/* ---------------------------------------------------------------------- */
+
+/*
+ * aufs caches
+ */
+struct kmem_cache *au_cachep[AuCache_Last];
+static int __init create_cache(void)
+{
+	au_cachep[AuCache_DINFO] = AuCache(au_dinfo);
+	if (au_cachep[AuCache_DINFO])
+		au_cachep[AuCache_ICNTNR] = AuCache(aufs_icntnr);
+	if (au_cachep[AuCache_ICNTNR])
+		au_cachep[AuCache_FINFO] = AuCache(au_finfo);
+	if (au_cachep[AuCache_FINFO])
+		au_cachep[AuCache_VDIR] = AuCache(au_vdir);
+	if (au_cachep[AuCache_VDIR])
+		au_cachep[AuCache_DEHSTR] = AuCache(au_vdir_dehstr);
+	if (au_cachep[AuCache_DEHSTR])
+		return 0;
+
+	return -ENOMEM;
+}
+
+static void destroy_cache(void)
+{
+	int i;
+	for (i = 0; i < AuCache_Last; i++)
+		if (au_cachep[i]) {
+			kmem_cache_destroy(au_cachep[i]);
+			au_cachep[i] = NULL;
+		}
+}
+
+/* ---------------------------------------------------------------------- */
+
+char au_esc_chars[0x20 + 3]; /* 0x01-0x20, backslash, del, and NULL */
+int au_dir_roflags;
+
+/*
+ * functions for module interface.
+ */
+MODULE_LICENSE("GPL");
+/* MODULE_LICENSE("GPL v2"); */
+MODULE_AUTHOR("Junjiro Okajima");
+MODULE_DESCRIPTION(AUFS_NAME " -- Another unionfs");
+MODULE_VERSION(AUFS_VERSION);
+
+/* it should be 'byte', but param_set_byte() prints it by "%c" */
+short aufs_nwkq = AUFS_NWKQ_DEF;
+MODULE_PARM_DESC(nwkq, "the number of workqueue thread, " AUFS_WKQ_NAME);
+module_param_named(nwkq, aufs_nwkq, short, S_IRUGO);
+
+int sysaufs_brs;
+MODULE_PARM_DESC(brs, "use <sysfs>/fs/aufs/si_*/brN");
+module_param_named(brs, sysaufs_brs, int, S_IRUGO);
+
+/* ---------------------------------------------------------------------- */
+
+static int __init aufs_init(void)
+{
+	int err, i;
+	char *p;
+
+	au_debug_init();
+#ifdef CONFIG_AUFS_INO_T_64
+	BUILD_BUG_ON(sizeof(ino_t) != sizeof(long long));
+#else
+	BUILD_BUG_ON(sizeof(ino_t) != sizeof(int));
+#endif
+
+	p = au_esc_chars;
+	for (i = 1; i <= ' '; i++)
+		*p++ = i;
+	*p++ = '\\';
+	*p++ = '\x7f';
+	*p = 0;
+
+	au_dir_roflags = au_file_roflags(O_DIRECTORY | O_LARGEFILE);
+
+	err = -EINVAL;
+	if (unlikely(aufs_nwkq <= 0))
+		goto out;
+
+	err = sysaufs_init();
+	if (unlikely(err))
+		goto out;
+	err = au_wkq_init();
+	if (unlikely(err))
+		goto out_sysaufs;
+	err = au_inotify_init();
+	if (unlikely(err))
+		goto out_wkq;
+	err = au_sysrq_init();
+	if (unlikely(err))
+		goto out_inotify;
+
+	err = create_cache();
+	if (unlikely(err))
+		goto out_sysrq;
+
+	err = register_filesystem(&aufs_fs_type);
+	if (unlikely(err))
+		goto out_cache;
+	pr_info(AUFS_NAME " " AUFS_VERSION "\n");
+	return 0; /* success */
+
+ out_cache:
+	destroy_cache();
+ out_sysrq:
+	au_sysrq_fin();
+ out_inotify:
+	au_inotify_fin();
+ out_wkq:
+	au_wkq_fin();
+ out_sysaufs:
+	sysaufs_fin();
+ out:
+	AuTraceErr(err);
+	return err;
+}
+
+static void __exit aufs_exit(void)
+{
+	unregister_filesystem(&aufs_fs_type);
+	destroy_cache();
+
+	au_sysrq_fin();
+	au_inotify_fin();
+	au_wkq_fin();
+	sysaufs_fin();
+}
+
+module_init(aufs_init);
+module_exit(aufs_exit);
+
+/* ---------------------------------------------------------------------- */
+
+/* fake Kconfig */
+#if 1
+
+#if AUFS_BRANCH_MAX > 511 && PAGE_SIZE > 4096
+#warning pagesize is larger than 4kb, \
+	CONFIG_AUFS_BRANCH_MAX_511 or smaller is recommended.
+#endif
+
+#ifdef CONFIG_AUFS_STAT
+#ifndef CONFIG_SYSFS
+#error CONFIG_AUFS_STAT requires CONFIG_SYSFS.
+#endif
+#endif /* CONFIG_AUFS_STAT */
+
+#ifdef CONFIG_AUFS_SYSAUFS
+#warning CONFIG_AUFS_SYSAUFS is unnecessary for linux-2.6.25 and later.
+#endif
+
+#ifdef CONFIG_AUFS_HINOTIFY
+#ifndef CONFIG_INOTIFY
+#error enable CONFIG_INOTIFY to use CONFIG_AUFS_HINOTIFY.
+#endif
+#endif /* CONFIG_AUFS_HINOTIFY */
+
+#ifdef CONFIG_AUFS_EXPORT
+#if !defined(CONFIG_EXPORTFS) && !defined(CONFIG_EXPORTFS_MODULE)
+#error CONFIG_AUFS_EXPORT requires CONFIG_EXPORTFS
+#endif
+#if defined(CONFIG_EXPORTFS_MODULE) && defined(CONFIG_AUFS)
+#error need CONFIG_EXPORTFS = y to link aufs statically with CONFIG_AUFS_EXPORT.
+#endif
+#endif /* CONFIG_AUFS_EXPORT */
+
+#ifdef CONFIG_AUFS_SEC_PERM_PATCH
+#ifndef CONFIG_SECURITY
+#warning AUFS_SEC_PERM_PATCH is unnecessary since SECURITY is disabled.
+#endif
+#ifdef CONFIG_AUFS
+#warning AUFS_SEC_PERM_PATCH is unnecessary since AUFS is not a module.
+#endif
+#endif
+
+#ifdef CONFIG_AUFS_LHASH_PATCH
+#if !defined(CONFIG_NFS_FS) && !defined(CONFIG_NFS_FS_MODULE)
+#warning CONFIG_AUFS_LHASH_PATCH is unnecessary since CONFIG_NFS_FS is disabled.
+#endif
+#endif
+
+#ifdef CONFIG_AUFS_PUT_FILP_PATCH
+#ifndef CONFIG_NFS_V4
+#warning AUFS_PUT_FILP_PATCH is unnecessary since NFS_V4 is disabled.
+#endif
+#ifdef CONFIG_AUFS
+#warning AUFS_PUT_FILP_PATCH is unnecessary since AUFS is not a module.
+#endif
+#endif /* CONFIG_AUFS_PUT_FILP_PATCH */
+
+#ifdef CONFIG_AUFS_FSYNC_SUPER_PATCH
+#ifdef CONFIG_AUFS
+#warning AUFS_FSYNC_SUPER_PATCH is unnecessary since AUFS is not a module.
+#endif
+#endif
+
+#ifdef CONFIG_AUFS_DENY_WRITE_ACCESS_PATCH
+#ifdef CONFIG_AUFS
+#warning AUFS_DENY_WRITE_ACCESS_PATCH is unnecessary since AUFS is not a module.
+#endif
+#endif
+
+#ifdef CONFIG_AUFS_KSIZE_PATCH
+#warning CONFIG_AUFS_KSIZE_PATCH is unnecessary for linux-2.6.22 and later.
+#endif
+
+#ifdef CONFIG_AUFS_WORKAROUND_FUSE
+#if !defined(CONFIG_FUSE_FS) && !defined(CONFIG_FUSE_FS_MODULE)
+#warning CONFIG_AUFS_WORKAROUND_FUSE is enabled while FUSE is disabled.
+#endif
+#endif
+
+#ifdef CONFIG_AUFS_DEBUG_LOCK
+#ifndef CONFIG_AUFS_MAGIC_SYSRQ
+#warning CONFIG_AUFS_DEBUG_LOCK is enabled but CONFIG_AUFS_MAGIC_SYSRQ.
+#endif
+#endif
+
+#ifdef CONFIG_AUFS_COMPAT
+#warning CONFIG_AUFS_COMPAT will be removed in the near future.
+#endif
+
+#ifdef CONFIG_AUFS_UNIONFS23_PATCH
+#ifndef CONFIG_AUFS_UNIONFS22_PATCH
+#error mis-config. AUFS_UNIONFS23_PATCH is enabled but AUFS_UNIONFS22_PATCH.
+#endif
+#ifndef CONFIG_AUFS_SPLICE_PATCH
+#error mis-config. AUFS_UNIONFS23_PATCH is enabled but AUFS_SPLICE_PATCH.
+#endif
+#endif
+
+#ifdef CONFIG_DEBUG_PROVE_LOCKING
+#if MAX_LOCKDEP_SUBCLASSES < AuLsc_I_End
+#warning lockdep will not work since aufs uses deeper locks.
+#endif
+#endif
+
+#endif
diff -Nurp linux-2.6.27.orig/fs/aufs/module.h linux-2.6.27/fs/aufs/module.h
--- linux-2.6.27.orig/fs/aufs/module.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.27/fs/aufs/module.h	2008-08-25 03:50:37.000000000 +0200
@@ -0,0 +1,73 @@
+/*
+ * Copyright (C) 2005-2008 Junjiro Okajima
+ *
+ * This program, aufs is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+ */
+
+/*
+ * module initialization and module-global
+ *
+ * $Id: module.h,v 1.8 2008/08/25 01:50:37 sfjro Exp $
+ */
+
+#ifndef __AUFS_MODULE_H__
+#define __AUFS_MODULE_H__
+
+#ifdef __KERNEL__
+
+/* module parameters */
+extern short aufs_nwkq;
+extern int sysaufs_brs;
+
+/* ---------------------------------------------------------------------- */
+
+extern char au_esc_chars[];
+extern int au_dir_roflags;
+
+/* kmem cache */
+enum {
+	AuCache_DINFO,
+	AuCache_ICNTNR,
+	AuCache_FINFO,
+	AuCache_VDIR,
+	AuCache_DEHSTR,
+#ifdef CONFIG_AUFS_HINOTIFY
+	AuCache_HINOTIFY,
+#endif
+	AuCache_Last
+};
+
+extern struct kmem_cache *au_cachep[];
+
+#define AuCacheArgs(type, sz)	(type), (sz), 0, SLAB_RECLAIM_ACCOUNT, NULL
+#define AuCache(type) \
+	kmem_cache_create(AuCacheArgs(#type, sizeof(struct type)))
+
+/* ---------------------------------------------------------------------- */
+
+#define AuCacheFuncs(name, index) \
+static inline void *au_cache_alloc_##name(void) \
+{ return kmem_cache_alloc(au_cachep[index], GFP_NOFS); } \
+static inline void au_cache_free_##name(void *p) \
+{ kmem_cache_free(au_cachep[index], p); }
+
+AuCacheFuncs(dinfo, AuCache_DINFO);
+AuCacheFuncs(icntnr, AuCache_ICNTNR);
+AuCacheFuncs(finfo, AuCache_FINFO);
+AuCacheFuncs(vdir, AuCache_VDIR);
+AuCacheFuncs(dehstr, AuCache_DEHSTR);
+
+#endif /* __KERNEL__ */
+#endif /* __AUFS_MODULE_H__ */
diff -Nurp linux-2.6.27.orig/fs/aufs/opts.c linux-2.6.27/fs/aufs/opts.c
--- linux-2.6.27.orig/fs/aufs/opts.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.27/fs/aufs/opts.c	2008-12-14 10:37:40.000000000 +0100
@@ -0,0 +1,1605 @@
+/*
+ * Copyright (C) 2005-2008 Junjiro Okajima
+ *
+ * This program, aufs is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+ */
+
+/*
+ * mount options/flags
+ *
+ * $Id: opts.c,v 1.19 2008/12/01 03:49:29 sfjro Exp $
+ */
+
+#include <linux/types.h> /* a distribution requires */
+#include <linux/parser.h>
+#include "aufs.h"
+
+/* ---------------------------------------------------------------------- */
+
+enum {
+	Opt_br,
+	Opt_add, Opt_del, Opt_mod, Opt_reorder, Opt_append, Opt_prepend,
+	Opt_idel, Opt_imod, Opt_ireorder,
+	Opt_dirwh, Opt_rdcache, Opt_deblk, Opt_nhash, Opt_rendir,
+	Opt_xino, Opt_zxino, Opt_noxino,
+	Opt_trunc_xino, Opt_trunc_xino_v, Opt_notrunc_xino,
+	Opt_trunc_xino_path, Opt_itrunc_xino,
+	Opt_xinodir,
+	Opt_trunc_xib, Opt_notrunc_xib,
+	Opt_dirperm1, Opt_nodirperm1,
+	Opt_shwh, Opt_noshwh,
+	Opt_plink, Opt_noplink, Opt_list_plink, Opt_clean_plink,
+	Opt_udba,
+	/* Opt_lock, Opt_unlock, */
+	Opt_cmd, Opt_cmd_args,
+	Opt_diropq_a, Opt_diropq_w,
+	Opt_warn_perm, Opt_nowarn_perm,
+	Opt_wbr_copyup, Opt_wbr_create,
+	Opt_coo,
+	Opt_dlgt, Opt_nodlgt,
+	Opt_refrof, Opt_norefrof,
+	Opt_verbose, Opt_noverbose,
+	Opt_sum, Opt_nosum, Opt_wsum,
+	Opt_tail, Opt_ignore, Opt_ignore_silent, Opt_err
+};
+
+static match_table_t options = {
+	{Opt_br, "br=%s"},
+	{Opt_br, "br:%s"},
+
+	{Opt_add, "add=%d:%s"},
+	{Opt_add, "add:%d:%s"},
+	{Opt_add, "ins=%d:%s"},
+	{Opt_add, "ins:%d:%s"},
+	{Opt_append, "append=%s"},
+	{Opt_append, "append:%s"},
+	{Opt_prepend, "prepend=%s"},
+	{Opt_prepend, "prepend:%s"},
+
+	{Opt_del, "del=%s"},
+	{Opt_del, "del:%s"},
+	/* {Opt_idel, "idel:%d"}, */
+	{Opt_mod, "mod=%s"},
+	{Opt_mod, "mod:%s"},
+	{Opt_imod, "imod:%d:%s"},
+
+	{Opt_dirwh, "dirwh=%d"},
+	{Opt_dirwh, "dirwh:%d"},
+
+	{Opt_xino, "xino=%s"},
+	{Opt_xino, "xino:%s"},
+#if 0 /* def CONFIG_AUFS_EXPORT */ /* reserved for futur use */
+	{Opt_xinodir, "xinodir=%s"},
+	{Opt_xinodir, "xinodir:%s"},
+#endif
+	{Opt_noxino, "noxino"},
+	{Opt_trunc_xino, "trunc_xino"},
+	{Opt_trunc_xino_v, "trunc_xino_v=%d:%d"},
+	{Opt_notrunc_xino, "notrunc_xino"},
+	{Opt_trunc_xino_path, "trunc_xino=%s"},
+	{Opt_trunc_xino_path, "trunc_xino:%s"},
+	{Opt_itrunc_xino, "itrunc_xino=%d"},
+	{Opt_itrunc_xino, "itrunc_xino:%d"},
+	/* {Opt_zxino, "zxino=%s"}, */
+	{Opt_trunc_xib, "trunc_xib"},
+	{Opt_notrunc_xib, "notrunc_xib"},
+
+	{Opt_plink, "plink"},
+	{Opt_noplink, "noplink"},
+#ifdef CONFIG_AUFS_DEBUG
+	{Opt_list_plink, "list_plink"},
+#endif
+	{Opt_clean_plink, "clean_plink"},
+
+	{Opt_udba, "udba=%s"},
+
+	{Opt_diropq_a, "diropq=always"},
+	{Opt_diropq_a, "diropq=a"},
+	{Opt_diropq_w, "diropq=whiteouted"},
+	{Opt_diropq_w, "diropq=w"},
+
+	{Opt_warn_perm, "warn_perm"},
+	{Opt_nowarn_perm, "nowarn_perm"},
+
+#ifdef CONFIG_AUFS_DLGT
+	{Opt_dlgt, "dlgt"},
+	{Opt_dirperm1, "dirperm1"},
+#endif
+	{Opt_nodlgt, "nodlgt"},
+	{Opt_nodirperm1, "nodirperm1"},
+
+#ifdef CONFIG_AUFS_SHWH
+	{Opt_shwh, "shwh"},
+#endif
+	{Opt_noshwh, "noshwh"},
+
+	{Opt_rendir, "rendir=%d"},
+	{Opt_rendir, "rendir:%d"},
+
+	{Opt_refrof, "refrof"},
+	{Opt_norefrof, "norefrof"},
+
+	{Opt_verbose, "verbose"},
+	{Opt_verbose, "v"},
+	{Opt_noverbose, "noverbose"},
+	{Opt_noverbose, "quiet"},
+	{Opt_noverbose, "q"},
+	{Opt_noverbose, "silent"},
+
+	{Opt_sum, "sum"},
+	{Opt_nosum, "nosum"},
+	{Opt_wsum, "wsum"},
+
+	{Opt_rdcache, "rdcache=%d"},
+	{Opt_rdcache, "rdcache:%d"},
+
+	{Opt_coo, "coo=%s"},
+
+	{Opt_wbr_create, "create=%s"},
+	{Opt_wbr_create, "create:%s"},
+	{Opt_wbr_create, "create_policy=%s"},
+	{Opt_wbr_create, "create_policy:%s"},
+	{Opt_wbr_copyup, "cpup=%s"},
+	{Opt_wbr_copyup, "cpup:%s"},
+	{Opt_wbr_copyup, "copyup=%s"},
+	{Opt_wbr_copyup, "copyup:%s"},
+	{Opt_wbr_copyup, "copyup_policy=%s"},
+	{Opt_wbr_copyup, "copyup_policy:%s"},
+
+	/* internal use for the scripts */
+	{Opt_ignore_silent, "si=%s"},
+
+#if 0 /* reserved for future use */
+	{Opt_deblk, "deblk=%d"},
+	{Opt_deblk, "deblk:%d"},
+	{Opt_nhash, "nhash=%d"},
+	{Opt_nhash, "nhash:%d"},
+#endif
+
+	{Opt_br, "dirs=%s"},
+	{Opt_ignore, "debug=%d"},
+	{Opt_ignore, "delete=whiteout"},
+	{Opt_ignore, "delete=all"},
+	{Opt_ignore, "imap=%s"},
+
+	{Opt_err, NULL}
+};
+
+/* ---------------------------------------------------------------------- */
+
+static const char *au_parser_pattern(int val, struct match_token *token)
+{
+	while (token->pattern) {
+		if (token->token == val)
+			return token->pattern;
+		token++;
+	}
+	BUG();
+	return "??";
+}
+
+/* ---------------------------------------------------------------------- */
+
+#define RW		"rw"
+#define RO		"ro"
+#define WH		"wh"
+#define RR		"rr"
+#define NoLinkWH	"nolwh"
+
+static match_table_t brperms = {
+	{AuBrPerm_RR, RR},
+	{AuBrPerm_RO, RO},
+	{AuBrPerm_RW, RW},
+
+	{AuBrPerm_RRWH, RR "+" WH},
+	{AuBrPerm_ROWH, RO "+" WH},
+	{AuBrPerm_RWNoLinkWH, RW "+" NoLinkWH},
+
+	{AuBrPerm_ROWH, "nfsro"},
+	{AuBrPerm_RO, NULL}
+};
+
+static noinline_for_stack int br_perm_val(char *perm)
+{
+	int val;
+	substring_t args[MAX_OPT_ARGS];
+
+	AuDebugOn(!perm || !*perm);
+	LKTRTrace("perm %s\n", perm);
+	val = match_token(perm, brperms, args);
+	AuTraceErr(val);
+	return val;
+}
+
+const char *au_optstr_br_perm(int brperm)
+{
+	return au_parser_pattern(brperm, (void *)brperms);
+}
+
+/* ---------------------------------------------------------------------- */
+
+static match_table_t udbalevel = {
+	{AuOpt_UDBA_REVAL, "reval"},
+#ifdef CONFIG_AUFS_HINOTIFY
+	{AuOpt_UDBA_INOTIFY, "inotify"},
+#endif
+	{AuOpt_UDBA_NONE, "none"},
+	{-1, NULL}
+};
+
+static noinline_for_stack int udba_val(char *str)
+{
+	substring_t args[MAX_OPT_ARGS];
+	return match_token(str, udbalevel, args);
+}
+
+const char *au_optstr_udba(int udba)
+{
+	return au_parser_pattern(udba, (void *)udbalevel);
+}
+
+/* ---------------------------------------------------------------------- */
+
+static match_table_t coolevel = {
+	{AuOpt_COO_NONE, "none"},
+	{AuOpt_COO_LEAF, "leaf"},
+	{AuOpt_COO_ALL, "all"},
+	{-1, NULL}
+};
+
+static noinline_for_stack int coo_val(char *str)
+{
+	substring_t args[MAX_OPT_ARGS];
+	return match_token(str, coolevel, args);
+}
+
+const char *au_optstr_coo(int coo)
+{
+	return au_parser_pattern(coo, (void *)coolevel);
+}
+
+/* ---------------------------------------------------------------------- */
+
+static match_table_t au_wbr_create_policy = {
+	{AuWbrCreate_TDP, "tdp"},
+	{AuWbrCreate_TDP, "top-down-parent"},
+	{AuWbrCreate_RR, "rr"},
+	{AuWbrCreate_RR, "round-robin"},
+	{AuWbrCreate_MFS, "mfs"},
+	{AuWbrCreate_MFS, "most-free-space"},
+	{AuWbrCreate_MFSV, "mfs:%d"},
+	{AuWbrCreate_MFSV, "most-free-space:%d"},
+
+	{AuWbrCreate_MFSRR, "mfsrr:%d"},
+	{AuWbrCreate_MFSRRV, "mfsrr:%d:%d"},
+	{AuWbrCreate_PMFS, "pmfs"},
+	{AuWbrCreate_PMFSV, "pmfs:%d"},
+
+	{-1, NULL}
+};
+
+/* cf. linux/lib/parser.c */
+static int au_match_ull(substring_t *s, unsigned long long *result)
+{
+	int err;
+	unsigned int len;
+	char a[32];
+
+	err = -ERANGE;
+	len = s->to - s->from;
+	if (len + 1 <= sizeof(a)) {
+		memcpy(a, s->from, len);
+		a[len] = '\0';
+#if 1
+		err = strict_strtoull(a, 0, result);
+#else
+		char *next;
+		*result = memparse(a, &next);
+		err = *result;
+		if (!IS_ERR((void *)err))
+			err = 0;
+#endif
+	}
+	return err;
+}
+
+static int au_wbr_mfs_wmark(substring_t *arg, char *str,
+			    struct au_opt_wbr_create *create)
+{
+	int err;
+	unsigned long long ull;
+
+	err = 0;
+	if (!au_match_ull(arg, &ull))
+		create->mfsrr_watermark = ull;
+	else {
+		AuErr("bad integer in %s\n", str);
+		err = -EINVAL;
+	}
+
+	AuTraceErr(err);
+	return err;
+}
+
+static int au_wbr_mfs_sec(substring_t *arg, char *str,
+			  struct au_opt_wbr_create *create)
+{
+	int n, err;
+
+	err = 0;
+	if (!match_int(arg, &n) && 0 <= n)
+		create->mfs_second = n;
+	else {
+		AuErr("bad integer in %s\n", str);
+		err = -EINVAL;
+	}
+
+	AuTraceErr(err);
+	return err;
+}
+
+static noinline_for_stack
+int au_wbr_create_val(char *str, struct au_opt_wbr_create *create)
+{
+	int err, e;
+	substring_t args[MAX_OPT_ARGS];
+
+	err = match_token(str, au_wbr_create_policy, args);
+	create->wbr_create = err;
+	switch (err) {
+	case AuWbrCreate_MFSRRV:
+		e = au_wbr_mfs_wmark(&args[0], str, create);
+		if (!e)
+			e = au_wbr_mfs_sec(&args[1], str, create);
+		if (unlikely(e))
+			err = e;
+		break;
+	case AuWbrCreate_MFSRR:
+		e = au_wbr_mfs_wmark(&args[0], str, create);
+		if (unlikely(e)) {
+			err = e;
+			break;
+		}
+		/*FALLTHROUGH*/
+	case AuWbrCreate_MFS:
+	case AuWbrCreate_PMFS:
+		create->mfs_second = AUFS_MFS_SECOND_DEF;
+		break;
+	case AuWbrCreate_MFSV:
+	case AuWbrCreate_PMFSV:
+		e = au_wbr_mfs_sec(&args[0], str, create);
+		if (unlikely(e))
+			err = e;
+		break;
+	}
+
+	return err;
+}
+
+const char *au_optstr_wbr_create(int wbr_create)
+{
+	return au_parser_pattern(wbr_create, (void *)au_wbr_create_policy);
+}
+
+static match_table_t au_wbr_copyup_policy = {
+	{AuWbrCopyup_TDP, "tdp"},
+	{AuWbrCopyup_TDP, "top-down-parent"},
+	{AuWbrCopyup_BUP, "bup"},
+	{AuWbrCopyup_BUP, "bottom-up-parent"},
+	{AuWbrCopyup_BU, "bu"},
+	{AuWbrCopyup_BU, "bottom-up"},
+	{-1, NULL}
+};
+
+static noinline_for_stack int au_wbr_copyup_val(char *str)
+{
+	substring_t args[MAX_OPT_ARGS];
+	return match_token(str, au_wbr_copyup_policy, args);
+}
+
+const char *au_optstr_wbr_copyup(int wbr_copyup)
+{
+	return au_parser_pattern(wbr_copyup, (void *)au_wbr_copyup_policy);
+}
+
+/* ---------------------------------------------------------------------- */
+
+static const int lkup_dirflags = LOOKUP_FOLLOW | LOOKUP_DIRECTORY;
+
+static void dump_opts(struct au_opts *opts)
+{
+#ifdef CONFIG_AUFS_DEBUG
+	/* reduce stack space */
+	union {
+		struct au_opt_add *add;
+		struct au_opt_del *del;
+		struct au_opt_mod *mod;
+		struct au_opt_xino *xino;
+		struct au_opt_xinodir *xinodir;
+		struct au_opt_xino_itrunc *xino_itrunc;
+		struct au_opt_wbr_create *create;
+	} u;
+	struct au_opt *opt;
+
+	AuTraceEnter();
+
+	opt = opts->opt;
+	while (/* opt < opts_tail && */ opt->type != Opt_tail) {
+		switch (opt->type) {
+		case Opt_add:
+			u.add = &opt->add;
+			LKTRTrace("add {b%d, %s, 0x%x, %p}\n",
+				  u.add->bindex, u.add->path, u.add->perm,
+				  u.add->nd.path.dentry);
+			break;
+		case Opt_del:
+		case Opt_idel:
+			u.del = &opt->del;
+			LKTRTrace("del {%s, %p}\n", u.del->path, u.del->h_root);
+			break;
+		case Opt_mod:
+		case Opt_imod:
+			u.mod = &opt->mod;
+			LKTRTrace("mod {%s, 0x%x, %p}\n",
+				  u.mod->path, u.mod->perm, u.mod->h_root);
+			break;
+		case Opt_append:
+			u.add = &opt->add;
+			LKTRTrace("append {b%d, %s, 0x%x, %p}\n",
+				  u.add->bindex, u.add->path, u.add->perm,
+				  u.add->nd.path.dentry);
+			break;
+		case Opt_prepend:
+			u.add = &opt->add;
+			LKTRTrace("prepend {b%d, %s, 0x%x, %p}\n",
+				  u.add->bindex, u.add->path, u.add->perm,
+				  u.add->nd.path.dentry);
+			break;
+		case Opt_dirwh:
+			LKTRTrace("dirwh %d\n", opt->dirwh);
+			break;
+		case Opt_rdcache:
+			LKTRTrace("rdcache %d\n", opt->rdcache);
+			break;
+		case Opt_xino:
+			u.xino = &opt->xino;
+			LKTRTrace("xino {%s %.*s}\n",
+				  u.xino->path,
+				  AuDLNPair(u.xino->file->f_dentry));
+			break;
+		case Opt_xinodir:
+			u.xinodir = &opt->xinodir;
+			LKTRTrace("xinodir {%s %.*s}\n",
+				  u.xinodir->name,
+				  AuDLNPair(u.xinodir->path.dentry));
+			break;
+		case Opt_trunc_xino:
+			LKTRLabel(trunc_xino);
+			break;
+		case Opt_notrunc_xino:
+			LKTRLabel(notrunc_xino);
+			break;
+		case Opt_trunc_xino_path:
+		case Opt_itrunc_xino:
+			u.xino_itrunc = &opt->xino_itrunc;
+			LKTRTrace("trunc_xino %d\n", u.xino_itrunc->bindex);
+			break;
+
+		case Opt_noxino:
+			LKTRLabel(noxino);
+			break;
+		case Opt_trunc_xib:
+			LKTRLabel(trunc_xib);
+			break;
+		case Opt_notrunc_xib:
+			LKTRLabel(notrunc_xib);
+			break;
+		case Opt_dirperm1:
+			LKTRLabel(dirperm1);
+			break;
+		case Opt_nodirperm1:
+			LKTRLabel(nodirperm1);
+			break;
+		case Opt_shwh:
+			LKTRLabel(shwh);
+			break;
+		case Opt_noshwh:
+			LKTRLabel(noshwh);
+			break;
+		case Opt_plink:
+			LKTRLabel(plink);
+			break;
+		case Opt_noplink:
+			LKTRLabel(noplink);
+			break;
+		case Opt_list_plink:
+			LKTRLabel(list_plink);
+			break;
+		case Opt_clean_plink:
+			LKTRLabel(clean_plink);
+			break;
+		case Opt_udba:
+			LKTRTrace("udba %d, %s\n",
+				  opt->udba, au_optstr_udba(opt->udba));
+			break;
+		case Opt_diropq_a:
+			LKTRLabel(diropq_a);
+			break;
+		case Opt_diropq_w:
+			LKTRLabel(diropq_w);
+			break;
+		case Opt_warn_perm:
+			LKTRLabel(warn_perm);
+			break;
+		case Opt_nowarn_perm:
+			LKTRLabel(nowarn_perm);
+			break;
+		case Opt_dlgt:
+			LKTRLabel(dlgt);
+			break;
+		case Opt_nodlgt:
+			LKTRLabel(nodlgt);
+			break;
+		case Opt_refrof:
+			LKTRLabel(refrof);
+			break;
+		case Opt_norefrof:
+			LKTRLabel(norefrof);
+			break;
+		case Opt_verbose:
+			LKTRLabel(verbose);
+			break;
+		case Opt_noverbose:
+			LKTRLabel(noverbose);
+			break;
+		case Opt_sum:
+			LKTRLabel(sum);
+			break;
+		case Opt_nosum:
+			LKTRLabel(nosum);
+			break;
+		case Opt_wsum:
+			LKTRLabel(wsum);
+			break;
+		case Opt_coo:
+			LKTRTrace("coo %d, %s\n",
+				  opt->coo, au_optstr_coo(opt->coo));
+			break;
+		case Opt_wbr_create:
+			u.create = &opt->wbr_create;
+			LKTRTrace("create %d, %s\n", u.create->wbr_create,
+				  au_optstr_wbr_create(u.create->wbr_create));
+			switch (u.create->wbr_create) {
+			case AuWbrCreate_MFSV:
+			case AuWbrCreate_PMFSV:
+				LKTRTrace("%d sec\n", u.create->mfs_second);
+				break;
+			case AuWbrCreate_MFSRR:
+				LKTRTrace("%llu watermark\n",
+					  u.create->mfsrr_watermark);
+				break;
+			case AuWbrCreate_MFSRRV:
+				LKTRTrace("%llu watermark, %d sec\n",
+					  u.create->mfsrr_watermark,
+					  u.create->mfs_second);
+				break;
+			}
+			break;
+		case Opt_wbr_copyup:
+			LKTRTrace("copyup %d, %s\n", opt->wbr_copyup,
+				  au_optstr_wbr_copyup(opt->wbr_copyup));
+			break;
+		default:
+			BUG();
+		}
+		opt++;
+	}
+#endif
+}
+
+void au_opts_free(struct au_opts *opts)
+{
+	struct au_opt *opt;
+
+	AuTraceEnter();
+
+	opt = opts->opt;
+	while (opt->type != Opt_tail) {
+		switch (opt->type) {
+		case Opt_add:
+		case Opt_append:
+		case Opt_prepend:
+			path_put(&opt->add.nd.path);
+			break;
+		case Opt_del:
+		case Opt_idel:
+			dput(opt->del.h_root);
+			break;
+		case Opt_mod:
+		case Opt_imod:
+			dput(opt->mod.h_root);
+			break;
+		case Opt_xino:
+			fput(opt->xino.file);
+			break;
+		case Opt_xinodir:
+			path_put(&opt->xinodir.path);
+			break;
+		}
+		opt++;
+	}
+}
+
+static int opt_add(struct au_opt *opt, char *opt_str, unsigned long sb_flags,
+		   struct super_block *sb, aufs_bindex_t bindex)
+{
+	int err;
+	struct au_opt_add *add = &opt->add;
+	char *p;
+
+	LKTRTrace("%s, b%d\n", opt_str, bindex);
+
+	add->bindex = bindex;
+	add->perm = AuBrPerm_Last;
+	add->path = opt_str;
+	p = strchr(opt_str, '=');
+	if (p) {
+		*p++ = 0;
+		if (*p)
+			add->perm = br_perm_val(p);
+	}
+
+	/* LSM may detect it */
+	/* do not superio. */
+	err = vfsub_path_lookup(add->path, lkup_dirflags, &add->nd);
+	if (!err) {
+		if (!p /* && add->perm == AuBrPerm_Last */) {
+			add->perm = AuBrPerm_RO;
+			if (au_test_def_rr(add->nd.path.dentry->d_sb))
+				add->perm = AuBrPerm_RR;
+			if (!bindex && !(sb_flags & MS_RDONLY))
+				add->perm = AuBrPerm_RW;
+#ifdef CONFIG_AUFS_COMPAT
+			add->perm = AuBrPerm_RW;
+#endif
+		}
+		opt->type = Opt_add;
+		goto out;
+	}
+	AuErr("lookup failed %s (%d)\n", add->path, err);
+	err = -EINVAL;
+
+ out:
+	AuTraceErr(err);
+	return err;
+}
+
+/* called without aufs lock */
+int au_opts_parse(struct super_block *sb, char *str, struct au_opts *opts)
+{
+	int err, n, token;
+	struct dentry *root;
+	struct au_opt *opt, *opt_tail;
+	char *opt_str, *p;
+	aufs_bindex_t bindex, bend;
+	unsigned char skipped;
+	union {
+		struct au_opt_del *del;
+		struct au_opt_mod *mod;
+		struct au_opt_xino *xino;
+		struct au_opt_xinodir *xinodir;
+		struct au_opt_xino_itrunc *xino_itrunc;
+		struct au_opt_wbr_create *create;
+	} u;
+	struct file *file;
+	/* reduce the stack space */
+	struct {
+		substring_t args[MAX_OPT_ARGS];
+		struct nameidata nd;
+	} *a;
+
+	LKTRTrace("%s, nopts %d\n", str, opts->max_opt);
+
+	err = -ENOMEM;
+	a = kmalloc(sizeof(*a), GFP_NOFS);
+	if (unlikely(!a))
+		goto out;
+
+	root = sb->s_root;
+	err = 0;
+	bindex = 0;
+	opt = opts->opt;
+	opt_tail = opt + opts->max_opt - 1;
+	opt->type = Opt_tail;
+	while (!err && (opt_str = strsep(&str, ",")) && *opt_str) {
+		err = -EINVAL;
+		token = match_token(opt_str, options, a->args);
+		LKTRTrace("%s, token %d, a->args[0]{%p, %p}\n",
+			  opt_str, token, a->args[0].from, a->args[0].to);
+
+		skipped = 0;
+		switch (token) {
+		case Opt_br:
+			err = 0;
+			while (!err && (opt_str = strsep(&a->args[0].from, ":"))
+			       && *opt_str) {
+				err = opt_add(opt, opt_str, opts->sb_flags, sb,
+					      bindex++);
+				if (unlikely(!err && ++opt > opt_tail)) {
+					err = -E2BIG;
+					break;
+				}
+				opt->type = Opt_tail;
+				skipped = 1;
+			}
+			break;
+		case Opt_add:
+			if (unlikely(match_int(&a->args[0], &n))) {
+				AuErr("bad integer in %s\n", opt_str);
+				break;
+			}
+			bindex = n;
+			err = opt_add(opt, a->args[1].from, opts->sb_flags, sb,
+				      bindex);
+			break;
+		case Opt_append:
+			err = opt_add(opt, a->args[0].from, opts->sb_flags, sb,
+				      /*dummy bindex*/1);
+			if (!err)
+				opt->type = token;
+			break;
+		case Opt_prepend:
+			err = opt_add(opt, a->args[0].from, opts->sb_flags, sb,
+				      /*bindex*/0);
+			if (!err)
+				opt->type = token;
+			break;
+		case Opt_del:
+			u.del = &opt->del;
+			u.del->path = a->args[0].from;
+			LKTRTrace("del path %s\n", u.del->path);
+			/* LSM may detect it */
+			/* do not superio. */
+			err = vfsub_path_lookup(u.del->path, lkup_dirflags,
+						&a->nd);
+			if (unlikely(err)) {
+				AuErr("lookup failed %s (%d)\n",
+				      u.del->path, err);
+				break;
+			}
+			u.del->h_root = dget(a->nd.path.dentry);
+			path_put(&a->nd.path);
+			opt->type = token;
+			break;
+#if 0 /* reserved for future use */
+		case Opt_idel:
+			u.del = &opt->del;
+			u.del->path = "(indexed)";
+			if (unlikely(match_int(&a->args[0], &n))) {
+				AuErr("bad integer in %s\n", opt_str);
+				break;
+			}
+			bindex = n;
+			aufs_read_lock(root, AuLock_FLUSH);
+			if (bindex < 0 || au_sbend(sb) < bindex) {
+				AuErr("out of bounds, %d\n", bindex);
+				aufs_read_unlock(root, !AuLock_IR);
+				break;
+			}
+			err = 0;
+			u.del->h_root = dget(au_h_dptr(root, bindex));
+			opt->type = token;
+			aufs_read_unlock(root, !AuLock_IR);
+			break;
+#endif
+		case Opt_mod:
+			u.mod = &opt->mod;
+			u.mod->path = a->args[0].from;
+			p = strchr(u.mod->path, '=');
+			if (unlikely(!p)) {
+				AuErr("no permssion %s\n", opt_str);
+				break;
+			}
+			*p++ = 0;
+			u.mod->perm = br_perm_val(p);
+			LKTRTrace("mod path %s, perm 0x%x, %s\n",
+				  u.mod->path, u.mod->perm, p);
+			/* LSM may detect it */
+			/* do not superio. */
+			err = vfsub_path_lookup(u.mod->path, lkup_dirflags,
+						&a->nd);
+			if (unlikely(err)) {
+				AuErr("lookup failed %s (%d)\n",
+				      u.mod->path, err);
+				break;
+			}
+			u.mod->h_root = dget(a->nd.path.dentry);
+			path_put(&a->nd.path);
+			opt->type = token;
+			break;
+#ifdef IMOD /* reserved for future use */
+		case Opt_imod:
+			u.mod = &opt->mod;
+			u.mod->path = "(indexed)";
+			if (unlikely(match_int(&a->args[0], &n))) {
+				AuErr("bad integer in %s\n", opt_str);
+				break;
+			}
+			bindex = n;
+			aufs_read_lock(root, AuLock_FLUSH);
+			if (bindex < 0 || au_sbend(sb) < bindex) {
+				AuErr("out of bounds, %d\n", bindex);
+				aufs_read_unlock(root, !AuLock_IR);
+				break;
+			}
+			u.mod->perm = br_perm_val(a->args[1].from);
+			LKTRTrace("mod path %s, perm 0x%x, %s\n",
+				  u.mod->path, u.mod->perm, a->args[1].from);
+			err = 0;
+			u.mod->h_root = dget(au_h_dptr(root, bindex));
+			opt->type = token;
+			aufs_read_unlock(root, !AuLock_IR);
+			break;
+#endif
+		case Opt_xino:
+			u.xino = &opt->xino;
+			file = au_xino_create(sb, a->args[0].from, /*silent*/0);
+			err = PTR_ERR(file);
+			if (IS_ERR(file))
+				break;
+			err = -EINVAL;
+			if (unlikely(file->f_dentry->d_sb == sb)) {
+				fput(file);
+				AuErr("%s must be outside\n", a->args[0].from);
+				break;
+			}
+			err = 0;
+			u.xino->file = file;
+			u.xino->path = a->args[0].from;
+			opt->type = token;
+			break;
+
+#if 0 /* def CONFIG_AUFS_EXPORT */ /* reserved for futur use */
+		case Opt_xinodir:
+			u.xinodir = &opt->xinodir;
+			u.xinodir->name = a->args[0].from;
+			err = vfsub_path_lookup(u.xinodir->name, lkup_dirflags,
+						&a->nd);
+			if (unlikely(err)) {
+				AuErr("lookup failed %s (%d)\n",
+				      u.xinodir->name, err);
+				break;
+			}
+			u.xinodir->path = a->nd.path;
+			/* do not path_put() */
+			opt->type = token;
+			break;
+#endif
+
+		case Opt_trunc_xino_path:
+			u.xino_itrunc = &opt->xino_itrunc;
+			p = a->args[0].from;
+			LKTRTrace("trunc_xino path %s\n", p);
+			/* LSM may detect it */
+			/* do not superio. */
+			err = vfsub_path_lookup(p, lkup_dirflags, &a->nd);
+			if (unlikely(err)) {
+				AuErr("lookup failed %s (%d)\n", p , err);
+				break;
+			}
+			u.xino_itrunc->bindex = -1;
+			aufs_read_lock(root, AuLock_FLUSH);
+			bend = au_sbend(sb);
+			for (bindex = 0; bindex <= bend; bindex++) {
+				if (au_h_dptr(root, bindex)
+				    == a->nd.path.dentry) {
+					u.xino_itrunc->bindex = bindex;
+					break;
+				}
+			}
+			aufs_read_unlock(root, !AuLock_IR);
+			path_put(&a->nd.path);
+			if (unlikely(u.xino_itrunc->bindex < 0)) {
+				AuErr("no such branch %s\n", p);
+				err = -EINVAL;
+				break;
+			}
+			opt->type = token;
+			break;
+
+		case Opt_itrunc_xino:
+			u.xino_itrunc = &opt->xino_itrunc;
+			if (unlikely(match_int(&a->args[0], &n))) {
+				AuErr("bad integer in %s\n", opt_str);
+				break;
+			}
+			u.xino_itrunc->bindex = n;
+			aufs_read_lock(root, AuLock_FLUSH);
+			if (n < 0 || au_sbend(sb) < n) {
+				AuErr("out of bounds, %d\n", n);
+				aufs_read_unlock(root, !AuLock_IR);
+				break;
+			}
+			aufs_read_unlock(root, !AuLock_IR);
+			err = 0;
+			opt->type = token;
+			break;
+
+		case Opt_dirwh:
+			if (unlikely(match_int(&a->args[0], &opt->dirwh)))
+				break;
+			err = 0;
+			opt->type = token;
+			break;
+
+		case Opt_rdcache:
+			if (unlikely(match_int(&a->args[0], &opt->rdcache)))
+				break;
+			err = 0;
+			opt->type = token;
+			break;
+
+		case Opt_shwh:
+			if (opts->sb_flags & MS_RDONLY) {
+				err = 0;
+				opt->type = token;
+			} else
+				AuErr("shwh requires ro\n");
+			break;
+
+		case Opt_trunc_xino:
+		case Opt_notrunc_xino:
+		case Opt_noxino:
+		case Opt_trunc_xib:
+		case Opt_notrunc_xib:
+		case Opt_dirperm1:
+		case Opt_nodirperm1:
+		case Opt_noshwh:
+		case Opt_plink:
+		case Opt_noplink:
+		case Opt_list_plink:
+		case Opt_clean_plink:
+		case Opt_diropq_a:
+		case Opt_diropq_w:
+		case Opt_warn_perm:
+		case Opt_nowarn_perm:
+		case Opt_dlgt:
+		case Opt_nodlgt:
+		case Opt_refrof:
+		case Opt_norefrof:
+		case Opt_verbose:
+		case Opt_noverbose:
+		case Opt_sum:
+		case Opt_nosum:
+		case Opt_wsum:
+			err = 0;
+			opt->type = token;
+			break;
+
+		case Opt_udba:
+			opt->udba = udba_val(a->args[0].from);
+			if (opt->udba >= 0) {
+				err = 0;
+				opt->type = token;
+			} else
+				AuErr("wrong value, %s\n", opt_str);
+			break;
+
+		case Opt_wbr_create:
+			u.create = &opt->wbr_create;
+			u.create->wbr_create
+				= au_wbr_create_val(a->args[0].from, u.create);
+			if (u.create->wbr_create >= 0) {
+				err = 0;
+				opt->type = token;
+			} else
+				AuErr("wrong value, %s\n", opt_str);
+			break;
+		case Opt_wbr_copyup:
+			opt->wbr_copyup = au_wbr_copyup_val(a->args[0].from);
+			if (opt->wbr_copyup >= 0) {
+				err = 0;
+				opt->type = token;
+			} else
+				AuErr("wrong value, %s\n", opt_str);
+			break;
+
+		case Opt_coo:
+			opt->coo = coo_val(a->args[0].from);
+			if (opt->coo >= 0) {
+				err = 0;
+				opt->type = token;
+			} else
+				AuErr("wrong value, %s\n", opt_str);
+			break;
+
+		case Opt_ignore:
+#ifndef CONFIG_AUFS_COMPAT
+			AuWarn("ignored %s\n", opt_str);
+#endif
+		case Opt_ignore_silent:
+			skipped = 1;
+			err = 0;
+			break;
+		case Opt_err:
+			AuErr("unknown option %s\n", opt_str);
+			break;
+		}
+
+		if (!err && !skipped) {
+			if (unlikely(++opt > opt_tail)) {
+				err = -E2BIG;
+				opt--;
+				opt->type = Opt_tail;
+				break;
+			}
+			opt->type = Opt_tail;
+		}
+	}
+
+	kfree(a);
+	dump_opts(opts);
+	if (unlikely(err))
+		au_opts_free(opts);
+
+ out:
+	AuTraceErr(err);
+	return err;
+}
+
+/*
+ * returns,
+ * plus: processed without an error
+ * zero: unprocessed
+ */
+static int au_opt_simple(struct super_block *sb, struct au_opt *opt,
+			 struct au_opts *opts)
+{
+	int err;
+	struct au_sbinfo *sbinfo;
+	struct au_opt_wbr_create *create;
+
+	AuTraceEnter();
+
+	err = 1; /* handled */
+	sbinfo = au_sbi(sb);
+	switch (opt->type) {
+	case Opt_udba:
+		sbinfo->si_mntflags &= ~AuOptMask_UDBA;
+		sbinfo->si_mntflags |= opt->udba;
+		opts->given_udba |= opt->udba;
+		break;
+
+	case Opt_plink:
+		au_opt_set(sbinfo->si_mntflags, PLINK);
+		break;
+	case Opt_noplink:
+		if (au_opt_test(sbinfo->si_mntflags, PLINK))
+			au_plink_put(sb);
+		au_opt_clr(sbinfo->si_mntflags, PLINK);
+		break;
+	case Opt_list_plink:
+		if (au_opt_test(sbinfo->si_mntflags, PLINK))
+			au_plink_list(sb);
+		break;
+	case Opt_clean_plink:
+		if (au_opt_test(sbinfo->si_mntflags, PLINK))
+			au_plink_put(sb);
+		break;
+
+	case Opt_diropq_a:
+		au_opt_set(sbinfo->si_mntflags, ALWAYS_DIROPQ);
+		break;
+	case Opt_diropq_w:
+		au_opt_clr(sbinfo->si_mntflags, ALWAYS_DIROPQ);
+		break;
+
+	case Opt_dlgt:
+		au_opt_set(sbinfo->si_mntflags, DLGT);
+		break;
+	case Opt_nodlgt:
+		au_opt_clr(sbinfo->si_mntflags, DLGT);
+		break;
+
+	case Opt_warn_perm:
+		au_opt_set(sbinfo->si_mntflags, WARN_PERM);
+		break;
+	case Opt_nowarn_perm:
+		au_opt_clr(sbinfo->si_mntflags, WARN_PERM);
+		break;
+
+	case Opt_refrof:
+		au_opt_set(sbinfo->si_mntflags, REFROF);
+		break;
+	case Opt_norefrof:
+		/* au_opt_set(sbinfo->si_mntflags, COO_LEAF); */
+		au_opt_clr(sbinfo->si_mntflags, REFROF);
+		break;
+
+	case Opt_verbose:
+		au_opt_set(sbinfo->si_mntflags, VERBOSE);
+		break;
+	case Opt_noverbose:
+		au_opt_clr(sbinfo->si_mntflags, VERBOSE);
+		break;
+
+	case Opt_sum:
+		au_opt_set(sbinfo->si_mntflags, SUM);
+		break;
+	case Opt_wsum:
+		au_opt_clr(sbinfo->si_mntflags, SUM);
+		au_opt_set(sbinfo->si_mntflags, SUM_W);
+	case Opt_nosum:
+		au_opt_clr(sbinfo->si_mntflags, SUM);
+		au_opt_clr(sbinfo->si_mntflags, SUM_W);
+		break;
+
+	case Opt_wbr_create:
+		create = &opt->wbr_create;
+		if (sbinfo->si_wbr_create_ops->fin) {
+			err = sbinfo->si_wbr_create_ops->fin(sb);
+			if (!err)
+				err = 1;
+		}
+		sbinfo->si_wbr_create = create->wbr_create;
+		sbinfo->si_wbr_create_ops
+			= au_wbr_create_ops + create->wbr_create;
+		switch (create->wbr_create) {
+		case AuWbrCreate_MFSRRV:
+		case AuWbrCreate_MFSRR:
+			sbinfo->si_wbr_mfs.mfsrr_watermark
+				= create->mfsrr_watermark;
+			/*FALLTHROUGH*/
+		case AuWbrCreate_MFS:
+		case AuWbrCreate_MFSV:
+		case AuWbrCreate_PMFS:
+		case AuWbrCreate_PMFSV:
+			sbinfo->si_wbr_mfs.mfs_expire = create->mfs_second * HZ;
+			break;
+		}
+		if (sbinfo->si_wbr_create_ops->init)
+			sbinfo->si_wbr_create_ops->init(sb); /* ignore */
+		break;
+	case Opt_wbr_copyup:
+		sbinfo->si_wbr_copyup = opt->wbr_copyup;
+		sbinfo->si_wbr_copyup_ops = au_wbr_copyup_ops + opt->wbr_copyup;
+		break;
+
+	case Opt_coo:
+		sbinfo->si_mntflags &= ~AuOptMask_COO;
+		sbinfo->si_mntflags |= opt->coo;
+		break;
+
+	case Opt_dirwh:
+		sbinfo->si_dirwh = opt->dirwh;
+		break;
+
+	case Opt_rdcache:
+		sbinfo->si_rdcache = opt->rdcache * HZ;
+		break;
+
+	case Opt_trunc_xino:
+		au_opt_set(sbinfo->si_mntflags, TRUNC_XINO);
+		break;
+	case Opt_notrunc_xino:
+		au_opt_clr(sbinfo->si_mntflags, TRUNC_XINO);
+		break;
+
+	case Opt_dirperm1:
+		au_opt_set(sbinfo->si_mntflags, DIRPERM1);
+		break;
+	case Opt_nodirperm1:
+		au_opt_clr(sbinfo->si_mntflags, DIRPERM1);
+		break;
+
+	case Opt_shwh:
+		au_opt_set(sbinfo->si_mntflags, SHWH);
+		break;
+	case Opt_noshwh:
+		au_opt_clr(sbinfo->si_mntflags, SHWH);
+		break;
+
+	case Opt_trunc_xino_path:
+	case Opt_itrunc_xino:
+		err = au_xino_trunc(sb, opt->xino_itrunc.bindex);
+		if (!err)
+			err = 1;
+		break;
+
+	case Opt_trunc_xib:
+		au_fset_opts(opts->flags, TRUNC_XIB);
+		break;
+	case Opt_notrunc_xib:
+		au_fclr_opts(opts->flags, TRUNC_XIB);
+		break;
+
+	default:
+		err = 0;
+		break;
+	}
+
+	AuTraceErr(err);
+	return err;
+}
+
+/*
+ * returns tri-state.
+ * plus: processed without an error
+ * zero: unprocessed
+ * minus: error
+ */
+static int au_opt_br(struct super_block *sb, struct au_opt *opt,
+		     struct au_opts *opts)
+{
+	int err, do_refresh;
+
+	AuTraceEnter();
+
+	err = 0;
+	switch (opt->type) {
+	case Opt_append:
+		opt->add.bindex = au_sbend(sb) + 1;
+		if (opt->add.bindex < 0)
+			opt->add.bindex = 0;
+		goto add;
+	case Opt_prepend:
+		opt->add.bindex = 0;
+	add:
+	case Opt_add:
+		err = au_br_add(sb, &opt->add,
+				au_ftest_opts(opts->flags, REMOUNT));
+		if (!err) {
+			err = 1;
+			au_fset_opts(opts->flags, REFRESH_DIR);
+			if (au_br_whable(opt->add.perm))
+				au_fset_opts(opts->flags, REFRESH_NONDIR);
+		}
+		break;
+
+	case Opt_del:
+	case Opt_idel:
+		err = au_br_del(sb, &opt->del,
+				au_ftest_opts(opts->flags, REMOUNT));
+		if (!err) {
+			err = 1;
+			au_fset_opts(opts->flags, TRUNC_XIB);
+			au_fset_opts(opts->flags, REFRESH_DIR);
+			au_fset_opts(opts->flags, REFRESH_NONDIR);
+		}
+		break;
+
+	case Opt_mod:
+	case Opt_imod:
+		err = au_br_mod(sb, &opt->mod,
+				au_ftest_opts(opts->flags, REMOUNT),
+				&do_refresh);
+		if (!err) {
+			err = 1;
+			if (do_refresh) {
+				au_fset_opts(opts->flags, REFRESH_DIR);
+				au_fset_opts(opts->flags, REFRESH_NONDIR);
+			}
+		}
+		break;
+	}
+
+	AuTraceErr(err);
+	return err;
+}
+
+static int au_opt_xino(struct super_block *sb, struct au_opt *opt,
+		       struct au_opt_xino **opt_xino,
+		       struct au_opt_xinodir **opt_xinodir,
+		       struct au_opts *opts)
+{
+	int err;
+	const int remount = !!au_ftest_opts(opts->flags, REMOUNT);
+
+	AuTraceEnter();
+
+	err = 0;
+	switch (opt->type) {
+	case Opt_xino:
+		err = au_xino_set(sb, &opt->xino, remount);
+		if (!err)
+			*opt_xino = &opt->xino;
+		break;
+#if 0 /* def CONFIG_AUFS_EXPORT */ /* reserved for futur use */
+	case Opt_xinodir:
+		err = au_xinodir_set(sb, &opt->xinodir, remount);
+		if (!err)
+			*opt_xinodir = &opt->xinodir;
+		break;
+#endif
+	case Opt_noxino:
+		au_xino_clr(sb);
+		*opt_xino = (void *)-1;
+		break;
+	}
+
+	AuTraceErr(err);
+	return err;
+}
+
+static int verify_opts(struct super_block *sb, unsigned long sb_flags,
+		       unsigned int pending, int remount)
+{
+	int err;
+	aufs_bindex_t bindex, bend;
+	unsigned char do_plink, skip, do_free;
+	struct au_branch *br;
+	struct au_wbr *wbr;
+	struct dentry *root;
+	struct inode *dir, *h_dir;
+	unsigned int mnt_flags;
+
+	AuTraceEnter();
+	mnt_flags = au_mntflags(sb);
+	AuDebugOn(!(mnt_flags & AuOptMask_COO));
+	AuDebugOn(!(mnt_flags & AuOptMask_UDBA));
+
+	if (!(sb_flags & MS_RDONLY)) {
+		if (unlikely(!au_br_writable(au_sbr_perm(sb, 0))))
+			AuWarn("first branch should be rw\n");
+		if (unlikely(au_opt_test(mnt_flags, SHWH)))
+			AuWarn("shwh should be used with ro\n");
+	}
+
+	if (unlikely(au_opt_test((mnt_flags | pending), UDBA_INOTIFY)
+		     && !au_opt_test_xino(mnt_flags)))
+		AuWarn("udba=inotify requires xino\n");
+
+	err = 0;
+	root = sb->s_root;
+	dir = sb->s_root->d_inode;
+	do_plink = !!au_opt_test(mnt_flags, PLINK);
+	bend = au_sbend(sb);
+	for (bindex = 0; !err && bindex <= bend; bindex++) {
+		skip = 0;
+		h_dir = au_h_iptr(dir, bindex);
+		br = au_sbr(sb, bindex);
+		do_free = 0;
+		wbr = br->br_wbr;
+		if (wbr)
+			wbr_wh_read_lock(wbr);
+		switch (br->br_perm) {
+		case AuBrPerm_RR:
+		case AuBrPerm_RO:
+		case AuBrPerm_RRWH:
+		case AuBrPerm_ROWH:
+			do_free = !!wbr;
+			skip = (!wbr
+				|| (!wbr->wbr_whbase
+				    && !wbr->wbr_plink
+				    && !wbr->wbr_tmp));
+			break;
+
+		case AuBrPerm_RWNoLinkWH:
+			/* skip = (!br->br_whbase && !br->br_tmp); */
+			skip = (!wbr || !wbr->wbr_whbase);
+			if (skip && wbr) {
+				if (do_plink)
+					skip = !!wbr->wbr_plink;
+				else
+					skip = !wbr->wbr_plink;
+			}
+			break;
+
+		case AuBrPerm_RW:
+			/* skip = (br->br_whbase && br->br_tmp); */
+			skip = (wbr && wbr->wbr_whbase);
+			if (skip) {
+				if (do_plink)
+					skip = !!wbr->wbr_plink;
+				else
+					skip = !wbr->wbr_plink;
+			}
+			break;
+
+		default:
+			BUG();
+		}
+		if (wbr)
+			wbr_wh_read_unlock(wbr);
+
+		if (skip)
+			continue;
+
+		mutex_lock_nested(&h_dir->i_mutex, AuLsc_I_PARENT);
+		if (wbr)
+			wbr_wh_write_lock(wbr);
+		err = au_wh_init(au_h_dptr(root, bindex), br, br->br_mnt, sb,
+				 bindex);
+		if (wbr)
+			wbr_wh_write_unlock(wbr);
+		mutex_unlock(&h_dir->i_mutex);
+
+		if (!err && do_free) {
+			kfree(wbr);
+			br->br_wbr = NULL;
+		}
+	}
+
+	AuTraceErr(err);
+	return err;
+}
+
+int au_opts_mount(struct super_block *sb, struct au_opts *opts)
+{
+	int err;
+	struct inode *dir;
+	struct au_opt *opt;
+	struct au_opt_xino *opt_xino, xino;
+	struct au_opt_xinodir *opt_xinodir;
+	aufs_bindex_t bend;
+	struct au_sbinfo *sbinfo;
+	unsigned int tmp;
+	struct au_branch *br;
+
+	AuTraceEnter();
+	SiMustWriteLock(sb);
+	DiMustWriteLock(sb->s_root);
+	dir = sb->s_root->d_inode;
+	IiMustWriteLock(dir);
+
+	err = 0;
+	opt_xino = NULL;
+	opt_xinodir = NULL;
+	opt = opts->opt;
+	while (err >= 0 && opt->type != Opt_tail)
+		err = au_opt_simple(sb, opt++, opts);
+	if (err > 0)
+		err = 0;
+	else if (unlikely(err < 0))
+		goto out;
+
+	/* disable xino, xinodir, hinotify, dlgt temporary */
+	sbinfo = au_sbi(sb);
+	tmp = sbinfo->si_mntflags;
+	au_opt_clr(sbinfo->si_mntflags, XINO);
+	au_opt_clr(sbinfo->si_mntflags, XINODIR);
+	au_opt_clr(sbinfo->si_mntflags, DLGT);
+	au_opt_set_udba(sbinfo->si_mntflags, UDBA_REVAL);
+
+	opt = opts->opt;
+	while (err >= 0 && opt->type != Opt_tail)
+		err = au_opt_br(sb, opt++, opts);
+	if (err > 0)
+		err = 0;
+	else if (unlikely(err < 0))
+		goto out;
+
+	bend = au_sbend(sb);
+	if (unlikely(bend < 0)) {
+		err = -EINVAL;
+		AuErr("no branches\n");
+		goto out;
+	}
+
+	if (au_opt_test(tmp, XINO))
+		au_opt_set(sbinfo->si_mntflags, XINO);
+	else if (au_opt_test(tmp, XINODIR))
+		au_opt_set(sbinfo->si_mntflags, XINODIR);
+	opt = opts->opt;
+	while (!err && opt->type != Opt_tail)
+		err = au_opt_xino(sb, opt++, &opt_xino, &opt_xinodir, opts);
+	if (unlikely(err))
+		goto out;
+
+	/* todo: test this error case? */
+	err = verify_opts(sb, sb->s_flags, tmp, /*remount*/0);
+	if (unlikely(err))
+		goto out;
+
+	/* enable xino */
+	if (au_opt_test(tmp, XINO) && !opt_xino) {
+		xino.file = au_xino_def(sb);
+		err = PTR_ERR(xino.file);
+		if (IS_ERR(xino.file))
+			goto out;
+
+		br = au_xino_def_br(sbinfo);
+		err = au_xino_set(sb, &xino, /*remount*/0);
+		fput(xino.file);
+		if (unlikely(err))
+			goto out;
+		au_xino_def_br_set(br, sbinfo);
+	}
+
+	/* restore hinotify */
+	sbinfo->si_mntflags &= ~AuOptMask_UDBA;
+	sbinfo->si_mntflags |= (tmp & AuOptMask_UDBA);
+	if (au_opt_test(tmp, UDBA_INOTIFY))
+		au_reset_hinotify(dir, au_hi_flags(dir, 1) & ~AuHi_XINO);
+
+	/* restore dlgt */
+	if (au_opt_test(tmp, DLGT))
+		au_opt_set(sbinfo->si_mntflags, DLGT);
+
+ out:
+	AuTraceErr(err);
+	return err;
+}
+
+int au_opts_remount(struct super_block *sb, struct au_opts *opts)
+{
+	int err, rerr;
+	struct inode *dir;
+	struct au_opt_xino *opt_xino;
+	struct au_opt_xinodir *opt_xinodir;
+	struct au_opt *opt;
+	unsigned char dlgt;
+	struct au_sbinfo *sbinfo;
+
+	AuTraceEnter();
+	SiMustWriteLock(sb);
+	DiMustWriteLock(sb->s_root);
+	dir = sb->s_root->d_inode;
+	IiMustWriteLock(dir);
+	sbinfo = au_sbi(sb);
+
+	err = 0;
+	dlgt = !!au_opt_test(sbinfo->si_mntflags, DLGT);
+	opt_xino = NULL;
+	opt_xinodir = NULL;
+	opt = opts->opt;
+	while (err >= 0 && opt->type != Opt_tail) {
+		err = au_opt_simple(sb, opt, opts);
+
+		/* disable it temporary */
+		dlgt = !!au_opt_test(sbinfo->si_mntflags, DLGT);
+		au_opt_clr(sbinfo->si_mntflags, DLGT);
+
+		if (!err)
+			err = au_opt_br(sb, opt, opts);
+		if (!err)
+			err = au_opt_xino(sb, opt, &opt_xino, &opt_xinodir,
+					  opts);
+
+		/* restore it */
+		if (dlgt)
+			au_opt_set(sbinfo->si_mntflags, DLGT);
+		opt++;
+	}
+	if (err > 0)
+		err = 0;
+	AuTraceErr(err);
+
+	/* go on even err */
+
+	/* todo: test this error case? */
+	au_opt_clr(sbinfo->si_mntflags, DLGT);
+	rerr = verify_opts(sb, opts->sb_flags, sbinfo->si_mntflags,
+			   /*remount*/1);
+	if (unlikely(dlgt))
+		au_opt_set(sbinfo->si_mntflags, DLGT);
+	if (unlikely(rerr && !err))
+		err = rerr;
+
+	if (au_ftest_opts(opts->flags, TRUNC_XIB)) {
+		rerr = au_xib_trunc(sb);
+		if (unlikely(rerr && !err))
+			err = rerr;
+	}
+
+	/* they are handled by the caller */
+	if (!au_ftest_opts(opts->flags, REFRESH_DIR)
+	    && (opts->given_udba || au_opt_test_xino(sbinfo->si_mntflags)))
+		au_fset_opts(opts->flags, REFRESH_DIR);
+
+	LKTRTrace("status 0x%x\n", opts->flags);
+	AuTraceErr(err);
+	return err;
+}
diff -Nurp linux-2.6.27.orig/fs/aufs/opts.h linux-2.6.27/fs/aufs/opts.h
--- linux-2.6.27.orig/fs/aufs/opts.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.27/fs/aufs/opts.h	2008-12-14 10:37:40.000000000 +0100
@@ -0,0 +1,253 @@
+/*
+ * Copyright (C) 2005-2008 Junjiro Okajima
+ *
+ * This program, aufs is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+ */
+
+/*
+ * mount options/flags
+ *
+ * $Id: opts.h,v 1.8 2008/11/17 02:11:42 sfjro Exp $
+ */
+
+#ifndef __AUFS_OPTS_H__
+#define __AUFS_OPTS_H__
+
+#ifdef __KERNEL__
+
+#include <linux/fs.h>
+#include <linux/namei.h>
+#include <linux/aufs_type.h>
+#include "wkq.h"
+
+/* ---------------------------------------------------------------------- */
+/* mount flags */
+
+/* external inode number bitmap and translation table */
+#define AuOpt_XINO		1
+#define AuOpt_XINODIR		(1 << 1)
+#define AuOpt_TRUNC_XINO	(1 << 2)
+#define AuOpt_UDBA_NONE		(1 << 3)	/* users direct branch access */
+#define AuOpt_UDBA_REVAL	(1 << 4)
+#define AuOpt_UDBA_INOTIFY	(1 << 5)
+#define AuOpt_SHWH		(1 << 6)
+#define AuOpt_PLINK		(1 << 7)
+#define AuOpt_WARN_PERM		(1 << 8)
+#define AuOpt_DIRPERM1		(1 << 9)
+#define AuOpt_DLGT		(1 << 10)
+#define AuOpt_COO_NONE		(1 << 11)	/* copyup on open */
+#define AuOpt_COO_LEAF		(1 << 12)
+#define AuOpt_COO_ALL		(1 << 13)
+#define AuOpt_ALWAYS_DIROPQ	(1 << 14)
+#define AuOpt_REFROF		(1 << 15)
+#define AuOpt_VERBOSE		(1 << 16)
+#define AuOpt_SUM		(1 << 17)
+#define AuOpt_SUM_W		(1 << 18)	/* unimplemented */
+
+#if 1 /* ndef CONFIG_AUFS_EXPORT */ /* reserved for future use */
+#undef AuOpt_XINODIR
+#define AuOpt_XINODIR		0
+#endif
+#ifndef CONFIG_AUFS_HINOTIFY
+#undef AuOpt_UDBA_INOTIFY
+#define AuOpt_UDBA_INOTIFY	0
+#endif
+#ifndef CONFIG_AUFS_SHWH
+#undef AuOpt_SHWH
+#define AuOpt_SHWH		0
+#endif
+#ifndef CONFIG_AUFS_DLGT
+#undef AuOpt_DIRPERM1
+#define AuOpt_DIRPERM1		0
+#undef AuOpt_DLGT
+#define AuOpt_DLGT		0
+#endif
+
+/* policies to select one among multiple writable branches */
+enum {
+	AuWbrCreate_TDP,	/* top down parent */
+	AuWbrCreate_RR,		/* round robin */
+	AuWbrCreate_MFS,	/* most free space */
+	AuWbrCreate_MFSV,	/* mfs with seconds */
+	AuWbrCreate_MFSRR,	/* mfs then rr */
+	AuWbrCreate_MFSRRV,	/* mfs then rr with seconds */
+	AuWbrCreate_PMFS,	/* parent and mfs */
+	AuWbrCreate_PMFSV,	/* parent and mfs with seconds */
+
+	AuWbrCreate_Def = AuWbrCreate_TDP
+};
+
+enum {
+	AuWbrCopyup_TDP,	/* top down parent */
+	AuWbrCopyup_BUP,	/* bottom up parent */
+	AuWbrCopyup_BU,		/* bottom up */
+
+	AuWbrCopyup_Def = AuWbrCopyup_TDP
+};
+
+#define AuOptMask_COO		(AuOpt_COO_NONE \
+				 | AuOpt_COO_LEAF \
+				 | AuOpt_COO_ALL)
+#define AuOptMask_UDBA		(AuOpt_UDBA_NONE \
+				 | AuOpt_UDBA_REVAL \
+				 | AuOpt_UDBA_INOTIFY)
+
+#ifdef CONFIG_AUFS_COMPAT
+#define AuOpt_DefExtra1	AuOpt_ALWAYS_DIROPQ
+#else
+#define AuOpt_DefExtra1	0
+#endif
+
+#define AuOpt_Def	(AuOpt_XINO \
+			 | AuOpt_UDBA_REVAL \
+			 | AuOpt_WARN_PERM \
+			 | AuOpt_COO_NONE \
+			 | AuOpt_PLINK \
+			 | AuOpt_DefExtra1)
+
+/* ---------------------------------------------------------------------- */
+
+struct au_opt_add {
+	aufs_bindex_t		bindex;
+	char			*path;
+	int			perm;
+	struct nameidata	nd;
+};
+
+struct au_opt_del {
+	char		*path;
+	struct dentry	*h_root;
+};
+
+struct au_opt_mod {
+	char		*path;
+	int		perm;
+	struct dentry	*h_root;
+};
+
+struct au_opt_xino {
+	char		*path;
+	struct file	*file;
+};
+
+struct au_opt_xinodir {
+	char		*name;
+	struct path	path;
+};
+
+struct au_opt_xino_itrunc {
+	aufs_bindex_t	bindex;
+};
+
+struct au_opt_xino_trunc_v {
+	unsigned long long	upper;
+	int			step;
+};
+
+struct au_opt_wbr_create {
+	int			wbr_create;
+	int			mfs_second;
+	unsigned long long	mfsrr_watermark;
+};
+
+struct au_opt {
+	int type;
+	union {
+		struct au_opt_xino	xino;
+		struct au_opt_xinodir	xinodir;
+		struct au_opt_xino_itrunc xino_itrunc;
+		struct au_opt_add	add;
+		struct au_opt_del	del;
+		struct au_opt_mod	mod;
+		int			dirwh;
+		int			rdcache;
+		int			deblk;
+		int			nhash;
+		int			udba;
+		int			coo;
+		struct au_opt_wbr_create wbr_create;
+		int			wbr_copyup;
+	};
+};
+
+/* opts flags */
+#define AuOpts_REMOUNT		1
+#define AuOpts_REFRESH_DIR	(1 << 1)
+#define AuOpts_REFRESH_NONDIR	(1 << 2)
+#define AuOpts_TRUNC_XIB	(1 << 3)
+#define au_ftest_opts(flags, name)	((flags) & AuOpts_##name)
+#define au_fset_opts(flags, name)	{ (flags) |= AuOpts_##name; }
+#define au_fclr_opts(flags, name)	{ (flags) &= ~AuOpts_##name; }
+
+struct au_opts {
+	struct au_opt	*opt;
+	int		max_opt;
+
+	unsigned int	given_udba;
+	unsigned int	flags;
+	unsigned long	sb_flags;
+};
+
+/* ---------------------------------------------------------------------- */
+
+const char *au_optstr_br_perm(int brperm);
+const char *au_optstr_udba(int udba);
+const char *au_optstr_coo(int coo);
+const char *au_optstr_wbr_copyup(int wbr_copyup);
+const char *au_optstr_wbr_create(int wbr_create);
+
+void au_opts_free(struct au_opts *opts);
+int au_opts_parse(struct super_block *sb, char *str, struct au_opts *opts);
+int au_opts_mount(struct super_block *sb, struct au_opts *opts);
+int au_opts_remount(struct super_block *sb, struct au_opts *opts);
+
+/* ---------------------------------------------------------------------- */
+
+#define au_opt_test(flags, name)	(flags & AuOpt_##name)
+
+static inline int au_opt_test_xino(unsigned int flags)
+{
+	return flags & (AuOpt_XINO | AuOpt_XINODIR);
+}
+
+#define au_opt_set(flags, name) do { \
+	BUILD_BUG_ON(AuOpt_##name & (AuOptMask_COO | AuOptMask_UDBA)); \
+	((flags) |= AuOpt_##name); \
+} while (0)
+
+#define au_opt_set_coo(flags, name) do { \
+	(flags) &= ~AuOptMask_COO; \
+	((flags) |= AuOpt_##name); \
+} while (0)
+
+#define au_opt_set_udba(flags, name) do { \
+	(flags) &= ~AuOptMask_UDBA; \
+	((flags) |= AuOpt_##name); \
+} while (0)
+
+#define au_opt_clr(flags, name)		{ ((flags) &= ~AuOpt_##name); }
+
+static inline int au_test_dlgt(unsigned int flags)
+{
+	return au_opt_test(flags, DLGT) && !au_test_wkq(current);
+}
+
+static inline int au_test_dirperm1(unsigned int flags)
+{
+	return au_opt_test(flags, DIRPERM1) && !au_test_wkq(current);
+}
+
+#endif /* __KERNEL__ */
+#endif /* __AUFS_OPTS_H__ */
diff -Nurp linux-2.6.27.orig/fs/aufs/plink.c linux-2.6.27/fs/aufs/plink.c
--- linux-2.6.27.orig/fs/aufs/plink.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.27/fs/aufs/plink.c	2008-12-14 10:37:40.000000000 +0100
@@ -0,0 +1,364 @@
+/*
+ * Copyright (C) 2005-2008 Junjiro Okajima
+ *
+ * This program, aufs is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+ */
+
+/*
+ * pseudo-link
+ *
+ * $Id: plink.c,v 1.12 2008/12/01 03:49:29 sfjro Exp $
+ */
+
+#include "aufs.h"
+
+struct pseudo_link {
+	struct list_head list;
+	struct inode *inode;
+};
+
+#ifdef CONFIG_AUFS_DEBUG
+void au_plink_list(struct super_block *sb)
+{
+	struct au_sbinfo *sbinfo;
+	struct list_head *plink_list;
+	struct pseudo_link *plink;
+
+	AuTraceEnter();
+	SiMustAnyLock(sb);
+	sbinfo = au_sbi(sb);
+	AuDebugOn(!au_opt_test(au_mntflags(sb), PLINK));
+
+	plink_list = &sbinfo->si_plink.head;
+	spin_lock(&sbinfo->si_plink.spin);
+	list_for_each_entry(plink, plink_list, list)
+		AuDbg("%lu\n", plink->inode->i_ino);
+	spin_unlock(&sbinfo->si_plink.spin);
+}
+#endif
+
+int au_plink_test(struct super_block *sb, struct inode *inode)
+{
+	int found;
+	struct au_sbinfo *sbinfo;
+	struct list_head *plink_list;
+	struct pseudo_link *plink;
+
+	LKTRTrace("i%lu\n", inode->i_ino);
+	SiMustAnyLock(sb);
+	sbinfo = au_sbi(sb);
+	AuDebugOn(!au_opt_test(au_mntflags(sb), PLINK));
+
+	found = 0;
+	plink_list = &sbinfo->si_plink.head;
+	spin_lock(&sbinfo->si_plink.spin);
+	list_for_each_entry(plink, plink_list, list)
+		if (plink->inode == inode) {
+			found = 1;
+			break;
+		}
+	spin_unlock(&sbinfo->si_plink.spin);
+	return found;
+}
+
+/* 20 is max digits length of ulong 64 */
+#define PLINK_NAME_LEN	((20 + 1) * 2)
+
+static int plink_name(char *name, int len, struct inode *inode,
+		      aufs_bindex_t bindex)
+{
+	int rlen;
+	struct inode *h_inode;
+
+	LKTRTrace("i%lu, b%d\n", inode->i_ino, bindex);
+	AuDebugOn(len != PLINK_NAME_LEN);
+	h_inode = au_h_iptr(inode, bindex);
+	AuDebugOn(!h_inode);
+	rlen = snprintf(name, len, "%lu.%lu", inode->i_ino, h_inode->i_ino);
+	AuDebugOn(rlen >= len);
+	return rlen;
+}
+
+struct dentry *au_plink_lkup(struct super_block *sb, aufs_bindex_t bindex,
+			     struct inode *inode)
+{
+	struct dentry *h_dentry, *h_parent;
+	struct au_branch *br;
+	struct au_wbr *wbr;
+	struct inode *h_dir;
+	char tgtname[PLINK_NAME_LEN];
+	int len;
+	struct au_ndx ndx = {
+		.flags	= 0,
+		.nd	= NULL,
+		/* .br	= NULL */
+	};
+
+	LKTRTrace("b%d, i%lu\n", bindex, inode->i_ino);
+	br = au_sbr(sb, bindex);
+	wbr = br->br_wbr;
+	AuDebugOn(!wbr);
+	h_parent = wbr->wbr_plink;
+	AuDebugOn(!h_parent);
+	h_dir = h_parent->d_inode;
+	AuDebugOn(!h_dir);
+
+	len = plink_name(tgtname, sizeof(tgtname), inode, bindex);
+
+	/* always superio. */
+	ndx.nfsmnt = au_do_nfsmnt(br->br_mnt);
+	mutex_lock_nested(&h_dir->i_mutex, AuLsc_I_CHILD2);
+	h_dentry = au_sio_lkup_one(tgtname, h_parent, len, &ndx);
+	mutex_unlock(&h_dir->i_mutex);
+	return h_dentry;
+}
+
+static int do_whplink(char *tgt, int len, struct dentry *h_parent,
+		      struct dentry *h_dentry, struct vfsmount *nfsmnt,
+		      struct super_block *sb)
+{
+	int err, dlgt;
+	struct dentry *h_tgt;
+	struct inode *h_dir;
+	struct vfsub_args vargs;
+	struct au_ndx ndx = {
+		.nfsmnt	= nfsmnt,
+		.flags	= 0,
+		.nd	= NULL,
+		/* .br	= NULL */
+	};
+
+	AuTraceEnter();
+
+	dlgt = !!au_test_dlgt(au_mntflags(sb));
+	if (dlgt)
+		au_fset_ndx(ndx.flags, DLGT);
+	h_tgt = au_lkup_one(tgt, h_parent, len, &ndx);
+	err = PTR_ERR(h_tgt);
+	if (IS_ERR(h_tgt))
+		goto out;
+
+	err = 0;
+	vfsub_args_init(&vargs, NULL, dlgt, 0);
+	/* wh.plink dir is not monitored */
+	h_dir = h_parent->d_inode;
+	if (h_tgt->d_inode && h_tgt->d_inode != h_dentry->d_inode)
+		err = vfsub_unlink(h_dir, h_tgt, &vargs);
+	if (!err && !h_tgt->d_inode) {
+		err = vfsub_link(h_dentry, h_dir, h_tgt, &vargs);
+		/* todo: unnecessary? */
+		/* inc_nlink(inode); */
+	}
+	dput(h_tgt);
+
+ out:
+	AuTraceErr(err);
+	return err;
+}
+
+struct do_whplink_args {
+	int *errp;
+	char *tgt;
+	int len;
+	struct dentry *h_parent;
+	struct dentry *h_dentry;
+	struct vfsmount *nfsmnt;
+	struct super_block *sb;
+};
+
+static void call_do_whplink(void *args)
+{
+	struct do_whplink_args *a = args;
+	*a->errp = do_whplink(a->tgt, a->len, a->h_parent, a->h_dentry,
+			      a->nfsmnt, a->sb);
+}
+
+static int whplink(struct dentry *h_dentry, struct inode *inode,
+		   aufs_bindex_t bindex, struct super_block *sb)
+{
+	int err, len, wkq_err;
+	struct au_branch *br;
+	struct au_wbr *wbr;
+	struct dentry *h_parent;
+	struct inode *h_dir;
+	char tgtname[PLINK_NAME_LEN];
+
+	LKTRTrace("%.*s\n", AuDLNPair(h_dentry));
+	br = au_sbr(inode->i_sb, bindex);
+	wbr = br->br_wbr;
+	AuDebugOn(!wbr);
+	h_parent = wbr->wbr_plink;
+	AuDebugOn(!h_parent);
+	h_dir = h_parent->d_inode;
+	AuDebugOn(!h_dir);
+
+	len = plink_name(tgtname, sizeof(tgtname), inode, bindex);
+
+	/* always superio. */
+	mutex_lock_nested(&h_dir->i_mutex, AuLsc_I_CHILD2);
+	if (!au_test_wkq(current)) {
+		struct do_whplink_args args = {
+			.errp		= &err,
+			.tgt		= tgtname,
+			.len		= len,
+			.h_parent	= h_parent,
+			.h_dentry	= h_dentry,
+			.nfsmnt		= au_do_nfsmnt(br->br_mnt),
+			.sb		= sb
+		};
+		wkq_err = au_wkq_wait(call_do_whplink, &args, /*dlgt*/0);
+		if (unlikely(wkq_err))
+			err = wkq_err;
+	} else
+		err = do_whplink(tgtname, len, h_parent, h_dentry,
+				 au_do_nfsmnt(br->br_mnt), sb);
+	mutex_unlock(&h_dir->i_mutex);
+
+	AuTraceErr(err);
+	return err;
+}
+
+static void do_put_plink(struct pseudo_link *plink, int do_del)
+{
+	AuTraceEnter();
+
+	iput(plink->inode);
+	if (do_del)
+		list_del(&plink->list);
+	kfree(plink);
+}
+
+void au_plink_append(struct super_block *sb, struct inode *inode,
+		     struct dentry *h_dentry, aufs_bindex_t bindex)
+{
+	struct au_sbinfo *sbinfo;
+	struct list_head *plink_list;
+	struct pseudo_link *plink;
+	int found, err, cnt;
+
+	LKTRTrace("i%lu\n", inode->i_ino);
+	SiMustAnyLock(sb);
+	sbinfo = au_sbi(sb);
+	AuDebugOn(!au_opt_test(au_mntflags(sb), PLINK));
+
+	cnt = 0;
+	found = 0;
+	plink_list = &sbinfo->si_plink.head;
+	spin_lock(&sbinfo->si_plink.spin);
+	list_for_each_entry(plink, plink_list, list) {
+		cnt++;
+		if (plink->inode == inode) {
+			found = 1;
+			break;
+		}
+	}
+
+	err = 0;
+	plink = NULL;
+	if (!found) {
+		plink = kmalloc(sizeof(*plink), GFP_ATOMIC);
+		if (plink) {
+			plink->inode = au_igrab(inode);
+			list_add(&plink->list, plink_list);
+			cnt++;
+		} else
+			err = -ENOMEM;
+	}
+	spin_unlock(&sbinfo->si_plink.spin);
+
+#if 0 /* todo: test here */
+	if (found)
+		return; /* success */
+#endif
+
+	if (!err)
+		err = whplink(h_dentry, inode, bindex, sb);
+
+	if (unlikely(cnt > AUFS_PLINK_WARN))
+		AuWarn1("unexpectedly many pseudo links, %d\n", cnt);
+	if (unlikely(err)) {
+		AuWarn("err %d, damaged pseudo link. ignored.\n", err);
+		if (!found && plink)
+			do_put_plink(plink, /*do_del*/1);
+	}
+}
+
+void au_plink_put(struct super_block *sb)
+{
+	struct au_sbinfo *sbinfo;
+	struct list_head *plink_list;
+	struct pseudo_link *plink, *tmp;
+
+	AuTraceEnter();
+	SiMustWriteLock(sb);
+	sbinfo = au_sbi(sb);
+	AuDebugOn(!au_opt_test(au_mntflags(sb), PLINK));
+
+	plink_list = &sbinfo->si_plink.head;
+	/* spin_lock(&sbinfo->si_plink.spin); */
+	list_for_each_entry_safe(plink, tmp, plink_list, list)
+		do_put_plink(plink, 0);
+	INIT_LIST_HEAD(plink_list);
+	/* spin_unlock(&sbinfo->si_plink.head); */
+}
+
+void au_plink_half_refresh(struct super_block *sb, aufs_bindex_t br_id)
+{
+	struct au_sbinfo *sbinfo;
+	struct list_head *plink_list;
+	struct pseudo_link *plink, *tmp;
+	struct inode *inode;
+	aufs_bindex_t bstart, bend, bindex;
+	int do_put;
+
+	AuTraceEnter();
+	SiMustWriteLock(sb);
+	sbinfo = au_sbi(sb);
+	AuDebugOn(!au_opt_test(au_mntflags(sb), PLINK));
+
+	plink_list = &sbinfo->si_plink.head;
+	/* spin_lock(&sbinfo->si_plink.spin); */
+	list_for_each_entry_safe(plink, tmp, plink_list, list) {
+		do_put = 0;
+		inode = au_igrab(plink->inode);
+		ii_write_lock_child(inode);
+		bstart = au_ibstart(inode);
+		bend = au_ibend(inode);
+		if (bstart >= 0) {
+			for (bindex = bstart; bindex <= bend; bindex++) {
+				if (!au_h_iptr(inode, bindex)
+				    || au_ii_br_id(inode, bindex) != br_id)
+					continue;
+				au_set_h_iptr(inode, bindex, NULL, 0);
+				do_put = 1;
+				break;
+			}
+		} else
+			do_put_plink(plink, 1);
+
+		if (do_put) {
+			for (bindex = bstart; bindex <= bend; bindex++)
+				if (au_h_iptr(inode, bindex)) {
+					do_put = 0;
+					break;
+				}
+			if (do_put)
+				do_put_plink(plink, 1);
+		}
+		ii_write_unlock(inode);
+		iput(inode);
+	}
+	/* spin_unlock(&sbinfo->si_plink.spin); */
+}
diff -Nurp linux-2.6.27.orig/fs/aufs/robr.c linux-2.6.27/fs/aufs/robr.c
--- linux-2.6.27.orig/fs/aufs/robr.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.27/fs/aufs/robr.c	2008-12-14 10:37:40.000000000 +0100
@@ -0,0 +1,117 @@
+/*
+ * Copyright (C) 2005-2008 Junjiro Okajima
+ *
+ * This program, aufs is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+ */
+
+/*
+ * 'robr', aufs as readonly branch of another aufs
+ *
+ * $Id: robr.c,v 1.8 2008/12/01 03:49:57 sfjro Exp $
+ */
+
+#include "aufs.h"
+
+/* ---------------------------------------------------------------------- */
+
+int au_test_robr_wh(struct qstr *name, struct dentry *h_parent,
+		    struct qstr *wh_name, int try_sio, struct au_ndx *ndx)
+{
+	if (strncmp(name->name, AUFS_WH_PFX, AUFS_WH_PFX_LEN))
+		return au_wh_test(h_parent, wh_name, try_sio, ndx);
+	return -EPERM;
+}
+
+int au_test_robr_shwh(struct super_block *sb, const struct qstr *name)
+{
+	return 0;
+}
+
+/* ---------------------------------------------------------------------- */
+
+struct au_robr_lvma {
+	struct list_head list;
+	struct vm_area_struct *vma;
+};
+
+struct file *au_robr_safe_file(struct vm_area_struct *vma)
+{
+	struct file *file = vma->vm_file;
+	struct super_block *sb = file->f_dentry->d_sb;
+	struct au_robr_lvma *lvma, *entry;
+	struct au_sbinfo *sbinfo;
+	struct list_head *head;
+	unsigned char found, warn;
+
+	AuTraceEnter();
+
+	if (!file->private_data || !au_test_aufs(sb))
+		return NULL;
+
+	warn = 0;
+	found = 0;
+	sbinfo = au_sbi(sb);
+	head = &sbinfo->si_lvma.head;
+	spin_lock(&sbinfo->si_lvma.spin);
+	list_for_each_entry(entry, head, list) {
+		found = (entry->vma == vma);
+		if (unlikely(found))
+			break;
+	}
+	if (!found) {
+		lvma = kmalloc(sizeof(*lvma), GFP_ATOMIC);
+		if (lvma) {
+			lvma->vma = vma;
+			list_add(&lvma->list, head);
+		} else {
+			warn = 1;
+			file = NULL;
+		}
+	} else
+		file = NULL;
+	spin_unlock(&sbinfo->si_lvma.spin);
+
+	if (unlikely(warn))
+		AuWarn1("no memory for lvma\n");
+	return file;
+}
+
+void au_robr_reset_file(struct vm_area_struct *vma, struct file *file)
+{
+	struct super_block *sb = file->f_dentry->d_sb;
+	struct au_robr_lvma *entry, *found;
+	struct au_sbinfo *sbinfo;
+	struct list_head *head;
+
+	AuTraceEnter();
+	AuDebugOn(!au_test_aufs(sb));
+
+	vma->vm_file = file;
+	/* smp_mb(); */ /* flush vm_file */
+
+	found = NULL;
+	sbinfo = au_sbi(sb);
+	head = &sbinfo->si_lvma.head;
+	spin_lock(&sbinfo->si_lvma.spin);
+	list_for_each_entry(entry, head, list)
+		if (entry->vma == vma) {
+			found = entry;
+			break;
+		}
+	AuDebugOn(!found);
+	list_del(&found->list);
+	spin_unlock(&sbinfo->si_lvma.spin);
+	kfree(found);
+}
diff -Nurp linux-2.6.27.orig/fs/aufs/sbinfo.c linux-2.6.27/fs/aufs/sbinfo.c
--- linux-2.6.27.orig/fs/aufs/sbinfo.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.27/fs/aufs/sbinfo.c	2008-12-14 10:37:40.000000000 +0100
@@ -0,0 +1,221 @@
+/*
+ * Copyright (C) 2005-2008 Junjiro Okajima
+ *
+ * This program, aufs is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+ */
+
+/*
+ * superblock private data
+ *
+ * $Id: sbinfo.c,v 1.15 2008/12/08 06:12:18 sfjro Exp $
+ */
+
+#include <linux/smp_lock.h>
+#include "aufs.h"
+
+/*
+ * they are necessary regardless sysfs is disabled.
+ */
+void au_si_free(struct kobject *kobj)
+{
+	struct au_sbinfo *sbinfo;
+	struct super_block *sb;
+
+	LKTRTrace("kobj %p\n", kobj);
+	sbinfo = container_of(kobj, struct au_sbinfo, si_kobj);
+	LKTRTrace("sbinfo %p\n", sbinfo);
+	AuDebugOn(!list_empty(&sbinfo->si_plink.head));
+
+	sb = sbinfo->si_sb;
+	si_write_lock(sb);
+	au_xino_clr(sb);
+	au_br_free(sbinfo);
+	kfree(sbinfo->si_branch);
+	au_export_put(sbinfo);
+	mutex_destroy(&sbinfo->si_xib_mtx);
+	si_write_unlock(sb);
+	au_rwsem_destroy(&sbinfo->si_rwsem);
+
+	kfree(sbinfo);
+}
+
+int au_si_alloc(struct super_block *sb)
+{
+	int err;
+	struct au_sbinfo *sbinfo;
+
+	AuTraceEnter();
+
+	err = -ENOMEM;
+	sbinfo = kmalloc(sizeof(*sbinfo), GFP_NOFS);
+	if (unlikely(!sbinfo))
+		goto out;
+	sbinfo->si_branch = kzalloc(sizeof(*sbinfo->si_branch), GFP_NOFS);
+	if (unlikely(!sbinfo->si_branch))
+		goto out_sbinfo;
+
+	memset(&sbinfo->si_kobj, 0, sizeof(sbinfo->si_kobj));
+	err = sysaufs_si_init(sbinfo);
+	if (unlikely(err))
+		goto out_br;
+
+	au_rw_init_wlock(&sbinfo->si_rwsem);
+	//au_dbg_locked_si_reg(sb, 1);
+	sbinfo->si_generation = 0;
+	sbinfo->au_si_status = 0;
+	sbinfo->si_bend = -1;
+	sbinfo->si_last_br_id = 0;
+
+	sbinfo->si_wbr_copyup = AuWbrCopyup_Def;
+	sbinfo->si_wbr_create = AuWbrCreate_Def;
+	sbinfo->si_wbr_copyup_ops = au_wbr_copyup_ops + AuWbrCopyup_Def;
+	sbinfo->si_wbr_create_ops = au_wbr_create_ops + AuWbrCreate_Def;
+
+	sbinfo->si_mntflags = AuOpt_Def;
+
+	sbinfo->si_xread = NULL;
+	sbinfo->si_xwrite = NULL;
+	sbinfo->si_xib = NULL;
+	mutex_init(&sbinfo->si_xib_mtx);
+	sbinfo->si_xib_buf = NULL;
+	au_xino_def_br_set(NULL, sbinfo);
+	/* leave si_xib_last_pindex and si_xib_next_bit */
+
+	au_nwt_init(&sbinfo->si_nowait);
+
+	sbinfo->si_rdcache = AUFS_RDCACHE_DEF * HZ;
+	sbinfo->si_dirwh = AUFS_DIRWH_DEF;
+
+	au_spl_init(&sbinfo->si_plink);
+
+	au_robr_lvma_init(sbinfo);
+
+	/* leave other members for sysaufs and si_mnt. */
+	sbinfo->si_sb = sb;
+
+	sb->s_fs_info = sbinfo;
+
+	au_debug_sbinfo_init(sbinfo);
+	return 0; /* success */
+
+ out_br:
+	kfree(sbinfo->si_branch);
+ out_sbinfo:
+	kfree(sbinfo);
+ out:
+	AuTraceErr(err);
+	return err;
+}
+
+/* ---------------------------------------------------------------------- */
+
+struct au_branch *au_sbr(struct super_block *sb, aufs_bindex_t bindex)
+{
+	struct au_branch *br;
+
+	SiMustAnyLock(sb);
+	AuDebugOn(bindex < 0 || au_sbend(sb) < bindex);
+	br = au_sbi(sb)->si_branch[0 + bindex];
+	AuDebugOn(!br);
+	return br;
+}
+
+au_gen_t au_sigen_inc(struct super_block *sb)
+{
+	au_gen_t gen;
+
+	SiMustWriteLock(sb);
+	gen = ++au_sbi(sb)->si_generation;
+	au_update_digen(sb->s_root);
+	au_update_iigen(sb->s_root->d_inode);
+	sb->s_root->d_inode->i_version++;
+	return gen;
+}
+
+int au_find_bindex(struct super_block *sb, struct au_branch *br)
+{
+	aufs_bindex_t bindex, bend;
+
+	bend = au_sbend(sb);
+	for (bindex = 0; bindex <= bend; bindex++)
+		if (au_sbr(sb, bindex) == br)
+			return bindex;
+	return -1;
+}
+
+/* ---------------------------------------------------------------------- */
+
+/* dentry and super_block lock. call at entry point */
+void aufs_read_lock(struct dentry *dentry, int flags)
+{
+	si_read_lock(dentry->d_sb, flags);
+	if (au_ftest_lock(flags, DW))
+		di_write_lock_child(dentry);
+	else
+		di_read_lock_child(dentry, flags);
+}
+
+void aufs_read_unlock(struct dentry *dentry, int flags)
+{
+	if (au_ftest_lock(flags, DW))
+		di_write_unlock(dentry);
+	else
+		di_read_unlock(dentry, flags);
+	si_read_unlock(dentry->d_sb);
+}
+
+void aufs_write_lock(struct dentry *dentry)
+{
+	si_write_lock(dentry->d_sb);
+	di_write_lock_child(dentry);
+}
+
+void aufs_write_unlock(struct dentry *dentry)
+{
+	di_write_unlock(dentry);
+	si_write_unlock(dentry->d_sb);
+}
+
+void aufs_read_and_write_lock2(struct dentry *d1, struct dentry *d2, int flags)
+{
+	AuDebugOn(d1 == d2 || d1->d_sb != d2->d_sb);
+	si_read_lock(d1->d_sb, flags);
+	di_write_lock2_child(d1, d2, au_ftest_lock(flags, DIR));
+}
+
+void aufs_read_and_write_unlock2(struct dentry *d1, struct dentry *d2)
+{
+	AuDebugOn(d1 == d2 || d1->d_sb != d2->d_sb);
+	di_write_unlock2(d1, d2);
+	si_read_unlock(d1->d_sb);
+}
+
+/* ---------------------------------------------------------------------- */
+
+aufs_bindex_t au_new_br_id(struct super_block *sb)
+{
+	aufs_bindex_t br_id;
+	struct au_sbinfo *sbinfo;
+
+	AuTraceEnter();
+	SiMustWriteLock(sb);
+
+	sbinfo = au_sbi(sb);
+	while (1) {
+		br_id = ++sbinfo->si_last_br_id;
+		if (br_id && au_br_index(sb, br_id) < 0)
+			return br_id;
+	}
+}
diff -Nurp linux-2.6.27.orig/fs/aufs/super.c linux-2.6.27/fs/aufs/super.c
--- linux-2.6.27.orig/fs/aufs/super.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.27/fs/aufs/super.c	2008-12-14 10:37:40.000000000 +0100
@@ -0,0 +1,933 @@
+/*
+ * Copyright (C) 2005-2008 Junjiro Okajima
+ *
+ * This program, aufs is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+ */
+
+/*
+ * mount and super_block operations
+ *
+ * $Id: super.c,v 1.22 2008/12/01 03:50:05 sfjro Exp $
+ */
+
+#include <linux/module.h>
+#include <linux/buffer_head.h>
+#include <linux/seq_file.h>
+#include <linux/smp_lock.h>
+#include <linux/statfs.h>
+
+#include "aufs.h"
+
+/*
+ * super_operations
+ */
+static struct inode *aufs_alloc_inode(struct super_block *sb)
+{
+	struct aufs_icntnr *c;
+
+	AuTraceEnter();
+
+	c = au_cache_alloc_icntnr();
+	if (c) {
+		inode_init_once(&c->vfs_inode);
+		c->vfs_inode.i_version = 1; /* sigen(sb); */
+		c->iinfo.ii_hinode = NULL;
+		return &c->vfs_inode;
+	}
+	return NULL;
+}
+
+static void aufs_destroy_inode(struct inode *inode)
+{
+	int err;
+
+	LKTRTrace("i%lu\n", inode->i_ino);
+
+	if (!inode->i_nlink || IS_DEADDIR(inode)) {
+		/* todo: move this lock into xigen_inc() */
+		/* in nowait task or remount, sbi is write-locked */
+		struct super_block *sb = inode->i_sb;
+		const int locked = si_noflush_read_trylock(sb);
+
+		err = au_xigen_inc(inode);
+		if (unlikely(err))
+			AuWarn1("failed resetting i_generation, %d\n", err);
+		if (locked)
+			si_read_unlock(sb);
+	}
+
+	au_iinfo_fin(inode);
+	au_cache_free_icntnr(container_of(inode, struct aufs_icntnr,
+					  vfs_inode));
+}
+
+struct inode *au_iget_locked(struct super_block *sb, ino_t ino)
+{
+	struct inode *inode;
+	int err;
+
+	LKTRTrace("i%lu\n", (unsigned long)ino);
+
+	inode = iget_locked(sb, ino);
+	if (unlikely(!inode)) {
+		inode = ERR_PTR(-ENOMEM);
+		goto out;
+	}
+	AuDebugOn(IS_ERR(inode));
+	if (!(inode->i_state & I_NEW))
+		goto out;
+
+	err = au_xigen_new(inode);
+	if (!err)
+		err = au_iinfo_init(inode);
+	if (!err)
+		inode->i_version++;
+	else {
+		iget_failed(inode);
+		inode = ERR_PTR(err);
+	}
+
+ out:
+	/* never return NULL */
+	AuDebugOn(!inode);
+	AuTraceErrPtr(inode);
+	return inode;
+}
+
+/* lock free root dinfo */
+static int au_show_brs(struct seq_file *seq, struct super_block *sb)
+{
+	int err;
+	aufs_bindex_t bindex, bend;
+	struct path path;
+	struct au_hdentry *hd;
+
+	AuTraceEnter();
+
+	err = 0;
+	bend = au_sbend(sb);
+	hd = au_di(sb->s_root)->di_hdentry;
+	for (bindex = 0; !err && bindex <= bend; bindex++) {
+		path.mnt = au_sbr_mnt(sb, bindex);
+		path.dentry = hd[bindex].hd_dentry;
+		err = seq_path(seq, &path, au_esc_chars);
+		if (err > 0) {
+			const char *p = au_optstr_br_perm(au_sbr_perm(sb,
+								      bindex));
+			err = seq_printf(seq, "=%s", p);
+		}
+		if (!err && bindex != bend)
+			err = seq_putc(seq, ':');
+	}
+
+	AuTraceErr(err);
+	return err;
+}
+
+static void au_show_wbr_create(struct seq_file *m, int v,
+			       struct au_sbinfo *sbinfo)
+{
+	const char *pat;
+
+	AuDebugOn(v == AuWbrCreate_Def);
+
+	seq_printf(m, ",create=");
+	pat = au_optstr_wbr_create(v);
+	switch (v) {
+	case AuWbrCreate_TDP:
+	case AuWbrCreate_RR:
+	case AuWbrCreate_MFS:
+	case AuWbrCreate_PMFS:
+		seq_printf(m, pat);
+		break;
+	case AuWbrCreate_MFSV:
+		seq_printf(m, /*pat*/"mfs:%lu",
+			   sbinfo->si_wbr_mfs.mfs_expire / HZ);
+		break;
+	case AuWbrCreate_PMFSV:
+		seq_printf(m, /*pat*/"pmfs:%lu",
+			   sbinfo->si_wbr_mfs.mfs_expire / HZ);
+		break;
+	case AuWbrCreate_MFSRR:
+		seq_printf(m, /*pat*/"mfsrr:%llu",
+			   sbinfo->si_wbr_mfs.mfsrr_watermark);
+		break;
+	case AuWbrCreate_MFSRRV:
+		seq_printf(m, /*pat*/"mfsrr:%llu:%lu",
+			   sbinfo->si_wbr_mfs.mfsrr_watermark,
+			   sbinfo->si_wbr_mfs.mfs_expire / HZ);
+		break;
+	}
+}
+
+/* seq_file will re-call me in case of too long string */
+static int aufs_show_options(struct seq_file *m, struct vfsmount *mnt)
+{
+	int err, n;
+	unsigned int mnt_flags, v;
+	struct path path;
+	struct super_block *sb;
+	struct au_sbinfo *sbinfo;
+	struct file *xino;
+
+	AuTraceEnter();
+
+	sb = mnt->mnt_sb;
+	/* lock free root dinfo */
+	si_noflush_read_lock(sb);
+	sbinfo = au_sbi(sb);
+	seq_printf(m, ",si=%lx", au_si_mask ^ (unsigned long)sbinfo);
+	mnt_flags = au_mntflags(sb);
+	if (au_opt_test(mnt_flags, XINO)) {
+		seq_puts(m, ",xino=");
+		xino = sbinfo->si_xib;
+		path.mnt = xino->f_vfsmnt;
+		path.dentry = xino->f_dentry;
+		err = seq_path(m, &path, au_esc_chars);
+		if (unlikely(err <= 0))
+			goto out;
+		err = 0;
+#define Deleted "\\040(deleted)"
+		m->count -= sizeof(Deleted) - 1;
+		AuDebugOn(memcmp(m->buf + m->count, Deleted,
+				 sizeof(Deleted) - 1));
+#undef Deleted
+#ifdef CONFIG_AUFS_EXPORT /* reserved for future use */
+	} else if (au_opt_test(mnt_flags, XINODIR)) {
+		seq_puts(m, ",xinodir=");
+		seq_path(m, &sbinfo->si_xinodir, au_esc_chars);
+#endif
+	} else
+		seq_puts(m, ",noxino");
+
+#define AuBool(name, str) do { \
+	v = au_opt_test(mnt_flags, name); \
+	if (v != au_opt_test(AuOpt_Def, name)) \
+		seq_printf(m, ",%s" #str, v ? "" : "no"); \
+} while (0)
+
+#define AuStr(name, str) do { \
+	v = mnt_flags & AuOptMask_##name; \
+	if (v != (AuOpt_Def & AuOptMask_##name)) \
+		seq_printf(m, "," #str "=%s", au_optstr_##str(v)); \
+} while (0)
+
+#ifdef CONFIG_AUFS_COMPAT
+#define AuStr_BrOpt	"dirs="
+#else
+#define AuStr_BrOpt	"br:"
+#endif
+
+	AuBool(TRUNC_XINO, trunc_xino);
+	AuBool(DIRPERM1, dirperm1);
+	AuBool(SHWH, shwh);
+	AuBool(PLINK, plink);
+	AuStr(UDBA, udba);
+
+	v = sbinfo->si_wbr_create;
+	if (v != AuWbrCreate_Def)
+		au_show_wbr_create(m, v, sbinfo);
+
+	v = sbinfo->si_wbr_copyup;
+	if (v != AuWbrCopyup_Def)
+		seq_printf(m, ",cpup=%s", au_optstr_wbr_copyup(v));
+
+	v = au_opt_test(mnt_flags, ALWAYS_DIROPQ);
+	if (v != au_opt_test(AuOpt_Def, ALWAYS_DIROPQ))
+		seq_printf(m, ",diropq=%c", v ? 'a' : 'w');
+	AuBool(REFROF, refrof);
+	AuBool(DLGT, dlgt);
+	AuBool(WARN_PERM, warn_perm);
+	AuBool(VERBOSE, verbose);
+	AuBool(SUM, sum);
+	/* AuBool(SUM_W, wsum); */
+
+	n = sbinfo->si_dirwh;
+	if (n != AUFS_DIRWH_DEF)
+		seq_printf(m, ",dirwh=%d", n);
+	n = sbinfo->si_rdcache / HZ;
+	if (n != AUFS_RDCACHE_DEF)
+		seq_printf(m, ",rdcache=%d", n);
+
+	AuStr(COO, coo);
+
+ out:
+	if (!sysaufs_brs) {
+		seq_puts(m, "," AuStr_BrOpt);
+		au_show_brs(m, sb);
+	}
+	si_read_unlock(sb);
+	return 0;
+
+#undef AuBool
+#undef AuStr
+#undef AuStr_BrOpt
+}
+
+static u64 au_add_till_max(u64 a, u64 b)
+{
+	u64 old;
+
+	old = a;
+	a += b;
+	if (old < a)
+		return a;
+	return ULLONG_MAX;
+}
+
+static int au_statfs_sum(struct super_block *sb, struct kstatfs *buf, int dlgt)
+{
+	int err;
+	aufs_bindex_t bend, bindex, i;
+	unsigned char shared;
+	u64 blocks, bfree, bavail, files, ffree;
+	struct super_block *h_sb;
+
+	AuTraceEnter();
+
+	blocks = 0;
+	bfree = 0;
+	bavail = 0;
+	files = 0;
+	ffree = 0;
+
+	err = 0;
+	bend = au_sbend(sb);
+	for (bindex = bend; bindex >= 0; bindex--) {
+		h_sb = au_sbr_sb(sb, bindex);
+		shared = 0;
+		for (i = bindex + 1; !shared && i <= bend; i++)
+			shared = au_sbr_sb(sb, i) == h_sb;
+		if (shared)
+			continue;
+
+		err = vfsub_statfs(h_sb->s_root, buf, dlgt);
+		if (unlikely(err))
+			goto out;
+
+		blocks = au_add_till_max(blocks, buf->f_blocks);
+		bfree = au_add_till_max(bfree, buf->f_bfree);
+		bavail = au_add_till_max(bavail, buf->f_bavail);
+		files = au_add_till_max(files, buf->f_files);
+		ffree = au_add_till_max(ffree, buf->f_ffree);
+	}
+
+	buf->f_blocks = blocks;
+	buf->f_bfree = bfree;
+	buf->f_bavail = bavail;
+	buf->f_files = files;
+	buf->f_ffree = ffree;
+
+ out:
+	AuTraceErr(err);
+	return err;
+}
+
+/* todo: in case of round-robin policy, return the sum of all rw branches? */
+static int aufs_statfs(struct dentry *dentry, struct kstatfs *buf)
+{
+	int err;
+	unsigned int mnt_flags;
+	unsigned char dlgt;
+	struct super_block *sb;
+
+	AuTraceEnter();
+
+	/* lock free root dinfo */
+	sb = dentry->d_sb;
+	si_noflush_read_lock(sb);
+	mnt_flags = au_mntflags(sb);
+	dlgt = !!au_test_dlgt(mnt_flags);
+	if (!au_opt_test(mnt_flags, SUM))
+		err = vfsub_statfs(au_sbr_sb(sb, 0)->s_root, buf, dlgt);
+	else
+		err = au_statfs_sum(sb, buf, dlgt);
+	si_read_unlock(sb);
+	if (!err) {
+		buf->f_type = AUFS_SUPER_MAGIC;
+		buf->f_namelen -= AUFS_WH_PFX_LEN;
+		memset(&buf->f_fsid, 0, sizeof(buf->f_fsid));
+	}
+	/* buf->f_bsize = buf->f_blocks = buf->f_bfree = buf->f_bavail = -1; */
+
+	AuTraceErr(err);
+	return err;
+}
+
+static void au_fsync_br(struct super_block *sb)
+{
+#ifdef CONFIG_AUFS_FSYNC_SUPER_PATCH
+	aufs_bindex_t bend, bindex;
+	int brperm;
+	struct super_block *h_sb;
+
+	AuTraceEnter();
+
+	si_write_lock(sb);
+	bend = au_sbend(sb);
+	for (bindex = 0; bindex < bend; bindex++) {
+		brperm = au_sbr_perm(sb, bindex);
+		if (brperm == AuBrPerm_RR || brperm == AuBrPerm_RRWH)
+			continue;
+		h_sb = au_sbr_sb(sb, bindex);
+		if (bdev_read_only(h_sb->s_bdev))
+			continue;
+
+		lockdep_off();
+		down_write(&h_sb->s_umount);
+		shrink_dcache_sb(h_sb);
+		fsync_super(h_sb);
+		up_write(&h_sb->s_umount);
+		lockdep_on();
+	}
+	si_write_unlock(sb);
+#endif
+}
+
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 26)
+/* this IS NOT for super_operations */
+static void aufs_umount_begin(struct super_block *arg)
+#define AuUmountBeginSb(arg)	(arg)
+#else
+/* this IS for super_operations */
+static void aufs_umount_begin(struct vfsmount *arg, int flags)
+#define AuUmountBeginSb(arg)	((arg)->mnt_sb)
+#endif
+{
+	struct super_block *sb = AuUmountBeginSb(arg);
+	struct au_sbinfo *sbinfo;
+
+	AuTraceEnter();
+	/* dont trust BKL */
+	AuDebugOn(!kernel_locked());
+
+	sbinfo = au_sbi(sb);
+	if (!sbinfo)
+		return;
+
+	au_fsync_br(sb);
+
+	si_write_lock(sb);
+	if (au_opt_test(au_mntflags(sb), PLINK))
+		au_plink_put(sb);
+	au_mnt_reset(sbinfo);
+#if 0 /* reserved for future use */
+	if (sbinfo->si_wbr_create_ops->fin)
+		sbinfo->si_wbr_create_ops->fin(sb);
+#endif
+	si_write_unlock(sb);
+}
+
+/* final actions when unmounting a file system */
+static void aufs_put_super(struct super_block *sb)
+{
+	struct au_sbinfo *sbinfo;
+
+	AuTraceEnter();
+
+	sbinfo = au_sbi(sb);
+	if (!sbinfo)
+		return;
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 26)
+	aufs_umount_begin(sb);
+#endif
+	kobject_put(&sbinfo->si_kobj);
+}
+
+/* ---------------------------------------------------------------------- */
+
+/*
+ * refresh dentry and inode at remount time.
+ */
+static int do_refresh(struct dentry *dentry, mode_t type,
+		      unsigned int dir_flags)
+{
+	int err;
+	struct dentry *parent;
+	struct inode *inode;
+
+	LKTRTrace("%.*s, 0%o\n", AuDLNPair(dentry), type);
+	inode = dentry->d_inode;
+	AuDebugOn(!inode);
+
+	di_write_lock_child(dentry);
+	parent = dget_parent(dentry);
+	di_read_lock_parent(parent, AuLock_IR);
+	/* returns a number of positive dentries */
+	err = au_refresh_hdentry(dentry, type);
+	if (err >= 0) {
+		err = au_refresh_hinode(inode, dentry);
+		if (!err && type == S_IFDIR)
+			au_reset_hinotify(inode, dir_flags);
+	}
+	if (unlikely(err))
+		AuErr("unrecoverable error %d, %.*s\n", err, AuDLNPair(dentry));
+	di_read_unlock(parent, AuLock_IR);
+	dput(parent);
+	di_write_unlock(dentry);
+
+	AuTraceErr(err);
+	return err;
+}
+
+static int test_dir(struct dentry *dentry, void *arg)
+{
+	return S_ISDIR(dentry->d_inode->i_mode);
+}
+
+/* todo: merge with refresh_nondir()? */
+static int refresh_dir(struct dentry *root, au_gen_t sgen)
+{
+	int err, i, j, ndentry, e;
+	struct au_dcsub_pages dpages;
+	struct au_dpage *dpage;
+	struct dentry **dentries;
+	struct inode *inode;
+	const unsigned int flags = au_hi_flags(root->d_inode, /*isdir*/1);
+
+	LKTRTrace("sgen %d\n", sgen);
+	SiMustWriteLock(root->d_sb);
+	/* dont trust BKL */
+	AuDebugOn(au_digen(root) != sgen || !kernel_locked());
+
+	err = 0;
+	list_for_each_entry(inode, &root->d_sb->s_inodes, i_sb_list)
+		if (S_ISDIR(inode->i_mode) && au_iigen(inode) != sgen) {
+			ii_write_lock_child(inode);
+			e = au_refresh_hinode_self(inode);
+			ii_write_unlock(inode);
+			if (unlikely(e)) {
+				LKTRTrace("e %d, i%lu\n", e, inode->i_ino);
+				if (!err)
+					err = e;
+				/* go on even if err */
+			}
+		}
+
+	e = au_dpages_init(&dpages, GFP_NOFS);
+	if (unlikely(e)) {
+		if (!err)
+			err = e;
+		goto out;
+	}
+	e = au_dcsub_pages(&dpages, root, test_dir, NULL);
+	if (unlikely(e)) {
+		if (!err)
+			err = e;
+		goto out_dpages;
+	}
+
+	for (i = 0; !e && i < dpages.ndpage; i++) {
+		dpage = dpages.dpages + i;
+		dentries = dpage->dentries;
+		ndentry = dpage->ndentry;
+		for (j = 0; !e && j < ndentry; j++) {
+			struct dentry *d;
+			d = dentries[j];
+#ifdef CONFIG_AUFS_DEBUG
+			{
+				struct dentry *parent;
+				parent = dget_parent(d);
+				AuDebugOn(!S_ISDIR(d->d_inode->i_mode)
+					  || IS_ROOT(d)
+					  || au_digen(parent) != sgen);
+				dput(parent);
+			}
+#endif
+			if (au_digen(d) != sgen) {
+				e = do_refresh(d, S_IFDIR, flags);
+				if (unlikely(e && !err))
+					err = e;
+				/* break on err */
+			}
+		}
+	}
+
+ out_dpages:
+	au_dpages_free(&dpages);
+ out:
+	AuTraceErr(err);
+	return err;
+}
+
+static int test_nondir(struct dentry *dentry, void *arg)
+{
+	return !S_ISDIR(dentry->d_inode->i_mode);
+}
+
+static int refresh_nondir(struct dentry *root, au_gen_t sgen, int do_dentry)
+{
+	int err, i, j, ndentry, e;
+	struct au_dcsub_pages dpages;
+	struct au_dpage *dpage;
+	struct dentry **dentries;
+	struct inode *inode;
+
+	LKTRTrace("sgen %d\n", sgen);
+	SiMustWriteLock(root->d_sb);
+	/* dont trust BKL */
+	AuDebugOn(au_digen(root) != sgen || !kernel_locked());
+
+	err = 0;
+	list_for_each_entry(inode, &root->d_sb->s_inodes, i_sb_list)
+		if (!S_ISDIR(inode->i_mode) && au_iigen(inode) != sgen) {
+			ii_write_lock_child(inode);
+			e = au_refresh_hinode_self(inode);
+			ii_write_unlock(inode);
+			if (unlikely(e)) {
+				LKTRTrace("e %d, i%lu\n", e, inode->i_ino);
+				if (!err)
+					err = e;
+				/* go on even if err */
+			}
+		}
+
+	if (!do_dentry)
+		goto out;
+
+	e = au_dpages_init(&dpages, GFP_NOFS);
+	if (unlikely(e)) {
+		if (!err)
+			err = e;
+		goto out;
+	}
+	e = au_dcsub_pages(&dpages, root, test_nondir, NULL);
+	if (unlikely(e)) {
+		if (!err)
+			err = e;
+		goto out_dpages;
+	}
+
+	for (i = 0; i < dpages.ndpage; i++) {
+		dpage = dpages.dpages + i;
+		dentries = dpage->dentries;
+		ndentry = dpage->ndentry;
+		for (j = 0; j < ndentry; j++) {
+			struct dentry *d;
+			d = dentries[j];
+#ifdef CONFIG_AUFS_DEBUG
+			{
+				struct dentry *parent;
+				parent = dget_parent(d);
+				AuDebugOn(S_ISDIR(d->d_inode->i_mode)
+					  || au_digen(parent) != sgen);
+				dput(parent);
+			}
+#endif
+			inode = d->d_inode;
+			if (inode && au_digen(d) != sgen) {
+				e = do_refresh(d, inode->i_mode & S_IFMT, 0);
+				if (unlikely(e && !err))
+					err = e;
+				/* go on even err */
+			}
+		}
+	}
+
+ out_dpages:
+	au_dpages_free(&dpages);
+ out:
+	AuTraceErr(err);
+	return err;
+}
+
+/* stop extra interpretation of errno in mount(8), and strange error messages */
+static int cvt_err(int err)
+{
+	AuTraceErr(err);
+
+	switch (err) {
+	case -ENOENT:
+	case -ENOTDIR:
+	case -EEXIST:
+	case -EIO:
+		err = -EINVAL;
+	}
+	return err;
+}
+
+/* protected by s_umount */
+static int aufs_remount_fs(struct super_block *sb, int *flags, char *data)
+{
+	int err, rerr;
+	au_gen_t sigen;
+	struct dentry *root;
+	struct inode *inode;
+	struct au_opts opts;
+	struct au_sbinfo *sbinfo;
+	unsigned char dlgt;
+
+	LKTRTrace("flags 0x%x, data %s, len %lu\n",
+		  *flags, data ? data : "NULL",
+		  (unsigned long)(data ? strlen(data) : 0));
+
+	au_fsync_br(sb);
+
+	err = 0;
+	if (!data || !*data)
+		goto out; /* success */
+
+	err = -ENOMEM;
+	memset(&opts, 0, sizeof(opts));
+	opts.opt = (void *)__get_free_page(GFP_NOFS);
+	if (unlikely(!opts.opt))
+		goto out;
+	opts.max_opt = PAGE_SIZE / sizeof(*opts.opt);
+	opts.flags = AuOpts_REMOUNT;
+	opts.sb_flags = *flags;
+
+	/* parse it before aufs lock */
+	err = au_opts_parse(sb, data, &opts);
+	if (unlikely(err))
+		goto out_opts;
+
+	sbinfo = au_sbi(sb);
+	root = sb->s_root;
+	inode = root->d_inode;
+	mutex_lock(&inode->i_mutex);
+	aufs_write_lock(root);
+
+	/* au_do_opts() may return an error */
+	err = au_opts_remount(sb, &opts);
+	au_opts_free(&opts);
+
+	if (au_ftest_opts(opts.flags, REFRESH_DIR)
+	    || au_ftest_opts(opts.flags, REFRESH_NONDIR)) {
+		dlgt = !!au_opt_test(sbinfo->si_mntflags, DLGT);
+		au_opt_clr(sbinfo->si_mntflags, DLGT);
+		au_sigen_inc(sb);
+		au_reset_hinotify(inode, au_hi_flags(inode, /*isdir*/1));
+		sigen = au_sigen(sb);
+		au_fclr_si(sbinfo, FAILED_REFRESH_DIRS);
+
+		DiMustNoWaiters(root);
+		IiMustNoWaiters(root->d_inode);
+		di_write_unlock(root);
+
+		rerr = refresh_dir(root, sigen);
+		if (unlikely(rerr)) {
+			au_fset_si(sbinfo, FAILED_REFRESH_DIRS);
+			AuWarn("Refreshing directories failed, ignores (%d)\n",
+			       rerr);
+		}
+
+		if (au_ftest_opts(opts.flags, REFRESH_NONDIR)) {
+			rerr = refresh_nondir(root, sigen, !rerr);
+			if (unlikely(rerr))
+				AuWarn("Refreshing non-directories failed,"
+				       " ignores (%d)\n", rerr);
+		}
+
+		/* aufs_write_lock() calls ..._child() */
+		di_write_lock_child(root);
+
+		au_cpup_attr_all(inode, /*force*/1);
+		if (dlgt)
+			au_opt_set(sbinfo->si_mntflags, DLGT);
+	}
+
+	aufs_write_unlock(root);
+	mutex_unlock(&inode->i_mutex);
+
+ out_opts:
+	free_page((unsigned long)opts.opt);
+ out:
+	err = cvt_err(err);
+	AuTraceErr(err);
+	return err;
+}
+
+static struct super_operations aufs_sop = {
+	.alloc_inode	= aufs_alloc_inode,
+	.destroy_inode	= aufs_destroy_inode,
+	.drop_inode	= generic_delete_inode,
+
+	.show_options	= aufs_show_options,
+	.statfs		= aufs_statfs,
+
+	.put_super	= aufs_put_super,
+	.remount_fs	= aufs_remount_fs,
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2, 6, 26)
+	.umount_begin	= aufs_umount_begin
+#endif
+};
+
+/* ---------------------------------------------------------------------- */
+
+static int alloc_root(struct super_block *sb)
+{
+	int err;
+	struct inode *inode;
+	struct dentry *root;
+
+	AuTraceEnter();
+
+	err = -ENOMEM;
+	inode = au_iget_locked(sb, AUFS_ROOT_INO);
+	err = PTR_ERR(inode);
+	if (IS_ERR(inode))
+		goto out;
+	inode->i_op = &aufs_dir_iop;
+	inode->i_fop = &aufs_dir_fop;
+	inode->i_mode = S_IFDIR;
+	unlock_new_inode(inode);
+	root = d_alloc_root(inode);
+	if (unlikely(!root))
+		goto out_iput;
+	err = PTR_ERR(root);
+	if (IS_ERR(root))
+		goto out_iput;
+
+	err = au_alloc_dinfo(root);
+	if (!err) {
+		sb->s_root = root;
+		return 0; /* success */
+	}
+	dput(root);
+	goto out; /* do not iput */
+
+ out_iput:
+	iget_failed(inode);
+	iput(inode);
+ out:
+	AuTraceErr(err);
+	return err;
+
+}
+
+static int aufs_fill_super(struct super_block *sb, void *raw_data, int silent)
+{
+	int err;
+	struct dentry *root;
+	struct inode *inode;
+	struct au_opts opts;
+	char *arg = raw_data;
+
+	if (unlikely(!arg || !*arg)) {
+		err = -EINVAL;
+		AuErr("no arg\n");
+		goto out;
+	}
+	LKTRTrace("%s, silent %d\n", arg, silent);
+
+	err = -ENOMEM;
+	memset(&opts, 0, sizeof(opts));
+	opts.opt = (void *)__get_free_page(GFP_NOFS);
+	if (unlikely(!opts.opt))
+		goto out;
+	opts.max_opt = PAGE_SIZE / sizeof(*opts.opt);
+	opts.sb_flags = sb->s_flags;
+
+	err = au_si_alloc(sb);
+	if (unlikely(err))
+		goto out_opts;
+	SiMustWriteLock(sb);
+
+	/* all timestamps always follow the ones on the branch */
+	sb->s_flags |= MS_NOATIME | MS_NODIRATIME;
+	sb->s_op = &aufs_sop;
+	sb->s_magic = AUFS_SUPER_MAGIC;
+	au_export_init(sb);
+
+	err = alloc_root(sb);
+	if (unlikely(err)) {
+		AuDebugOn(sb->s_root);
+		si_write_unlock(sb);
+		goto out_info;
+	}
+	root = sb->s_root;
+	DiMustWriteLock(root);
+	inode = root->d_inode;
+	inode->i_nlink = 2;
+
+	/*
+	 * actually we can parse options regardless aufs lock here.
+	 * but at remount time, parsing must be done before aufs lock.
+	 * so we follow the same rule.
+	 */
+	ii_write_lock_parent(inode);
+	au_dbg_locked_si_reg(sb, 1);
+	aufs_write_unlock(root);
+	err = au_opts_parse(sb, arg, &opts);
+	if (unlikely(err))
+		goto out_root;
+
+	/* lock vfs_inode first, then aufs. */
+	mutex_lock(&inode->i_mutex);
+	inode->i_op = &aufs_dir_iop;
+	inode->i_fop = &aufs_dir_fop;
+	aufs_write_lock(root);
+
+	sb->s_maxbytes = 0;
+	err = au_opts_mount(sb, &opts);
+	au_opts_free(&opts);
+	if (unlikely(err))
+		goto out_unlock;
+	AuDebugOn(!sb->s_maxbytes);
+
+	aufs_write_unlock(root);
+	mutex_unlock(&inode->i_mutex);
+	goto out_opts; /* success */
+
+ out_unlock:
+	aufs_write_unlock(root);
+	mutex_unlock(&inode->i_mutex);
+ out_root:
+	dput(root);
+	sb->s_root = NULL;
+ out_info:
+	kobject_put(&au_sbi(sb)->si_kobj);
+	sb->s_fs_info = NULL;
+ out_opts:
+	free_page((unsigned long)opts.opt);
+ out:
+	AuTraceErr(err);
+	err = cvt_err(err);
+	AuTraceErr(err);
+	return err;
+}
+
+/* ---------------------------------------------------------------------- */
+
+static int aufs_get_sb(struct file_system_type *fs_type, int flags,
+		       const char *dev_name, void *raw_data,
+		       struct vfsmount *mnt)
+{
+	int err;
+	struct super_block *sb;
+
+	/* all timestamps always follow the ones on the branch */
+	/* mnt->mnt_flags |= MNT_NOATIME | MNT_NODIRATIME; */
+	err = get_sb_nodev(fs_type, flags, raw_data, aufs_fill_super, mnt);
+	if (!err) {
+		sb = mnt->mnt_sb;
+		au_mnt_init(au_sbi(sb), mnt);
+		si_write_lock(sb);
+		sysaufs_brs_add(sb, 0);
+		si_write_unlock(sb);
+	}
+	return err;
+}
+
+struct file_system_type aufs_fs_type = {
+	.name		= AUFS_FSTYPE,
+	.fs_flags	=
+		FS_RENAME_DOES_D_MOVE	/* a race between rename and others*/
+		| FS_REVAL_DOT,		/* for NFS branch and udba */
+	.get_sb		= aufs_get_sb,
+	.kill_sb	= generic_shutdown_super,
+	/* no need to __module_get() and module_put(). */
+	.owner		= THIS_MODULE,
+};
diff -Nurp linux-2.6.27.orig/fs/aufs/super.h linux-2.6.27/fs/aufs/super.h
--- linux-2.6.27.orig/fs/aufs/super.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.27/fs/aufs/super.h	2008-12-14 10:37:40.000000000 +0100
@@ -0,0 +1,569 @@
+/*
+ * Copyright (C) 2005-2008 Junjiro Okajima
+ *
+ * This program, aufs is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+ */
+
+/*
+ * super_block operations
+ *
+ * $Id: super.h,v 1.21 2008/12/08 06:12:22 sfjro Exp $
+ */
+
+#ifndef __AUFS_SUPER_H__
+#define __AUFS_SUPER_H__
+
+#ifdef __KERNEL__
+
+#include <linux/fs.h>
+#include <linux/cramfs_fs.h>
+#include <linux/kobject.h>
+#include <linux/magic.h>
+#include <linux/mount.h>
+#include <linux/aufs_type.h>
+#include "misc.h"
+#include "wkq.h"
+
+typedef ssize_t (*au_readf_t)(struct file *, char __user *, size_t, loff_t *);
+typedef ssize_t (*au_writef_t)(struct file *, const char __user *, size_t,
+			       loff_t *);
+
+struct au_wbr_copyup_operations {
+	int (*copyup)(struct dentry *dentry);
+};
+
+struct au_wbr_create_operations {
+	int (*create)(struct dentry *dentry, int isdir);
+	int (*init)(struct super_block *sb);
+	int (*fin)(struct super_block *sb);
+};
+
+struct au_wbr_mfs {
+	struct mutex	mfs_lock; /* protect this structure */
+	unsigned long	mfs_jiffy;
+	unsigned long	mfs_expire;
+	aufs_bindex_t	mfs_bindex;
+
+	unsigned long long	mfsrr_bytes;
+	unsigned long long	mfsrr_watermark;
+};
+
+/* sbinfo status flags */
+/*
+ * set true when refresh_dirs() failed at remount time.
+ * then try refreshing dirs at access time again.
+ * if it is false, refreshing dirs at access time is unnecesary
+ */
+#define AuSi_FAILED_REFRESH_DIRS	1
+#define au_ftest_si(sbinfo, name)	((sbinfo)->au_si_status & AuSi_##name)
+#define au_fset_si(sbinfo, name) \
+	{ (sbinfo)->au_si_status |= AuSi_##name; }
+#define au_fclr_si(sbinfo, name) \
+	{ (sbinfo)->au_si_status &= ~AuSi_##name; }
+
+struct au_branch;
+struct au_sbinfo {
+	/* nowait tasks in the system-wide workqueue */
+	struct au_nowait_tasks	si_nowait;
+
+	struct au_rwsem		si_rwsem;
+
+	/* branch management */
+	au_gen_t		si_generation;
+
+	/* see above flags */
+	unsigned char		au_si_status;
+
+	aufs_bindex_t		si_bend;
+	aufs_bindex_t		si_last_br_id;
+	struct au_branch	**si_branch;
+
+	/* policy to select a writable branch */
+	unsigned char		si_wbr_copyup;
+	unsigned char		si_wbr_create;
+	struct au_wbr_copyup_operations *si_wbr_copyup_ops;
+	struct au_wbr_create_operations *si_wbr_create_ops;
+
+	/* round robin */
+	atomic_t		si_wbr_rr_next;
+
+	/* most free space */
+	struct au_wbr_mfs	si_wbr_mfs;
+
+	/* mount flags */
+	/* include/asm-ia64/siginfo.h defines a macro named si_flags */
+	unsigned int		si_mntflags;
+
+	/* external inode number (bitmap and translation table) */
+	au_readf_t		si_xread;
+	au_writef_t		si_xwrite;
+	struct file		*si_xib;
+	struct mutex		si_xib_mtx; /* protect xib members */
+	unsigned long		*si_xib_buf;
+	unsigned long		si_xib_last_pindex;
+	int			si_xib_next_bit;
+	/* reserved for future use */
+	/* unsigned long long	si_xib_limit; */	/* Max xib file size */
+
+#ifdef CONFIG_AUFS_HINOTIFY
+	struct au_branch	*si_xino_def_br;
+#endif
+
+#ifdef CONFIG_AUFS_EXPORT
+	/* i_generation */
+	struct file		*si_xigen;
+	atomic_t		si_xigen_next;
+#endif
+
+	/* readdir cache time, max, in HZ */
+	unsigned long		si_rdcache;
+
+	/*
+	 * If the number of whiteouts are larger than si_dirwh, leave all of
+	 * them after au_whtmp_ren to reduce the cost of rmdir(2).
+	 * future fsck.aufs or kernel thread will remove them later.
+	 * Otherwise, remove all whiteouts and the dir in rmdir(2).
+	 */
+	unsigned int		si_dirwh;
+
+	/*
+	 * rename(2) a directory with all children.
+	 */
+	/* reserved for future use */
+	/* int			si_rendir; */
+
+	/* pseudo_link list */ /* todo: dirty? */
+	struct au_splhead	si_plink;
+
+#if defined(CONFIG_AUFS_EXPORT) && LINUX_VERSION_CODE < KERNEL_VERSION(2, 6, 26)
+	/* dirty, for export, async ops, and sysfs */
+	spinlock_t		si_mntcache_lock;
+	struct vfsmount		*si_mntcache;	/* no get/put */
+#endif
+
+	/*
+	 * sysfs and lifetime management.
+	 * this is not a small structure and it may be a waste of memory in case
+	 * of sysfs is disabled, particulary when many aufs-es are mounted.
+	 */
+	struct kobject		si_kobj;
+
+#ifdef CONFIG_AUFS_ROBR
+	/* locked vma list for mmap() */ /* todo: dirty? */
+	struct au_splhead	si_lvma;
+#endif
+
+#ifdef CONFIG_AUFS_EXPORT /* reserved for future use */
+	struct path		si_xinodir;
+#endif
+
+	/* dirty, necessary for unmounting, sysfs and sysrq */
+	struct super_block	*si_sb;
+
+#ifdef CONFIG_AUFS_DEBUG_LOCK
+	struct au_splhead	si_dbg_lock[AuDbgLock_Last];
+#endif
+};
+
+/* ---------------------------------------------------------------------- */
+
+/* policy to select one among writable branches */
+#define AuWbrCopyup(sbinfo, args...) \
+	((sbinfo)->si_wbr_copyup_ops->copyup(args))
+#define AuWbrCreate(sbinfo, args...) \
+	((sbinfo)->si_wbr_create_ops->create(args))
+
+/* flags for si_read_lock()/aufs_read_lock()/di_read_lock() */
+#define AuLock_DW		1		/* write-lock dentry */
+#define AuLock_IR		(1 << 1)	/* read-lock inode */
+#define AuLock_IW		(1 << 2)	/* write-lock inode */
+#define AuLock_FLUSH		(1 << 3)	/* wait for 'nowait' tasks */
+#define AuLock_DIR		(1 << 4)	/* target is a dir */
+#define au_ftest_lock(flags, name)	((flags) & AuLock_##name)
+#define au_fset_lock(flags, name)	{ (flags) |= AuLock_##name; }
+#define au_fclr_lock(flags, name)	{ (flags) &= ~AuLock_##name; }
+
+/* ---------------------------------------------------------------------- */
+
+/* super.c */
+extern struct file_system_type aufs_fs_type;
+struct inode *au_iget_locked(struct super_block *sb, ino_t ino);
+
+/* sbinfo.c */
+void au_si_free(struct kobject *kobj);
+int au_si_alloc(struct super_block *sb);
+struct au_branch *au_sbr(struct super_block *sb, aufs_bindex_t bindex);
+au_gen_t au_sigen_inc(struct super_block *sb);
+int au_find_bindex(struct super_block *sb, struct au_branch *br);
+
+void aufs_read_lock(struct dentry *dentry, int flags);
+void aufs_read_unlock(struct dentry *dentry, int flags);
+void aufs_write_lock(struct dentry *dentry);
+void aufs_write_unlock(struct dentry *dentry);
+void aufs_read_and_write_lock2(struct dentry *d1, struct dentry *d2, int isdir);
+void aufs_read_and_write_unlock2(struct dentry *d1, struct dentry *d2);
+
+aufs_bindex_t au_new_br_id(struct super_block *sb);
+
+/* wbr_policy.c */
+extern struct au_wbr_copyup_operations au_wbr_copyup_ops[];
+extern struct au_wbr_create_operations au_wbr_create_ops[];
+int au_cpdown_dirs(struct dentry *dentry, aufs_bindex_t bdst);
+
+/* ---------------------------------------------------------------------- */
+
+#if defined(CONFIG_AUFS_EXPORT) && LINUX_VERSION_CODE < KERNEL_VERSION(2, 6, 26)
+static inline void au_mnt_init(struct au_sbinfo *sbinfo, struct vfsmount *mnt)
+{
+	spin_lock_init(&sbinfo->si_mntcache_lock);
+	sbinfo->si_mntcache = mnt;
+}
+
+static inline void au_mnt_reset(struct au_sbinfo *sbinfo)
+{
+	spin_lock(&sbinfo->si_mntcache_lock);
+	sbinfo->si_mntcache = NULL;
+	spin_unlock(&sbinfo->si_mntcache_lock);
+}
+#else
+static inline void au_mnt_init(struct au_sbinfo *sbinfo, struct vfsmount *mnt)
+{
+	/* emptr */
+}
+
+static inline void au_mnt_reset(struct au_sbinfo *sbinfo)
+{
+	/* emptr */
+}
+#endif /* EXPORT && < 2.6.26 */
+
+/* ---------------------------------------------------------------------- */
+
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 26)
+static inline int au_mnt_want_write(struct vfsmount *h_mnt)
+{
+	return mnt_want_write(h_mnt);
+}
+
+static inline void au_mnt_drop_write(struct vfsmount *h_mnt)
+{
+	mnt_drop_write(h_mnt);
+}
+#else
+static inline int au_mnt_want_write(struct vfsmount *h_mnt)
+{
+	return 0;
+}
+
+static inline void au_mnt_drop_write(struct vfsmount *h_mnt)
+{
+	/* empty */
+}
+#endif
+
+/* ---------------------------------------------------------------------- */
+
+static inline struct au_sbinfo *au_sbi(struct super_block *sb)
+{
+	return sb->s_fs_info;
+}
+
+static inline const char *au_sbtype(struct super_block *sb)
+{
+	return sb->s_type->name;
+}
+
+static inline int au_test_aufs(struct super_block *sb)
+{
+	return sb->s_magic == AUFS_SUPER_MAGIC;
+}
+
+static inline int au_test_nfs(struct super_block *sb)
+{
+#ifdef CONFIG_AUFS_BR_NFS
+	return sb->s_magic == NFS_SUPER_MAGIC;
+#else
+	return 0;
+#endif
+}
+
+static inline int au_test_nfs4(struct super_block *sb)
+{
+#ifdef CONFIG_AUFS_BR_NFS_V4
+	return au_test_nfs(sb) && !strcmp(sb->s_type->name, "nfs4");
+#else
+	return 0;
+#endif
+}
+
+static inline int au_test_fuse(struct super_block *sb)
+{
+#ifdef CONFIG_AUFS_WORKAROUND_FUSE
+	return sb->s_magic == FUSE_SUPER_MAGIC;
+#else
+	return 0;
+#endif
+}
+
+static inline int au_test_xfs(struct super_block *sb)
+{
+#ifdef CONFIG_AUFS_BR_XFS
+	return sb->s_magic == XFS_SB_MAGIC;
+#else
+	return 0;
+#endif
+}
+
+static inline int au_test_tmpfs(struct super_block *sb)
+{
+#ifdef CONFIG_TMPFS
+	return sb->s_magic == TMPFS_MAGIC;
+#else
+	return 0;
+#endif
+}
+
+/* ---------------------------------------------------------------------- */
+
+#ifdef CONFIG_AUFS_HINOTIFY
+static inline void au_xino_def_br_set(struct au_branch *br,
+				      struct au_sbinfo *sbinfo)
+{
+	sbinfo->si_xino_def_br = br;
+}
+
+static inline struct au_branch *au_xino_def_br(struct au_sbinfo *sbinfo)
+{
+	return sbinfo->si_xino_def_br;
+}
+#else
+static inline void au_xino_def_br_set(struct au_branch *br,
+				      struct au_sbinfo *sbinfo)
+{
+	/* empty */
+}
+
+static inline struct au_branch *au_xino_def_br(struct au_sbinfo *sbinfo)
+{
+	return NULL;
+}
+#endif
+
+/* ---------------------------------------------------------------------- */
+
+#ifdef CONFIG_AUFS_EXPORT
+void au_export_init(struct super_block *sb);
+
+static inline int au_test_nfsd(struct task_struct *tsk)
+{
+	return !tsk->mm && !strcmp(tsk->comm, "nfsd");
+}
+
+static inline void au_export_put(struct au_sbinfo *sbinfo)
+{
+	path_put(&sbinfo->si_xinodir);
+}
+
+int au_xigen_inc(struct inode *inode);
+int au_xigen_new(struct inode *inode);
+int au_xigen_set(struct super_block *sb, struct file *base);
+void au_xigen_clr(struct super_block *sb);
+#else
+static inline void au_export_init(struct super_block *sb)
+{
+	/* nothing */
+}
+
+static inline int au_test_nfsd(struct task_struct *tsk)
+{
+	return 0;
+}
+
+static inline void au_export_put(struct au_sbinfo *sbinfo)
+{
+	/* nothing */
+}
+
+static inline int au_xigen_inc(struct inode *inode)
+{
+	return 0;
+}
+
+static inline int au_xigen_new(struct inode *inode)
+{
+	return 0;
+}
+
+static inline int au_xigen_set(struct super_block *sb, struct file *base)
+{
+	return 0;
+}
+
+static inline void au_xigen_clr(struct super_block *sb)
+{
+	/* empty */
+}
+#endif /* CONFIG_AUFS_EXPORT */
+
+#ifdef CONFIG_AUFS_ROBR
+static inline int au_test_nested(struct super_block *h_sb)
+{
+	return 0;
+}
+
+static inline void au_robr_lvma_init(struct au_sbinfo *sbinfo)
+{
+	au_spl_init(&sbinfo->si_lvma);
+}
+#else
+static inline int au_test_nested(struct super_block *h_sb)
+{
+	int err = 0;
+	if (unlikely(au_test_aufs(h_sb))) {
+		err = -EINVAL;
+		AuTraceErr(err);
+	}
+	return err;
+}
+
+static inline void au_robr_lvma_init(struct au_sbinfo *sbinfo)
+{
+	/* empty */
+}
+#endif /* CONFIG_AUFS_ROBR */
+
+/* ---------------------------------------------------------------------- */
+
+/* lock superblock. mainly for entry point functions */
+/*
+ * si_do_noflush_read_lock, si_do_noflush_write_lock,
+ * si_do_read_unlock, si_do_write_unlock, si_do_downgrade_lock
+ */
+AuSimpleLockRwsemFuncs(si_do_noflush, struct super_block *sb,
+		       au_sbi(sb)->si_rwsem);
+AuSimpleUnlockRwsemFuncs(si_do, struct super_block *sb, au_sbi(sb)->si_rwsem);
+
+static inline void si_noflush_read_lock(struct super_block *sb)
+{
+	au_dbg_locking_si_reg(sb, 0);
+	si_do_noflush_read_lock(sb);
+	au_dbg_locking_si_unreg(sb, 0);
+	au_dbg_locked_si_reg(sb, 0);
+}
+
+static inline void si_noflush_write_lock(struct super_block *sb)
+{
+	au_dbg_locking_si_reg(sb, 1);
+	si_do_noflush_write_lock(sb);
+	au_dbg_locking_si_unreg(sb, 1);
+	au_dbg_locked_si_reg(sb, 1);
+}
+
+static inline int si_noflush_read_trylock(struct super_block *sb)
+{
+	int locked;
+
+	au_dbg_locking_si_reg(sb, 0);
+	locked = si_do_noflush_read_trylock(sb);
+	au_dbg_locking_si_unreg(sb, 0);
+	if (locked)
+		au_dbg_locked_si_reg(sb, 0);
+	return locked;
+}
+
+static inline int si_noflush_write_trylock(struct super_block *sb)
+{
+	int locked;
+
+	au_dbg_locking_si_reg(sb, 1);
+	locked = si_do_noflush_write_trylock(sb);
+	au_dbg_locking_si_unreg(sb, 1);
+	if (locked)
+		au_dbg_locked_si_reg(sb, 1);
+	return locked;
+}
+
+static inline void si_read_unlock(struct super_block *sb)
+{
+	si_do_read_unlock(sb);
+	au_dbg_locked_si_unreg(sb, 0);
+}
+
+static inline void si_write_unlock(struct super_block *sb)
+{
+	si_do_write_unlock(sb);
+	au_dbg_locked_si_unreg(sb, 1);
+}
+
+static inline void si_downgrade_lock(struct super_block *sb)
+{
+	si_do_downgrade_lock(sb);
+}
+
+static inline void si_read_lock(struct super_block *sb, int flags)
+{
+	if (/* !au_test_nfsd(current) &&  */au_ftest_lock(flags, FLUSH))
+		au_nwt_flush(&au_sbi(sb)->si_nowait);
+	si_noflush_read_lock(sb);
+}
+
+static inline void si_write_lock(struct super_block *sb)
+{
+	//WARN_ON(au_test_nfsd(current));
+	au_nwt_flush(&au_sbi(sb)->si_nowait);
+	si_noflush_write_lock(sb);
+}
+
+static inline int si_read_trylock(struct super_block *sb, int flags)
+{
+	if (/* !au_test_nfsd(current) &&  */au_ftest_lock(flags, FLUSH))
+		au_nwt_flush(&au_sbi(sb)->si_nowait);
+	return si_noflush_read_trylock(sb);
+}
+
+static inline int si_write_trylock(struct super_block *sb, int flags)
+{
+	if (/* !au_test_nfsd(current) &&  */au_ftest_lock(flags, FLUSH))
+		au_nwt_flush(&au_sbi(sb)->si_nowait);
+	return si_noflush_write_trylock(sb);
+}
+
+/* to debug easier, do not make them inlined functions */
+#define SiMustReadLock(sb)	AuRwMustReadLock(&au_sbi(sb)->si_rwsem)
+#define SiMustWriteLock(sb)	AuRwMustWriteLock(&au_sbi(sb)->si_rwsem)
+#define SiMustAnyLock(sb)	AuRwMustAnyLock(&au_sbi(sb)->si_rwsem)
+
+/* ---------------------------------------------------------------------- */
+
+static inline aufs_bindex_t au_sbend(struct super_block *sb)
+{
+	SiMustAnyLock(sb);
+	return au_sbi(sb)->si_bend;
+}
+
+static inline unsigned int au_mntflags(struct super_block *sb)
+{
+	SiMustAnyLock(sb);
+	return au_sbi(sb)->si_mntflags;
+}
+
+static inline au_gen_t au_sigen(struct super_block *sb)
+{
+	SiMustAnyLock(sb);
+	return au_sbi(sb)->si_generation;
+}
+
+#endif /* __KERNEL__ */
+#endif /* __AUFS_SUPER_H__ */
diff -Nurp linux-2.6.27.orig/fs/aufs/sysaufs.c linux-2.6.27/fs/aufs/sysaufs.c
--- linux-2.6.27.orig/fs/aufs/sysaufs.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.27/fs/aufs/sysaufs.c	2008-09-15 05:14:55.000000000 +0200
@@ -0,0 +1,109 @@
+/*
+ * Copyright (C) 2005-2008 Junjiro Okajima
+ *
+ * This program, aufs is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+ */
+
+/*
+ * sysfs interface and lifetime management
+ * they are necessary regardless sysfs is disabled.
+ *
+ * $Id: sysaufs.c,v 1.10 2008/09/15 03:14:55 sfjro Exp $
+ */
+
+#include <linux/fs.h>
+#include <linux/module.h>
+#include <linux/random.h>
+#include <linux/sysfs.h>
+#include "aufs.h"
+
+/* ---------------------------------------------------------------------- */
+
+unsigned long au_si_mask;
+
+/* ---------------------------------------------------------------------- */
+
+struct kset *au_kset;
+
+#define AuSbiAttr(_name) { \
+	.attr   = { .name = __stringify(_name), .mode = 0444 },	\
+	.show   = sysaufs_sbi_##_name,				\
+}
+
+static struct au_sbi_attr au_sbi_attr_xino = AuSbiAttr(xino);
+#ifdef CONFIG_AUFS_EXPORT
+static struct au_sbi_attr au_sbi_attr_xigen = AuSbiAttr(xigen);
+#endif
+struct attribute *au_sbi_attrs[] = {
+	&au_sbi_attr_xino.attr,
+#ifdef CONFIG_AUFS_EXPORT
+	&au_sbi_attr_xigen.attr,
+#endif
+	NULL,
+};
+
+static struct sysfs_ops au_sbi_ops = {
+	.show   = sysaufs_sbi_show
+};
+
+static struct kobj_type au_sbi_ktype = {
+	.release	= au_si_free,
+	.sysfs_ops	= &au_sbi_ops,
+	.default_attrs	= au_sbi_attrs
+};
+
+/* ---------------------------------------------------------------------- */
+
+int sysaufs_si_init(struct au_sbinfo *sbinfo)
+{
+	int err;
+
+	sbinfo->si_kobj.kset = au_kset;
+	/* some people doesn't like to show a pointer in kernel */
+	err = kobject_init_and_add(&sbinfo->si_kobj, &au_sbi_ktype,
+				   NULL/*&au_kset->kobj*/,
+				   SysaufsSb_PREFIX "%lx",
+				   au_si_mask ^ (unsigned long)sbinfo);
+	AuTraceErr(err);
+	return err;
+}
+
+
+/* ---------------------------------------------------------------------- */
+
+void sysaufs_fin(void)
+{
+	sysfs_remove_group(&au_kset->kobj, au_attr_group);
+	kset_unregister(au_kset);
+}
+
+int __init sysaufs_init(void)
+{
+	int err;
+
+	get_random_bytes(&au_si_mask, sizeof(au_si_mask));
+
+	au_kset = kset_create_and_add(AUFS_NAME, NULL, fs_kobj);
+	err = PTR_ERR(au_kset);
+	if (IS_ERR(au_kset))
+		goto out;
+	err = sysfs_create_group(&au_kset->kobj, au_attr_group);
+	if (unlikely(err))
+		kset_unregister(au_kset);
+
+ out:
+	AuTraceErr(err);
+	return err;
+}
diff -Nurp linux-2.6.27.orig/fs/aufs/sysaufs.h linux-2.6.27/fs/aufs/sysaufs.h
--- linux-2.6.27.orig/fs/aufs/sysaufs.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.27/fs/aufs/sysaufs.h	2008-09-15 05:14:55.000000000 +0200
@@ -0,0 +1,119 @@
+/*
+ * Copyright (C) 2005-2008 Junjiro Okajima
+ *
+ * This program, aufs is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+ */
+
+/*
+ * sysfs interface and lifetime management
+ *
+ * $Id: sysaufs.h,v 1.11 2008/09/15 03:14:55 sfjro Exp $
+ */
+
+#ifndef __SYSAUFS_H__
+#define __SYSAUFS_H__
+
+#ifdef __KERNEL__
+
+#include <linux/fs.h>
+#include <linux/sysfs.h>
+#include "module.h"
+#include "super.h"
+
+#define SysaufsSb_PREFIX	"si_"	/* followed by %p */
+
+struct au_sbi_attr {
+	struct attribute attr;
+	int (*show)(struct seq_file *seq, struct super_block *sb);
+};
+
+/* ---------------------------------------------------------------------- */
+
+/* sysaufs.c */
+extern unsigned long au_si_mask;
+extern struct kset *au_kset;
+extern struct attribute *au_sbi_attrs[];
+int sysaufs_si_init(struct au_sbinfo *sbinfo);
+int __init sysaufs_init(void);
+void sysaufs_fin(void);
+
+/* ---------------------------------------------------------------------- */
+
+struct au_branch;
+#ifdef CONFIG_SYSFS
+/* sysfs.c */
+extern struct attribute_group *au_attr_group;
+extern struct kobj_type *au_ktype;
+
+int sysaufs_sbi_xino(struct seq_file *seq, struct super_block *sb);
+#ifdef CONFIG_AUFS_EXPORT
+int sysaufs_sbi_xigen(struct seq_file *seq, struct super_block *sb);
+#endif
+int sysaufs_sbi_mntpnt1(struct seq_file *seq, struct super_block *sb);
+ssize_t sysaufs_sbi_show(struct kobject *kobj, struct attribute *attr,
+			 char *buf);
+
+void sysaufs_br_init(struct au_branch *br);
+void sysaufs_brs_add(struct super_block *sb, aufs_bindex_t bindex);
+void sysaufs_brs_del(struct super_block *sb, aufs_bindex_t bindex);
+#else
+#define au_attr_group	NULL
+#define au_ktype	NULL
+
+static inline
+int sysaufs_sbi_xino(struct seq_file *seq, struct super_block *sb)
+{
+	return 0;
+}
+
+#ifdef CONFIG_AUFS_EXPORT
+static inline
+int sysaufs_sbi_xigen(struct seq_file *seq, struct super_block *sb)
+{
+	return 0;
+}
+#endif
+
+static inline
+int sysaufs_sbi_mntpnt1(struct seq_file *seq, struct super_block *sb)
+{
+	return 0;
+}
+
+static inline
+ssize_t sysaufs_sbi_show(struct kobject *kobj, struct attribute *attr,
+			 char *buf)
+{
+	return 0;
+}
+
+static inline void sysaufs_br_init(struct au_branch *br)
+{
+	/* empty */
+}
+
+static inline void sysaufs_brs_add(struct super_block *sb, aufs_bindex_t bindex)
+{
+	/* nothing */
+}
+
+static inline void sysaufs_brs_del(struct super_block *sb, aufs_bindex_t bindex)
+{
+	/* nothing */
+}
+#endif /* CONFIG_SYSFS */
+
+#endif /* __KERNEL__ */
+#endif /* __SYSAUFS_H__ */
diff -Nurp linux-2.6.27.orig/fs/aufs/sysfs.c linux-2.6.27/fs/aufs/sysfs.c
--- linux-2.6.27.orig/fs/aufs/sysfs.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.27/fs/aufs/sysfs.c	2008-12-14 10:37:40.000000000 +0100
@@ -0,0 +1,533 @@
+/*
+ * Copyright (C) 2005-2008 Junjiro Okajima
+ *
+ * This program, aufs is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+ */
+
+/*
+ * sysfs interface
+ *
+ * $Id: sysfs.c,v 1.18 2008/12/01 03:49:29 sfjro Exp $
+ */
+
+#include <linux/fs.h>
+#include <linux/module.h>
+#include <linux/seq_file.h>
+#include <linux/sysfs.h>
+#include "aufs.h"
+
+
+#ifdef CONFIG_AUFS_LOCAL
+static ssize_t config_show(struct kobject *kobj, struct kobj_attribute *attr,
+			   char *buf)
+{
+#define conf_bool(name)	"CONFIG_AUFS_" #name "=y\n"
+	static const char opt[] =
+#ifdef CONFIG_AUFS
+		"CONFIG_AUFS=y\n"
+#else
+		"CONFIG_AUFS=m\n"
+#endif
+#ifdef CONFIG_AUFS_BRANCH_MAX_127
+		conf_bool(BRANCH_MAX_127)
+#elif defined(CONFIG_AUFS_BRANCH_MAX_511)
+		conf_bool(BRANCH_MAX_511)
+#elif defined(CONFIG_AUFS_BRANCH_MAX_1023)
+		conf_bool(BRANCH_MAX_1023)
+#elif defined(CONFIG_AUFS_BRANCH_MAX_32767)
+		conf_bool(BRANCH_MAX_32767)
+#endif
+#ifdef CONFIG_AUFS_STAT
+		conf_bool(STAT)
+#endif
+#ifdef CONFIG_AUFS_HINOTIFY
+		conf_bool(HINOTIFY)
+#endif
+#ifdef CONFIG_AUFS_EXPORT
+		conf_bool(EXPORT)
+#endif
+#ifdef CONFIG_AUFS_INO_T_64
+		conf_bool(INO_T_64)
+#endif
+#ifdef CONFIG_AUFS_ROBR
+		conf_bool(ROBR)
+#endif
+#ifdef CONFIG_AUFS_DLGT
+		conf_bool(DLGT)
+#endif
+#ifdef CONFIG_AUFS_HIN_OR_DLGT
+		conf_bool(HIN_OR_DLGT)
+#endif
+#ifdef CONFIG_AUFS_SHWH
+		conf_bool(SHWH)
+#endif
+#ifdef CONFIG_AUFS_RR_SQUASHFS
+		conf_bool(RR_SQUASHFS)
+#endif
+#ifdef CONFIG_AUFS_SEC_PERM_PATCH
+		conf_bool(SEC_PERM_PATCH)
+#endif
+#ifdef CONFIG_AUFS_SPLICE_PATCH
+		conf_bool(SPLICE_PATCH)
+#endif
+#ifdef CONFIG_AUFS_LHASH_PATCH
+		conf_bool(LHASH_PATCH)
+#endif
+#ifdef CONFIG_AUFS_PUT_FILP_PATCH
+		conf_bool(PUT_FILP_PATCH)
+#endif
+#ifdef CONFIG_AUFS_BR_NFS
+		conf_bool(BR_NFS)
+#endif
+#ifdef CONFIG_AUFS_BR_NFS_V4
+		conf_bool(BR_NFS_V4)
+#endif
+#ifdef CONFIG_AUFS_BR_XFS
+		conf_bool(BR_XFS)
+#endif
+#ifdef CONFIG_AUFS_FSYNC_SUPER_PATCH
+		conf_bool(FSYNC_SUPER_PATCH)
+#endif
+#ifdef CONFIG_AUFS_DENY_WRITE_ACCESS_PATCH
+		conf_bool(DENY_WRITE_ACCESS_PATCH)
+#endif
+#ifdef CONFIG_AUFS_KSIZE_PATCH
+		conf_bool(KSIZE_PATCH)
+#endif
+#ifdef CONFIG_AUFS_WORKAROUND_FUSE
+		conf_bool(WORKAROUND_FUSE)
+#endif
+#ifdef CONFIG_AUFS_GETATTR
+		conf_bool(GETATTR)
+#endif
+#ifdef CONFIG_AUFS_DEBUG
+		conf_bool(DEBUG)
+#endif
+#ifdef CONFIG_AUFS_MAGIC_SYSRQ
+		conf_bool(MAGIC_SYSRQ)
+#endif
+#ifdef CONFIG_AUFS_DEBUG_LOCK
+		conf_bool(DEBUG_LOCK)
+#endif
+#ifdef CONFIG_AUFS_COMPAT
+		conf_bool(COMPAT)
+#endif
+#ifdef CONFIG_AUFS_UNIONFS22_PATCH
+		conf_bool(UNIONFS22_PATCH)
+#endif
+#ifdef CONFIG_AUFS_UNIONFS23_PATCH
+		conf_bool(UNIONFS23_PATCH)
+#endif
+		;
+#undef conf_bool
+
+	char *p = buf;
+	const char *end = buf + PAGE_SIZE;
+
+	p += snprintf(p, end - p, "%s", opt);
+#ifdef DbgUdbaRace
+	if (p < end)
+		p += snprintf(p, end - p, "DbgUdbaRace=%d\n", DbgUdbaRace);
+#endif
+	if (p < end)
+		return p - buf;
+	else
+		return -EFBIG;
+}
+
+static struct kobj_attribute au_config_attr = __ATTR_RO(config);
+#endif
+
+#ifdef CONFIG_AUFS_STAT
+static ssize_t stat_show(struct kobject *kobj, struct kobj_attribute *attr,
+			 char *buf)
+{
+	char *p = buf;
+	const char *end = buf + PAGE_SIZE;
+	int i;
+
+	p += snprintf(p, end - p, "wkq max_busy:");
+	for (i = 0; p < end && i < aufs_nwkq; i++)
+		p += snprintf(p, end - p, " %u", au_wkq[i].max_busy);
+	if (p < end)
+		p += snprintf(p, end - p, ", %u(generic)\n",
+			      au_wkq[aufs_nwkq].max_busy);
+
+	if (p < end)
+		return p - buf;
+	else
+		return -EFBIG;
+}
+
+static struct kobj_attribute au_stat_attr = __ATTR_RO(stat);
+#endif
+
+#ifdef CONFIG_AUFS_DEBUG
+static ssize_t debug_show(struct kobject *kobj, struct kobj_attribute *attr,
+			  char *buf)
+{
+	return sprintf(buf, "%d\n", au_debug_test());
+}
+
+static ssize_t debug_store(struct kobject *kobj, struct kobj_attribute *attr,
+			   const char *buf, size_t sz)
+{
+	LKTRTrace("%.*s\n", (unsigned int)sz, buf);
+
+	if (unlikely(!sz || (*buf != '0' && *buf != '1')))
+		return -EOPNOTSUPP;
+
+	if (*buf == '0')
+		au_debug_off();
+	else if (*buf == '1')
+		au_debug_on();
+	return sz;
+}
+
+static struct kobj_attribute au_debug_attr = __ATTR(debug, S_IRUGO | S_IWUSR,
+						    debug_show, debug_store);
+#endif
+
+static struct attribute *au_attr[] = {
+#ifdef CONFIG_AUFS_LOCAL
+	&au_config_attr.attr,
+#endif
+#ifdef CONFIG_AUFS_STAT
+	&au_stat_attr.attr,
+#endif
+#ifdef CONFIG_AUFS_DEBUG
+	&au_debug_attr.attr,
+#endif
+	NULL,	/* need to NULL terminate the list of attributes */
+};
+
+static struct attribute_group au_attr_group_body = {
+	.attrs = au_attr
+};
+
+struct attribute_group *au_attr_group = &au_attr_group_body;
+
+/* ---------------------------------------------------------------------- */
+
+/*
+ * they are copied from linux/lib/kobject.c,
+ * and will be exported in the future.
+ */
+static ssize_t au_attr_show(struct kobject *kobj, struct attribute *attr,
+			    char *buf)
+{
+	struct kobj_attribute *kattr;
+	ssize_t ret = -EIO;
+
+	kattr = container_of(attr, struct kobj_attribute, attr);
+	if (kattr->show)
+		ret = kattr->show(kobj, kattr, buf);
+	return ret;
+}
+
+#ifdef CONFIG_AUFS_DEBUG
+static ssize_t au_attr_store(struct kobject *kobj, struct attribute *attr,
+			     const char *buf, size_t count)
+{
+	struct kobj_attribute *kattr;
+	ssize_t ret = -EIO;
+
+	kattr = container_of(attr, struct kobj_attribute, attr);
+	if (kattr->store)
+		ret = kattr->store(kobj, kattr, buf, count);
+	return ret;
+}
+#endif
+
+static struct sysfs_ops sysaufs_ops = {
+	.show   = au_attr_show,
+#ifdef CONFIG_AUFS_DEBUG
+	.store  = au_attr_store
+#endif
+};
+
+static struct kobj_type au_ktype_body = {
+	.sysfs_ops = &sysaufs_ops
+};
+struct kobj_type *au_ktype = &au_ktype_body;
+
+/* ---------------------------------------------------------------------- */
+
+static noinline_for_stack
+int sysaufs_sbi_xi(struct seq_file *seq, struct file *xf, int dlgt,
+		   int print_path)
+{
+	int err;
+	struct kstat st;
+	struct path path;
+
+	err = vfsub_getattr(xf->f_vfsmnt, xf->f_dentry, &st, dlgt);
+	if (!err) {
+		seq_printf(seq, "%llux%lu %lld",
+			   st.blocks, st.blksize, (long long)st.size);
+		if (print_path) {
+			path.dentry = xf->f_dentry;
+			path.mnt = xf->f_vfsmnt;
+			seq_putc(seq, ' ');
+			seq_path(seq, &path, au_esc_chars);
+		}
+		seq_putc(seq, '\n');
+	} else
+		seq_printf(seq, "err %d\n", err);
+
+	AuTraceErr(err);
+	return err;
+}
+
+int sysaufs_sbi_xino(struct seq_file *seq, struct super_block *sb)
+{
+	int err;
+	unsigned int mnt_flags;
+	aufs_bindex_t bend, bindex;
+	unsigned char dlgt, xinodir;
+	struct kstat st;
+	struct path path;
+	struct au_sbinfo *sbinfo;
+	struct file *xf;
+
+	AuTraceEnter();
+
+	sbinfo = au_sbi(sb);
+	mnt_flags = au_mntflags(sb);
+	xinodir = !!au_opt_test(mnt_flags, XINODIR);
+	if (!au_opt_test_xino(mnt_flags)) {
+#ifdef CONFIG_AUFS_DEBUG
+		AuDebugOn(sbinfo->si_xib);
+		bend = au_sbend(sb);
+		for (bindex = 0; bindex <= bend; bindex++)
+			AuDebugOn(au_sbr(sb, bindex)->br_xino.xi_file);
+#endif
+		err = 0;
+		goto out; /* success */
+	}
+
+	dlgt = !!au_test_dlgt(mnt_flags);
+	err = sysaufs_sbi_xi(seq, sbinfo->si_xib, dlgt, xinodir);
+
+	bend = au_sbend(sb);
+	for (bindex = 0; !err && bindex <= bend; bindex++) {
+		xf = au_sbr(sb, bindex)->br_xino.xi_file;
+		if (!xf)
+			continue;
+		seq_printf(seq, "%d: ", bindex);
+		err = vfsub_getattr(xf->f_vfsmnt, xf->f_dentry, &st, dlgt);
+		if (!err) {
+			seq_printf(seq, "%ld, %llux%lu %lld",
+				   (long)file_count(xf), st.blocks, st.blksize,
+				   (long long)st.size);
+			if (xinodir) {
+				path.dentry = xf->f_dentry;
+				path.mnt = xf->f_vfsmnt;
+				seq_putc(seq, ' ');
+				seq_path(seq, &path, au_esc_chars);
+			}
+			seq_putc(seq, '\n');
+		} else
+			seq_printf(seq, "err %d\n", err);
+	}
+
+ out:
+	AuTraceErr(err);
+	return err;
+}
+
+#ifdef CONFIG_AUFS_EXPORT
+int sysaufs_sbi_xigen(struct seq_file *seq, struct super_block *sb)
+{
+	int err;
+	unsigned int mnt_flags;
+	struct au_sbinfo *sbinfo;
+
+	AuTraceEnter();
+
+	err = 0;
+	sbinfo = au_sbi(sb);
+	mnt_flags = au_mntflags(sb);
+	if (au_opt_test_xino(mnt_flags))
+		err = sysaufs_sbi_xi(seq, sbinfo->si_xigen,
+				     !!au_opt_test(mnt_flags, DLGT),
+				     !!au_opt_test(mnt_flags, XINODIR));
+
+	AuTraceErr(err);
+	return err;
+}
+#endif
+
+/*
+ * the lifetime of branch is independent from the entry under sysfs.
+ * sysfs handles the lifetime of the entry, and never call ->show() after it is
+ * unlinked.
+ */
+#define SysaufsBr_PREFIX "br"
+static int sysaufs_sbi_br(struct seq_file *seq, struct super_block *sb,
+			  aufs_bindex_t bindex)
+{
+	int err;
+	struct dentry *root;
+	struct au_branch *br;
+	struct path path;
+
+	LKTRTrace("b%d\n", bindex);
+
+	err = -ENOENT;
+	if (unlikely(au_sbend(sb) < bindex))
+		goto out;
+
+	err = 0;
+	root = sb->s_root;
+	di_read_lock_parent(root, !AuLock_IR);
+	br = au_sbr(sb, bindex);
+	path.mnt = br->br_mnt;
+	path.dentry = au_h_dptr(root, bindex);
+	seq_path(seq, &path, au_esc_chars);
+	di_read_unlock(root, !AuLock_IR);
+	seq_printf(seq, "=%s\n", au_optstr_br_perm(br->br_perm));
+
+ out:
+	AuTraceErr(err);
+	return err;
+}
+
+/* ---------------------------------------------------------------------- */
+
+static struct seq_file *au_seq(char *p, ssize_t len)
+{
+	struct seq_file *seq;
+
+	seq = kzalloc(sizeof(*seq), GFP_NOFS);
+	if (seq) {
+		/* todo: necessary? */
+		/* mutex_init(&seq.lock); */
+		seq->buf = p;
+		seq->size = len;
+		return seq; /* success */
+	}
+
+	seq = ERR_PTR(-ENOMEM);
+	AuTraceErrPtr(seq);
+	return seq;
+}
+
+/* todo: file size may exceed PAGE_SIZE */
+ssize_t sysaufs_sbi_show(struct kobject *kobj, struct attribute *attr,
+			 char *buf)
+{
+	ssize_t err;
+	long l;
+	struct au_sbinfo *sbinfo;
+	struct super_block *sb;
+	struct seq_file *seq;
+	char *name;
+	struct attribute **cattr;
+
+	LKTRTrace("%s/%s\n", kobject_name(kobj), attr->name);
+
+	sbinfo = container_of(kobj, struct au_sbinfo, si_kobj);
+	sb = sbinfo->si_sb;
+	si_noflush_read_lock(sb);
+
+	seq = au_seq(buf, PAGE_SIZE);
+	err = PTR_ERR(seq);
+	if (IS_ERR(seq))
+		goto out;
+
+	name = (void *)attr->name;
+	cattr = au_sbi_attrs;
+	while (*cattr) {
+		if (!strcmp(name, (*cattr)->name)) {
+			err = container_of(*cattr, struct au_sbi_attr, attr)
+				->show(seq, sb);
+			goto out_seq;
+		}
+		cattr++;
+	}
+
+	if (!strncmp(name, SysaufsBr_PREFIX, sizeof(SysaufsBr_PREFIX) - 1)) {
+		name += sizeof(SysaufsBr_PREFIX) - 1;
+		err = strict_strtol(name, 10, &l);
+		if (!err)
+			err = sysaufs_sbi_br(seq, sb, (aufs_bindex_t)l);
+		goto out_seq;
+	}
+	BUG();
+
+ out_seq:
+	if (!err) {
+		err = seq->count;
+		/* sysfs limit */
+		if (unlikely(err == PAGE_SIZE))
+			err = -EFBIG;
+	}
+	kfree(seq);
+ out:
+	si_read_unlock(sb);
+	AuTraceErr(err);
+	return err;
+}
+
+/* ---------------------------------------------------------------------- */
+
+void sysaufs_br_init(struct au_branch *br)
+{
+	br->br_attr.name = br->br_name;
+	br->br_attr.mode = S_IRUGO;
+	br->br_attr.owner = THIS_MODULE;
+}
+
+void sysaufs_brs_del(struct super_block *sb, aufs_bindex_t bindex)
+{
+	struct au_sbinfo *sbinfo;
+	aufs_bindex_t bend;
+
+	LKTRTrace("b%d\n", bindex);
+
+	if (!sysaufs_brs)
+		return;
+
+	sbinfo = au_sbi(sb);
+	bend = au_sbend(sb);
+	for (; bindex <= bend; bindex++)
+		sysfs_remove_file(&sbinfo->si_kobj,
+				  &au_sbr(sb, bindex)->br_attr);
+}
+
+void sysaufs_brs_add(struct super_block *sb, aufs_bindex_t bindex)
+{
+	int err;
+	struct kobject *kobj;
+	aufs_bindex_t bend;
+	struct au_branch *br;
+
+	LKTRTrace("b%d\n", bindex);
+
+	if (!sysaufs_brs)
+		return;
+
+	kobj = &au_sbi(sb)->si_kobj;
+	bend = au_sbend(sb);
+	for (; bindex <= bend; bindex++) {
+		br = au_sbr(sb, bindex);
+		snprintf(br->br_name, sizeof(br->br_name),
+			 SysaufsBr_PREFIX "%d", bindex);
+		err = sysfs_create_file(kobj, &br->br_attr);
+		if (unlikely(err))
+			AuWarn("failed %s under sysfs(%d)\n", br->br_name, err);
+	}
+}
diff -Nurp linux-2.6.27.orig/fs/aufs/sysrq.c linux-2.6.27/fs/aufs/sysrq.c
--- linux-2.6.27.orig/fs/aufs/sysrq.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.27/fs/aufs/sysrq.c	2008-12-14 10:37:40.000000000 +0100
@@ -0,0 +1,280 @@
+/*
+ * Copyright (C) 2005-2008 Junjiro Okajima
+ *
+ * This program, aufs is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+ */
+
+/*
+ * magic sysrq hanlder
+ *
+ * $Id: sysrq.c,v 1.13 2008/12/08 06:12:26 sfjro Exp $
+ */
+
+#include <linux/fs.h>
+#include <linux/module.h>
+#include <linux/moduleparam.h>
+/* #include <linux/sysrq.h> */
+#include "aufs.h"
+
+#ifdef CONFIG_AUFS_DEBUG_LOCK
+struct au_dbg_lock {
+	struct list_head list;
+	union {
+		struct super_block	*sb;
+		struct dentry		*dentry;
+		struct inode		*inode;
+		void			*any;
+	};
+	int flags;
+	unsigned int lsc;
+	pid_t pid;
+};
+
+static void au_dbg_reg(struct au_splhead *spl, void *any, int flags,
+		       unsigned int lsc)
+{
+	struct au_dbg_lock *p = kmalloc(sizeof(*p), GFP_NOFS);
+
+	if (p) {
+		p->any = any;
+		p->flags = flags;
+		p->lsc = lsc;
+		p->pid = current->pid;
+		spin_lock(&spl->spin);
+		list_add(&p->list, &spl->head);
+		spin_unlock(&spl->spin);
+	}
+	WARN_ON(!p);
+}
+
+static void au_dbg_unreg(struct au_splhead *spl, void *any, int flags)
+{
+	struct au_dbg_lock *p, *tmp, *found;
+	struct list_head *head = &spl->head;
+	const pid_t pid = current->pid;
+
+	found = NULL;
+	spin_lock(&spl->spin);
+	list_for_each_entry_safe(p, tmp, head, list)
+		if (p->any == any && p->pid == pid) {
+			list_del(&p->list);
+			found = p;
+			break;
+		}
+	spin_unlock(&spl->spin);
+	kfree(found);
+	WARN_ON(!found);
+}
+
+/* ---------------------------------------------------------------------- */
+
+void au_dbg_locking_si_reg(struct super_block *sb, int flags)
+{
+	au_dbg_reg(au_sbi(sb)->si_dbg_lock + AuDbgLock_SI_LOCKING, sb, flags,
+		   -1);
+}
+
+void au_dbg_locking_si_unreg(struct super_block *sb, int flags)
+{
+	au_dbg_unreg(au_sbi(sb)->si_dbg_lock + AuDbgLock_SI_LOCKING, sb, flags);
+}
+
+void au_dbg_locked_si_reg(struct super_block *sb, int flags)
+{
+	au_dbg_reg(au_sbi(sb)->si_dbg_lock + AuDbgLock_SI_LOCKED, sb, flags,
+		   -1);
+}
+
+void au_dbg_locked_si_unreg(struct super_block *sb, int flags)
+{
+	au_dbg_unreg(au_sbi(sb)->si_dbg_lock + AuDbgLock_SI_LOCKED, sb, flags);
+}
+
+void au_dbg_locking_di_reg(struct dentry *d, int flags, unsigned int lsc)
+{
+	au_dbg_reg(au_sbi(d->d_sb)->si_dbg_lock + AuDbgLock_DI_LOCKING, d,
+		   flags, lsc);
+}
+
+void au_dbg_locking_di_unreg(struct dentry *d, int flags)
+{
+	au_dbg_unreg(au_sbi(d->d_sb)->si_dbg_lock + AuDbgLock_DI_LOCKING, d,
+		     flags);
+}
+
+void au_dbg_locked_di_reg(struct dentry *d, int flags, unsigned int lsc)
+{
+	au_dbg_reg(au_sbi(d->d_sb)->si_dbg_lock + AuDbgLock_DI_LOCKED, d, flags,
+		   lsc);
+}
+
+void au_dbg_locked_di_unreg(struct dentry *d, int flags)
+{
+	au_dbg_unreg(au_sbi(d->d_sb)->si_dbg_lock + AuDbgLock_DI_LOCKED, d,
+		     flags);
+}
+
+void au_dbg_locking_ii_reg(struct inode *i, int flags, unsigned int lsc)
+{
+	au_dbg_reg(au_sbi(i->i_sb)->si_dbg_lock + AuDbgLock_II_LOCKING, i,
+		   flags, lsc);
+}
+
+void au_dbg_locking_ii_unreg(struct inode *i, int flags)
+{
+	au_dbg_unreg(au_sbi(i->i_sb)->si_dbg_lock + AuDbgLock_II_LOCKING, i,
+		     flags);
+}
+
+void au_dbg_locked_ii_reg(struct inode *i, int flags, unsigned int lsc)
+{
+	au_dbg_reg(au_sbi(i->i_sb)->si_dbg_lock + AuDbgLock_II_LOCKED, i, flags,
+		   lsc);
+}
+
+void au_dbg_locked_ii_unreg(struct inode *i, int flags)
+{
+	au_dbg_unreg(au_sbi(i->i_sb)->si_dbg_lock + AuDbgLock_II_LOCKED, i,
+		     flags);
+}
+#endif /* CONFIG_AUFS_DEBUG_LOCK */
+
+/* ---------------------------------------------------------------------- */
+
+static void sysrq_sb(struct super_block *sb)
+{
+	char *plevel;
+	struct inode *i;
+	struct au_sbinfo *sbinfo;
+	struct file *file;
+
+	plevel = au_plevel;
+	au_plevel = KERN_WARNING;
+	au_debug_on();
+
+	sbinfo = au_sbi(sb);
+	pr_warning("si=%lx\n", au_si_mask ^ (unsigned long)sbinfo);
+	pr_warning(AUFS_NAME ": superblock\n");
+	au_dpri_sb(sb);
+	pr_warning(AUFS_NAME ": root dentry\n");
+	au_dpri_dentry(sb->s_root);
+	pr_warning(AUFS_NAME ": root inode\n");
+	au_dpri_inode(sb->s_root->d_inode);
+	pr_warning(AUFS_NAME ": isolated inode\n");
+	list_for_each_entry(i, &sb->s_inodes, i_sb_list)
+		if (list_empty(&i->i_dentry))
+			au_dpri_inode(i);
+	pr_warning(AUFS_NAME ": files\n");
+	list_for_each_entry(file, &sb->s_files, f_u.fu_list)
+		if (au_test_aufs_file(file))
+			au_dpri_file(file);
+
+#ifdef CONFIG_AUFS_DEBUG_LOCK
+	{
+		struct au_dbg_lock *p;
+		struct list_head *head;
+
+		pr_warning(AUFS_NAME ": locking si\n");
+		head = &sbinfo->si_dbg_lock[AuDbgLock_SI_LOCKING].head;
+		list_for_each_entry(p, head, list)
+			pr_warning("pid: %d, 0x%x\n", p->pid, p->flags);
+		pr_warning(AUFS_NAME ": locked si\n");
+		head = &sbinfo->si_dbg_lock[AuDbgLock_SI_LOCKED].head;
+		list_for_each_entry(p, head, list)
+			pr_warning("pid: %d, 0x%x\n", p->pid, p->flags);
+		pr_warning(AUFS_NAME ": locking di\n");
+		head = &sbinfo->si_dbg_lock[AuDbgLock_DI_LOCKING].head;
+		list_for_each_entry(p, head, list) {
+			pr_warning("pid: %d, 0x%x, %d\n",
+				   p->pid, p->flags, p->lsc);
+			au_dpri_dentry(p->dentry);
+		}
+		pr_warning(AUFS_NAME ": locked di\n");
+		head = &sbinfo->si_dbg_lock[AuDbgLock_DI_LOCKED].head;
+		list_for_each_entry(p, head, list) {
+			pr_warning("pid: %d, 0x%x, %d\n",
+				   p->pid, p->flags, p->lsc);
+			au_dpri_dentry(p->dentry);
+		}
+		pr_warning(AUFS_NAME ": locking ii\n");
+		head = &sbinfo->si_dbg_lock[AuDbgLock_II_LOCKING].head;
+		list_for_each_entry(p, head, list) {
+			pr_warning("pid: %d, %d\n", p->pid, p->lsc);
+			au_dpri_inode(p->inode);
+		}
+		pr_warning(AUFS_NAME ": locked ii\n");
+		head = &sbinfo->si_dbg_lock[AuDbgLock_II_LOCKED].head;
+		list_for_each_entry(p, head, list) {
+			pr_warning("pid: %d, %d\n", p->pid, p->lsc);
+			au_dpri_inode(p->inode);
+		}
+	}
+#endif
+
+	au_plevel = plevel;
+	au_debug_off();
+}
+
+/* ---------------------------------------------------------------------- */
+
+/* module parameter */
+static char *aufs_sysrq_key = "a";
+module_param_named(sysrq, aufs_sysrq_key, charp, S_IRUGO);
+MODULE_PARM_DESC(sysrq, "MagicSysRq key for " AUFS_NAME);
+
+static void au_sysrq(int key, struct tty_struct *tty)
+{
+	struct kobject *kobj;
+	struct au_sbinfo *sbinfo;
+
+	/* spin_lock(&au_kset->list_lock); */
+	list_for_each_entry(kobj, &au_kset->list, entry) {
+		sbinfo = container_of(kobj, struct au_sbinfo, si_kobj);
+		sysrq_sb(sbinfo->si_sb);
+	}
+	/* spin_unlock(&au_kset->list_lock); */
+}
+
+static struct sysrq_key_op au_sysrq_op = {
+	.handler	= au_sysrq,
+	.help_msg	= "Aufs",
+	.action_msg	= "Aufs",
+	/* todo: test mask? */
+	.enable_mask	= SYSRQ_ENABLE_DUMP
+};
+
+/* ---------------------------------------------------------------------- */
+
+int __init au_sysrq_init(void)
+{
+	int err;
+	char key;
+
+	err = -1;
+	key = *aufs_sysrq_key;
+	if ('a' <= key && key <= 'z')
+		err = register_sysrq_key(key, &au_sysrq_op);
+	if (unlikely(err))
+		AuErr("err %d, sysrq=%c\n", err, key);
+	return err;
+}
+
+void au_sysrq_fin(void)
+{
+	int err;
+	err = unregister_sysrq_key(*aufs_sysrq_key, &au_sysrq_op);
+	if (unlikely(err))
+		AuErr("err %d (ignored)\n", err);
+}
diff -Nurp linux-2.6.27.orig/fs/aufs/.tmp_versions/aufs.mod linux-2.6.27/fs/aufs/.tmp_versions/aufs.mod
--- linux-2.6.27.orig/fs/aufs/.tmp_versions/aufs.mod	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.27/fs/aufs/.tmp_versions/aufs.mod	2008-12-14 11:06:46.000000000 +0100
@@ -0,0 +1,2 @@
+/usr/src/aufs.wcvs/aufs/fs/aufs25/aufs.ko
+/usr/src/aufs.wcvs/aufs/fs/aufs25/module.o /usr/src/aufs.wcvs/aufs/fs/aufs25/super.o /usr/src/aufs.wcvs/aufs/fs/aufs25/sbinfo.o /usr/src/aufs.wcvs/aufs/fs/aufs25/branch.o /usr/src/aufs.wcvs/aufs/fs/aufs25/xino.o /usr/src/aufs.wcvs/aufs/fs/aufs25/sysaufs.o /usr/src/aufs.wcvs/aufs/fs/aufs25/opts.o /usr/src/aufs.wcvs/aufs/fs/aufs25/wkq.o /usr/src/aufs.wcvs/aufs/fs/aufs25/vfsub.o /usr/src/aufs.wcvs/aufs/fs/aufs25/dcsub.o /usr/src/aufs.wcvs/aufs/fs/aufs25/cpup.o /usr/src/aufs.wcvs/aufs/fs/aufs25/whout.o /usr/src/aufs.wcvs/aufs/fs/aufs25/plink.o /usr/src/aufs.wcvs/aufs/fs/aufs25/wbr_policy.o /usr/src/aufs.wcvs/aufs/fs/aufs25/dentry.o /usr/src/aufs.wcvs/aufs/fs/aufs25/dinfo.o /usr/src/aufs.wcvs/aufs/fs/aufs25/file.o /usr/src/aufs.wcvs/aufs/fs/aufs25/f_op.o /usr/src/aufs.wcvs/aufs/fs/aufs25/finfo.o /usr/src/aufs.wcvs/aufs/fs/aufs25/dir.o /usr/src/aufs.wcvs/aufs/fs/aufs25/vdir.o /usr/src/aufs.wcvs/aufs/fs/aufs25/inode.o /usr/src/aufs.wcvs/aufs/fs/aufs25/i_op.o /usr/src/aufs.wcvs/aufs/fs/aufs25/i_op_add.o /usr/src/aufs.wcvs/aufs/fs/aufs25/i_op_del.o /usr/src/aufs.wcvs/aufs/fs/aufs25/i_op_ren.o /usr/src/aufs.wcvs/aufs/fs/aufs25/iinfo.o /usr/src/aufs.wcvs/aufs/fs/aufs25/misc.o /usr/src/aufs.wcvs/aufs/fs/aufs25/sysfs.o /usr/src/aufs.wcvs/aufs/fs/aufs25/br_xfs.o /usr/src/aufs.wcvs/aufs/fs/aufs25/debug.o /usr/src/aufs.wcvs/aufs/fs/aufs25/sysrq.o
diff -Nurp linux-2.6.27.orig/fs/aufs/vdir.c linux-2.6.27/fs/aufs/vdir.c
--- linux-2.6.27.orig/fs/aufs/vdir.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.27/fs/aufs/vdir.c	2008-12-14 10:37:40.000000000 +0100
@@ -0,0 +1,941 @@
+/*
+ * Copyright (C) 2005-2008 Junjiro Okajima
+ *
+ * This program, aufs is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+ */
+
+/*
+ * virtual or vertical directory
+ *
+ * $Id: vdir.c,v 1.13 2008/12/01 03:49:29 sfjro Exp $
+ */
+
+#include "aufs.h"
+
+static int calc_size(int namelen)
+{
+	int sz;
+
+	sz = sizeof(struct au_vdir_de) + namelen;
+	if (sizeof(ino_t) == sizeof(long)) {
+		const int mask = sizeof(ino_t) - 1;
+		if (sz & mask) {
+			sz += sizeof(ino_t);
+			sz &= ~mask;
+		}
+	}
+
+	AuDebugOn(sz % sizeof(ino_t));
+	return sz;
+}
+
+static int set_deblk_end(union au_vdir_deblk_p *p,
+			 union au_vdir_deblk_p *deblk_end)
+{
+	if (calc_size(0) <= deblk_end->p - p->p) {
+		p->de->de_str.len = 0;
+		/* smp_mb(); */
+		return 0;
+	}
+	return -1; /* error */
+}
+
+/* returns true or false */
+static int is_deblk_end(union au_vdir_deblk_p *p,
+			union au_vdir_deblk_p *deblk_end)
+{
+	if (calc_size(0) <= deblk_end->p - p->p)
+		return !p->de->de_str.len;
+	return 1;
+}
+
+static au_vdir_deblk_t *last_deblk(struct au_vdir *vdir)
+{
+	return vdir->vd_deblk[vdir->vd_nblk - 1];
+}
+
+void au_nhash_init(struct au_nhash *nhash)
+{
+	int i;
+	for (i = 0; i < AuSize_NHASH; i++)
+		INIT_HLIST_HEAD(nhash->heads + i);
+}
+
+struct au_nhash *au_nhash_new(gfp_t gfp)
+{
+	struct au_nhash *nhash;
+
+	nhash = kmalloc(sizeof(*nhash), gfp);
+	if (nhash) {
+		au_nhash_init(nhash);
+		return nhash;
+	}
+	return ERR_PTR(-ENOMEM);
+}
+
+void au_nhash_del(struct au_nhash *nhash)
+{
+	au_nhash_fin(nhash);
+	kfree(nhash);
+}
+
+void au_nhash_move(struct au_nhash *dst, struct au_nhash *src)
+{
+	int i;
+
+	AuTraceEnter();
+
+	*dst = *src;
+	for (i = 0; i < AuSize_NHASH; i++) {
+		struct hlist_head *h;
+		h = dst->heads + i;
+		if (h->first)
+			h->first->pprev = &h->first;
+		INIT_HLIST_HEAD(src->heads + i);
+	}
+	/* smp_mb(); */
+}
+
+/* ---------------------------------------------------------------------- */
+
+void au_nhash_fin(struct au_nhash *whlist)
+{
+	int i;
+	struct hlist_head *head;
+	struct au_vdir_wh *tpos;
+	struct hlist_node *pos, *n;
+
+	AuTraceEnter();
+
+	for (i = 0; i < AuSize_NHASH; i++) {
+		head = whlist->heads + i;
+		hlist_for_each_entry_safe(tpos, pos, n, head, wh_hash) {
+			/* hlist_del(pos); */
+			kfree(tpos);
+		}
+	}
+}
+
+int au_nhash_test_longer_wh(struct au_nhash *whlist, aufs_bindex_t btgt,
+			    int limit)
+{
+	int n, i;
+	struct hlist_head *head;
+	struct au_vdir_wh *tpos;
+	struct hlist_node *pos;
+
+	LKTRTrace("limit %d\n", limit);
+
+	n = 0;
+	for (i = 0; i < AuSize_NHASH; i++) {
+		head = whlist->heads + i;
+		hlist_for_each_entry(tpos, pos, head, wh_hash)
+			if (tpos->wh_bindex == btgt && ++n > limit)
+				return 1;
+	}
+	return 0;
+}
+
+static unsigned int au_name_hash(const unsigned char *name, unsigned int len)
+{
+	return full_name_hash(name, len) % AuSize_NHASH;
+}
+
+/* returns found(true) or not */
+int au_nhash_test_known_wh(struct au_nhash *whlist, char *name, int namelen)
+{
+	struct hlist_head *head;
+	struct au_vdir_wh *tpos;
+	struct hlist_node *pos;
+	struct au_vdir_destr *str;
+
+	LKTRTrace("%.*s\n", namelen, name);
+
+	head = whlist->heads + au_name_hash(name, namelen);
+	hlist_for_each_entry(tpos, pos, head, wh_hash) {
+		str = &tpos->wh_str;
+		LKTRTrace("%.*s\n", str->len, str->name);
+		if (str->len == namelen && !memcmp(str->name, name, namelen))
+			return 1;
+	}
+	return 0;
+}
+
+int au_nhash_append_wh(struct au_nhash *whlist, char *name, int namelen,
+		       ino_t ino, unsigned int d_type, aufs_bindex_t bindex,
+		       unsigned char shwh)
+{
+	int err;
+	struct au_vdir_destr *str;
+	struct au_vdir_wh *wh;
+
+	LKTRTrace("%.*s\n", namelen, name);
+
+	err = -ENOMEM;
+	wh = kmalloc(sizeof(*wh) + namelen, GFP_NOFS);
+	if (unlikely(!wh))
+		goto out;
+	err = 0;
+	wh->wh_bindex = bindex;
+	if (shwh)
+		au_shwh_init_wh(wh, ino, d_type);
+	str = &wh->wh_str;
+	str->len = namelen;
+	memcpy(str->name, name, namelen);
+	hlist_add_head(&wh->wh_hash,
+		       whlist->heads + au_name_hash(name, namelen));
+	/* smp_mb(); */
+
+ out:
+	AuTraceErr(err);
+	return err;
+}
+
+/* ---------------------------------------------------------------------- */
+
+void au_vdir_free(struct au_vdir *vdir)
+{
+	au_vdir_deblk_t **deblk;
+
+	AuTraceEnter();
+
+	deblk = vdir->vd_deblk;
+	while (vdir->vd_nblk--) {
+		kfree(*deblk);
+		deblk++;
+	}
+	kfree(vdir->vd_deblk);
+	au_cache_free_vdir(vdir);
+}
+
+static int append_deblk(struct au_vdir *vdir)
+{
+	int err, sz, i;
+	au_vdir_deblk_t **o;
+	union au_vdir_deblk_p p, deblk_end;
+
+	AuTraceEnter();
+
+	err = -ENOMEM;
+	sz = sizeof(*o) * vdir->vd_nblk;
+	o = au_kzrealloc(vdir->vd_deblk, sz, sz + sizeof(*o), GFP_NOFS);
+	if (unlikely(!o))
+		goto out;
+	vdir->vd_deblk = o;
+	p.deblk = kmalloc(sizeof(*p.deblk), GFP_NOFS);
+	if (p.deblk) {
+		i = vdir->vd_nblk++;
+		vdir->vd_deblk[i] = p.deblk;
+		vdir->vd_last.i = i;
+		vdir->vd_last.p.p = p.p;
+		deblk_end.deblk = p.deblk + 1;
+		err = set_deblk_end(&p, &deblk_end);
+		AuDebugOn(err);
+	}
+
+ out:
+	AuTraceErr(err);
+	return err;
+}
+
+static struct au_vdir *alloc_vdir(void)
+{
+	struct au_vdir *vdir;
+	int err;
+
+	AuTraceEnter();
+
+	err = -ENOMEM;
+	vdir = au_cache_alloc_vdir();
+	if (unlikely(!vdir))
+		goto out;
+	vdir->vd_deblk = kzalloc(sizeof(*vdir->vd_deblk), GFP_NOFS);
+	if (unlikely(!vdir->vd_deblk))
+		goto out_free;
+
+	vdir->vd_nblk = 0;
+	vdir->vd_version = 0;
+	vdir->vd_jiffy = 0;
+	err = append_deblk(vdir);
+	if (!err)
+		return vdir; /* success */
+
+	kfree(vdir->vd_deblk);
+
+ out_free:
+	au_cache_free_vdir(vdir);
+ out:
+	vdir = ERR_PTR(err);
+	AuTraceErrPtr(vdir);
+	return vdir;
+}
+
+static int reinit_vdir(struct au_vdir *vdir)
+{
+	int err;
+	union au_vdir_deblk_p p, deblk_end;
+
+	AuTraceEnter();
+
+	while (vdir->vd_nblk > 1) {
+		kfree(vdir->vd_deblk[vdir->vd_nblk - 1]);
+		vdir->vd_deblk[vdir->vd_nblk - 1] = NULL;
+		vdir->vd_nblk--;
+	}
+	p.deblk = vdir->vd_deblk[0];
+	deblk_end.deblk = p.deblk + 1;
+	err = set_deblk_end(&p, &deblk_end);
+	AuDebugOn(err);
+	vdir->vd_version = 0;
+	vdir->vd_jiffy = 0;
+	vdir->vd_last.i = 0;
+	vdir->vd_last.p.deblk = vdir->vd_deblk[0];
+	/* smp_mb(); */
+	return err;
+}
+
+/* ---------------------------------------------------------------------- */
+
+static void free_dehlist(struct au_nhash *dehlist)
+{
+	int i;
+	struct hlist_head *head;
+	struct au_vdir_dehstr *tpos;
+	struct hlist_node *pos, *n;
+
+	AuTraceEnter();
+
+	for (i = 0; i < AuSize_NHASH; i++) {
+		head = dehlist->heads + i;
+		hlist_for_each_entry_safe(tpos, pos, n, head, hash) {
+			/* hlist_del(pos); */
+			au_cache_free_dehstr(tpos);
+		}
+	}
+}
+
+/* returns found(true) or not */
+static int test_known(struct au_nhash *delist, char *name, int namelen)
+{
+	struct hlist_head *head;
+	struct au_vdir_dehstr *tpos;
+	struct hlist_node *pos;
+	struct au_vdir_destr *str;
+
+	LKTRTrace("%.*s\n", namelen, name);
+
+	head = delist->heads + au_name_hash(name, namelen);
+	hlist_for_each_entry(tpos, pos, head, hash) {
+		str = tpos->str;
+		LKTRTrace("%.*s\n", str->len, str->name);
+		if (str->len == namelen && !memcmp(str->name, name, namelen))
+			return 1;
+	}
+	return 0;
+
+}
+
+static int append_de(struct au_vdir *vdir, char *name, int namelen, ino_t ino,
+		     unsigned int d_type, struct au_nhash *delist)
+{
+	int err, sz;
+	union au_vdir_deblk_p p, *room, deblk_end;
+	struct au_vdir_dehstr *dehstr;
+
+	LKTRTrace("%.*s %d, i%lu, dt%u\n",
+		  namelen, name, namelen, (unsigned long)ino, d_type);
+
+	p.deblk = last_deblk(vdir);
+	deblk_end.deblk = p.deblk + 1;
+	room = &vdir->vd_last.p;
+	AuDebugOn(room->p < p.p || deblk_end.p <= room->p
+		  || !is_deblk_end(room, &deblk_end));
+
+	sz = calc_size(namelen);
+	if (unlikely(sz > deblk_end.p - room->p)) {
+		err = append_deblk(vdir);
+		if (unlikely(err))
+			goto out;
+		p.deblk = last_deblk(vdir);
+		deblk_end.deblk = p.deblk + 1;
+		/* smp_mb(); */
+		AuDebugOn(room->p != p.p);
+	}
+
+	err = -ENOMEM;
+	dehstr = au_cache_alloc_dehstr();
+	if (unlikely(!dehstr))
+		goto out;
+	dehstr->str = &room->de->de_str;
+	hlist_add_head(&dehstr->hash,
+		       delist->heads + au_name_hash(name, namelen));
+
+	room->de->de_ino = ino;
+	room->de->de_type = d_type;
+	room->de->de_str.len = namelen;
+	memcpy(room->de->de_str.name, name, namelen);
+
+	err = 0;
+	room->p += sz;
+	if (unlikely(set_deblk_end(room, &deblk_end)))
+		err = append_deblk(vdir);
+	/* smp_mb(); */
+
+ out:
+	AuTraceErr(err);
+	return err;
+}
+
+/* ---------------------------------------------------------------------- */
+
+static int au_ino(struct super_block *sb, aufs_bindex_t bindex, ino_t h_ino,
+		  unsigned int d_type, ino_t *ino)
+{
+	int err;
+	struct au_xino_entry xinoe;
+	struct mutex *mtx;
+	const int isdir = (d_type == DT_DIR);
+
+	/* prevent hardlinks from race condition */
+	mtx = NULL;
+	if (!isdir) {
+		mtx = &au_sbr(sb, bindex)->br_xino.xi_nondir_mtx;
+		mutex_lock(mtx);
+	}
+	err = au_xino_read(sb, bindex, h_ino, &xinoe);
+	if (unlikely(err))
+		goto out;
+
+	if (!xinoe.ino) {
+		err = -EIO;
+		xinoe.ino = au_xino_new_ino(sb);
+		if (unlikely(!xinoe.ino))
+			goto out;
+
+#if 0 /* reserved for future use */
+		struct inode *h_inode;
+		xinoe.h_gen = AuXino_INVALID_HGEN;
+		h_inode = ilookup(au_sbr_sb(sb, bindex), h_ino);
+		if (h_inode) {
+			if (!is_bad_inode(h_inode)) {
+				xinoe.h_gen = h_inode->i_generation;
+				WARN_ON(xinoe.h_gen == AuXino_INVALID_HGEN);
+			}
+			iput(h_inode);
+		}
+#endif
+		err = au_xino_write(sb, bindex, h_ino, &xinoe);
+		if (unlikely(err))
+			goto out;
+	}
+
+	*ino = xinoe.ino;
+
+ out:
+	if (!isdir)
+		mutex_unlock(mtx);
+	AuTraceErr(err);
+	return err;
+}
+
+static int au_wh_ino(struct super_block *sb, aufs_bindex_t bindex, ino_t h_ino,
+		     unsigned int d_type, ino_t *ino)
+{
+#ifdef CONFIG_AUFS_SHWH
+	return au_ino(sb, bindex, h_ino, d_type, ino);
+#else
+	return 0;
+#endif
+}
+
+#define AuFillVdir_CALLED	1
+#define AuFillVdir_SHWH		(1 << 1)
+#define au_ftest_fillvdir(flags, name)	((flags) & AuFillVdir_##name)
+#define au_fset_fillvdir(flags, name)	{ (flags) |= AuFillVdir_##name; }
+#define au_fclr_fillvdir(flags, name)	{ (flags) &= ~AuFillVdir_##name; }
+#ifndef CONFIG_AUFS_SHWH
+#undef AuFillVdir_SHWH
+#define AuFillVdir_SHWH		0
+#endif
+
+struct fillvdir_arg {
+	struct file		*file;
+	struct au_vdir		*vdir;
+	struct au_nhash		*delist;
+	struct au_nhash		*whlist;
+	aufs_bindex_t		bindex;
+	unsigned int		flags;
+	int			err;
+};
+
+static int fillvdir(void *__arg, const char *__name, int namelen, loff_t offset,
+		    u64 h_ino, unsigned int d_type)
+{
+	struct fillvdir_arg *arg = __arg;
+	char *name = (void *)__name;
+	aufs_bindex_t bindex, bend;
+	struct super_block *sb;
+	ino_t ino;
+
+	LKTRTrace("%.*s, namelen %d, i%llu, dt%u\n",
+		  namelen, name, namelen, (unsigned long long)h_ino, d_type);
+
+	sb = arg->file->f_dentry->d_sb;
+	bend = arg->bindex;
+	arg->err = 0;
+	au_fset_fillvdir(arg->flags, CALLED);
+	/* smp_mb(); */
+	if (namelen <= AUFS_WH_PFX_LEN
+	    || memcmp(name, AUFS_WH_PFX, AUFS_WH_PFX_LEN)) {
+		for (bindex = 0; bindex < bend; bindex++)
+			if (test_known(arg->delist + bindex, name, namelen)
+			    || au_nhash_test_known_wh(arg->whlist + bindex,
+						      name, namelen))
+				goto out; /* already exists or whiteouted */
+
+		ino = 1; /* why does gcc warns? */
+		arg->err = au_ino(sb, bend, h_ino, d_type, &ino);
+		if (!arg->err)
+			arg->err = append_de(arg->vdir, name, namelen, ino,
+					     d_type, arg->delist + bend);
+	} else {
+		name += AUFS_WH_PFX_LEN;
+		namelen -= AUFS_WH_PFX_LEN;
+		for (bindex = 0; bindex < bend; bindex++)
+			if (au_nhash_test_known_wh(arg->whlist + bend, name,
+						   namelen))
+				goto out; /* already whiteouted */
+
+		ino = 1; /* dummy */
+		if (au_ftest_fillvdir(arg->flags, SHWH))
+			arg->err = au_wh_ino(sb, bend, h_ino, d_type, &ino);
+		if (!arg->err)
+			arg->err = au_nhash_append_wh
+				(arg->whlist + bend, name, namelen, ino, d_type,
+				 bend, au_ftest_fillvdir(arg->flags, SHWH));
+	}
+
+ out:
+	if (!arg->err)
+		arg->vdir->vd_jiffy = jiffies;
+	/* smp_mb(); */
+	AuTraceErr(arg->err);
+	return arg->err;
+}
+
+static int au_handle_shwh(struct super_block *sb, struct au_vdir *vdir,
+			  aufs_bindex_t bstart, aufs_bindex_t bend,
+			  struct au_nhash *_whlist, struct au_nhash *_delist)
+{
+#ifdef CONFIG_AUFS_SHWH
+	int err, i;
+	struct hlist_head *head;
+	struct au_vdir_wh *tpos;
+	struct hlist_node *pos, *n;
+	char *p, *o;
+	struct au_nhash *whlist, *delist;
+	struct au_vdir_destr *destr;
+	aufs_bindex_t bindex;
+
+	AuTraceEnter();
+	AuDebugOn(!au_opt_test(au_mntflags(sb), SHWH));
+
+	err = -ENOMEM;
+	o = p = __getname();
+	if (unlikely(!p))
+		goto out;
+
+	err = 0;
+	memcpy(p, AUFS_WH_PFX, AUFS_WH_PFX_LEN);
+	p += AUFS_WH_PFX_LEN;
+	for (bindex = bstart; !err && bindex <= bend; bindex++) {
+		whlist = _whlist + bindex;
+		delist = _delist + bindex;
+
+		for (i = 0; i < AuSize_NHASH; i++) {
+			head = whlist->heads + i;
+			hlist_for_each_entry_safe(tpos, pos, n, head, wh_hash) {
+				destr = &tpos->wh_str;
+				memcpy(p, destr->name, destr->len);
+				err = append_de(vdir, o,
+						destr->len + AUFS_WH_PFX_LEN,
+						tpos->wh_ino, tpos->wh_type,
+						delist);
+				if (unlikely(err))
+					break;
+			}
+		}
+	}
+
+	__putname(o);
+
+ out:
+	AuTraceErr(err);
+	return err;
+#else
+	return 0;
+#endif
+}
+
+static int au_do_read_vdir(struct fillvdir_arg *arg)
+{
+	int err;
+	unsigned int mnt_flags;
+	loff_t offset;
+	aufs_bindex_t bend, bindex, bstart;
+	unsigned char dlgt, shwh;
+	struct super_block *sb;
+	struct file *hf;
+
+	AuTraceEnter();
+
+	err = -ENOMEM;
+	bend = au_fbend(arg->file);
+	arg->delist = kmalloc(sizeof(*arg->delist) * (bend + 1), GFP_NOFS);
+	if (unlikely(!arg->delist))
+		goto out;
+	arg->whlist = kmalloc(sizeof(*arg->whlist) * (bend + 1), GFP_NOFS);
+	if (unlikely(!arg->whlist))
+		goto out_delist;
+	err = 0;
+	for (bindex = 0; bindex <= bend; bindex++) {
+		au_nhash_init(arg->delist + bindex);
+		au_nhash_init(arg->whlist + bindex);
+	}
+
+	sb = arg->file->f_dentry->d_sb;
+	mnt_flags = au_mntflags(sb);
+	dlgt = !!au_test_dlgt(mnt_flags);
+	arg->flags = 0;
+	shwh = 0;
+	if (au_opt_test(mnt_flags, SHWH)) {
+		shwh = 1;
+		au_fset_fillvdir(arg->flags, SHWH);
+	}
+	bstart = au_fbstart(arg->file);
+	for (bindex = bstart; !err && bindex <= bend; bindex++) {
+		hf = au_h_fptr(arg->file, bindex);
+		if (!hf)
+			continue;
+
+		offset = vfsub_llseek(hf, 0, SEEK_SET);
+		err = offset;
+		if (unlikely(offset))
+			break;
+		arg->bindex = bindex;
+		do {
+			arg->err = 0;
+			au_fclr_fillvdir(arg->flags, CALLED);
+			/* smp_mb(); */
+			err = vfsub_readdir(hf, fillvdir, arg, dlgt);
+			if (err >= 0)
+				err = arg->err;
+		} while (!err && au_ftest_fillvdir(arg->flags, CALLED));
+	}
+
+	if (!err && shwh)
+		err = au_handle_shwh(sb, arg->vdir, bstart, bend, arg->whlist,
+				     arg->delist);
+
+	for (bindex = bstart; bindex <= bend; bindex++) {
+		free_dehlist(arg->delist + bindex);
+		au_nhash_fin(arg->whlist + bindex);
+	}
+	kfree(arg->whlist);
+
+ out_delist:
+	kfree(arg->delist);
+ out:
+	AuTraceErr(err);
+	return err;
+}
+
+static int read_vdir(struct file *file, int may_read)
+{
+	int err;
+	unsigned long expire;
+	struct fillvdir_arg arg;
+	unsigned char do_read;
+	struct dentry *dentry;
+	struct inode *inode;
+	struct au_vdir *vdir, *allocated;
+	struct super_block *sb;
+
+	dentry = file->f_dentry;
+	LKTRTrace("%.*s, may %d\n", AuDLNPair(dentry), may_read);
+	FiMustWriteLock(file);
+	inode = dentry->d_inode;
+	IMustLock(inode);
+	IiMustWriteLock(inode);
+	AuDebugOn(!S_ISDIR(inode->i_mode));
+
+	err = 0;
+	allocated = NULL;
+	do_read = 0;
+	sb = inode->i_sb;
+	expire = au_sbi(sb)->si_rdcache;
+	vdir = au_ivdir(inode);
+	if (!vdir) {
+		AuDebugOn(au_fvdir_cache(file));
+		do_read = 1;
+		vdir = alloc_vdir();
+		err = PTR_ERR(vdir);
+		if (IS_ERR(vdir))
+			goto out;
+		err = 0;
+		allocated = vdir;
+	} else if (may_read
+		   && (inode->i_version != vdir->vd_version
+		       || time_after(jiffies, vdir->vd_jiffy + expire))) {
+		LKTRTrace("iver %llu, vdver %lu, exp %lu\n",
+			  (unsigned long long)inode->i_version,
+			  vdir->vd_version, vdir->vd_jiffy + expire);
+		do_read = 1;
+		err = reinit_vdir(vdir);
+		if (unlikely(err))
+			goto out;
+	}
+
+	if (!do_read)
+		return 0; /* success */
+
+	arg.file = file;
+	arg.vdir = vdir;
+	err = au_do_read_vdir(&arg);
+	if (!err) {
+		/* todo: necessary? */
+		/* file->f_pos = 0; */
+		vdir->vd_version = inode->i_version;
+		vdir->vd_last.i = 0;
+		vdir->vd_last.p.deblk = vdir->vd_deblk[0];
+		if (allocated)
+			au_set_ivdir(inode, allocated);
+	} else if (allocated)
+		au_vdir_free(allocated);
+
+ out:
+	AuTraceErr(err);
+	return err;
+}
+
+static int copy_vdir(struct au_vdir *tgt, struct au_vdir *src)
+{
+	int err, i, rerr, n;
+
+	AuTraceEnter();
+	AuDebugOn(tgt->vd_nblk != 1);
+
+	err = -ENOMEM;
+	if (tgt->vd_nblk < src->vd_nblk) {
+		au_vdir_deblk_t **p;
+		p = au_kzrealloc(tgt->vd_deblk, sizeof(*p) * tgt->vd_nblk,
+				 sizeof(*p) * src->vd_nblk, GFP_NOFS);
+		if (unlikely(!p))
+			goto out;
+		tgt->vd_deblk = p;
+	}
+
+	tgt->vd_nblk = src->vd_nblk;
+	n = src->vd_nblk;
+	memcpy(tgt->vd_deblk[0], src->vd_deblk[0], AuSize_DEBLK);
+	/* tgt->vd_last.i = 0; */
+	/* tgt->vd_last.p.deblk = tgt->vd_deblk[0]; */
+	tgt->vd_version = src->vd_version;
+	tgt->vd_jiffy = src->vd_jiffy;
+
+	for (i = 1; i < n; i++) {
+		tgt->vd_deblk[i] = kmalloc(AuSize_DEBLK, GFP_NOFS);
+		if (tgt->vd_deblk[i])
+			memcpy(tgt->vd_deblk[i], src->vd_deblk[i],
+			       AuSize_DEBLK);
+		else
+			goto out;
+	}
+	/* smp_mb(); */
+	return 0; /* success */
+
+ out:
+	rerr = reinit_vdir(tgt);
+	BUG_ON(rerr);
+	AuTraceErr(err);
+	return err;
+}
+
+int au_vdir_init(struct file *file)
+{
+	int err;
+	struct dentry *dentry;
+	struct inode *inode;
+	struct au_vdir *vdir_cache, *allocated;
+
+	dentry = file->f_dentry;
+	LKTRTrace("%.*s, pos %lld\n", AuDLNPair(dentry), file->f_pos);
+	FiMustWriteLock(file);
+	inode = dentry->d_inode;
+	IiMustWriteLock(inode);
+	AuDebugOn(!S_ISDIR(inode->i_mode));
+
+	err = read_vdir(file, !file->f_pos);
+	if (unlikely(err))
+		goto out;
+
+	allocated = NULL;
+	vdir_cache = au_fvdir_cache(file);
+	if (!vdir_cache) {
+		vdir_cache = alloc_vdir();
+		err = PTR_ERR(vdir_cache);
+		if (IS_ERR(vdir_cache))
+			goto out;
+		allocated = vdir_cache;
+	} else if (!file->f_pos && vdir_cache->vd_version != file->f_version) {
+		err = reinit_vdir(vdir_cache);
+		if (unlikely(err))
+			goto out;
+	} else
+		return 0; /* success */
+
+	err = copy_vdir(vdir_cache, au_ivdir(inode));
+	if (!err) {
+		file->f_version = inode->i_version;
+		if (allocated)
+			au_set_fvdir_cache(file, allocated);
+	} else if (allocated)
+		au_vdir_free(allocated);
+
+ out:
+	AuTraceErr(err);
+	return err;
+}
+
+static loff_t calc_offset(struct au_vdir *vdir)
+{
+	loff_t offset;
+	union au_vdir_deblk_p p;
+
+	p.deblk = vdir->vd_deblk[vdir->vd_last.i];
+	offset = vdir->vd_last.p.p - p.p;
+	offset += sizeof(*p.deblk) * vdir->vd_last.i;
+	return offset;
+}
+
+/* returns true or false */
+static int seek_vdir(struct file *file)
+{
+	int valid, i, n;
+	struct dentry *dentry;
+	struct au_vdir *vdir_cache;
+	loff_t offset;
+	union au_vdir_deblk_p p, deblk_end;
+
+	dentry = file->f_dentry;
+	LKTRTrace("%.*s, pos %lld\n", AuDLNPair(dentry), file->f_pos);
+	vdir_cache = au_fvdir_cache(file);
+	AuDebugOn(!vdir_cache);
+
+	valid = 1;
+	offset = calc_offset(vdir_cache);
+	LKTRTrace("offset %lld\n", offset);
+	if (file->f_pos == offset)
+		goto out;
+
+	vdir_cache->vd_last.i = 0;
+	vdir_cache->vd_last.p.deblk = vdir_cache->vd_deblk[0];
+	if (!file->f_pos)
+		goto out;
+
+	valid = 0;
+	i = file->f_pos / AuSize_DEBLK;
+	LKTRTrace("i %d\n", i);
+	if (i >= vdir_cache->vd_nblk)
+		goto out;
+
+	n = vdir_cache->vd_nblk;
+	for (; i < n; i++) {
+		p.deblk = vdir_cache->vd_deblk[i];
+		deblk_end.deblk = p.deblk + 1;
+		offset = i;
+		offset *= AuSize_DEBLK;
+		while (!is_deblk_end(&p, &deblk_end) && offset < file->f_pos) {
+			int l;
+			l = calc_size(p.de->de_str.len);
+			offset += l;
+			p.p += l;
+		}
+		if (!is_deblk_end(&p, &deblk_end)) {
+			valid = 1;
+			vdir_cache->vd_last.i = i;
+			vdir_cache->vd_last.p = p;
+			break;
+		}
+	}
+
+ out:
+	/* smp_mb(); */
+	AuTraceErr(!valid);
+	return valid;
+}
+
+int au_vdir_fill_de(struct file *file, void *dirent, filldir_t filldir)
+{
+	int err, l;
+	struct dentry *dentry;
+	struct au_vdir *vdir_cache;
+	struct au_vdir_de *de;
+	union au_vdir_deblk_p deblk_end;
+
+	dentry = file->f_dentry;
+	LKTRTrace("%.*s, pos %lld\n", AuDLNPair(dentry), file->f_pos);
+	vdir_cache = au_fvdir_cache(file);
+	AuDebugOn(!vdir_cache);
+
+	if (!seek_vdir(file))
+		return 0;
+
+	while (1) {
+		deblk_end.deblk
+			= vdir_cache->vd_deblk[vdir_cache->vd_last.i] + 1;
+		while (!is_deblk_end(&vdir_cache->vd_last.p, &deblk_end)) {
+			de = vdir_cache->vd_last.p.de;
+			LKTRTrace("%.*s, off%lld, i%lu, dt%d\n",
+				  de->de_str.len, de->de_str.name,
+				  file->f_pos, (unsigned long)de->de_ino,
+				  de->de_type);
+			err = filldir(dirent, de->de_str.name, de->de_str.len,
+				      file->f_pos, de->de_ino, de->de_type);
+			if (unlikely(err)) {
+				AuTraceErr(err);
+				/* todo: ignore the error caused by udba? */
+				/* return err; */
+				return 0;
+			}
+
+			l = calc_size(de->de_str.len);
+			vdir_cache->vd_last.p.p += l;
+			file->f_pos += l;
+		}
+		if (vdir_cache->vd_last.i < vdir_cache->vd_nblk - 1) {
+			vdir_cache->vd_last.i++;
+			vdir_cache->vd_last.p.deblk
+				= vdir_cache->vd_deblk[vdir_cache->vd_last.i];
+			file->f_pos = sizeof(*vdir_cache->vd_last.p.deblk)
+				* vdir_cache->vd_last.i;
+			continue;
+		}
+		break;
+	}
+
+	/* smp_mb(); */
+	return 0;
+}
diff -Nurp linux-2.6.27.orig/fs/aufs/vfsub.c linux-2.6.27/fs/aufs/vfsub.c
--- linux-2.6.27.orig/fs/aufs/vfsub.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.27/fs/aufs/vfsub.c	2008-12-14 10:37:40.000000000 +0100
@@ -0,0 +1,686 @@
+/*
+ * Copyright (C) 2005-2008 Junjiro Okajima
+ *
+ * This program, aufs is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+ */
+
+/*
+ * sub-routines for VFS
+ *
+ * $Id: vfsub.c,v 1.14 2008/12/01 03:49:29 sfjro Exp $
+ */
+
+#include <linux/uaccess.h>
+#include "aufs.h"
+
+/* ---------------------------------------------------------------------- */
+
+void vfsub_args_init(struct vfsub_args *vargs, struct au_hin_ignore *ign,
+		     int dlgt, int force_unlink)
+{
+	do_vfsub_args_reinit(vargs, ign);
+	vargs->flags = 0;
+	if (dlgt)
+		vfsub_fset(vargs->flags, DLGT);
+	if (force_unlink)
+		vfsub_fset(vargs->flags, FORCE_UNLINK);
+}
+
+/* ---------------------------------------------------------------------- */
+
+struct file *vfsub_filp_open(const char *path, int oflags, int mode)
+{
+	struct file *err;
+
+	LKTRTrace("%s\n", path);
+
+	lockdep_off();
+	err = filp_open(path, oflags, mode);
+	lockdep_on();
+	if (!IS_ERR(err))
+		au_update_fuse_h_inode(err->f_vfsmnt, err->f_dentry); /*ignore*/
+	return err;
+}
+
+int vfsub_path_lookup(const char *name, unsigned int flags,
+		      struct nameidata *nd)
+{
+	int err;
+
+	LKTRTrace("%s\n", name);
+
+	/* lockdep_off(); */
+	err = path_lookup(name, flags, nd);
+	/* lockdep_on(); */
+	if (!err)
+		au_update_fuse_h_inode(nd->path.mnt, nd->path.dentry);
+	/*ignore*/
+	return err;
+}
+
+struct dentry *vfsub_lookup_one_len(const char *name, struct dentry *parent,
+				    int len)
+{
+	struct dentry *d;
+
+	LKTRTrace("%.*s/%.*s\n", AuDLNPair(parent), len, name);
+	IMustLock(parent->d_inode);
+
+	d = lookup_one_len(name, parent, len);
+	if (!IS_ERR(d))
+		au_update_fuse_h_inode(NULL, d); /*ignore*/
+	return d;
+}
+
+#ifdef CONFIG_AUFS_LHASH_PATCH
+struct dentry *vfsub__lookup_hash(struct qstr *name, struct dentry *parent,
+				  struct nameidata *nd)
+{
+	struct dentry *d;
+
+	LKTRTrace("%.*s/%.*s, nd %d\n",
+		  AuDLNPair(parent), AuLNPair(name), !!nd);
+	if (nd)
+		LKTRTrace("nd{0x%x}\n", nd->flags);
+	IMustLock(parent->d_inode);
+
+	d = __lookup_hash(name, parent, nd);
+	if (!IS_ERR(d))
+		au_update_fuse_h_inode(NULL, d); /*ignore*/
+	return d;
+}
+#endif
+
+/* ---------------------------------------------------------------------- */
+
+int do_vfsub_create(struct inode *dir, struct dentry *dentry, int mode,
+		    struct nameidata *nd)
+{
+	int err;
+	struct vfsmount *mnt;
+
+	LKTRTrace("i%lu, %.*s, 0x%x\n", dir->i_ino, AuDLNPair(dentry), mode);
+	IMustLock(dir);
+
+	err = vfs_create(dir, dentry, mode, nd);
+	if (!err) {
+		mnt = NULL;
+		if (nd)
+			mnt = nd->path.mnt;
+		/* dir inode is locked */
+		au_update_fuse_h_inode(mnt, dentry->d_parent); /*ignore*/
+		au_update_fuse_h_inode(mnt, dentry); /*ignore*/
+	}
+	return err;
+}
+
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 27)
+#define VfsubSymlinkArgs	dir, dentry, symname
+#else
+#define VfsubSymlinkArgs	dir, dentry, symname, mode
+#endif
+
+int do_vfsub_symlink(struct inode *dir, struct dentry *dentry,
+		     const char *symname, int mode)
+{
+	int err;
+
+	LKTRTrace("i%lu, %.*s, %s, 0x%x\n",
+		  dir->i_ino, AuDLNPair(dentry), symname, mode);
+	IMustLock(dir);
+
+	err = vfs_symlink(VfsubSymlinkArgs);
+	if (!err) {
+		/* dir inode is locked */
+		au_update_fuse_h_inode(NULL, dentry->d_parent); /*ignore*/
+		au_update_fuse_h_inode(NULL, dentry); /*ignore*/
+	}
+	return err;
+}
+
+int do_vfsub_mknod(struct inode *dir, struct dentry *dentry, int mode,
+		   dev_t dev)
+{
+	int err;
+
+	LKTRTrace("i%lu, %.*s, 0x%x\n", dir->i_ino, AuDLNPair(dentry), mode);
+	IMustLock(dir);
+
+	err = vfs_mknod(dir, dentry, mode, dev);
+	if (!err) {
+		/* dir inode is locked */
+		au_update_fuse_h_inode(NULL, dentry->d_parent); /*ignore*/
+		au_update_fuse_h_inode(NULL, dentry); /*ignore*/
+	}
+	return err;
+}
+
+int do_vfsub_link(struct dentry *src_dentry, struct inode *dir,
+		  struct dentry *dentry)
+{
+	int err;
+
+	LKTRTrace("%.*s, i%lu, %.*s\n",
+		  AuDLNPair(src_dentry), dir->i_ino, AuDLNPair(dentry));
+	IMustLock(dir);
+
+	lockdep_off();
+	err = vfs_link(src_dentry, dir, dentry);
+	lockdep_on();
+	if (!err) {
+		LKTRTrace("src_i %p, dst_i %p\n",
+			  src_dentry->d_inode, dentry->d_inode);
+		/* fuse has different memory inode for the same inumber */
+		au_update_fuse_h_inode(NULL, src_dentry); /*ignore*/
+		/* dir inode is locked */
+		au_update_fuse_h_inode(NULL, dentry->d_parent); /*ignore*/
+		au_update_fuse_h_inode(NULL, dentry); /*ignore*/
+	}
+	return err;
+}
+
+int do_vfsub_rename(struct inode *src_dir, struct dentry *src_dentry,
+		    struct inode *dir, struct dentry *dentry)
+{
+	int err;
+
+	LKTRTrace("i%lu, %.*s, i%lu, %.*s\n",
+		  src_dir->i_ino, AuDLNPair(src_dentry),
+		  dir->i_ino, AuDLNPair(dentry));
+	IMustLock(dir);
+	IMustLock(src_dir);
+	AuDebugOn(src_dir != dir && !vfsub_is_rename_mutex_locked(dir->i_sb));
+
+	lockdep_off();
+	err = vfs_rename(src_dir, src_dentry, dir, dentry);
+	lockdep_on();
+	if (!err) {
+		/* dir inode is locked */
+		au_update_fuse_h_inode(NULL, dentry->d_parent); /*ignore*/
+		au_update_fuse_h_inode(NULL, src_dentry->d_parent); /*ignore*/
+		au_update_fuse_h_inode(NULL, src_dentry); /*ignore*/
+	}
+	return err;
+}
+
+int do_vfsub_mkdir(struct inode *dir, struct dentry *dentry, int mode)
+{
+	int err;
+
+	LKTRTrace("i%lu, %.*s, 0x%x\n", dir->i_ino, AuDLNPair(dentry), mode);
+	IMustLock(dir);
+
+	err = vfs_mkdir(dir, dentry, mode);
+	if (!err) {
+		/* dir inode is locked */
+		au_update_fuse_h_inode(NULL, dentry->d_parent); /*ignore*/
+		au_update_fuse_h_inode(NULL, dentry); /*ignore*/
+	}
+	return err;
+}
+
+int do_vfsub_rmdir(struct inode *dir, struct dentry *dentry)
+{
+	int err;
+
+	LKTRTrace("i%lu, %.*s\n", dir->i_ino, AuDLNPair(dentry));
+	IMustLock(dir);
+
+	lockdep_off();
+	err = vfs_rmdir(dir, dentry);
+	lockdep_on();
+	/* dir inode is locked */
+	if (!err)
+		au_update_fuse_h_inode(NULL, dentry->d_parent); /*ignore*/
+	return err;
+}
+
+int do_vfsub_unlink(struct inode *dir, struct dentry *dentry)
+{
+	int err;
+
+	LKTRTrace("i%lu, %.*s\n", dir->i_ino, AuDLNPair(dentry));
+	IMustLock(dir);
+
+	/* vfs_unlink() locks inode */
+	lockdep_off();
+	err = vfs_unlink(dir, dentry);
+	lockdep_on();
+	/* dir inode is locked */
+	if (!err)
+		au_update_fuse_h_inode(NULL, dentry->d_parent); /*ignore*/
+	return err;
+}
+
+/* ---------------------------------------------------------------------- */
+
+ssize_t do_vfsub_read_u(struct file *file, char __user *ubuf, size_t count,
+			loff_t *ppos)
+{
+	ssize_t err;
+
+	LKTRTrace("%.*s, cnt %zu, pos %lld\n",
+		  AuDLNPair(file->f_dentry), count, *ppos);
+
+	/* todo: always off, regardless nfs branch? */
+	au_br_nfs_lockdep_off(file->f_vfsmnt->mnt_sb);
+	err = vfs_read(file, ubuf, count, ppos);
+	au_br_nfs_lockdep_on(file->f_vfsmnt->mnt_sb);
+	if (err >= 0)
+		au_update_fuse_h_inode(file->f_vfsmnt, file->f_dentry);
+	/*ignore*/
+	return err;
+}
+
+/* todo: kernel_read()? */
+ssize_t do_vfsub_read_k(struct file *file, void *kbuf, size_t count,
+			loff_t *ppos)
+{
+	ssize_t err;
+	mm_segment_t oldfs;
+
+	oldfs = get_fs();
+	set_fs(KERNEL_DS);
+	err = do_vfsub_read_u(file, (char __user *)kbuf, count, ppos);
+	set_fs(oldfs);
+	return err;
+}
+
+ssize_t do_vfsub_write_u(struct file *file, const char __user *ubuf,
+			 size_t count, loff_t *ppos)
+{
+	ssize_t err;
+
+	LKTRTrace("%.*s, cnt %zu, pos %lld\n",
+		  AuDLNPair(file->f_dentry), count, *ppos);
+
+	lockdep_off();
+	err = vfs_write(file, ubuf, count, ppos);
+	lockdep_on();
+	if (err >= 0)
+		au_update_fuse_h_inode(file->f_vfsmnt, file->f_dentry);
+	/*ignore*/
+	return err;
+}
+
+ssize_t do_vfsub_write_k(struct file *file, void *kbuf, size_t count,
+			 loff_t *ppos)
+{
+	ssize_t err;
+	mm_segment_t oldfs;
+
+	oldfs = get_fs();
+	set_fs(KERNEL_DS);
+	err = do_vfsub_write_u(file, (const char __user *)kbuf, count, ppos);
+	set_fs(oldfs);
+	return err;
+}
+
+int do_vfsub_readdir(struct file *file, filldir_t filldir, void *arg)
+{
+	int err;
+
+	LKTRTrace("%.*s\n", AuDLNPair(file->f_dentry));
+
+	lockdep_off();
+	err = vfs_readdir(file, filldir, arg);
+	lockdep_on();
+	if (err >= 0)
+		au_update_fuse_h_inode(file->f_vfsmnt, file->f_dentry);
+	/*ignore*/
+	return err;
+}
+
+#ifdef CONFIG_AUFS_SPLICE_PATCH
+long do_vfsub_splice_to(struct file *in, loff_t *ppos,
+			struct pipe_inode_info *pipe, size_t len,
+			unsigned int flags)
+{
+	long err;
+
+	LKTRTrace("%.*s, pos %lld, len %zu, 0x%x\n",
+		  AuDLNPair(in->f_dentry), *ppos, len, flags);
+
+	lockdep_off();
+	err = vfs_splice_to(in, ppos, pipe, len, flags);
+	lockdep_on();
+	if (err >= 0)
+		au_update_fuse_h_inode(in->f_vfsmnt, in->f_dentry); /*ignore*/
+	return err;
+}
+
+long do_vfsub_splice_from(struct pipe_inode_info *pipe, struct file *out,
+			  loff_t *ppos, size_t len, unsigned int flags)
+{
+	long err;
+
+	LKTRTrace("%.*s, pos %lld, len %zu, 0x%x\n",
+		  AuDLNPair(out->f_dentry), *ppos, len, flags);
+
+	lockdep_off();
+	err = vfs_splice_from(pipe, out, ppos, len, flags);
+	lockdep_on();
+	if (err >= 0)
+		au_update_fuse_h_inode(out->f_vfsmnt, out->f_dentry); /*ignore*/
+	return err;
+}
+#endif
+
+/* ---------------------------------------------------------------------- */
+
+struct au_vfsub_mkdir_args {
+	int *errp;
+	struct inode *dir;
+	struct dentry *dentry;
+	int mode;
+	struct vfsub_args *vargs;
+};
+
+static void au_call_vfsub_mkdir(void *args)
+{
+	struct au_vfsub_mkdir_args *a = args;
+	*a->errp = vfsub_mkdir(a->dir, a->dentry, a->mode, a->vargs);
+}
+
+int vfsub_sio_mkdir(struct au_hinode *hdir, struct dentry *dentry, int mode,
+		    int dlgt)
+{
+	int err, do_sio, wkq_err;
+	struct inode *dir = hdir->hi_inode;
+	struct au_hin_ignore ign;
+	struct vfsub_args vargs;
+
+	LKTRTrace("i%lu, %.*s\n", dir->i_ino, AuDLNPair(dentry));
+
+	vfsub_args_init(&vargs, &ign, dlgt, /*force_unlink*/0);
+	vfsub_ign_hinode(&vargs, IN_CREATE, hdir);
+	do_sio = au_test_h_perm_sio(dir, MAY_EXEC | MAY_WRITE, dlgt);
+	if (!do_sio)
+		err = vfsub_mkdir(dir, dentry, mode, &vargs);
+	else {
+		struct au_vfsub_mkdir_args args = {
+			.errp	= &err,
+			.dir	= dir,
+			.dentry	= dentry,
+			.mode	= mode,
+			.vargs	= &vargs
+		};
+		vfsub_fclr(vargs.flags, DLGT);
+		wkq_err = au_wkq_wait(au_call_vfsub_mkdir, &args, /*dlgt*/0);
+		if (unlikely(wkq_err))
+			err = wkq_err;
+	}
+
+	AuTraceErr(err);
+	return err;
+}
+
+struct au_vfsub_rmdir_args {
+	int *errp;
+	struct inode *dir;
+	struct dentry *dentry;
+	struct vfsub_args *vargs;
+};
+
+static void au_call_vfsub_rmdir(void *args)
+{
+	struct au_vfsub_rmdir_args *a = args;
+	*a->errp = vfsub_rmdir(a->dir, a->dentry, a->vargs);
+}
+
+int vfsub_sio_rmdir(struct au_hinode *hdir, struct dentry *dentry, int dlgt)
+{
+	int err, do_sio, wkq_err;
+	struct inode *dir = hdir->hi_inode;
+	struct au_hin_ignore ign;
+	struct vfsub_args vargs;
+
+	LKTRTrace("i%lu, %.*s\n", dir->i_ino, AuDLNPair(dentry));
+
+	vfsub_args_init(&vargs, &ign, dlgt, /*force_unlink*/0);
+	vfsub_ign_hinode(&vargs, IN_DELETE, hdir);
+	do_sio = au_test_h_perm_sio(dir, MAY_EXEC | MAY_WRITE, dlgt);
+	if (!do_sio)
+		err = vfsub_rmdir(dir, dentry, &vargs);
+	else {
+		struct au_vfsub_rmdir_args args = {
+			.errp		= &err,
+			.dir		= dir,
+			.dentry		= dentry,
+			.vargs		= &vargs
+		};
+		vfsub_fclr(vargs.flags, DLGT);
+		wkq_err = au_wkq_wait(au_call_vfsub_rmdir, &args, /*dlgt*/0);
+		if (unlikely(wkq_err))
+			err = wkq_err;
+	}
+
+	AuTraceErr(err);
+	return err;
+}
+
+/* ---------------------------------------------------------------------- */
+
+struct notify_change_args {
+	int *errp;
+	struct dentry *h_dentry;
+	struct iattr *ia;
+	struct vfsub_args *vargs;
+};
+
+static void call_notify_change(void *args)
+{
+	struct notify_change_args *a = args;
+	struct inode *h_inode;
+
+	LKTRTrace("%.*s, ia_valid 0x%x\n",
+		  AuDLNPair(a->h_dentry), a->ia->ia_valid);
+	h_inode = a->h_dentry->d_inode;
+	IMustLock(h_inode);
+
+	*a->errp = -EPERM;
+	if (!IS_IMMUTABLE(h_inode) && !IS_APPEND(h_inode)) {
+		vfsub_ignore(a->vargs);
+		lockdep_off();
+		*a->errp = notify_change(a->h_dentry, a->ia);
+		lockdep_on();
+		if (!*a->errp)
+			au_update_fuse_h_inode(NULL, a->h_dentry); /*ignore*/
+		else
+			vfsub_unignore(a->vargs);
+		au_dbg_hin_list(a->vargs);
+	}
+	AuTraceErr(*a->errp);
+}
+
+#ifdef CONFIG_AUFS_DLGT
+static void vfsub_notify_change_dlgt(struct notify_change_args *args,
+				     unsigned int flags)
+{
+	if (!vfsub_ftest(flags, DLGT))
+		call_notify_change(args);
+	else {
+		int wkq_err;
+		wkq_err = au_wkq_wait(call_notify_change, args, /*dlgt*/1);
+		if (unlikely(wkq_err))
+			*args->errp = wkq_err;
+	}
+}
+#else
+static void vfsub_notify_change_dlgt(struct notify_change_args *args,
+				     unsigned int flags)
+{
+	call_notify_change(args);
+}
+#endif
+
+int vfsub_notify_change(struct dentry *dentry, struct iattr *ia,
+			struct vfsub_args *vargs)
+{
+	int err;
+	struct notify_change_args args = {
+		.errp		= &err,
+		.h_dentry	= dentry,
+		.ia		= ia,
+		.vargs		= vargs
+	};
+
+	vfsub_notify_change_dlgt(&args, vargs->flags);
+
+	AuTraceErr(err);
+	return err;
+}
+
+int vfsub_sio_notify_change(struct au_hinode *hdir, struct dentry *dentry,
+			    struct iattr *ia)
+{
+	int err, wkq_err;
+	struct au_hin_ignore ign;
+	struct vfsub_args vargs;
+	__u32 events;
+	struct notify_change_args args = {
+		.errp		= &err,
+		.h_dentry	= dentry,
+		.ia		= ia,
+		.vargs		= &vargs
+	};
+
+	LKTRTrace("%.*s, 0x%x\n", AuDLNPair(dentry), ia->ia_valid);
+
+	vfsub_args_init(&vargs, &ign, /*dlgt*/0, /*force_unlink*/0);
+	events = vfsub_events_notify_change(ia);
+	if (events)
+		vfsub_ign_hinode(&vargs, events, hdir);
+	wkq_err = au_wkq_wait(call_notify_change, &args, /*dlgt*/0);
+	if (unlikely(wkq_err))
+		err = wkq_err;
+
+	AuTraceErr(err);
+	return err;
+}
+
+/* ---------------------------------------------------------------------- */
+
+struct unlink_args {
+	int *errp;
+	struct inode *dir;
+	struct dentry *dentry;
+	struct vfsub_args *vargs;
+};
+
+static void call_unlink(void *args)
+{
+	struct unlink_args *a = args;
+	struct inode *h_inode;
+	const int stop_sillyrename = (au_test_nfs(a->dentry->d_sb)
+				      && atomic_read(&a->dentry->d_count) == 1);
+
+	LKTRTrace("%.*s, stop_silly %d, cnt %d\n",
+		  AuDLNPair(a->dentry), stop_sillyrename,
+		  atomic_read(&a->dentry->d_count));
+
+	if (!stop_sillyrename)
+		dget(a->dentry);
+	h_inode = a->dentry->d_inode;
+	if (h_inode)
+		atomic_inc_return(&h_inode->i_count);
+	vfsub_ignore(a->vargs);
+	*a->errp = do_vfsub_unlink(a->dir, a->dentry);
+	if (unlikely(*a->errp || (a->dentry->d_flags & DCACHE_NFSFS_RENAMED)))
+		vfsub_unignore(a->vargs);
+	au_dbg_hin_list(a->vargs);
+	if (!stop_sillyrename)
+		dput(a->dentry);
+	if (h_inode)
+		iput(h_inode);
+
+	AuTraceErr(*a->errp);
+}
+
+/*
+ * @dir: must be locked.
+ * @dentry: target dentry.
+ */
+int vfsub_unlink(struct inode *dir, struct dentry *dentry,
+		 struct vfsub_args *vargs)
+{
+	int err;
+	struct unlink_args args = {
+		.errp	= &err,
+		.dir	= dir,
+		.dentry	= dentry,
+		.vargs	= vargs
+	};
+
+	if (!vfsub_ftest(vargs->flags, DLGT)
+	    && !vfsub_ftest(vargs->flags, FORCE_UNLINK))
+		call_unlink(&args);
+	else {
+		int wkq_err;
+		wkq_err = au_wkq_wait(call_unlink, &args,
+				      vfsub_ftest(vargs->flags, DLGT));
+		if (unlikely(wkq_err))
+			err = wkq_err;
+	}
+
+	return err;
+}
+
+/* ---------------------------------------------------------------------- */
+
+struct statfs_args {
+	int *errp;
+	void *arg;
+	struct kstatfs *buf;
+};
+
+static void call_statfs(void *args)
+{
+	struct statfs_args *a = args;
+	*a->errp = vfs_statfs(a->arg, a->buf);
+}
+
+#ifdef CONFIG_AUFS_DLGT
+static void vfsub_statfs_dlgt(struct statfs_args *args, int dlgt)
+{
+	if (!dlgt)
+		call_statfs(args);
+	else {
+		int wkq_err;
+		wkq_err = au_wkq_wait(call_statfs, args, /*dlgt*/1);
+		if (unlikely(wkq_err))
+			*args->errp = wkq_err;
+	}
+}
+#else
+static void vfsub_statfs_dlgt(struct statfs_args *args, int dlgt)
+{
+	call_statfs(args);
+}
+#endif
+
+int vfsub_statfs(void *arg, struct kstatfs *buf, int dlgt)
+{
+	int err;
+	struct statfs_args args = {
+		.errp	= &err,
+		.arg	= arg,
+		.buf	= buf
+	};
+
+	vfsub_statfs_dlgt(&args, dlgt);
+
+	return err;
+}
diff -Nurp linux-2.6.27.orig/fs/aufs/vfsub.h linux-2.6.27/fs/aufs/vfsub.h
--- linux-2.6.27.orig/fs/aufs/vfsub.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.27/fs/aufs/vfsub.h	2008-12-14 10:37:40.000000000 +0100
@@ -0,0 +1,530 @@
+/*
+ * Copyright (C) 2005-2008 Junjiro Okajima
+ *
+ * This program, aufs is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+ */
+
+/*
+ * sub-routines for VFS
+ *
+ * $Id: vfsub.h,v 1.13 2008/12/01 03:50:21 sfjro Exp $
+ */
+
+#ifndef __AUFS_VFSUB_H__
+#define __AUFS_VFSUB_H__
+
+#ifdef __KERNEL__
+
+#include <linux/fs.h>
+#include <linux/fs_stack.h>
+#include <linux/inotify.h>
+#include <linux/namei.h>
+#include <linux/security.h>
+#include <linux/splice.h>
+
+/* ---------------------------------------------------------------------- */
+
+/* vfsub flags */
+#define Vfsub_DLGT		1		/* operation with delegation */
+#define Vfsub_FORCE_UNLINK	(1 << 1)	/* force unlinking */
+#define vfsub_ftest(flags, name)	((flags) & Vfsub_##name)
+#define vfsub_fset(flags, name)		{ (flags) |= Vfsub_##name; }
+#define vfsub_fclr(flags, name)		{ (flags) &= ~Vfsub_##name; }
+#ifndef CONFIG_AUFS_DLGT
+#undef Vfsub_DLGT
+#define Vfsub_DLGT	0
+#endif
+
+struct au_hin_ignore;
+struct vfsub_args {
+#ifdef CONFIG_AUFS_HINOTIFY
+	/* inotify events to be ignored */
+	int			nignore;
+	struct au_hin_ignore	*ignore;
+#endif
+
+	unsigned int		flags;
+};
+
+struct au_hinode;
+#ifdef CONFIG_AUFS_HINOTIFY
+static inline
+void do_vfsub_args_reinit(struct vfsub_args *vargs, struct au_hin_ignore *ign)
+{
+	vargs->nignore = 0;
+	vargs->ignore = ign;
+}
+
+static inline void vfsub_args_reinit(struct vfsub_args *vargs)
+{
+	vargs->nignore = 0;
+}
+
+__u32 vfsub_events_notify_change(struct iattr *ia);
+void vfsub_ign_hinode(struct vfsub_args *vargs, __u32 events,
+		      struct au_hinode *hinode);
+void vfsub_ignore(struct vfsub_args *vargs);
+void vfsub_unignore(struct vfsub_args *vargs);
+#else
+static inline
+void do_vfsub_args_reinit(struct vfsub_args *vargs, struct au_hin_ignore *ign)
+{
+	/* empty */
+}
+
+static inline void vfsub_args_reinit(struct vfsub_args *vargs)
+{
+	/* empty */
+}
+
+static inline __u32 vfsub_events_notify_change(struct iattr *ia)
+{
+	return 0;
+}
+
+static inline void vfsub_ign_hinode(struct vfsub_args *vargs, __u32 events,
+				    struct au_hinode *hinode)
+{
+	/* empty */
+}
+
+static inline void vfsub_ignore(struct vfsub_args *vargs)
+{
+	/* empty */
+}
+
+static inline void vfsub_unignore(struct vfsub_args *vargs)
+{
+	/* empty */
+}
+#endif /* CONFIG_AUFS_HINOTIFY */
+
+void vfsub_args_init(struct vfsub_args *vargs, struct au_hin_ignore *ign,
+		     int dlgt, int force_unlink);
+
+/* ---------------------------------------------------------------------- */
+
+/* inotify_inode_watched() is not exported */
+static inline int au_test_inotify(struct inode *inode)
+{
+#ifdef CONFIG_INOTIFY
+	return !list_empty(&inode->inotify_watches);
+#endif
+	return 0;
+}
+
+/* ---------------------------------------------------------------------- */
+
+/* lock subclass for hidden inode */
+/* default MAX_LOCKDEP_SUBCLASSES(8) is not enough */
+/* reduce? gave up. */
+enum {
+	AuLsc_I_Begin = I_MUTEX_QUOTA, /* 4 */
+	AuLsc_I_PARENT,		/* hidden inode, parent first */
+	AuLsc_I_PARENT2,	/* copyup dirs */
+	AuLsc_I_PARENT3,	/* rename with hinotify */
+	AuLsc_I_PARENT4,	/* ditto */
+	AuLsc_I_CHILD,
+	AuLsc_I_CHILD2,
+	AuLsc_I_End
+};
+
+#define IMustLock(i)	MtxMustLock(&(i)->i_mutex)
+
+static inline void vfsub_lock_rename_mutex(struct super_block *sb)
+{
+	lockdep_off();
+	mutex_lock(&sb->s_vfs_rename_mutex);
+	lockdep_on();
+}
+
+static inline void vfsub_unlock_rename_mutex(struct super_block *sb)
+{
+	lockdep_off();
+	mutex_unlock(&sb->s_vfs_rename_mutex);
+	lockdep_on();
+}
+
+static inline int vfsub_is_rename_mutex_locked(struct super_block *sb)
+{
+	int res;
+
+	lockdep_off();
+	res = mutex_is_locked(&sb->s_vfs_rename_mutex);
+	lockdep_on();
+
+	return res;
+}
+
+static inline
+struct dentry *vfsub_lock_rename(struct dentry *d1, struct dentry *d2)
+{
+	struct dentry *d;
+
+	lockdep_off();
+	d = lock_rename(d1, d2);
+	lockdep_on();
+	return d;
+}
+
+static inline void vfsub_unlock_rename(struct dentry *d1, struct dentry *d2)
+{
+	lockdep_off();
+	unlock_rename(d1, d2);
+	lockdep_on();
+}
+
+static inline int au_verify_parent(struct dentry *dentry, struct inode *dir)
+{
+	IMustLock(dir);
+	return /* !dir->i_nlink || */ dentry->d_parent->d_inode != dir;
+}
+
+/* ---------------------------------------------------------------------- */
+
+#ifdef CONFIG_AUFS_WORKAROUND_FUSE
+/* br_fuse.c */
+int au_update_fuse_h_inode(struct vfsmount *h_mnt, struct dentry *h_dentry);
+#else
+static inline
+int au_update_fuse_h_inode(struct vfsmount *h_mnt, struct dentry *h_dentry)
+{
+	return 0;
+}
+#endif
+
+#ifdef CONFIG_AUFS_BR_XFS
+/* br_xfs.c */
+dev_t au_h_rdev(struct inode *h_inode, struct vfsmount *h_mnt,
+		struct dentry *h_dentry);
+#else
+static inline
+dev_t au_h_rdev(struct inode *h_inode, struct vfsmount *h_mnt,
+		struct dentry *h_dentry)
+{
+	return h_inode->i_rdev;
+}
+#endif
+
+/* simple abstractions, for future use */
+static inline
+int do_vfsub_permission(struct inode *inode, int mask, struct nameidata *nd)
+{
+	LKTRTrace("i%lu, mask 0x%x, nd %d\n", inode->i_ino, mask, !!nd);
+	IMustLock(inode);
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 27)
+	return inode_permission(inode, mask);
+#else
+	return permission(inode, mask, nd);
+#endif
+}
+
+static inline
+int vfsub_security_inode_permission(struct inode *inode, int mask,
+				    struct nameidata *nd)
+{
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 27)
+	mask &= MAY_READ | MAY_WRITE | MAY_EXEC | MAY_APPEND;
+	return security_inode_permission(inode, mask);
+#else
+	return security_inode_permission(inode, mask, nd);
+#endif
+}
+
+/* ---------------------------------------------------------------------- */
+
+struct file *vfsub_filp_open(const char *path, int oflags, int mode);
+int vfsub_path_lookup(const char *name, unsigned int flags,
+		      struct nameidata *nd);
+struct dentry *vfsub_lookup_one_len(const char *name, struct dentry *parent,
+				    int len);
+
+#ifdef CONFIG_AUFS_LHASH_PATCH
+struct dentry *vfsub__lookup_hash(struct qstr *name, struct dentry *parent,
+				  struct nameidata *nd);
+#endif
+
+/* ---------------------------------------------------------------------- */
+
+int do_vfsub_create(struct inode *dir, struct dentry *dentry, int mode,
+		    struct nameidata *nd);
+int do_vfsub_symlink(struct inode *dir, struct dentry *dentry,
+		     const char *symname, int mode);
+int do_vfsub_mknod(struct inode *dir, struct dentry *dentry, int mode,
+		   dev_t dev);
+int do_vfsub_link(struct dentry *src_dentry, struct inode *dir,
+		  struct dentry *dentry);
+int do_vfsub_rename(struct inode *src_dir, struct dentry *src_dentry,
+		    struct inode *dir, struct dentry *dentry);
+int do_vfsub_mkdir(struct inode *dir, struct dentry *dentry, int mode);
+int do_vfsub_rmdir(struct inode *dir, struct dentry *dentry);
+int do_vfsub_unlink(struct inode *dir, struct dentry *dentry);
+
+/* ---------------------------------------------------------------------- */
+
+ssize_t do_vfsub_read_u(struct file *file, char __user *ubuf, size_t count,
+			loff_t *ppos);
+/* todo: kernel_read()? */
+ssize_t do_vfsub_read_k(struct file *file, void *kbuf, size_t count,
+			loff_t *ppos);
+ssize_t do_vfsub_write_u(struct file *file, const char __user *ubuf,
+			 size_t count, loff_t *ppos);
+ssize_t do_vfsub_write_k(struct file *file, void *kbuf, size_t count,
+			 loff_t *ppos);
+int do_vfsub_readdir(struct file *file, filldir_t filldir, void *arg);
+
+/* ---------------------------------------------------------------------- */
+
+#ifndef CONFIG_AUFS_UNIONFS22_PATCH
+static inline void vfsub_copy_inode_size(struct inode *inode,
+					 struct inode *h_inode)
+{
+	spin_lock(&inode->i_lock);
+	fsstack_copy_inode_size(inode, h_inode);
+	spin_unlock(&inode->i_lock);
+}
+#else
+static inline void vfsub_copy_inode_size(struct inode *inode,
+					 struct inode *h_inode)
+{
+	fsstack_copy_inode_size(inode, h_inode);
+}
+#endif
+
+#ifndef CONFIG_AUFS_UNIONFS23_PATCH
+#define vfs_splice_to		do_splice_to
+#define vfs_splice_from		do_splice_from
+#endif
+
+#ifdef CONFIG_AUFS_SPLICE_PATCH
+long do_vfsub_splice_to(struct file *in, loff_t *ppos,
+			struct pipe_inode_info *pipe, size_t len,
+			unsigned int flags);
+long do_vfsub_splice_from(struct pipe_inode_info *pipe, struct file *out,
+			  loff_t *ppos, size_t len, unsigned int flags);
+#else
+static inline
+long do_vfsub_splice_to(struct file *in, loff_t *ppos,
+			struct pipe_inode_info *pipe, size_t len,
+			unsigned int flags)
+{
+	return -ENOSYS;
+}
+
+static inline
+long do_vfsub_splice_from(struct pipe_inode_info *pipe, struct file *out,
+			  loff_t *ppos, size_t len, unsigned int flags)
+{
+	return -ENOSYS;
+}
+#endif /* CONFIG_AUFS_SPLICE_PATCH */
+
+/* ---------------------------------------------------------------------- */
+
+static inline loff_t vfsub_llseek(struct file *file, loff_t offset, int origin)
+{
+	loff_t err;
+
+	LKTRTrace("%.*s\n", AuDLNPair(file->f_dentry));
+
+	lockdep_off();
+	err = vfs_llseek(file, offset, origin);
+	lockdep_on();
+	return err;
+}
+
+static inline int do_vfsub_getattr(struct vfsmount *mnt, struct dentry *dentry,
+				   struct kstat *st)
+{
+	LKTRTrace("%.*s\n", AuDLNPair(dentry));
+	return vfs_getattr(mnt, dentry, st);
+}
+
+/* ---------------------------------------------------------------------- */
+
+#ifdef CONFIG_AUFS_HIN_OR_DLGT
+/* hin_or_dlgt.c */
+int vfsub_permission(struct inode *inode, int mask, struct nameidata *nd,
+		     int dlgt);
+
+int vfsub_create(struct inode *dir, struct dentry *dentry, int mode,
+		 struct nameidata *nd, struct vfsub_args *vargs);
+int vfsub_symlink(struct inode *dir, struct dentry *dentry, const char *symname,
+		  int mode, struct vfsub_args *vargs);
+int vfsub_mknod(struct inode *dir, struct dentry *dentry, int mode, dev_t dev,
+		struct vfsub_args *vargs);
+int vfsub_link(struct dentry *src_dentry, struct inode *dir,
+	       struct dentry *dentry, struct vfsub_args *vargs);
+int vfsub_rename(struct inode *src_dir, struct dentry *src_dentry,
+		 struct inode *dir, struct dentry *dentry,
+		 struct vfsub_args *vargs);
+int vfsub_mkdir(struct inode *dir, struct dentry *dentry, int mode,
+		struct vfsub_args *vargs);
+int vfsub_rmdir(struct inode *dir, struct dentry *dentry,
+		struct vfsub_args *vargs);
+
+ssize_t vfsub_read_u(struct file *file, char __user *ubuf, size_t count,
+		     loff_t *ppos, int dlgt);
+ssize_t vfsub_read_k(struct file *file, void *kbuf, size_t count, loff_t *ppos,
+		     int dlgt);
+ssize_t vfsub_write_u(struct file *file, const char __user *ubuf, size_t count,
+		      loff_t *ppos, struct vfsub_args *vargs);
+ssize_t vfsub_write_k(struct file *file, void *kbuf, size_t count, loff_t *ppos,
+		      struct vfsub_args *vargs);
+int vfsub_readdir(struct file *file, filldir_t filldir, void *arg, int dlgt);
+long vfsub_splice_to(struct file *in, loff_t *ppos,
+		     struct pipe_inode_info *pipe, size_t len,
+		     unsigned int flags, int dlgt);
+long vfsub_splice_from(struct pipe_inode_info *pipe, struct file *out,
+		       loff_t *ppos, size_t len, unsigned int flags,
+		       struct vfsub_args *vargs);
+
+int vfsub_getattr(struct vfsmount *mnt, struct dentry *dentry, struct kstat *st,
+		  int dlgt);
+#else
+
+static inline
+int vfsub_permission(struct inode *inode, int mask, struct nameidata *nd,
+		     int dlgt)
+{
+	return do_vfsub_permission(inode, mask, nd);
+}
+
+static inline
+int vfsub_create(struct inode *dir, struct dentry *dentry, int mode,
+		 struct nameidata *nd, struct vfsub_args *vargs)
+{
+	return do_vfsub_create(dir, dentry, mode, nd);
+}
+
+static inline
+int vfsub_symlink(struct inode *dir, struct dentry *dentry, const char *symname,
+		  int mode, struct vfsub_args *vargs)
+{
+	return do_vfsub_symlink(dir, dentry, symname, mode);
+}
+
+static inline
+int vfsub_mknod(struct inode *dir, struct dentry *dentry, int mode, dev_t dev,
+		struct vfsub_args *vargs)
+{
+	return do_vfsub_mknod(dir, dentry, mode, dev);
+}
+
+static inline
+int vfsub_link(struct dentry *src_dentry, struct inode *dir,
+	       struct dentry *dentry, struct vfsub_args *vargs)
+{
+	return do_vfsub_link(src_dentry, dir, dentry);
+}
+
+static inline
+int vfsub_rename(struct inode *src_dir, struct dentry *src_dentry,
+		 struct inode *dir, struct dentry *dentry,
+		 struct vfsub_args *vargs)
+{
+	return do_vfsub_rename(src_dir, src_dentry, dir, dentry);
+}
+
+static inline
+int vfsub_mkdir(struct inode *dir, struct dentry *dentry, int mode,
+		struct vfsub_args *vargs)
+{
+	return do_vfsub_mkdir(dir, dentry, mode);
+}
+
+static inline
+int vfsub_rmdir(struct inode *dir, struct dentry *dentry,
+		struct vfsub_args *vargs)
+{
+	return do_vfsub_rmdir(dir, dentry);
+}
+
+static inline
+ssize_t vfsub_read_u(struct file *file, char __user *ubuf, size_t count,
+		     loff_t *ppos, int dlgt)
+{
+	return do_vfsub_read_u(file, ubuf, count, ppos);
+}
+
+static inline
+ssize_t vfsub_read_k(struct file *file, void *kbuf, size_t count, loff_t *ppos,
+		     int dlgt)
+{
+	return do_vfsub_read_k(file, kbuf, count, ppos);
+}
+
+static inline
+ssize_t vfsub_write_u(struct file *file, const char __user *ubuf, size_t count,
+		      loff_t *ppos, struct vfsub_args *vargs)
+{
+	return do_vfsub_write_u(file, ubuf, count, ppos);
+}
+
+static inline
+ssize_t vfsub_write_k(struct file *file, void *kbuf, size_t count, loff_t *ppos,
+		      struct vfsub_args *vargs)
+{
+	return do_vfsub_write_k(file, kbuf, count, ppos);
+}
+
+static inline
+int vfsub_readdir(struct file *file, filldir_t filldir, void *arg, int dlgt)
+{
+	return do_vfsub_readdir(file, filldir, arg);
+}
+
+static inline
+long vfsub_splice_to(struct file *in, loff_t *ppos,
+		     struct pipe_inode_info *pipe, size_t len,
+		     unsigned int flags, int dlgt)
+{
+	return do_vfsub_splice_to(in, ppos, pipe, len, flags);
+}
+
+static inline
+long vfsub_splice_from(struct pipe_inode_info *pipe, struct file *out,
+		       loff_t *ppos, size_t len, unsigned int flags,
+		       struct vfsub_args *vargs)
+{
+	return do_vfsub_splice_from(pipe, out, ppos, len, flags);
+}
+
+static inline
+int vfsub_getattr(struct vfsmount *mnt, struct dentry *dentry, struct kstat *st,
+		  int dlgt)
+{
+	return do_vfsub_getattr(mnt, dentry, st);
+}
+#endif /* HIN_OR_DLGT */
+
+/* ---------------------------------------------------------------------- */
+
+int vfsub_sio_mkdir(struct au_hinode *hdir, struct dentry *dentry, int mode,
+		    int dlgt);
+int vfsub_sio_rmdir(struct au_hinode *hdir, struct dentry *dentry, int dlgt);
+int vfsub_sio_notify_change(struct au_hinode *hdir, struct dentry *dentry,
+			    struct iattr *ia);
+
+/* ---------------------------------------------------------------------- */
+
+int vfsub_notify_change(struct dentry *dentry, struct iattr *ia,
+			struct vfsub_args *vargs);
+int vfsub_unlink(struct inode *dir, struct dentry *dentry,
+		 struct vfsub_args *vargs);
+int vfsub_statfs(void *arg, struct kstatfs *buf, int dlgt);
+
+#endif /* __KERNEL__ */
+#endif /* __AUFS_VFSUB_H__ */
diff -Nurp linux-2.6.27.orig/fs/aufs/wbr_policy.c linux-2.6.27/fs/aufs/wbr_policy.c
--- linux-2.6.27.orig/fs/aufs/wbr_policy.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.27/fs/aufs/wbr_policy.c	2008-12-14 10:37:40.000000000 +0100
@@ -0,0 +1,700 @@
+/*
+ * Copyright (C) 2005-2008 Junjiro Okajima
+ *
+ * This program, aufs is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+ */
+
+/*
+ * policies for selecting one among multiple writable branches
+ *
+ * $Id: wbr_policy.c,v 1.14 2008/12/01 03:49:29 sfjro Exp $
+ */
+
+#include <linux/statfs.h>
+#include "aufs.h"
+
+static int au_cpdown_attr(struct au_hinode *hdir, struct dentry *h_dst,
+			  struct dentry *h_src)
+{
+	int err, sbits;
+	struct iattr ia;
+	struct inode *h_idst, *h_isrc;
+
+	LKTRTrace("%.*s\n", AuDLNPair(h_dst));
+	h_idst = h_dst->d_inode;
+	/* todo? IMustLock(h_idst); */
+	h_isrc = h_src->d_inode;
+	/* todo? IMustLock(h_isrc); */
+
+	ia.ia_valid = ATTR_FORCE | ATTR_MODE | ATTR_UID | ATTR_GID;
+	ia.ia_mode = h_isrc->i_mode;
+	ia.ia_uid = h_isrc->i_uid;
+	ia.ia_gid = h_isrc->i_gid;
+	sbits = !!(ia.ia_mode & (S_ISUID | S_ISGID));
+
+	err = vfsub_sio_notify_change(hdir, h_dst, &ia);
+
+	/* is this nfs only? */
+	if (!err && sbits && au_test_nfs(h_dst->d_sb)) {
+		ia.ia_valid = ATTR_FORCE | ATTR_MODE;
+		ia.ia_mode = h_isrc->i_mode;
+		err = vfsub_sio_notify_change(hdir, h_dst, &ia);
+	}
+
+	/* todo: necessary? */
+	if (!err)
+		h_idst->i_flags = h_isrc->i_flags;
+
+	AuTraceErr(err);
+	return err;
+}
+
+struct au_cpdown_dir_args {
+	struct dentry *parent;
+	unsigned int parent_opq; /* bit-flags */
+};
+
+static int au_cpdown_dir(struct dentry *dentry, aufs_bindex_t bdst,
+			 struct dentry *h_parent, void *arg)
+{
+	int err, rerr;
+	struct au_cpdown_dir_args *args = arg;
+	aufs_bindex_t bend, bopq, bstart;
+	unsigned char parent_opq, whed, dlgt, do_opq, made_dir, diropq;
+	struct dentry *h_dentry, *opq_dentry, *wh_dentry, *parent;
+	struct inode *h_dir, *h_inode, *inode, *dir;
+
+	LKTRTrace("%.*s, b%d\n", AuDLNPair(dentry), bdst);
+	bstart = au_dbstart(dentry);
+	AuDebugOn(bstart <= bdst
+		  && bdst <= au_dbend(dentry)
+		  && au_h_dptr(dentry, bdst));
+	AuDebugOn(!h_parent);
+	/* todo: safe? */
+	parent = dget_parent(dentry);
+	dir = parent->d_inode;
+	dput(parent);
+	h_dir = h_parent->d_inode;
+	AuDebugOn(!h_dir);
+	AuDebugOn(h_dir != au_h_iptr(dir, bdst));
+	IMustLock(h_dir);
+
+	err = au_lkup_neg(dentry, bdst);
+	if (unlikely(err < 0))
+		goto out;
+	h_dentry = au_h_dptr(dentry, bdst);
+	dlgt = !!au_test_dlgt(au_mntflags(dentry->d_sb));
+	err = vfsub_sio_mkdir(au_hi(dir, bdst), h_dentry,
+			      S_IRWXU | S_IRUGO | S_IXUGO, dlgt);
+	if (unlikely(err))
+		goto out_put;
+
+	made_dir = 1;
+	bend = au_dbend(dentry);
+	bopq = au_dbdiropq(dentry);
+	whed = (au_dbwh(dentry) == bdst);
+	if (!args->parent_opq)
+		args->parent_opq |= (bopq <= bdst);
+	parent_opq = (args->parent_opq && args->parent == dentry);
+	do_opq = 0;
+	diropq = 0;
+	h_inode = h_dentry->d_inode;
+	mutex_lock_nested(&h_inode->i_mutex, AuLsc_I_CHILD);
+	if (whed || (parent_opq && do_opq)) {
+		opq_dentry = au_diropq_create(dentry, bdst, dlgt);
+		err = PTR_ERR(opq_dentry);
+		if (IS_ERR(opq_dentry)) {
+			mutex_unlock(&h_inode->i_mutex);
+			goto out_dir;
+		}
+		dput(opq_dentry);
+		diropq = 1;
+	}
+
+	err = au_cpdown_attr(au_hi(dir, bdst), h_dentry,
+			     au_h_dptr(dentry, bstart));
+	mutex_unlock(&h_inode->i_mutex);
+	if (unlikely(err))
+		goto out_opq;
+
+	wh_dentry = NULL;
+	if (whed) {
+		wh_dentry = au_wh_lkup(h_parent, &dentry->d_name, /*ndx*/NULL);
+		err = PTR_ERR(wh_dentry);
+		if (IS_ERR(wh_dentry))
+			goto out_opq;
+		err = 0;
+		if (wh_dentry->d_inode)
+			err = au_wh_unlink_dentry(au_hi(dir, bdst), wh_dentry,
+						  dentry, dlgt);
+		dput(wh_dentry);
+		if (unlikely(err))
+			goto out_opq;
+	}
+
+	inode = dentry->d_inode;
+	if (au_ibend(inode) < bdst)
+		au_set_ibend(inode, bdst);
+	au_set_h_iptr(inode, bdst, au_igrab(h_inode), au_hi_flags(inode, 1));
+	goto out; /* success */
+
+	/* revert */
+ out_opq:
+	if (diropq) {
+		mutex_lock_nested(&h_inode->i_mutex, AuLsc_I_CHILD);
+		rerr = au_diropq_remove(dentry, bdst, dlgt);
+		mutex_unlock(&h_inode->i_mutex);
+		if (unlikely(rerr)) {
+			AuIOErr("failed removing diropq for %.*s b%d (%d)\n",
+				AuDLNPair(dentry), bdst, rerr);
+			err = -EIO;
+			goto out;
+		}
+	}
+ out_dir:
+	if (made_dir) {
+		rerr = vfsub_sio_rmdir(au_hi(dir, bdst), h_dentry, dlgt);
+		if (unlikely(rerr)) {
+			AuIOErr("failed removing %.*s b%d (%d)\n",
+				AuDLNPair(dentry), bdst, rerr);
+			err = -EIO;
+		}
+	}
+ out_put:
+	au_set_h_dptr(dentry, bdst, NULL);
+	if (au_dbend(dentry) == bdst)
+		au_update_dbend(dentry);
+ out:
+	AuTraceErr(err);
+	return err;
+}
+
+int au_cpdown_dirs(struct dentry *dentry, aufs_bindex_t bdst)
+{
+	int err;
+	struct au_cpdown_dir_args args = {
+		.parent		= dget_parent(dentry),
+		.parent_opq	= 0
+	};
+
+	LKTRTrace("%.*s, b%d\n", AuDLNPair(dentry), bdst);
+
+	err = au_cp_dirs(dentry, bdst, au_cpdown_dir, &args);
+	dput(args.parent);
+
+	AuTraceErr(err);
+	return err;
+}
+
+/* ---------------------------------------------------------------------- */
+
+/* policies for create */
+
+static int au_wbr_bu(struct super_block *sb, aufs_bindex_t bindex)
+{
+	for (; bindex >= 0; bindex--)
+		if (!au_br_rdonly(au_sbr(sb, bindex)))
+			return bindex;
+	return -EROFS;
+}
+
+/* top down parent */
+static int au_wbr_create_tdp(struct dentry *dentry, int isdir)
+{
+	int err;
+	struct super_block *sb;
+	aufs_bindex_t bstart, bindex;
+	unsigned char dirperm1;
+	struct dentry *parent, *h_parent;
+	struct inode *h_dir;
+
+	LKTRTrace("%.*s, dir %d\n", AuDLNPair(dentry), isdir);
+
+	sb = dentry->d_sb;
+	dirperm1 = !!au_test_dirperm1(au_mntflags(sb));
+	bstart = au_dbstart(dentry);
+	AuDebugOn(bstart < 0);
+	err = bstart;
+	/* todo: can 'err' be an illegal? */
+	if (/* err >= 0 && */ !au_br_rdonly(au_sbr(sb, bstart)))
+		goto out;
+
+	err = -EROFS;
+	parent = dget_parent(dentry);
+	for (bindex = au_dbstart(parent); bindex < bstart; bindex++) {
+		h_parent = au_h_dptr(parent, bindex);
+		if (!h_parent)
+			continue;
+		h_dir = h_parent->d_inode;
+		if (!h_dir)
+			continue;
+
+		if (!au_br_rdonly(au_sbr(sb, bindex))
+		    && (!dirperm1
+			|| au_test_h_perm(h_dir, MAY_WRITE | MAY_EXEC,
+					  /*dlgt*/0))) {
+				err = bindex;
+				break;
+		}
+	}
+	dput(parent);
+
+	/* bottom up here */
+	if (unlikely(err < 0))
+		err = au_wbr_bu(sb, bstart - 1);
+
+ out:
+	LKTRTrace("b%d\n", err);
+	return err;
+}
+
+/* ---------------------------------------------------------------------- */
+
+/* an exception for the policy other than tdp */
+static int au_wbr_create_exp(struct dentry *dentry)
+{
+	int err;
+	struct dentry *parent;
+	aufs_bindex_t bwh, bdiropq;
+
+	LKTRTrace("%.*s\n", AuDLNPair(dentry));
+
+	err = -1;
+	bwh = au_dbwh(dentry);
+	parent = dget_parent(dentry);
+	bdiropq = au_dbdiropq(parent);
+	if (bwh >= 0) {
+		if (bdiropq >= 0)
+			err = min(bdiropq, bwh);
+		else
+			err = bwh;
+		LKTRTrace("%d\n", err);
+	} else if (bdiropq >= 0) {
+		err = bdiropq;
+		LKTRTrace("%d\n", err);
+	}
+	dput(parent);
+
+	if (err >= 0 && au_br_rdonly(au_sbr(dentry->d_sb, err)))
+		err = -1;
+
+	LKTRTrace("%d\n", err);
+	return err;
+}
+
+/* ---------------------------------------------------------------------- */
+
+/* round robin */
+static int au_wbr_create_init_rr(struct super_block *sb)
+{
+	int err;
+
+	err = au_wbr_bu(sb, au_sbend(sb));
+	atomic_set(&au_sbi(sb)->si_wbr_rr_next, -err); /* less important */
+
+	LKTRTrace("b%d\n", err);
+	return err;
+}
+
+static int au_wbr_create_rr(struct dentry *dentry, int isdir)
+{
+	int err, nbr;
+	struct super_block *sb;
+	atomic_t *next;
+	unsigned int u;
+	aufs_bindex_t bindex, bend;
+
+	LKTRTrace("%.*s, dir %d\n", AuDLNPair(dentry), isdir);
+
+	sb = dentry->d_sb;
+	next = NULL;
+	err = au_wbr_create_exp(dentry);
+	if (err >= 0)
+		goto out;
+
+	next = &au_sbi(sb)->si_wbr_rr_next;
+	bend = au_sbend(sb);
+	nbr = bend + 1;
+	for (bindex = 0; bindex <= bend; bindex++) {
+		if (!isdir) {
+			err = atomic_dec_return(next) + 1;
+			/* modulo for 0 is meaningless */
+			if (unlikely(!err))
+				err = atomic_dec_return(next) + 1;
+		} else
+			err = atomic_read(next);
+		LKTRTrace("%d\n", err);
+		u = err;
+		err = u % nbr;
+		LKTRTrace("%d\n", err);
+		if (!au_br_rdonly(au_sbr(sb, err)))
+			break;
+		err = -EROFS;
+	}
+
+ out:
+	LKTRTrace("%d\n", err);
+	return err;
+}
+
+/* ---------------------------------------------------------------------- */
+
+/* most free space */
+static void *au_wbr_statfs_arg(struct au_branch *br, struct super_block *sb,
+			       aufs_bindex_t bindex)
+{
+	struct super_block *h_sb;
+
+	h_sb = br->br_mnt->mnt_sb;
+
+	if (!au_test_nfs(h_sb))
+		return h_sb->s_root;
+
+	/* sigh,,, why nfs s_root has wrong inode? */
+	return au_di(sb->s_root)->di_hdentry[0 + bindex].hd_dentry;
+}
+
+static void au_mfs(struct dentry *dentry)
+{
+	struct super_block *sb;
+	aufs_bindex_t bindex, bend;
+	unsigned char dlgt;
+	int err;
+	struct kstatfs st;
+	unsigned long long b, bavail;
+	void *arg;
+	struct au_branch *br;
+	struct au_wbr_mfs *mfs;
+
+	LKTRTrace("%.*s\n", AuDLNPair(dentry));
+
+	bavail = 0;
+	sb = dentry->d_sb;
+	mfs = &au_sbi(sb)->si_wbr_mfs;
+	mfs->mfs_bindex = -EROFS;
+	mfs->mfsrr_bytes = 0;
+	dlgt = !!au_test_dlgt(au_mntflags(sb));
+	bend = au_sbend(sb);
+	for (bindex = 0; bindex <= bend; bindex++) {
+		br = au_sbr(sb, bindex);
+		if (au_br_rdonly(br))
+			continue;
+		AuDebugOn(!br->br_wbr);
+		arg = au_wbr_statfs_arg(br, sb, bindex);
+		if (!arg)
+			continue;
+
+		err = vfsub_statfs(arg, &st, dlgt);
+		LKTRTrace("b%d, %d, %llu\n",
+			  bindex, err, (unsigned long long)st.f_bavail);
+		if (unlikely(err)) {
+			AuWarn1("failed statfs, b%d, %d\n", bindex, err);
+			continue;
+		}
+
+		/* when the available size is equal, select lower one */
+		b = st.f_bavail * st.f_bsize;
+		br->br_wbr->wbr_bytes = b;
+		if (b >= bavail) {
+			bavail = b;
+			mfs->mfs_bindex = bindex;
+			mfs->mfs_jiffy = jiffies;
+		}
+	}
+
+	mfs->mfsrr_bytes = bavail;
+	LKTRTrace("b%d\n", mfs->mfs_bindex);
+}
+
+static int au_wbr_create_mfs(struct dentry *dentry, int isdir)
+{
+	int err;
+	struct super_block *sb;
+	struct au_wbr_mfs *mfs;
+
+	LKTRTrace("%.*s\n", AuDLNPair(dentry));
+
+	sb = dentry->d_sb;
+	err = au_wbr_create_exp(dentry);
+	if (err >= 0)
+		goto out;
+
+	mfs = &au_sbi(sb)->si_wbr_mfs;
+	mutex_lock(&mfs->mfs_lock);
+	if (unlikely(time_after(jiffies, mfs->mfs_jiffy + mfs->mfs_expire)
+		     || mfs->mfs_bindex < 0
+		     || au_br_rdonly(au_sbr(sb, mfs->mfs_bindex))))
+		au_mfs(dentry);
+	mutex_unlock(&mfs->mfs_lock);
+	err = mfs->mfs_bindex;
+
+ out:
+	LKTRTrace("b%d\n", err);
+	return err;
+}
+
+static int au_wbr_create_init_mfs(struct super_block *sb)
+{
+	struct au_wbr_mfs *mfs;
+
+	mfs = &au_sbi(sb)->si_wbr_mfs;
+	LKTRTrace("expire %lu\n", mfs->mfs_expire);
+
+	mutex_init(&mfs->mfs_lock);
+	mfs->mfs_jiffy = 0;
+	mfs->mfs_bindex = -EROFS;
+
+	return 0;
+}
+
+static int au_wbr_create_fin_mfs(struct super_block *sb)
+{
+	AuTraceEnter();
+	mutex_destroy(&au_sbi(sb)->si_wbr_mfs.mfs_lock);
+	return 0;
+}
+
+/* ---------------------------------------------------------------------- */
+
+/* most free space and then round robin */
+static int au_wbr_create_mfsrr(struct dentry *dentry, int isdir)
+{
+	int err;
+	struct au_wbr_mfs *mfs;
+
+	LKTRTrace("%.*s, %d\n", AuDLNPair(dentry), isdir);
+
+	err = au_wbr_create_mfs(dentry, isdir);
+	if (err >= 0) {
+		mfs = &au_sbi(dentry->d_sb)->si_wbr_mfs;
+		LKTRTrace("%llu bytes, %llu wmark\n",
+			  mfs->mfsrr_bytes, mfs->mfsrr_watermark);
+		if (mfs->mfsrr_bytes < mfs->mfsrr_watermark)
+			err = au_wbr_create_rr(dentry, isdir);
+	}
+
+	LKTRTrace("b%d\n", err);
+	return err;
+}
+
+static int au_wbr_create_init_mfsrr(struct super_block *sb)
+{
+	int err;
+
+	au_wbr_create_init_mfs(sb); /* ignore */
+	err = au_wbr_create_init_rr(sb);
+
+	AuTraceErr(err);
+	return err;
+}
+
+/* ---------------------------------------------------------------------- */
+
+/* top down parent and most free space */
+static int au_wbr_create_pmfs(struct dentry *dentry, int isdir)
+{
+	int err, e2;
+	struct super_block *sb;
+	struct dentry *parent, *h_parent;
+	aufs_bindex_t bindex, bstart, bend;
+	unsigned char dirperm1;
+	struct au_branch *br;
+	unsigned long long b;
+	struct inode *h_dir;
+
+	LKTRTrace("%.*s, %d\n", AuDLNPair(dentry), isdir);
+
+	err = au_wbr_create_tdp(dentry, isdir);
+	if (unlikely(err < 0))
+		goto out;
+	parent = dget_parent(dentry);
+	bstart = au_dbstart(parent);
+	bend = au_dbtaildir(parent);
+	if (bstart == bend)
+		goto out_parent; /* success */
+
+	e2 = au_wbr_create_mfs(dentry, isdir);
+	if (e2 < 0)
+		goto out_parent; /* success */
+
+	/* when the available size is equal, select upper one */
+	sb = dentry->d_sb;
+	br = au_sbr(sb, err);
+	AuDebugOn(!br->br_wbr);
+	dirperm1 = !!au_test_dirperm1(au_mntflags(sb));
+	b = br->br_wbr->wbr_bytes;
+	LKTRTrace("b%d, %llu\n", err, b);
+
+	if (dirperm1) {
+		for (bindex = bstart; bindex <= bend; bindex++) {
+			h_parent = au_h_dptr(parent, bindex);
+			if (!h_parent)
+				continue;
+			h_dir = h_parent->d_inode;
+			if (!h_dir)
+				continue;
+
+			br = au_sbr(sb, bindex);
+			if (!au_br_rdonly(br)
+			    && au_test_h_perm(h_dir, MAY_WRITE | MAY_EXEC,
+					      /*dlgt*/0)
+			    && br->br_wbr->wbr_bytes > b) {
+				b = br->br_wbr->wbr_bytes;
+				err = bindex;
+				LKTRTrace("b%d, %llu\n", err, b);
+			}
+		}
+		if (err >= 0)
+			goto out_parent;
+	}
+	for (bindex = bstart; bindex <= bend; bindex++) {
+		h_parent = au_h_dptr(parent, bindex);
+		if (!h_parent || !h_parent->d_inode)
+			continue;
+
+		br = au_sbr(sb, bindex);
+		if (!au_br_rdonly(br) && br->br_wbr->wbr_bytes > b) {
+			b = br->br_wbr->wbr_bytes;
+			err = bindex;
+			LKTRTrace("b%d, %llu\n", err, b);
+		}
+	}
+
+ out_parent:
+	dput(parent);
+ out:
+	LKTRTrace("b%d\n", err);
+	return err;
+}
+
+/* ---------------------------------------------------------------------- */
+
+/* policies for copyup */
+
+/* top down parent */
+static int au_wbr_copyup_tdp(struct dentry *dentry)
+{
+	return au_wbr_create_tdp(dentry, /*isdir, anything is ok*/0);
+}
+
+/* bottom up parent */
+static int au_wbr_copyup_bup(struct dentry *dentry)
+{
+	int err;
+	struct dentry *parent, *h_parent;
+	aufs_bindex_t bindex, bstart;
+	unsigned char dirperm1;
+	struct super_block *sb;
+	struct inode *h_dir;
+
+	LKTRTrace("%.*s\n", AuDLNPair(dentry));
+
+	err = -EROFS;
+	sb = dentry->d_sb;
+	dirperm1 = !!au_test_dirperm1(au_mntflags(sb));
+	parent = dget_parent(dentry);
+	bstart = au_dbstart(parent);
+	for (bindex = au_dbstart(dentry); bindex >= bstart; bindex--) {
+		h_parent = au_h_dptr(parent, bindex);
+		if (!h_parent)
+			continue;
+		h_dir = h_parent->d_inode;
+		if (!h_dir)
+			continue;
+
+		if (!au_br_rdonly(au_sbr(sb, bindex))
+		    && (!dirperm1
+			|| au_test_h_perm(h_dir, MAY_WRITE | MAY_EXEC,
+					  /*dlgt*/0))) {
+			err = bindex;
+			break;
+		}
+	}
+	dput(parent);
+
+	/* bottom up here */
+	if (unlikely(err < 0))
+		err = au_wbr_bu(sb, bstart - 1);
+
+	LKTRTrace("b%d\n", err);
+	return err;
+}
+
+/* bottom up */
+static int au_wbr_copyup_bu(struct dentry *dentry)
+{
+	int err;
+
+	LKTRTrace("%.*s\n", AuDLNPair(dentry));
+
+	err = au_wbr_bu(dentry->d_sb, au_dbstart(dentry));
+
+	LKTRTrace("b%d\n", err);
+	return err;
+}
+
+/* ---------------------------------------------------------------------- */
+
+struct au_wbr_copyup_operations au_wbr_copyup_ops[] = {
+	[AuWbrCopyup_TDP] = {
+		.copyup	= au_wbr_copyup_tdp
+	},
+	[AuWbrCopyup_BUP] = {
+		.copyup	= au_wbr_copyup_bup
+	},
+	[AuWbrCopyup_BU] = {
+		.copyup	= au_wbr_copyup_bu
+	}
+};
+
+struct au_wbr_create_operations au_wbr_create_ops[] = {
+	[AuWbrCreate_TDP] = {
+		.create	= au_wbr_create_tdp
+	},
+	[AuWbrCreate_RR] = {
+		.create	= au_wbr_create_rr,
+		.init	= au_wbr_create_init_rr
+	},
+	[AuWbrCreate_MFS] = {
+		.create	= au_wbr_create_mfs,
+		.init	= au_wbr_create_init_mfs,
+		.fin	= au_wbr_create_fin_mfs
+	},
+	[AuWbrCreate_MFSV] = {
+		.create	= au_wbr_create_mfs,
+		.init	= au_wbr_create_init_mfs,
+		.fin	= au_wbr_create_fin_mfs
+	},
+	[AuWbrCreate_MFSRR] = {
+		.create	= au_wbr_create_mfsrr,
+		.init	= au_wbr_create_init_mfsrr,
+		.fin	= au_wbr_create_fin_mfs
+	},
+	[AuWbrCreate_MFSRRV] = {
+		.create	= au_wbr_create_mfsrr,
+		.init	= au_wbr_create_init_mfsrr,
+		.fin	= au_wbr_create_fin_mfs
+	},
+	[AuWbrCreate_PMFS] = {
+		.create	= au_wbr_create_pmfs,
+		.init	= au_wbr_create_init_mfs,
+		.fin	= au_wbr_create_fin_mfs
+	},
+	[AuWbrCreate_PMFSV] = {
+		.create	= au_wbr_create_pmfs,
+		.init	= au_wbr_create_init_mfs,
+		.fin	= au_wbr_create_fin_mfs
+	}
+};
diff -Nurp linux-2.6.27.orig/fs/aufs/whout.c linux-2.6.27/fs/aufs/whout.c
--- linux-2.6.27.orig/fs/aufs/whout.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.27/fs/aufs/whout.c	2008-12-14 10:37:40.000000000 +0100
@@ -0,0 +1,1154 @@
+/*
+ * Copyright (C) 2005-2008 Junjiro Okajima
+ *
+ * This program, aufs is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+ */
+
+/*
+ * whiteout for logical deletion and opaque directory
+ *
+ * $Id: whout.c,v 1.18 2008/12/01 03:49:29 sfjro Exp $
+ */
+
+#include <linux/fs.h>
+#include <linux/namei.h>
+#include "aufs.h"
+
+#define WH_MASK			S_IRUGO
+
+/* If a directory contains this file, then it is opaque.  We start with the
+ * .wh. flag so that it is blocked by lookup.
+ */
+static struct qstr diropq_name = {
+	.name = AUFS_WH_DIROPQ,
+	.len = sizeof(AUFS_WH_DIROPQ) - 1
+};
+
+/*
+ * generate whiteout name, which is NOT terminated by NULL.
+ * @name: original d_name.name
+ * @len: original d_name.len
+ * @wh: whiteout qstr
+ * returns zero when succeeds, otherwise error.
+ * succeeded value as wh->name should be freed by au_wh_name_free().
+ */
+int au_wh_name_alloc(const char *name, int len, struct qstr *wh)
+{
+	char *p;
+
+	AuDebugOn(!name || !len || !wh);
+
+	if (unlikely(len > PATH_MAX - AUFS_WH_PFX_LEN))
+		return -ENAMETOOLONG;
+
+	wh->len = len + AUFS_WH_PFX_LEN;
+	p = kmalloc(wh->len, GFP_NOFS);
+	wh->name = p;
+	if (p) {
+		memcpy(p, AUFS_WH_PFX, AUFS_WH_PFX_LEN);
+		memcpy(p + AUFS_WH_PFX_LEN, name, len);
+		/* smp_mb(); */
+		return 0;
+	}
+	return -ENOMEM;
+}
+
+void au_wh_name_free(struct qstr *wh)
+{
+	AuDebugOn(!wh || !wh->name);
+	kfree(wh->name);
+}
+
+/* ---------------------------------------------------------------------- */
+
+/*
+ * test if the @wh_name exists under @h_parent.
+ * @try_sio specifies the necessary of super-io.
+ */
+int au_wh_test(struct dentry *h_parent, struct qstr *wh_name, int try_sio,
+	       struct au_ndx *ndx)
+{
+	int err;
+	struct dentry *wh_dentry;
+	struct inode *h_dir;
+	unsigned int flags;
+
+	LKTRTrace("%.*s/%.*s, ndx{%p, 0x%x}\n", AuDLNPair(h_parent),
+		  wh_name->len, wh_name->name, ndx->nfsmnt, ndx->flags);
+	h_dir = h_parent->d_inode;
+	AuDebugOn(!S_ISDIR(h_dir->i_mode));
+
+	flags = 0;
+	if (ndx && ndx->nd) {
+		flags = ndx->nd->flags;
+		ndx->nd->flags &= ~(LOOKUP_OPEN | LOOKUP_CREATE);
+	}
+
+	if (!try_sio)
+		wh_dentry = au_lkup_one(wh_name->name, h_parent,
+					wh_name->len, ndx);
+	else
+		wh_dentry = au_sio_lkup_one(wh_name->name, h_parent,
+					    wh_name->len, ndx);
+	if (flags)
+		ndx->nd->flags = flags;
+	err = PTR_ERR(wh_dentry);
+	if (IS_ERR(wh_dentry))
+		goto out;
+
+	err = 0;
+	if (!wh_dentry->d_inode)
+		goto out_wh; /* success */
+
+	err = 1;
+	if (S_ISREG(wh_dentry->d_inode->i_mode))
+		goto out_wh; /* success */
+
+	err = -EIO;
+	AuIOErr("%.*s Invalid whiteout entry type 0%o.\n",
+		AuDLNPair(wh_dentry), wh_dentry->d_inode->i_mode);
+
+ out_wh:
+	dput(wh_dentry);
+ out:
+	AuTraceErr(err);
+	return err;
+}
+
+/*
+ * test if the @h_dentry sets opaque or not.
+ */
+int au_diropq_test(struct dentry *h_dentry, struct au_ndx *ndx)
+{
+	int err, try_sio;
+	struct inode *h_dir;
+
+	LKTRTrace("dentry %.*s\n", AuDLNPair(h_dentry));
+	h_dir = h_dentry->d_inode;
+	AuDebugOn(!S_ISDIR(h_dir->i_mode));
+
+	try_sio = au_test_h_perm_sio(h_dir, MAY_EXEC,
+				     au_ftest_ndx(ndx->flags, DLGT));
+	err = au_wh_test(h_dentry, &diropq_name, try_sio, ndx);
+	AuTraceErr(err);
+	return err;
+}
+
+/*
+ * returns a negative dentry whose name is unique and temporary.
+ */
+struct dentry *au_whtmp_lkup(struct dentry *h_parent, struct qstr *prefix,
+			     struct au_ndx *ndx)
+{
+#define HEX_LEN 4
+	struct dentry *dentry;
+	int len, i;
+	char defname[AUFS_WH_PFX_LEN * 2 + DNAME_INLINE_LEN_MIN + 1
+		     + HEX_LEN + 1], *name, *p;
+	static unsigned char cnt;
+
+	LKTRTrace("hp %.*s, prefix %.*s\n",
+		  AuDLNPair(h_parent), prefix->len, prefix->name);
+	AuDebugOn(!h_parent->d_inode);
+
+	name = defname;
+	len = sizeof(defname) - DNAME_INLINE_LEN_MIN + prefix->len - 1;
+	if (unlikely(prefix->len > DNAME_INLINE_LEN_MIN)) {
+		dentry = ERR_PTR(-ENAMETOOLONG);
+		if (unlikely(len >= PATH_MAX))
+			goto out;
+		dentry = ERR_PTR(-ENOMEM);
+		name = kmalloc(len + 1, GFP_NOFS);
+		if (unlikely(!name))
+			goto out;
+	}
+
+	/* doubly whiteout-ed */
+	memcpy(name, AUFS_WH_PFX AUFS_WH_PFX, AUFS_WH_PFX_LEN * 2);
+	p = name + AUFS_WH_PFX_LEN * 2;
+	memcpy(p, prefix->name, prefix->len);
+	p += prefix->len;
+	*p++ = '.';
+	AuDebugOn(name + len + 1 - p <= HEX_LEN);
+
+	for (i = 0; i < 3; i++) {
+		sprintf(p, "%.*d", HEX_LEN, cnt++);
+		dentry = au_sio_lkup_one(name, h_parent, len, ndx);
+		if (IS_ERR(dentry) || !dentry->d_inode)
+			goto out_name;
+		dput(dentry);
+	}
+	/* AuWarn("could not get random name\n"); */
+	dentry = ERR_PTR(-EEXIST);
+	AuDbg("%.*s\n", len, name);
+	BUG();
+
+ out_name:
+	if (name != defname)
+		kfree(name);
+ out:
+	AuTraceErrPtr(dentry);
+	return dentry;
+#undef HEX_LEN
+}
+
+/*
+ * rename the @dentry of @bindex to the whiteouted temporary name.
+ */
+int au_whtmp_ren(struct inode *dir, aufs_bindex_t bindex,
+		 struct dentry *h_dentry)
+{
+	int err, dlgt;
+	struct inode *h_dir;
+	struct dentry *h_parent, *tmp_dentry;
+	struct super_block *sb;
+	unsigned int mnt_flags;
+	struct au_hin_ignore ign;
+	struct vfsub_args vargs;
+	struct au_ndx ndx = {
+		.flags	= 0,
+		.nd	= NULL,
+		/* .br	= NULL */
+	};
+
+	LKTRTrace("%.*s\n", AuDLNPair(h_dentry));
+	AuDebugOn(!h_dentry->d_inode);
+	h_parent = h_dentry->d_parent; /* dir inode is locked */
+	h_dir = h_parent->d_inode;
+	IMustLock(h_dir);
+
+	sb = dir->i_sb;
+	mnt_flags = au_mntflags(sb);
+	dlgt = !!au_test_dlgt(mnt_flags);
+	if (dlgt)
+		au_fset_ndx(ndx.flags, DLGT);
+	ndx.nfsmnt = au_nfsmnt(sb, bindex);
+	tmp_dentry = au_whtmp_lkup(h_parent, &h_dentry->d_name, &ndx);
+	err = PTR_ERR(tmp_dentry);
+	if (IS_ERR(tmp_dentry))
+		goto out;
+
+	/* under the same dir, no need to lock_rename() */
+	vfsub_args_init(&vargs, &ign, dlgt, 0);
+	AuDebugOn(!S_ISDIR(h_dentry->d_inode->i_mode));
+	vfsub_ign_hinode(&vargs, IN_MOVED_FROM | IN_MOVED_TO,
+			 au_hi(dir, bindex));
+	err = vfsub_rename(h_dir, h_dentry, h_dir, tmp_dentry, &vargs);
+	AuTraceErr(err);
+	dput(tmp_dentry);
+
+ out:
+	AuTraceErr(err);
+	return err;
+}
+
+/* ---------------------------------------------------------------------- */
+
+static int do_unlink_wh(struct au_hinode *hdir, struct inode *h_dir,
+			struct dentry *wh_dentry, const int dlgt)
+{
+	int err;
+	struct au_hin_ignore ign;
+	struct vfsub_args vargs;
+
+	AuDebugOn(hdir && h_dir);
+	AuDebugOn(!hdir && !h_dir);
+	if (!h_dir)
+		h_dir = hdir->hi_inode;
+	LKTRTrace("hi%lu, wh %.*s\n", h_dir->i_ino, AuDLNPair(wh_dentry));
+	AuDebugOn(!wh_dentry->d_inode || !S_ISREG(wh_dentry->d_inode->i_mode));
+
+	/*
+	 * forces superio when the dir has a sticky bit.
+	 * this may be a violation of unix fs semantics.
+	 */
+	vfsub_args_init(&vargs, &ign, dlgt,
+			(h_dir->i_mode & S_ISVTX)
+			&& wh_dentry->d_inode->i_uid != current->fsuid);
+	vfsub_ign_hinode(&vargs, IN_DELETE, hdir);
+	err = vfsub_unlink(h_dir, wh_dentry, &vargs);
+	AuTraceErr(err);
+	return err;
+}
+
+int au_wh_unlink_dentry(struct au_hinode *hdir, struct dentry *wh_dentry,
+			struct dentry *dentry, int dlgt)
+{
+	int err;
+
+	LKTRTrace("i%lu, wh %.*s, d %p\n",
+		  hdir->hi_inode->i_ino, AuDLNPair(wh_dentry), dentry);
+	AuDebugOn((dentry && au_dbwh(dentry) < 0)
+		  || !wh_dentry->d_inode
+		  || !S_ISREG(wh_dentry->d_inode->i_mode));
+
+	err = do_unlink_wh(hdir, /*h_dir*/NULL, wh_dentry, dlgt);
+	if (!err && dentry)
+		au_set_dbwh(dentry, -1);
+
+	AuTraceErr(err);
+	return err;
+}
+
+static int unlink_wh_name(struct dentry *h_parent, struct qstr *wh,
+			  struct au_ndx *ndx)
+{
+	int err;
+	struct dentry *wh_dentry;
+
+	LKTRTrace("%.*s/%.*s\n", AuDLNPair(h_parent), AuLNPair(wh));
+
+	/* au_test_h_perm() is already done */
+	wh_dentry = au_lkup_one(wh->name, h_parent, wh->len, ndx);
+	if (IS_ERR(wh_dentry))
+		err = PTR_ERR(wh_dentry);
+	else {
+		err = 0;
+		if (wh_dentry->d_inode && S_ISREG(wh_dentry->d_inode->i_mode))
+			err = do_unlink_wh(/*hdir*/NULL, h_parent->d_inode,
+					   wh_dentry,
+					   au_ftest_ndx(ndx->flags, DLGT));
+		dput(wh_dentry);
+	}
+
+	AuTraceErr(err);
+	return err;
+}
+
+/* ---------------------------------------------------------------------- */
+
+static void clean_wh(struct inode *h_dir, struct path *whpath,
+		     struct au_hinode *hdir, struct vfsub_args *vargs)
+{
+	int err;
+
+	AuTraceEnter();
+
+	if (!whpath->dentry->d_inode)
+		return;
+
+	err = au_mnt_want_write(whpath->mnt);
+	if (!err) {
+		vfsub_args_reinit(vargs);
+		vfsub_ign_hinode(vargs, IN_DELETE, hdir);
+		err = vfsub_unlink(h_dir, whpath->dentry, vargs);
+		au_mnt_drop_write(whpath->mnt);
+	}
+	if (unlikely(err))
+		AuWarn("failed unlink %.*s (%d), ignored.\n",
+		       AuDLNPair(whpath->dentry), err);
+}
+
+static void au_whdir_clean(struct inode *h_dir, struct path *whpath,
+			   struct au_hinode *hdir, struct vfsub_args *vargs)
+{
+	int err;
+
+	AuTraceEnter();
+
+	if (!whpath->dentry->d_inode)
+		return;
+
+	err = au_mnt_want_write(whpath->mnt);
+	if (!err) {
+		vfsub_args_reinit(vargs);
+		vfsub_ign_hinode(vargs, IN_DELETE, hdir);
+		err = vfsub_rmdir(h_dir, whpath->dentry, vargs);
+		au_mnt_drop_write(whpath->mnt);
+	}
+	if (unlikely(err))
+		AuWarn("failed rmdir %.*s (%d), ignored.\n",
+		       AuDLNPair(whpath->dentry), err);
+}
+
+static int test_linkable(struct inode *h_dir)
+{
+	if (h_dir->i_op && h_dir->i_op->link)
+		return 0;
+	return -ENOSYS;
+}
+
+/* todo: should this mkdir be done in /sbin/mount.aufs script? */
+static int au_whdir(struct inode *h_dir, struct path *path,
+		    struct au_hinode *hdir, struct vfsub_args *vargs)
+{
+	int err;
+
+	err = -EEXIST;
+	if (!path->dentry->d_inode) {
+		int mode = S_IRWXU;
+		if (au_test_nfs(path->dentry->d_sb))
+			mode |= S_IXUGO;
+		err = au_mnt_want_write(path->mnt);
+		if (!err) {
+			vfsub_args_reinit(vargs);
+			vfsub_ign_hinode(vargs, IN_CREATE, hdir);
+			err = vfsub_mkdir(h_dir, path->dentry, mode, vargs);
+			au_mnt_drop_write(path->mnt);
+		}
+	} else if (S_ISDIR(path->dentry->d_inode->i_mode))
+		err = 0;
+	else
+		AuErr("unknown %.*s exists\n", AuDLNPair(path->dentry));
+
+	return err;
+}
+
+/*
+ * initialize the whiteout base file/dir for @br.
+ */
+int au_wh_init(struct dentry *h_root, struct au_branch *br,
+	       struct vfsmount *h_mnt, struct super_block *sb,
+	       aufs_bindex_t bindex)
+{
+	int err, i;
+	const unsigned int mnt_flags = au_mntflags(sb);
+	const unsigned char do_plink = !!au_opt_test(mnt_flags, PLINK),
+		do_hinotify = au_opt_test(mnt_flags, UDBA_INOTIFY);
+	struct path path = {
+		.mnt = h_mnt
+	};
+	struct au_hin_ignore ign;
+	struct vfsub_args vargs;
+	struct inode *h_dir;
+	struct au_hinode *hdir;
+	struct au_wbr *wbr = br->br_wbr;
+	struct vfsmount *nfsmnt = au_do_nfsmnt(h_mnt);
+	static const struct qstr base_name[] = {
+		[AuBrWh_BASE] = {
+			.name	= AUFS_BASE_NAME,
+			.len	= sizeof(AUFS_BASE_NAME) - 1
+		},
+		[AuBrWh_PLINK] = {
+			.name	= AUFS_PLINKDIR_NAME,
+			.len	= sizeof(AUFS_PLINKDIR_NAME) - 1
+		},
+		[AuBrWh_TMP] = {
+			.name	= AUFS_TMPDIR_NAME,
+			.len	= sizeof(AUFS_TMPDIR_NAME) - 1
+		}
+	};
+	struct {
+		const struct qstr *name;
+		struct dentry *dentry;
+	} base[] = {
+		[AuBrWh_BASE] = {
+			.name	= base_name + AuBrWh_BASE,
+			.dentry	= NULL
+		},
+		[AuBrWh_PLINK] = {
+			.name	= base_name + AuBrWh_PLINK,
+			.dentry	= NULL
+		},
+		[AuBrWh_TMP] = {
+			.name	= base_name + AuBrWh_TMP,
+			.dentry	= NULL
+		}
+	};
+	struct au_ndx ndx = {
+		.nfsmnt	= nfsmnt,
+		.flags	= 0, /* always no dlgt */
+		.nd	= NULL,
+		/* .br	= NULL */
+	};
+
+	LKTRTrace("nfsmnt %p\n", nfsmnt);
+	WbrWhMustWriteLock(wbr);
+	SiMustWriteLock(sb);
+	h_dir = h_root->d_inode;
+
+	for (i = 0; i < AuBrWh_Last; i++) {
+		/* doubly whiteouted */
+		struct dentry *d;
+		d = au_wh_lkup(h_root, (void *)base[i].name, &ndx);
+		err = PTR_ERR(d);
+		if (IS_ERR(d))
+			goto out;
+		base[i].dentry = d;
+		AuDebugOn(wbr
+			  && wbr->wbr_wh[i]
+			  && wbr->wbr_wh[i] != base[i].dentry);
+	}
+
+	if (wbr)
+		for (i = 0; i < AuBrWh_Last; i++) {
+			dput(wbr->wbr_wh[i]);
+			wbr->wbr_wh[i] = NULL;
+		}
+
+	err = 0;
+	hdir = NULL;
+	if (bindex >= 0 && do_hinotify)
+		hdir = au_hi(sb->s_root->d_inode, bindex);
+	vfsub_args_init(&vargs, &ign, au_test_dlgt(mnt_flags), 0);
+
+	switch (br->br_perm) {
+	case AuBrPerm_RR:
+	case AuBrPerm_RO:
+	case AuBrPerm_RRWH:
+	case AuBrPerm_ROWH:
+		path.dentry = base[AuBrWh_BASE].dentry;
+		clean_wh(h_dir, &path, hdir, &vargs);
+		path.dentry = base[AuBrWh_PLINK].dentry;
+		au_whdir_clean(h_dir, &path, hdir, &vargs);
+		path.dentry = base[AuBrWh_TMP].dentry;
+		au_whdir_clean(h_dir, &path, hdir, &vargs);
+		break;
+
+	case AuBrPerm_RWNoLinkWH:
+		path.dentry = base[AuBrWh_BASE].dentry;
+		clean_wh(h_dir, &path, hdir, &vargs);
+		path.dentry = base[AuBrWh_PLINK].dentry;
+		if (do_plink) {
+			err = test_linkable(h_dir);
+			if (unlikely(err))
+				goto out_nolink;
+
+			err = au_whdir(h_dir, &path, hdir, &vargs);
+			if (unlikely(err))
+				goto out_err;
+			wbr->wbr_plink = dget(base[AuBrWh_PLINK].dentry);
+		} else
+			au_whdir_clean(h_dir, &path, hdir, &vargs);
+		path.dentry = base[AuBrWh_TMP].dentry;
+		err = au_whdir(h_dir, &path, hdir, &vargs);
+		if (unlikely(err))
+			goto out_err;
+		wbr->wbr_tmp = dget(base[AuBrWh_TMP].dentry);
+		break;
+
+	case AuBrPerm_RW:
+		/*
+		 * for the moment, aufs supports the branch filesystem
+		 * which does not support link(2).
+		 * testing on FAT which does not support i_op->setattr() fully
+		 * either, copyup failed.
+		 * finally, such filesystem will not be used as the writable
+		 * branch.
+		 */
+		err = test_linkable(h_dir);
+		if (unlikely(err))
+			goto out_nolink;
+
+		err = -EEXIST;
+		/*
+		 * todo: should this create be done
+		 * in /sbin/mount.aufs script?
+		 */
+		if (!base[AuBrWh_BASE].dentry->d_inode) {
+			err = au_mnt_want_write(h_mnt);
+			if (!err) {
+				vfsub_args_reinit(&vargs);
+				vfsub_ign_hinode(&vargs, IN_CREATE, hdir);
+				err = au_h_create
+					(h_dir, base[AuBrWh_BASE].dentry,
+					 WH_MASK, &vargs, /*nd*/NULL, nfsmnt);
+				au_mnt_drop_write(h_mnt);
+			}
+		} else if (S_ISREG(base[AuBrWh_BASE].dentry->d_inode->i_mode))
+			err = 0;
+		else
+			AuErr("unknown %.*s/%.*s exists\n",
+			      AuDLNPair(h_root),
+			      AuDLNPair(base[AuBrWh_BASE].dentry));
+		if (unlikely(err))
+			goto out_err;
+
+		path.dentry = base[AuBrWh_PLINK].dentry;
+		if (do_plink) {
+			err = au_whdir(h_dir, &path, hdir, &vargs);
+			if (unlikely(err))
+				goto out_err;
+			wbr->wbr_plink = dget(base[AuBrWh_PLINK].dentry);
+		} else
+			au_whdir_clean(h_dir, &path, hdir, &vargs);
+		wbr->wbr_whbase = dget(base[AuBrWh_BASE].dentry);
+
+		path.dentry = base[AuBrWh_TMP].dentry;
+		err = au_whdir(h_dir, &path, hdir, &vargs);
+		if (unlikely(err))
+			goto out_err;
+		wbr->wbr_tmp = dget(base[AuBrWh_TMP].dentry);
+		break;
+
+	default:
+		BUG();
+	}
+
+ out:
+	for (i = 0; i < AuBrWh_Last; i++)
+		dput(base[i].dentry);
+	AuTraceErr(err);
+	return err;
+ out_nolink:
+	AuErr("%.*s doesn't support link(2), use noplink and rw+nolwh\n",
+	      AuDLNPair(h_root));
+	goto out;
+ out_err:
+	AuErr("an error(%d) on the writable branch %.*s(%s)\n",
+	      err, AuDLNPair(h_root), au_sbtype(h_root->d_sb));
+	goto out;
+}
+
+struct reinit_br_wh {
+	struct super_block *sb;
+	struct au_branch *br;
+};
+
+static void reinit_br_wh(void *arg)
+{
+	int err;
+	struct reinit_br_wh *a = arg;
+	struct au_wbr *wbr;
+	struct inode *h_dir, *dir;
+	struct dentry *h_root;
+	aufs_bindex_t bindex;
+	struct au_hin_ignore ign;
+	struct vfsub_args vargs;
+
+	AuTraceEnter();
+	AuDebugOn(current->fsuid);
+
+	err = 0;
+	wbr = a->br->br_wbr;
+	/* big aufs lock */
+	si_noflush_write_lock(a->sb);
+	if (!au_br_writable(a->br->br_perm))
+		goto out;
+	bindex = au_br_index(a->sb, a->br->br_id);
+	if (unlikely(bindex < 0))
+		goto out;
+
+	AuDebugOn(!wbr);
+	AuDebugOn(!wbr->wbr_whbase || !wbr->wbr_whbase->d_inode);
+
+	dir = a->sb->s_root->d_inode;
+	ii_read_lock_parent(dir);
+	h_root = dget_parent(wbr->wbr_whbase);
+	h_dir = h_root->d_inode;
+	AuDebugOn(!h_dir->i_op || !h_dir->i_op->link);
+	mutex_lock_nested(&h_dir->i_mutex, AuLsc_I_PARENT);
+	wbr_wh_write_lock(wbr);
+	if (!au_verify_parent(wbr->wbr_whbase, h_dir)) {
+		err = au_br_want_write(a->br);
+		if (!err) {
+			vfsub_args_init(&vargs, &ign, /*dlgt*/0, 0);
+			vfsub_ign_hinode(&vargs, IN_DELETE, au_hi(dir, bindex));
+			err = vfsub_unlink(h_dir, wbr->wbr_whbase, &vargs);
+			au_br_drop_write(a->br);
+		}
+	} else {
+		AuWarn("%.*s is moved, ignored\n", AuDLNPair(wbr->wbr_whbase));
+		err = 0;
+	}
+	dput(wbr->wbr_whbase);
+	wbr->wbr_whbase = NULL;
+	if (!err)
+		err = au_wh_init(h_root, a->br, a->br->br_mnt, a->sb, bindex);
+	wbr_wh_write_unlock(wbr);
+	mutex_unlock(&h_dir->i_mutex);
+	dput(h_root);
+	ii_read_unlock(dir);
+
+ out:
+	if (wbr)
+		atomic_dec_return(&wbr->wbr_wh_running);
+	au_br_put(a->br);
+	au_nwt_done(&au_sbi(a->sb)->si_nowait);
+	si_write_unlock(a->sb);
+	kfree(arg);
+	if (unlikely(err))
+		AuIOErr("err %d\n", err);
+}
+
+static void kick_reinit_br_wh(struct super_block *sb, struct au_branch *br)
+{
+	int do_dec, wkq_err;
+	struct reinit_br_wh *arg;
+
+	AuTraceEnter();
+	AuDebugOn(!br->br_wbr);
+
+	do_dec = 1;
+	if (atomic_inc_return(&br->br_wbr->wbr_wh_running) != 1)
+		goto out;
+
+	/* ignore ENOMEM */
+	arg = kmalloc(sizeof(*arg), GFP_NOFS);
+	if (arg) {
+		/*
+		 * dec(wh_running), kfree(arg) and au_br_put()
+		 * in reinit function
+		 */
+		arg->sb = sb;
+		arg->br = br;
+		au_br_get(br);
+		wkq_err = au_wkq_nowait(reinit_br_wh, arg, sb, /*dlgt*/0);
+		if (unlikely(wkq_err)) {
+			atomic_dec_return(&br->br_wbr->wbr_wh_running);
+			au_br_put(br);
+			kfree(arg);
+		}
+		do_dec = 0;
+	}
+
+ out:
+	if (do_dec)
+		atomic_dec_return(&br->br_wbr->wbr_wh_running);
+}
+
+/*
+ * create the whiteout @wh.
+ */
+static int link_or_create_wh(struct super_block *sb, aufs_bindex_t bindex,
+			     struct dentry *wh, struct inode *dir)
+{
+	int err, dlgt;
+	struct au_branch *br;
+	struct au_wbr *wbr;
+	struct dentry *h_parent;
+	struct inode *h_dir;
+	struct au_hin_ignore ign;
+	struct vfsub_args vargs;
+
+	LKTRTrace("%.*s\n", AuDLNPair(wh));
+	h_parent = wh->d_parent; /* dir inode is locked */
+	h_dir = h_parent->d_inode;
+	IMustLock(h_dir);
+	br = au_sbr(sb, bindex);
+	wbr = br->br_wbr;
+	AuDebugOn(!wbr);
+
+	dlgt = !!au_test_dlgt(au_mntflags(sb));
+	wbr_wh_read_lock(wbr);
+	if (wbr->wbr_whbase) {
+		vfsub_args_init(&vargs, &ign, dlgt, 0);
+		if (dir)
+			vfsub_ign_hinode(&vargs, IN_CREATE, au_hi(dir, bindex));
+		err = vfsub_link(wbr->wbr_whbase, h_dir, wh, &vargs);
+		if (!err || err != -EMLINK)
+			goto out;
+
+		/* link count full. re-initialize br_whbase. */
+		kick_reinit_br_wh(sb, br);
+	}
+
+	/* return this error in this context */
+	vfsub_args_init(&vargs, &ign, dlgt, 0);
+	if (dir)
+		vfsub_ign_hinode(&vargs, IN_CREATE, au_hi(dir, bindex));
+	err = au_h_create(h_dir, wh, WH_MASK, &vargs, /*nd*/NULL,
+			  au_do_nfsmnt(br->br_mnt));
+
+ out:
+	wbr_wh_read_unlock(wbr);
+	AuTraceErr(err);
+	return err;
+}
+
+/* ---------------------------------------------------------------------- */
+
+/*
+ * create or remove the diropq.
+ */
+static struct dentry *do_diropq(struct dentry *dentry, aufs_bindex_t bindex,
+				unsigned int flags)
+{
+	struct dentry *opq_dentry, *h_dentry;
+	struct inode *h_dir;
+	int err, dlgt;
+	struct super_block *sb;
+	struct au_ndx ndx = {
+		.flags	= 0,
+		.nd	= NULL,
+		/* .br	= NULL */
+	};
+
+	LKTRTrace("%.*s, bindex %d, flags 0x%x\n",
+		  AuDLNPair(dentry), bindex, flags);
+	h_dentry = au_h_dptr(dentry, bindex);
+	AuDebugOn(!h_dentry);
+	h_dir = h_dentry->d_inode;
+	AuDebugOn(!h_dir || !S_ISDIR(h_dir->i_mode));
+
+	/* already checked by au_test_h_perm(). */
+	sb = dentry->d_sb;
+	ndx.nfsmnt = au_nfsmnt(sb, bindex);
+	dlgt = 0;
+	if (au_ftest_diropq(flags, DLGT)) {
+		dlgt = 1;
+		au_fset_ndx(ndx.flags, DLGT);
+	}
+	opq_dentry = au_lkup_one(diropq_name.name, h_dentry, diropq_name.len,
+				 &ndx);
+	if (IS_ERR(opq_dentry))
+		goto out;
+
+	if (au_ftest_diropq(flags, CREATE)) {
+		AuDebugOn(opq_dentry->d_inode);
+		err = link_or_create_wh(dentry->d_sb, bindex, opq_dentry,
+					dentry->d_inode);
+		if (!err) {
+			au_set_dbdiropq(dentry, bindex);
+			goto out; /* success */
+		}
+	} else {
+		AuDebugOn(/* !S_ISDIR(dentry->d_inode->i_mode)
+			   * ||  */!opq_dentry->d_inode);
+		err = do_unlink_wh(au_hi(dentry->d_inode, bindex),
+				   /*h_dir*/NULL, opq_dentry, dlgt);
+		if (!err)
+			au_set_dbdiropq(dentry, -1);
+	}
+	dput(opq_dentry);
+	opq_dentry = ERR_PTR(err);
+
+ out:
+	AuTraceErrPtr(opq_dentry);
+	return opq_dentry;
+}
+
+struct do_diropq_args {
+	struct dentry **errp;
+	struct dentry *dentry;
+	aufs_bindex_t bindex;
+	unsigned int flags;
+};
+
+static void call_do_diropq(void *args)
+{
+	struct do_diropq_args *a = args;
+	*a->errp = do_diropq(a->dentry, a->bindex, a->flags);
+}
+
+struct dentry *au_diropq_sio(struct dentry *dentry, aufs_bindex_t bindex,
+			     unsigned int flags)
+{
+	struct dentry *diropq, *h_dentry;
+
+	LKTRTrace("%.*s, bindex %d, flags 0x%x\n",
+		  AuDLNPair(dentry), bindex, flags);
+
+	h_dentry = au_h_dptr(dentry, bindex);
+	if (!au_test_h_perm_sio(h_dentry->d_inode, MAY_EXEC | MAY_WRITE,
+				au_ftest_diropq(flags, DLGT)))
+		diropq = do_diropq(dentry, bindex, flags);
+	else {
+		int wkq_err;
+		struct do_diropq_args args = {
+			.errp		= &diropq,
+			.dentry		= dentry,
+			.bindex		= bindex,
+			.flags		= flags
+		};
+		wkq_err = au_wkq_wait(call_do_diropq, &args, /*dlgt*/0);
+		if (unlikely(wkq_err))
+			diropq = ERR_PTR(wkq_err);
+	}
+
+	AuTraceErrPtr(diropq);
+	return diropq;
+}
+
+/* ---------------------------------------------------------------------- */
+
+/*
+ * lookup whiteout dentry.
+ * @h_parent: hidden parent dentry which must exist and be locked
+ * @base_name: name of dentry which will be whiteouted
+ * returns dentry for whiteout.
+ */
+struct dentry *au_wh_lkup(struct dentry *h_parent, struct qstr *base_name,
+			  struct au_ndx *ndx)
+{
+	int err;
+	struct qstr wh_name;
+	struct dentry *wh_dentry;
+
+	LKTRTrace("%.*s/%.*s\n", AuDLNPair(h_parent), AuLNPair(base_name));
+
+	err = au_wh_name_alloc(base_name->name, base_name->len, &wh_name);
+	wh_dentry = ERR_PTR(err);
+	if (!err) {
+		/* do not superio. */
+		wh_dentry = au_lkup_one(wh_name.name, h_parent,
+					wh_name.len, ndx);
+		au_wh_name_free(&wh_name);
+	}
+	AuTraceErrPtr(wh_dentry);
+	return wh_dentry;
+}
+
+/*
+ * link/create a whiteout for @dentry on @bindex.
+ */
+struct dentry *au_wh_create(struct dentry *dentry, aufs_bindex_t bindex,
+			    struct dentry *h_parent, struct au_ndx *ndx)
+{
+	struct dentry *wh_dentry;
+	struct inode *dir;
+	int err;
+	struct super_block *sb;
+
+	LKTRTrace("%.*s/%.*s on b%d\n", AuDLNPair(h_parent),
+		  AuDLNPair(dentry), bindex);
+
+	sb = dentry->d_sb;
+	wh_dentry = au_wh_lkup(h_parent, &dentry->d_name, ndx);
+	if (!IS_ERR(wh_dentry) && !wh_dentry->d_inode) {
+		dir = dentry->d_parent->d_inode; /* dir is locked */
+		IMustLock(dir);
+		err = link_or_create_wh(sb, bindex, wh_dentry, dir);
+		if (!err)
+			au_set_dbwh(dentry, bindex);
+		else {
+			dput(wh_dentry);
+			wh_dentry = ERR_PTR(err);
+		}
+	}
+
+	AuTraceErrPtr(wh_dentry);
+	return wh_dentry;
+}
+
+/* ---------------------------------------------------------------------- */
+
+/* Delete all whiteouts in this directory on branch bindex. */
+static int del_wh_children(struct dentry *h_dentry, struct au_nhash *whlist,
+			   aufs_bindex_t bindex, struct au_ndx *ndx)
+{
+	int err, i;
+	struct qstr wh_name;
+	char *p;
+	struct inode *h_inode;
+	struct hlist_head *head;
+	struct au_vdir_wh *tpos;
+	struct hlist_node *pos;
+	struct au_vdir_destr *str;
+
+	LKTRTrace("%.*s\n", AuDLNPair(h_dentry));
+	h_inode = h_dentry->d_inode;
+	AuDebugOn(IS_RDONLY(h_inode));
+
+	err = -ENOMEM;
+	p = __getname();
+	wh_name.name = p;
+	if (unlikely(!wh_name.name))
+		goto out;
+	memcpy(p, AUFS_WH_PFX, AUFS_WH_PFX_LEN);
+	p += AUFS_WH_PFX_LEN;
+
+	/* already checked by au_test_h_perm(). */
+	err = 0;
+	for (i = 0; !err && i < AuSize_NHASH; i++) {
+		head = whlist->heads + i;
+		hlist_for_each_entry(tpos, pos, head, wh_hash) {
+			if (tpos->wh_bindex != bindex)
+				continue;
+			str = &tpos->wh_str;
+			if (str->len + AUFS_WH_PFX_LEN <= PATH_MAX) {
+				memcpy(p, str->name, str->len);
+				wh_name.len = AUFS_WH_PFX_LEN + str->len;
+				err = unlink_wh_name(h_dentry, &wh_name, ndx);
+				if (!err)
+					continue;
+				break;
+			}
+			AuIOErr("whiteout name too long %.*s\n",
+				str->len, str->name);
+			err = -EIO;
+			break;
+		}
+	}
+	__putname(wh_name.name);
+
+ out:
+	AuTraceErr(err);
+	return err;
+}
+
+struct del_wh_children_args {
+	int *errp;
+	struct dentry *h_dentry;
+	struct au_nhash *whlist;
+	aufs_bindex_t bindex;
+	struct au_ndx *ndx;
+};
+
+static void call_del_wh_children(void *args)
+{
+	struct del_wh_children_args *a = args;
+	*a->errp = del_wh_children(a->h_dentry, a->whlist, a->bindex, a->ndx);
+}
+
+/* ---------------------------------------------------------------------- */
+
+/*
+ * rmdir the whiteouted temporary named dir @h_dentry.
+ * @whlist: whiteouted children.
+ */
+int au_whtmp_rmdir(struct inode *dir, aufs_bindex_t bindex,
+		   struct dentry *wh_dentry, struct au_nhash *whlist)
+{
+	int err, dlgt;
+	struct inode *wh_inode, *h_dir;
+	struct super_block *sb;
+	unsigned int mnt_flags;
+	struct au_hin_ignore ign;
+	struct vfsub_args vargs;
+	struct au_ndx ndx = {
+		.flags	= 0,
+		.nd	= NULL,
+		/* .br	= NULL */
+	};
+
+	LKTRTrace("i%lu, %.*s, b%d\n",
+		  dir->i_ino, AuDLNPair(wh_dentry), bindex);
+	/* IMustLock(dir); */
+	IiMustAnyLock(dir);
+	h_dir = wh_dentry->d_parent->d_inode; /* dir inode is locked */
+	IMustLock(h_dir);
+
+	sb = dir->i_sb;
+	mnt_flags = au_mntflags(sb);
+	dlgt = !!au_test_dlgt(mnt_flags);
+	if (dlgt)
+		au_fset_ndx(ndx.flags, DLGT);
+	ndx.nfsmnt = au_nfsmnt(sb, bindex);
+	wh_inode = wh_dentry->d_inode;
+	mutex_lock_nested(&wh_inode->i_mutex, AuLsc_I_CHILD);
+
+	/*
+	 * someone else might change some whiteouts while we were sleeping.
+	 * it means this whlist may have an obsoleted entry.
+	 */
+	if (!au_test_h_perm_sio(wh_inode, MAY_EXEC | MAY_WRITE, dlgt))
+		err = del_wh_children(wh_dentry, whlist, bindex, &ndx);
+	else {
+		int wkq_err;
+		/* ugly */
+		unsigned int flags = ndx.flags;
+		struct del_wh_children_args args = {
+			.errp		= &err,
+			.h_dentry	= wh_dentry,
+			.whlist		= whlist,
+			.bindex		= bindex,
+			.ndx		= &ndx
+		};
+
+		ndx.flags = 0;
+		wkq_err = au_wkq_wait(call_del_wh_children, &args, /*dlgt*/0);
+		if (unlikely(wkq_err))
+			err = wkq_err;
+		ndx.flags = flags;
+	}
+	mutex_unlock(&wh_inode->i_mutex);
+
+	if (!err) {
+		vfsub_args_init(&vargs, &ign, dlgt, 0);
+		vfsub_ign_hinode(&vargs, IN_DELETE, au_hi(dir, bindex));
+		err = vfsub_rmdir(h_dir, wh_dentry, &vargs);
+		/* d_drop(h_dentry); */
+	}
+
+	if (!err) {
+		if (au_ibstart(dir) == bindex) {
+			au_cpup_attr_timesizes(dir);
+			/* au_cpup_attr_nlink(dir); */
+			drop_nlink(dir);
+		}
+		return 0; /* success */
+	}
+
+	AuWarn("failed removing %.*s(%d), ignored\n",
+	       AuDLNPair(wh_dentry), err);
+	return err;
+}
+
+static void au_whtmp_rmdir_free_args(struct au_whtmp_rmdir_args *args)
+{
+	au_nhash_fin(&args->whlist);
+	dput(args->wh_dentry);
+	iput(args->dir);
+	kfree(args);
+}
+
+static void call_rmdir_whtmp(void *args)
+{
+	int err;
+	struct au_whtmp_rmdir_args *a = args;
+	struct super_block *sb;
+	struct dentry *h_parent;
+	struct inode *h_dir;
+
+	LKTRTrace("%.*s, b%d, dir i%lu\n",
+		  AuDLNPair(a->wh_dentry), a->bindex, a->dir->i_ino);
+
+	/* rmdir by nfsd may cause deadlock with this i_mutex */
+	/* mutex_lock(&a->dir->i_mutex); */
+	sb = a->dir->i_sb;
+	si_noflush_read_lock(sb);
+	err = au_test_ro(sb, a->bindex, NULL);
+	if (unlikely(err))
+		goto out;
+
+	err = -EIO;
+	ii_write_lock_parent(a->dir);
+	h_parent = dget_parent(a->wh_dentry);
+	h_dir = h_parent->d_inode;
+	mutex_lock_nested(&h_dir->i_mutex, AuLsc_I_PARENT);
+	if (!au_verify_parent(a->wh_dentry, h_dir)) {
+		err = au_br_want_write(au_sbr(sb, a->bindex));
+		if (!err) {
+			err = au_whtmp_rmdir(a->dir, a->bindex, a->wh_dentry,
+					     &a->whlist);
+			au_br_drop_write(au_sbr(sb, a->bindex));
+		}
+	}
+	mutex_unlock(&h_dir->i_mutex);
+	dput(h_parent);
+	ii_write_unlock(a->dir);
+
+ out:
+	/* mutex_unlock(&a->dir->i_mutex); */
+	au_nwt_done(&au_sbi(sb)->si_nowait);
+	si_read_unlock(sb);
+	au_whtmp_rmdir_free_args(a);
+	if (unlikely(err))
+		AuIOErr("err %d\n", err);
+}
+
+void au_whtmp_kick_rmdir(struct inode *dir, aufs_bindex_t bindex,
+			 struct dentry *wh_dentry, struct au_nhash *whlist,
+			 struct au_whtmp_rmdir_args *args)
+{
+	int wkq_err;
+
+	LKTRTrace("%.*s\n", AuDLNPair(wh_dentry));
+	IMustLock(dir);
+
+	/* all post-process will be done in do_rmdir_whtmp(). */
+	args->dir = au_igrab(dir);
+	args->bindex = bindex;
+	args->wh_dentry = dget(wh_dentry);
+	au_nhash_init(&args->whlist);
+	au_nhash_move(&args->whlist, whlist);
+	wkq_err = au_wkq_nowait(call_rmdir_whtmp, args, dir->i_sb, /*dlgt*/0);
+	if (unlikely(wkq_err)) {
+		AuWarn("rmdir error %.*s (%d), ignored\n",
+		       AuDLNPair(wh_dentry), wkq_err);
+		au_whtmp_rmdir_free_args(args);
+	}
+}
diff -Nurp linux-2.6.27.orig/fs/aufs/whout.h linux-2.6.27/fs/aufs/whout.h
--- linux-2.6.27.orig/fs/aufs/whout.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.27/fs/aufs/whout.h	2008-12-14 10:37:40.000000000 +0100
@@ -0,0 +1,137 @@
+/*
+ * Copyright (C) 2005-2008 Junjiro Okajima
+ *
+ * This program, aufs is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+ */
+
+/*
+ * whiteout for logical deletion and opaque directory
+ *
+ * $Id: whout.h,v 1.4 2008/12/01 03:49:29 sfjro Exp $
+ */
+
+#ifndef __AUFS_WHOUT_H__
+#define __AUFS_WHOUT_H__
+
+#ifdef __KERNEL__
+
+#include <linux/fs.h>
+#include <linux/aufs_type.h>
+#include "dir.h"
+#include "opts.h"
+#include "super.h"
+
+int au_wh_name_alloc(const char *name, int len, struct qstr *wh);
+void au_wh_name_free(struct qstr *wh);
+
+struct au_ndx;
+int au_wh_test(struct dentry *h_parent, struct qstr *wh_name, int try_sio,
+	       struct au_ndx *ndx);
+int au_diropq_test(struct dentry *h_dentry, struct au_ndx *ndx);
+
+struct dentry *au_whtmp_lkup(struct dentry *h_parent, struct qstr *prefix,
+			     struct au_ndx *ndx);
+int au_whtmp_ren(struct inode *dir, aufs_bindex_t bindex,
+		 struct dentry *h_dentry);
+int au_wh_unlink_dentry(struct au_hinode *dir, struct dentry *wh_dentry,
+			struct dentry *dentry, int dlgt);
+
+struct au_branch;
+int au_wh_init(struct dentry *h_parent, struct au_branch *br,
+	       struct vfsmount *nfsmnt, struct super_block *sb,
+	       aufs_bindex_t bindex);
+
+/* diropq flags */
+#define AuDiropq_CREATE	1
+#define AuDiropq_DLGT	(1 << 1)
+#define au_ftest_diropq(flags, name)	((flags) & AuDiropq_##name)
+#define au_fset_diropq(flags, name)	{ (flags) |= AuDiropq_##name; }
+#define au_fclr_diropq(flags, name)	{ (flags) &= ~AuDiropq_##name; }
+#ifndef CONFIG_AUFS_DLGT
+#undef AuDiropq_DLGT
+#define AuDiropq_DLGT	0
+#endif
+
+struct dentry *au_diropq_sio(struct dentry *dentry, aufs_bindex_t bindex,
+			     unsigned int flags);
+
+struct dentry *au_wh_lkup(struct dentry *h_parent, struct qstr *base_name,
+			  struct au_ndx *ndx);
+struct dentry *au_wh_create(struct dentry *dentry, aufs_bindex_t bindex,
+			    struct dentry *h_parent, struct au_ndx *ndx);
+
+/* real rmdir the whiteout-ed dir */
+struct au_whtmp_rmdir_args {
+	struct inode *dir;
+	aufs_bindex_t bindex;
+	struct dentry *wh_dentry;
+	struct au_nhash whlist;
+};
+
+struct au_nhash;
+int au_whtmp_rmdir(struct inode *dir, aufs_bindex_t bindex,
+		   struct dentry *wh_dentry, struct au_nhash *whlist);
+void au_whtmp_kick_rmdir(struct inode *dir, aufs_bindex_t bindex,
+			 struct dentry *wh_dentry, struct au_nhash *whlist,
+			 struct au_whtmp_rmdir_args *args);
+
+/* ---------------------------------------------------------------------- */
+
+static inline
+struct dentry *au_diropq_create(struct dentry *dentry, aufs_bindex_t bindex,
+				int dlgt)
+{
+	unsigned int flags = AuDiropq_CREATE;
+	if (dlgt)
+		au_fset_diropq(flags, DLGT);
+	return au_diropq_sio(dentry, bindex, flags);
+}
+
+static inline
+int au_diropq_remove(struct dentry *dentry, aufs_bindex_t bindex, int dlgt)
+{
+	unsigned int flags = !AuDiropq_CREATE;
+	if (dlgt)
+		au_fset_diropq(flags, DLGT);
+	return PTR_ERR(au_diropq_sio(dentry, bindex, flags));
+}
+
+/* ---------------------------------------------------------------------- */
+
+#ifdef CONFIG_AUFS_ROBR
+/* robr.c */
+int au_test_robr_wh(struct qstr *name, struct dentry *h_parent,
+		    struct qstr *wh_name, int try_sio, struct au_ndx *ndx);
+int au_test_robr_shwh(struct super_block *sb, const struct qstr *name);
+#else
+static inline
+int au_test_robr_wh(struct qstr *name, struct dentry *h_parent,
+		    struct qstr *wh_name, int try_sio, struct au_ndx *ndx)
+{
+	return au_wh_test(h_parent, wh_name, try_sio, ndx);
+}
+
+static inline
+int au_test_robr_shwh(struct super_block *sb, const struct qstr *name)
+{
+	if (unlikely(!au_opt_test(au_mntflags(sb), SHWH)
+		     && !strncmp(name->name, AUFS_WH_PFX, AUFS_WH_PFX_LEN)))
+		return -EPERM;
+	return 0;
+}
+#endif /* CONFIG_AUFS_ROBR */
+
+#endif /* __KERNEL__ */
+#endif /* __AUFS_WHOUT_H__ */
diff -Nurp linux-2.6.27.orig/fs/aufs/wkq.c linux-2.6.27/fs/aufs/wkq.c
--- linux-2.6.27.orig/fs/aufs/wkq.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.27/fs/aufs/wkq.c	2008-12-14 10:37:40.000000000 +0100
@@ -0,0 +1,366 @@
+/*
+ * Copyright (C) 2005-2008 Junjiro Okajima
+ *
+ * This program, aufs is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+ */
+
+/*
+ * workqueue for asynchronous/super-io/delegated operations
+ *
+ * $Id: wkq.c,v 1.16 2008/12/01 03:49:29 sfjro Exp $
+ */
+
+#include <linux/module.h>
+#include "aufs.h"
+
+struct au_wkq *au_wkq;
+
+struct au_cred {
+#ifdef CONFIG_AUFS_DLGT
+	int umask;
+	uid_t fsuid;
+	gid_t fsgid;
+	kernel_cap_t cap_effective, cap_inheritable, cap_permitted;
+#if 0 /* reserved for future use */
+	unsigned keep_capabilities:1;
+	struct user_struct *user;
+	struct fs_struct *fs;
+	struct nsproxy *nsproxy;
+#endif
+#endif
+};
+
+struct au_wkinfo {
+	struct work_struct wk;
+	struct super_block *sb;
+
+	unsigned int flags;
+	struct au_cred cred;
+
+	au_wkq_func_t func;
+	void *args;
+
+	atomic_t *busyp;
+	struct completion *comp;
+};
+
+/* ---------------------------------------------------------------------- */
+
+#ifdef CONFIG_AUFS_DLGT
+static void cred_store(struct au_cred *cred)
+{
+	cred->umask = current->fs->umask;
+	cred->fsuid = current->fsuid;
+	cred->fsgid = current->fsgid;
+	cred->cap_effective = current->cap_effective;
+	cred->cap_inheritable = current->cap_inheritable;
+	cred->cap_permitted = current->cap_permitted;
+}
+
+static void cred_revert(struct au_cred *cred)
+{
+	AuDebugOn(!au_test_wkq(current));
+	current->fs->umask = cred->umask;
+	current->fsuid = cred->fsuid;
+	current->fsgid = cred->fsgid;
+	current->cap_effective = cred->cap_effective;
+	current->cap_inheritable = cred->cap_inheritable;
+	current->cap_permitted = cred->cap_permitted;
+}
+
+static void cred_switch(struct au_cred *old, struct au_cred *new)
+{
+	cred_store(old);
+	cred_revert(new);
+}
+
+static void dlgt_cred_store(unsigned int flags, struct au_wkinfo *wkinfo)
+{
+	if (au_ftest_wkq(flags, DLGT))
+		cred_store(&wkinfo->cred);
+}
+
+static void dlgt_func(struct au_wkinfo *wkinfo)
+{
+	if (!au_ftest_wkq(wkinfo->flags, DLGT))
+		wkinfo->func(wkinfo->args);
+	else {
+		struct au_cred cred;
+		cred_switch(&cred, &wkinfo->cred);
+		wkinfo->func(wkinfo->args);
+		cred_revert(&cred);
+	}
+}
+#else
+static void dlgt_cred_store(unsigned int flags, struct au_wkinfo *wkinfo)
+{
+	/* empty */
+}
+
+static void dlgt_func(struct au_wkinfo *wkinfo)
+{
+	wkinfo->func(wkinfo->args);
+}
+#endif /* CONFIG_AUFS_DLGT */
+
+/* ---------------------------------------------------------------------- */
+
+static void update_busy(struct au_wkq *wkq, struct au_wkinfo *wkinfo)
+{
+#ifdef CONFIG_AUFS_STAT
+	unsigned int new, old;
+
+	do {
+		new = atomic_read(wkinfo->busyp);
+		old = wkq->max_busy;
+		if (new <= old)
+			break;
+	} while (cmpxchg(&wkq->max_busy, old, new) == old);
+#endif
+}
+
+static int enqueue(struct au_wkq *wkq, struct au_wkinfo *wkinfo)
+{
+	AuTraceEnter();
+
+	wkinfo->busyp = &wkq->busy;
+	update_busy(wkq, wkinfo);
+	if (au_ftest_wkq(wkinfo->flags, WAIT))
+		return !queue_work(wkq->q, &wkinfo->wk);
+	else
+		return !schedule_work(&wkinfo->wk);
+}
+
+static void do_wkq(struct au_wkinfo *wkinfo)
+{
+	unsigned int idle, n;
+	int i, idle_idx;
+
+	AuTraceEnter();
+
+	while (1) {
+		if (au_ftest_wkq(wkinfo->flags, WAIT)) {
+			idle_idx = 0;
+			idle = UINT_MAX;
+			for (i = 0; i < aufs_nwkq; i++) {
+				n = atomic_inc_return(&au_wkq[i].busy);
+				if (n == 1 && !enqueue(au_wkq + i, wkinfo))
+					return; /* success */
+
+				if (n < idle) {
+					idle_idx = i;
+					idle = n;
+				}
+				atomic_dec_return(&au_wkq[i].busy);
+			}
+		} else
+			idle_idx = aufs_nwkq;
+
+		atomic_inc_return(&au_wkq[idle_idx].busy);
+		if (!enqueue(au_wkq + idle_idx, wkinfo))
+			return; /* success */
+
+		/* impossible? */
+		AuWarn1("failed to queue_work()\n");
+		yield();
+	}
+}
+
+static void wkq_func(struct work_struct *wk)
+{
+	struct au_wkinfo *wkinfo = container_of(wk, struct au_wkinfo, wk);
+
+	LKTRTrace("wkinfo{0x%x, %p, %p, %p}\n",
+		  wkinfo->flags, wkinfo->func, wkinfo->busyp, wkinfo->comp);
+
+	dlgt_func(wkinfo);
+	atomic_dec_return(wkinfo->busyp);
+	if (au_ftest_wkq(wkinfo->flags, WAIT))
+		complete(wkinfo->comp);
+	else {
+		kobject_put(&au_sbi(wkinfo->sb)->si_kobj);
+		module_put(THIS_MODULE);
+		kfree(wkinfo);
+	}
+}
+
+#if defined(CONFIG_4KSTACKS) || defined(Test4KSTACKS)
+#define AuWkqCompDeclare(name)	struct completion *comp = NULL
+
+static int au_wkq_comp_alloc(struct au_wkinfo *wkinfo, struct completion **comp)
+{
+	*comp = kmalloc(sizeof(**comp), GFP_NOFS);
+	if (*comp) {
+		init_completion(*comp);
+		wkinfo->comp = *comp;
+		return 0;
+	}
+	return -ENOMEM;
+}
+
+static void au_wkq_comp_free(struct completion *comp)
+{
+	kfree(comp);
+}
+
+#else
+
+/* no braces */
+#define AuWkqCompDeclare(name) \
+	DECLARE_COMPLETION_ONSTACK(_ ## name); \
+	struct completion *comp = &_ ## name
+
+static int au_wkq_comp_alloc(struct au_wkinfo *wkinfo, struct completion **comp)
+{
+	wkinfo->comp = *comp;
+	return 0;
+}
+
+static void au_wkq_comp_free(struct completion *comp)
+{
+	/* empty */
+}
+#endif /* 4KSTACKS */
+
+static void au_wkq_run(struct au_wkinfo *wkinfo)
+{
+#if 1 /* tmp debug */
+	if (au_test_wkq(current))
+		au_dbg_blocked();
+#endif
+	AuDebugOn(au_test_wkq(current));
+
+	INIT_WORK(&wkinfo->wk, wkq_func);
+	dlgt_cred_store(wkinfo->flags, wkinfo);
+	do_wkq(wkinfo);
+}
+
+int au_wkq_wait(au_wkq_func_t func, void *args, int dlgt)
+{
+	int err;
+	AuWkqCompDeclare(comp);
+	struct au_wkinfo wkinfo = {
+		.flags	= AuWkq_WAIT,
+		.func	= func,
+		.args	= args
+	};
+
+	LKTRTrace("dlgt %d\n", dlgt);
+
+	err = au_wkq_comp_alloc(&wkinfo, &comp);
+	if (!err) {
+		if (dlgt)
+			au_fset_wkq(wkinfo.flags, DLGT);
+		au_wkq_run(&wkinfo);
+		/* no timeout, no interrupt */
+		wait_for_completion(wkinfo.comp);
+		au_wkq_comp_free(comp);
+	}
+
+	AuTraceErr(err);
+	return err;
+
+}
+
+int au_wkq_nowait(au_wkq_func_t func, void *args, struct super_block *sb,
+		  int dlgt)
+{
+	int err;
+	struct au_wkinfo *wkinfo;
+
+	LKTRTrace("dlgt %d\n", dlgt);
+	AuDebugOn(!sb);
+
+	atomic_inc_return(&au_sbi(sb)->si_nowait.nw_len);
+
+	/*
+	 * wkq_func() must free this wkinfo.
+	 * it highly depends upon the implementation of workqueue.
+	 */
+	err = 0;
+	wkinfo = kmalloc(sizeof(*wkinfo), GFP_NOFS);
+	if (wkinfo) {
+		wkinfo->sb = sb;
+		wkinfo->flags = !AuWkq_WAIT;
+		wkinfo->func = func;
+		wkinfo->args = args;
+		wkinfo->comp = NULL;
+		if (dlgt)
+			au_fset_wkq(wkinfo->flags, DLGT);
+		kobject_get(&au_sbi(sb)->si_kobj);
+		__module_get(THIS_MODULE);
+
+		au_wkq_run(wkinfo);
+	} else {
+		err = -ENOMEM;
+		atomic_dec_return(&au_sbi(sb)->si_nowait.nw_len);
+	}
+
+	AuTraceErr(err);
+	return err;
+}
+
+/* ---------------------------------------------------------------------- */
+
+void au_wkq_fin(void)
+{
+	int i;
+
+	AuTraceEnter();
+
+	for (i = 0; i < aufs_nwkq; i++)
+		if (au_wkq[i].q && !IS_ERR(au_wkq[i].q))
+			destroy_workqueue(au_wkq[i].q);
+	kfree(au_wkq);
+}
+
+int __init au_wkq_init(void)
+{
+	int err, i;
+	struct au_wkq *nowaitq;
+
+	LKTRTrace("%d\n", aufs_nwkq);
+
+	/* '+1' is for accounting  of nowait queue */
+	err = -ENOMEM;
+	au_wkq = kcalloc(aufs_nwkq + 1, sizeof(*au_wkq), GFP_NOFS);
+	if (unlikely(!au_wkq))
+		goto out;
+
+	err = 0;
+	for (i = 0; i < aufs_nwkq; i++) {
+		au_wkq[i].q = create_singlethread_workqueue(AUFS_WKQ_NAME);
+		if (au_wkq[i].q && !IS_ERR(au_wkq[i].q)) {
+			atomic_set(&au_wkq[i].busy, 0);
+			au_wkq_max_busy_init(au_wkq + i);
+			continue;
+		}
+
+		err = PTR_ERR(au_wkq[i].q);
+		au_wkq_fin();
+		break;
+	}
+
+	/* nowait accounting */
+	nowaitq = au_wkq + aufs_nwkq;
+	atomic_set(&nowaitq->busy, 0);
+	au_wkq_max_busy_init(nowaitq);
+	nowaitq->q = NULL;
+	/* smp_mb(); */ /* atomic_set */
+
+ out:
+	AuTraceErr(err);
+	return err;
+}
diff -Nurp linux-2.6.27.orig/fs/aufs/wkq.h linux-2.6.27/fs/aufs/wkq.h
--- linux-2.6.27.orig/fs/aufs/wkq.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.27/fs/aufs/wkq.h	2008-10-20 03:47:43.000000000 +0200
@@ -0,0 +1,128 @@
+/*
+ * Copyright (C) 2005-2008 Junjiro Okajima
+ *
+ * This program, aufs is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+ */
+
+/*
+ * workqueue for asynchronous/super-io/delegated operations
+ *
+ * $Id: wkq.h,v 1.9 2008/10/20 01:47:43 sfjro Exp $
+ */
+
+#ifndef __AUFS_WKQ_H__
+#define __AUFS_WKQ_H__
+
+#ifdef __KERNEL__
+
+#include <linux/fs.h>
+#include <linux/sched.h>
+#include <linux/workqueue.h>
+#include <linux/aufs_type.h>
+
+/* ---------------------------------------------------------------------- */
+
+/* internal workqueue named AUFS_WKQ_NAME */
+struct au_wkq {
+	struct workqueue_struct	*q;
+
+	/* balancing */
+	atomic_t		busy;
+
+	/* accounting */
+#ifdef CONFIG_AUFS_STAT
+	unsigned int		max_busy;
+#endif
+};
+
+/*
+ * in the next operation, wait for the 'nowait' tasks in system-wide workqueue
+ */
+struct au_nowait_tasks {
+	atomic_t		nw_len;
+	wait_queue_head_t	nw_wq;
+};
+
+/* ---------------------------------------------------------------------- */
+
+extern struct au_wkq *au_wkq;
+typedef void (*au_wkq_func_t)(void *args);
+
+/* wkq flags */
+#define AuWkq_WAIT	1
+#define AuWkq_DLGT	(1 << 1)
+#define au_ftest_wkq(flags, name)	((flags) & AuWkq_##name)
+#define au_fset_wkq(flags, name)	{ (flags) |= AuWkq_##name; }
+#define au_fclr_wkq(flags, name)	{ (flags) &= ~AuWkq_##name; }
+#ifndef CONFIG_AUFS_DLGT
+#undef AuWkq_DLGT
+#define AuWkq_DLGT	0
+#endif
+
+int au_wkq_wait(au_wkq_func_t func, void *args, int dlgt);
+int au_wkq_nowait(au_wkq_func_t func, void *args, struct super_block *sb,
+		  int dlgt);
+int __init au_wkq_init(void);
+void au_wkq_fin(void);
+
+/* ---------------------------------------------------------------------- */
+
+static inline int au_test_nowait_wkq(struct task_struct *tsk)
+{
+	static const char *p = "events";
+	return !tsk->mm && !strncmp(tsk->comm, p, strlen(p));
+}
+
+static inline int au_test_wkq(struct task_struct *tsk)
+{
+	return !tsk->mm && !strcmp(tsk->comm, AUFS_WKQ_NAME);
+#if 0 /* reserved for future use, per-cpu workqueue */
+	return !tsk->mm
+		&& !memcmp(tsk->comm, AUFS_WKQ_NAME "/",
+			   sizeof(AUFS_WKQ_NAME));
+#endif
+}
+
+static inline void au_wkq_max_busy_init(struct au_wkq *wkq)
+{
+#ifdef CONFIG_AUFS_STAT
+	wkq->max_busy = 0;
+#endif
+}
+
+/* todo: memory barrier? */
+static inline void au_nwt_init(struct au_nowait_tasks *nwt)
+{
+	atomic_set(&nwt->nw_len, 0);
+	smp_mb(); /* atomic_set */
+	init_waitqueue_head(&nwt->nw_wq);
+}
+
+static inline void au_nwt_done(struct au_nowait_tasks *nwt)
+{
+	AuTraceEnter();
+
+	if (!atomic_dec_return(&nwt->nw_len))
+		wake_up_all(&nwt->nw_wq);
+}
+
+static inline int au_nwt_flush(struct au_nowait_tasks *nwt)
+{
+	wait_event(nwt->nw_wq, !atomic_read(&nwt->nw_len));
+	return 0;
+}
+
+#endif /* __KERNEL__ */
+#endif /* __AUFS_WKQ_H__ */
diff -Nurp linux-2.6.27.orig/fs/aufs/xino.c linux-2.6.27/fs/aufs/xino.c
--- linux-2.6.27.orig/fs/aufs/xino.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.27/fs/aufs/xino.c	2008-12-14 10:37:40.000000000 +0100
@@ -0,0 +1,1264 @@
+/*
+ * Copyright (C) 2005-2008 Junjiro Okajima
+ *
+ * This program, aufs is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+ */
+
+/*
+ * external inode number translation table and bitmap
+ *
+ * $Id: xino.c,v 1.19 2008/12/01 03:49:29 sfjro Exp $
+ */
+
+#include <linux/uaccess.h>
+#include "aufs.h"
+
+/* ---------------------------------------------------------------------- */
+
+ssize_t xino_fread(au_readf_t func, struct file *file, void *buf, size_t size,
+		   loff_t *pos)
+{
+	ssize_t err;
+	mm_segment_t oldfs;
+
+	LKTRTrace("%.*s, sz %zu, *pos %lld\n",
+		  AuDLNPair(file->f_dentry), size, *pos);
+
+	oldfs = get_fs();
+	set_fs(KERNEL_DS);
+	do {
+		/* todo: signal_pending? */
+		err = func(file, (char __user *)buf, size, pos);
+	} while (err == -EAGAIN || err == -EINTR);
+	set_fs(oldfs);
+
+#if 0 /* reserved for future use */
+	if (err > 0)
+		fsnotify_access(file->f_dentry);
+#endif
+
+	AuTraceErr(err);
+	return err;
+}
+
+/* ---------------------------------------------------------------------- */
+
+static ssize_t do_xino_fwrite(au_writef_t func, struct file *file, void *buf,
+			      size_t size, loff_t *pos)
+{
+	ssize_t err;
+	mm_segment_t oldfs;
+
+	lockdep_off();
+	oldfs = get_fs();
+	set_fs(KERNEL_DS);
+	do {
+		/* todo: signal_pending? */
+		err = func(file, (const char __user *)buf, size, pos);
+	} while (err == -EAGAIN || err == -EINTR);
+	set_fs(oldfs);
+	lockdep_on();
+
+	if (err >= 0)
+		au_update_fuse_h_inode(file->f_vfsmnt, file->f_dentry);
+	/*ignore*/
+
+#if 0 /* reserved for future use */
+	if (err > 0)
+		fsnotify_modify(file->f_dentry);
+#endif
+
+	AuTraceErr(err);
+	return err;
+}
+
+struct do_xino_fwrite_args {
+	ssize_t *errp;
+	au_writef_t func;
+	struct file *file;
+	void *buf;
+	size_t size;
+	loff_t *pos;
+};
+
+static void call_do_xino_fwrite(void *args)
+{
+	struct do_xino_fwrite_args *a = args;
+	*a->errp = do_xino_fwrite(a->func, a->file, a->buf, a->size, a->pos);
+}
+
+ssize_t xino_fwrite(au_writef_t func, struct file *file, void *buf, size_t size,
+		    loff_t *pos)
+{
+	ssize_t err;
+
+	LKTRTrace("%.*s, sz %zu, *pos %lld\n",
+		  AuDLNPair(file->f_dentry), size, *pos);
+
+	/* todo: signal block and no wkq? */
+	/*
+	 * it breaks RLIMIT_FSIZE and normal user's limit,
+	 * users should care about quota and real 'filesystem full.'
+	 */
+	if (!au_test_wkq(current)) {
+		int wkq_err;
+		struct do_xino_fwrite_args args = {
+			.errp	= &err,
+			.func	= func,
+			.file	= file,
+			.buf	= buf,
+			.size	= size,
+			.pos	= pos
+		};
+		wkq_err = au_wkq_wait(call_do_xino_fwrite, &args, /*dlgt*/0);
+		if (unlikely(wkq_err))
+			err = wkq_err;
+	} else
+		err = do_xino_fwrite(func, file, buf, size, pos);
+
+	AuTraceErr(err);
+	return err;
+}
+
+/* ---------------------------------------------------------------------- */
+
+struct xino_do_trunc_args {
+	struct super_block *sb;
+	struct au_branch *br;
+};
+
+static void xino_do_trunc(void *_args)
+{
+	struct xino_do_trunc_args *args = _args;
+	struct super_block *sb;
+	aufs_bindex_t bindex;
+	int err;
+	struct file *file;
+	struct inode *dir;
+	struct au_sbinfo *sbinfo;
+
+	err = 0;
+	sb = args->sb;
+	dir = sb->s_root->d_inode;
+	si_noflush_write_lock(sb);
+	ii_read_lock_parent(dir);
+	bindex = au_br_index(sb, args->br->br_id);
+	AuDebugOn(bindex < 0);
+	err = au_xino_trunc(sb, bindex);
+	if (unlikely(err))
+		goto out;
+
+	file = args->br->br_xino.xi_file;
+	au_update_fuse_h_inode(args->br->br_mnt, file->f_dentry); /*ignore*/
+	if (file->f_dentry->d_inode->i_blocks >= args->br->br_xino_upper)
+		args->br->br_xino_upper += AUFS_XINO_TRUNC_STEP;
+
+ out:
+	ii_read_unlock(dir);
+	if (unlikely(err))
+		AuWarn("err b%d, (%d)\n", bindex, err);
+	atomic_dec_return(&args->br->br_xino_running);
+	au_br_put(args->br);
+	sbinfo = au_sbi(sb);
+	au_nwt_done(&sbinfo->si_nowait);
+	si_write_unlock(sb);
+	kfree(args);
+}
+
+static void xino_try_trunc(struct super_block *sb, struct au_branch *br)
+{
+	struct xino_do_trunc_args *args;
+	struct au_sbinfo *sbinfo;
+	struct file *file = br->br_xino.xi_file;
+	int wkq_err;
+
+	au_update_fuse_h_inode(br->br_mnt, file->f_dentry); /*ignore*/
+	if (file->f_dentry->d_inode->i_blocks < br->br_xino_upper)
+		return;
+	if (atomic_inc_return(&br->br_xino_running) > 1)
+		goto out;
+
+	/* lock and kfree() will be called in trunc_xino() */
+	args = kmalloc(sizeof(*args), GFP_NOFS);
+	if (unlikely(!args)) {
+		AuErr1("no memory\n");
+		goto out_args;
+	}
+
+	sbinfo = au_sbi(sb);
+	au_br_get(br);
+	args->sb = sb;
+	args->br = br;
+	wkq_err = au_wkq_nowait(xino_do_trunc, args, sb, /*dlgt*/0);
+	if (!wkq_err)
+		return; /* success */
+
+	AuErr("wkq %d\n", wkq_err);
+	au_br_put(br);
+
+ out_args:
+	kfree(args);
+ out:
+	atomic_dec_return(&br->br_xino_running);
+}
+
+/* ---------------------------------------------------------------------- */
+
+static int au_xino_do_write(au_writef_t write, struct file *file,
+			    ino_t h_ino, struct au_xino_entry *xinoe)
+{
+	loff_t pos;
+	ssize_t sz;
+
+	AuTraceEnter();
+
+	pos = h_ino;
+	if (unlikely(Au_LOFF_MAX / sizeof(*xinoe) - 1 < pos)) {
+		AuIOErr1("too large hi%lu\n", (unsigned long)h_ino);
+		return -EFBIG;
+	}
+	pos *= sizeof(*xinoe);
+	sz = xino_fwrite(write, file, xinoe, sizeof(*xinoe), &pos);
+	if (sz == sizeof(*xinoe))
+		return 0; /* success */
+
+	AuIOErr("write failed (%zd)\n", sz);
+	return -EIO;
+}
+
+/*
+ * write @ino to the xinofile for the specified branch{@sb, @bindex}
+ * at the position of @_ino.
+ * when @ino is zero, it is written to the xinofile and means no entry.
+ */
+int au_xino_write(struct super_block *sb, aufs_bindex_t bindex, ino_t h_ino,
+		  struct au_xino_entry *xinoe)
+{
+	int err;
+	struct file *file;
+	struct au_branch *br;
+	unsigned int mnt_flags;
+
+	LKTRTrace("b%d, hi%lu, i%lu\n",
+		  bindex, (unsigned long)h_ino, (unsigned long)xinoe->ino);
+	BUILD_BUG_ON(sizeof(long long) != sizeof(Au_LOFF_MAX)
+		     || ((loff_t)-1) > 0);
+
+	mnt_flags = au_mntflags(sb);
+	if (!au_opt_test_xino(mnt_flags))
+		return 0;
+
+	br = au_sbr(sb, bindex);
+	file = br->br_xino.xi_file;
+	AuDebugOn(!file);
+
+	err = au_xino_do_write(au_sbi(sb)->si_xwrite, file, h_ino, xinoe);
+	if (!err) {
+		if (au_opt_test(mnt_flags, TRUNC_XINO)
+		    && au_test_trunc_xino(br->br_mnt->mnt_sb))
+			xino_try_trunc(sb, br);
+		return 0; /* success */
+	}
+
+	AuIOErr("write failed (%d)\n", err);
+	return -EIO;
+}
+
+/* ---------------------------------------------------------------------- */
+
+static const int page_bits = (int)PAGE_SIZE * BITS_PER_BYTE;
+static ino_t xib_calc_ino(unsigned long pindex, int bit)
+{
+	ino_t ino;
+
+	AuDebugOn(bit < 0 || page_bits <= bit);
+	ino = AUFS_FIRST_INO + pindex * page_bits + bit;
+	return ino;
+}
+
+static void xib_calc_bit(ino_t ino, unsigned long *pindex, int *bit)
+{
+	AuDebugOn(ino < AUFS_FIRST_INO);
+	ino -= AUFS_FIRST_INO;
+	*pindex = ino / page_bits;
+	*bit = ino % page_bits;
+}
+
+static int xib_pindex(struct super_block *sb, unsigned long pindex)
+{
+	int err;
+	struct au_sbinfo *sbinfo;
+	loff_t pos;
+	ssize_t sz;
+	struct file *xib;
+	unsigned long *p;
+
+	LKTRTrace("pindex %lu\n", pindex);
+	sbinfo = au_sbi(sb);
+	MtxMustLock(&sbinfo->si_xib_mtx);
+	AuDebugOn(pindex > ULONG_MAX / PAGE_SIZE
+		  || !au_opt_test_xino(sbinfo->si_mntflags));
+
+	if (pindex == sbinfo->si_xib_last_pindex)
+		return 0;
+
+	xib = sbinfo->si_xib;
+	p = sbinfo->si_xib_buf;
+	pos = sbinfo->si_xib_last_pindex;
+	pos *= PAGE_SIZE;
+	sz = xino_fwrite(sbinfo->si_xwrite, xib, p, PAGE_SIZE, &pos);
+	if (unlikely(sz != PAGE_SIZE))
+		goto out;
+
+	pos = pindex;
+	pos *= PAGE_SIZE;
+	if (i_size_read(xib->f_dentry->d_inode) >= pos + PAGE_SIZE)
+		sz = xino_fread(sbinfo->si_xread, xib, p, PAGE_SIZE, &pos);
+	else {
+		memset(p, 0, PAGE_SIZE);
+		sz = xino_fwrite(sbinfo->si_xwrite, xib, p, PAGE_SIZE, &pos);
+	}
+	if (sz == PAGE_SIZE) {
+		sbinfo->si_xib_last_pindex = pindex;
+		return 0; /* success */
+	}
+
+ out:
+	AuIOErr1("write failed (%zd)\n", sz);
+	err = sz;
+	if (sz >= 0)
+		err = -EIO;
+	AuTraceErr(err);
+	return err;
+}
+
+/* ---------------------------------------------------------------------- */
+
+int au_xino_write0(struct super_block *sb, aufs_bindex_t bindex, ino_t h_ino,
+		   ino_t ino)
+{
+	int err, bit;
+	unsigned long pindex;
+	struct au_sbinfo *sbinfo;
+	struct au_xino_entry xinoe = {
+		.ino	= 0
+	};
+
+	LKTRTrace("b%d, hi%lu, i%lu\n",
+		  bindex, (unsigned long)h_ino, (unsigned long)ino);
+
+	if (!au_opt_test_xino(au_mntflags(sb)))
+		return 0;
+
+	err = 0;
+	sbinfo = au_sbi(sb);
+	if (ino) {
+		AuDebugOn(ino < AUFS_FIRST_INO);
+		xib_calc_bit(ino, &pindex, &bit);
+		AuDebugOn(page_bits <= bit);
+		mutex_lock(&sbinfo->si_xib_mtx);
+		err = xib_pindex(sb, pindex);
+		if (!err) {
+			clear_bit(bit, sbinfo->si_xib_buf);
+			sbinfo->si_xib_next_bit = bit;
+		}
+		mutex_unlock(&sbinfo->si_xib_mtx);
+	}
+
+	if (!err)
+		err = au_xino_write(sb, bindex, h_ino, &xinoe);
+	return err;
+}
+
+ino_t au_xino_new_ino(struct super_block *sb)
+{
+	ino_t ino;
+	struct au_sbinfo *sbinfo;
+	int free_bit, err;
+	unsigned long *p, pindex, ul, pend;
+	struct file *file;
+
+	AuTraceEnter();
+
+	if (!au_opt_test_xino(au_mntflags(sb)))
+		return iunique(sb, AUFS_FIRST_INO);
+
+	sbinfo = au_sbi(sb);
+	mutex_lock(&sbinfo->si_xib_mtx);
+	p = sbinfo->si_xib_buf;
+	free_bit = sbinfo->si_xib_next_bit;
+	if (free_bit < page_bits && !test_bit(free_bit, p))
+		goto out; /* success */
+	free_bit = find_first_zero_bit(p, page_bits);
+	if (free_bit < page_bits)
+		goto out; /* success */
+
+	pindex = sbinfo->si_xib_last_pindex;
+	for (ul = pindex - 1; ul < ULONG_MAX; ul--) {
+		err = xib_pindex(sb, ul);
+		if (unlikely(err))
+			goto out_err;
+		free_bit = find_first_zero_bit(p, page_bits);
+		if (free_bit < page_bits)
+			goto out; /* success */
+	}
+
+	file = sbinfo->si_xib;
+	pend = i_size_read(file->f_dentry->d_inode) / PAGE_SIZE;
+	for (ul = pindex + 1; ul <= pend; ul++) {
+		err = xib_pindex(sb, ul);
+		if (unlikely(err))
+			goto out_err;
+		free_bit = find_first_zero_bit(p, page_bits);
+		if (free_bit < page_bits)
+			goto out; /* success */
+	}
+	BUG();
+
+ out:
+	set_bit(free_bit, p);
+	sbinfo->si_xib_next_bit++;
+	pindex = sbinfo->si_xib_last_pindex;
+	mutex_unlock(&sbinfo->si_xib_mtx);
+	ino = xib_calc_ino(pindex, free_bit);
+	LKTRTrace("i%lu\n", (unsigned long)ino);
+	return ino;
+ out_err:
+	mutex_unlock(&sbinfo->si_xib_mtx);
+	LKTRTrace("i0\n");
+	return 0;
+}
+
+/*
+ * read @ino from xinofile for the specified branch{@sb, @bindex}
+ * at the position of @h_ino.
+ * if @ino does not exist and @do_new is true, get new one.
+ */
+int au_xino_read(struct super_block *sb, aufs_bindex_t bindex, ino_t h_ino,
+		 struct au_xino_entry *xinoe)
+{
+	int err;
+	struct file *file;
+	loff_t pos;
+	ssize_t sz;
+	struct au_sbinfo *sbinfo;
+
+	LKTRTrace("b%d, hi%lu\n", bindex, (unsigned long)h_ino);
+
+	xinoe->ino = 0;
+	if (!au_opt_test_xino(au_mntflags(sb)))
+		return 0; /* no ino */
+
+	err = 0;
+	sbinfo = au_sbi(sb);
+	pos = h_ino;
+	if (unlikely(Au_LOFF_MAX / sizeof(*xinoe) - 1 < pos)) {
+		AuIOErr1("too large hi%lu\n", (unsigned long)h_ino);
+		return -EFBIG;
+	}
+	pos *= sizeof(*xinoe);
+
+	file = au_sbr(sb, bindex)->br_xino.xi_file;
+	AuDebugOn(!file);
+	if (i_size_read(file->f_dentry->d_inode) < pos + sizeof(*xinoe))
+		return 0; /* no ino */
+
+	sz = xino_fread(sbinfo->si_xread, file, xinoe, sizeof(*xinoe), &pos);
+	if (sz == sizeof(*xinoe))
+		return 0; /* success */
+
+	err = sz;
+	if (unlikely(sz >= 0)) {
+		err = -EIO;
+		AuIOErr("xino read error (%zd)\n", sz);
+	}
+
+	AuTraceErr(err);
+	return err;
+}
+
+/* ---------------------------------------------------------------------- */
+
+struct file *au_xino_create(struct super_block *sb, char *fname, int silent)
+{
+	struct file *file;
+	int err;
+	struct dentry *h_parent;
+	struct inode *h_dir;
+	struct vfsub_args vargs;
+
+	LKTRTrace("%s\n", fname);
+
+	/*
+	 * at mount-time, and the xino file is the default path,
+	 * hinotify is disabled so we have no inotify events to ignore.
+	 * when a user specified the xino, we cannot get au_hdir to be ignored.
+	 */
+	vfsub_args_init(&vargs, /*ign*/NULL, /*dlgt*/0, 0);
+	file = vfsub_filp_open(fname, O_RDWR | O_CREAT | O_EXCL | O_LARGEFILE,
+			       S_IRUGO | S_IWUGO);
+	if (IS_ERR(file)) {
+		if (!silent)
+			AuErr("open %s(%ld)\n", fname, PTR_ERR(file));
+		return file;
+	}
+
+	/* keep file count */
+	h_parent = dget_parent(file->f_dentry);
+	h_dir = h_parent->d_inode;
+	mutex_lock_nested(&h_dir->i_mutex, AuLsc_I_PARENT);
+	/* mnt_want_write() is unnecessary here */
+	err = vfsub_unlink(h_dir, file->f_dentry, &vargs);
+	mutex_unlock(&h_dir->i_mutex);
+	dput(h_parent);
+	if (unlikely(err)) {
+		if (!silent)
+			AuErr("unlink %s(%d)\n", fname, err);
+		goto out;
+	}
+
+	if (sb != file->f_dentry->d_sb)
+		return file; /* success */
+
+	if (!silent)
+		AuErr("%s must be outside\n", fname);
+	err = -EINVAL;
+
+ out:
+	fput(file);
+	file = ERR_PTR(err);
+	return file;
+}
+
+/*
+ * find another branch who is on the same filesystem of the specified
+ * branch{@btgt}. search until @bend.
+ */
+static int is_sb_shared(struct super_block *sb, aufs_bindex_t btgt,
+			aufs_bindex_t bend)
+{
+	aufs_bindex_t bindex;
+	struct super_block *tgt_sb = au_sbr_sb(sb, btgt);
+
+	for (bindex = 0; bindex < btgt; bindex++)
+		if (unlikely(tgt_sb == au_sbr_sb(sb, bindex)))
+			return bindex;
+	for (bindex++; bindex <= bend; bindex++)
+		if (unlikely(tgt_sb == au_sbr_sb(sb, bindex)))
+			return bindex;
+	return -1;
+}
+
+/*
+ * create a new xinofile at the same place/path as @base_file.
+ */
+struct file *au_xino_create2(struct super_block *sb, struct file *base_file,
+			     struct file *copy_src)
+{
+	struct file *file;
+	int err;
+	struct dentry *base, *dentry, *parent;
+	struct inode *dir, *inode;
+	struct qstr *name;
+	struct au_hinode *hdir;
+	struct au_branch *br;
+	aufs_bindex_t bindex;
+	struct au_hin_ignore ign;
+	struct vfsub_args vargs;
+	struct au_ndx ndx = {
+		.nfsmnt	= NULL,
+		.flags	= 0,
+		.nd	= NULL,
+		/* .br	= NULL */
+	};
+
+	base = base_file->f_dentry;
+	LKTRTrace("%.*s\n", AuDLNPair(base));
+	parent = base->d_parent; /* dir inode is locked */
+	dir = parent->d_inode;
+	IMustLock(dir);
+
+	file = ERR_PTR(-EINVAL);
+	if (unlikely(au_test_nfs(parent->d_sb)))
+		goto out;
+
+	/* do not superio, nor NFS. */
+	name = &base->d_name;
+	dentry = au_lkup_one(name->name, parent, name->len, &ndx);
+	if (IS_ERR(dentry)) {
+		file = (void *)dentry;
+		AuErr("%.*s lookup err %ld\n", AuLNPair(name), PTR_ERR(dentry));
+		goto out;
+	}
+
+	hdir = NULL;
+	br = au_xino_def_br(au_sbi(sb));
+	if (br) {
+		bindex = au_find_bindex(sb, br);
+		if (bindex >= 0)
+			hdir = au_hi(sb->s_root->d_inode, bindex);
+	}
+	vfsub_args_init(&vargs, &ign, 0, 0);
+	vfsub_ign_hinode(&vargs, IN_CREATE, hdir);
+	/* no need to mnt_want_write() since we call dentry_open() later */
+	err = vfsub_create(dir, dentry, S_IRUGO | S_IWUGO, NULL, &vargs);
+	if (unlikely(err)) {
+		file = ERR_PTR(err);
+		AuErr("%.*s create err %d\n", AuLNPair(name), err);
+		goto out_dput;
+	}
+	file = dentry_open(dget(dentry), mntget(base_file->f_vfsmnt),
+			   O_RDWR | O_CREAT | O_EXCL | O_LARGEFILE);
+	if (IS_ERR(file)) {
+		AuErr("%.*s open err %ld\n", AuLNPair(name), PTR_ERR(file));
+		goto out_dput;
+	}
+	vfsub_args_reinit(&vargs);
+	vfsub_ign_hinode(&vargs, IN_DELETE, hdir);
+	err = vfsub_unlink(dir, dentry, &vargs);
+	if (unlikely(err)) {
+		AuErr("%.*s unlink err %d\n", AuLNPair(name), err);
+		goto out_fput;
+	}
+
+	if (copy_src) {
+		inode = copy_src->f_dentry->d_inode;
+		err = au_copy_file(file, copy_src, i_size_read(inode),
+				   hdir, sb, &vargs);
+		if (unlikely(err)) {
+			AuErr("%.*s copy err %d\n", AuLNPair(name), err);
+			goto out_fput;
+		}
+	}
+	goto out_dput; /* success */
+
+ out_fput:
+	fput(file);
+	file = ERR_PTR(err);
+ out_dput:
+	dput(dentry);
+ out:
+	AuTraceErrPtr(file);
+	return file;
+}
+
+/* ---------------------------------------------------------------------- */
+
+/*
+ * initialize the xinofile for the specified branch{@sb, @bindex}
+ * at the place/path where @base_file indicates.
+ * test whether another branch is on the same filesystem or not,
+ * if @do_test is true.
+ */
+int au_xino_br(struct super_block *sb, struct au_branch *br, ino_t h_ino,
+	       struct file *base_file, int do_test)
+{
+	int err;
+	struct au_branch *shared_br;
+	aufs_bindex_t bshared, bend, bindex;
+	unsigned char do_create;
+	struct inode *dir;
+	struct au_xino_entry xinoe;
+	struct dentry *parent;
+	struct file *file;
+	struct super_block *tgt_sb;
+
+	LKTRTrace("base_file %p, do_test %d\n", base_file, do_test);
+	SiMustWriteLock(sb);
+	AuDebugOn(!au_opt_test_xino(au_mntflags(sb)));
+	AuDebugOn(br->br_xino.xi_file);
+
+	do_create = 1;
+	bshared = -1;
+	shared_br = NULL;
+	bend = au_sbend(sb);
+	if (do_test) {
+		tgt_sb = br->br_mnt->mnt_sb;
+		for (bindex = 0; bindex <= bend; bindex++)
+			if (tgt_sb == au_sbr_sb(sb, bindex)) {
+				bshared = bindex;
+				break;
+			}
+	}
+	if (bshared >= 0) {
+		shared_br = au_sbr(sb, bshared);
+		do_create = !shared_br->br_xino.xi_file;
+	}
+
+	if (do_create) {
+		parent = dget_parent(base_file->f_dentry);
+		dir = parent->d_inode;
+		mutex_lock_nested(&dir->i_mutex, AuLsc_I_PARENT);
+		/* mnt_want_write() is unnecessary here */
+		file = au_xino_create2(sb, base_file, NULL);
+		mutex_unlock(&dir->i_mutex);
+		dput(parent);
+		err = PTR_ERR(file);
+		if (IS_ERR(file))
+			goto out;
+		br->br_xino.xi_file = file;
+	} else {
+		br->br_xino.xi_file = shared_br->br_xino.xi_file;
+		get_file(br->br_xino.xi_file);
+	}
+
+	xinoe.ino = AUFS_ROOT_INO;
+#if 0 /* reserved for future use */
+	xinoe.h_gen = h_inode->i_generation;
+	WARN_ON(xinoe.h_gen == AuXino_INVALID_HGEN);
+#endif
+	err = au_xino_do_write(au_sbi(sb)->si_xwrite, br->br_xino.xi_file,
+			       h_ino, &xinoe);
+	if (!err)
+		return 0; /* success */
+
+
+ out:
+	AuTraceErr(err);
+	return err;
+}
+
+/* too slow */
+static int do_xib_restore(struct super_block *sb, struct file *file, void *page)
+{
+	int err, bit;
+	struct au_sbinfo *sbinfo;
+	au_readf_t func;
+	loff_t pos, pend;
+	ssize_t sz;
+	struct au_xino_entry *xinoe;
+	unsigned long pindex;
+
+	AuTraceEnter();
+	SiMustWriteLock(sb);
+
+	err = 0;
+	sbinfo = au_sbi(sb);
+	func = sbinfo->si_xread;
+	pend = i_size_read(file->f_dentry->d_inode);
+#ifdef CONFIG_AUFS_DEBUG
+	if (unlikely(pend > (1 << 22)))
+		AuWarn("testing a large xino file %lld\n", (long long)pend);
+#endif
+	pos = 0;
+	while (pos < pend) {
+		sz = xino_fread(func, file, page, PAGE_SIZE, &pos);
+		err = sz;
+		if (unlikely(sz <= 0))
+			goto out;
+
+		err = 0;
+		for (xinoe = page; sz > 0; xinoe++, sz -= sizeof(xinoe)) {
+			if (unlikely(xinoe->ino < AUFS_FIRST_INO))
+				continue;
+
+			xib_calc_bit(xinoe->ino, &pindex, &bit);
+			AuDebugOn(page_bits <= bit);
+			err = xib_pindex(sb, pindex);
+			if (!err)
+				set_bit(bit, sbinfo->si_xib_buf);
+			else
+				goto out;
+		}
+	}
+
+ out:
+	AuTraceErr(err);
+	return err;
+}
+
+static int xib_restore(struct super_block *sb)
+{
+	int err;
+	aufs_bindex_t bindex, bend;
+	void *page;
+
+	AuTraceEnter();
+
+	err = -ENOMEM;
+	page = (void *)__get_free_page(GFP_NOFS);
+	if (unlikely(!page))
+		goto out;
+
+	err = 0;
+	bend = au_sbend(sb);
+	for (bindex = 0; !err && bindex <= bend; bindex++)
+		if (!bindex || is_sb_shared(sb, bindex, bindex - 1) < 0)
+			err = do_xib_restore
+				(sb, au_sbr(sb, bindex)->br_xino.xi_file, page);
+		else
+			LKTRTrace("b%d\n", bindex);
+	free_page((unsigned long)page);
+
+ out:
+	AuTraceErr(err);
+	return err;
+}
+
+int au_xib_trunc(struct super_block *sb)
+{
+	int err;
+	unsigned int mnt_flags;
+	ssize_t sz;
+	loff_t pos;
+	struct au_sbinfo *sbinfo;
+	unsigned long *p;
+	struct dentry *parent;
+	struct inode *dir;
+	struct file *file;
+
+	AuTraceEnter();
+	SiMustWriteLock(sb);
+
+	err = 0;
+	mnt_flags = au_mntflags(sb);
+	if (!au_opt_test_xino(mnt_flags))
+		goto out;
+
+	sbinfo = au_sbi(sb);
+	if (i_size_read(sbinfo->si_xib->f_dentry->d_inode) <= PAGE_SIZE)
+		goto out;
+	parent = dget_parent(sbinfo->si_xib->f_dentry);
+	dir = parent->d_inode;
+	mutex_lock_nested(&dir->i_mutex, AuLsc_I_PARENT);
+	/* mnt_want_write() is unnecessary here */
+	file = au_xino_create2(sb, sbinfo->si_xib, NULL);
+	mutex_unlock(&dir->i_mutex);
+	dput(parent);
+	err = PTR_ERR(file);
+	if (IS_ERR(file))
+		goto out;
+	fput(sbinfo->si_xib);
+	sbinfo->si_xib = file;
+
+	p = sbinfo->si_xib_buf;
+	memset(p, 0, PAGE_SIZE);
+	pos = 0;
+	sz = xino_fwrite(sbinfo->si_xwrite, sbinfo->si_xib, p, PAGE_SIZE, &pos);
+	if (unlikely(sz != PAGE_SIZE)) {
+		err = sz;
+		AuIOErr("err %d\n", err);
+		if (sz >= 0)
+			err = -EIO;
+		goto out;
+	}
+
+	if (au_opt_test_xino(mnt_flags)) {
+		mutex_lock(&sbinfo->si_xib_mtx);
+		/* mnt_want_write() is unnecessary here */
+		err = xib_restore(sb);
+		mutex_unlock(&sbinfo->si_xib_mtx);
+#if 0 /* reserved for future use */
+	} else {
+		/* is it really safe? */
+		/* dont trust BKL */
+		AuDebugOn(!kernel_locked());
+		ino = AUFS_FIRST_INO;
+		list_for_each_entry(inode, &sb->s_inodes, i_sb_list)
+			if (ino < inode->i_ino)
+				ino = inode->i_ino;
+
+		/* make iunique to return larger than active max inode number */
+		iunique(sb, ino);
+		err = 0;
+#endif
+	}
+
+out:
+	AuTraceErr(err);
+	return err;
+}
+
+/* ---------------------------------------------------------------------- */
+
+/*
+ * xino mount option handlers
+ */
+static au_readf_t find_readf(struct file *h_file)
+{
+	const struct file_operations *fop = h_file->f_op;
+
+	if (fop) {
+		if (fop->read)
+			return fop->read;
+		if (fop->aio_read)
+			return do_sync_read;
+	}
+	return ERR_PTR(-ENOSYS);
+}
+
+static au_writef_t find_writef(struct file *h_file)
+{
+	const struct file_operations *fop = h_file->f_op;
+
+	if (fop) {
+		if (fop->write)
+			return fop->write;
+		if (fop->aio_write)
+			return do_sync_write;
+	}
+	return ERR_PTR(-ENOSYS);
+}
+
+/* xino bitmap */
+static void xino_clear_xib(struct super_block *sb)
+{
+	struct au_sbinfo *sbinfo;
+
+	AuTraceEnter();
+	SiMustWriteLock(sb);
+
+	sbinfo = au_sbi(sb);
+	sbinfo->si_xread = NULL;
+	sbinfo->si_xwrite = NULL;
+	if (sbinfo->si_xib)
+		fput(sbinfo->si_xib);
+	sbinfo->si_xib = NULL;
+	free_page((unsigned long)sbinfo->si_xib_buf);
+	sbinfo->si_xib_buf = NULL;
+}
+
+static int au_xino_set_xib(struct super_block *sb, struct file *base)
+{
+	int err;
+	struct au_sbinfo *sbinfo;
+	struct file *file;
+	loff_t pos;
+
+	LKTRTrace("%.*s\n", AuDLNPair(base->f_dentry));
+	SiMustWriteLock(sb);
+
+	sbinfo = au_sbi(sb);
+	file = au_xino_create2(sb, base, sbinfo->si_xib);
+	err = PTR_ERR(file);
+	if (IS_ERR(file))
+		goto out;
+	if (sbinfo->si_xib)
+		fput(sbinfo->si_xib);
+	sbinfo->si_xib = file;
+	sbinfo->si_xread = find_readf(file);
+	AuDebugOn(IS_ERR(sbinfo->si_xread));
+	sbinfo->si_xwrite = find_writef(file);
+	AuDebugOn(IS_ERR(sbinfo->si_xwrite));
+
+	err = -ENOMEM;
+	if (!sbinfo->si_xib_buf)
+		sbinfo->si_xib_buf = (void *)get_zeroed_page(GFP_NOFS);
+	if (unlikely(!sbinfo->si_xib_buf))
+		goto out_unset;
+
+	sbinfo->si_xib_last_pindex = 0;
+	sbinfo->si_xib_next_bit = 0;
+
+	/* no need to lock for i_size_read() */
+	if (i_size_read(file->f_dentry->d_inode) < PAGE_SIZE) {
+		pos = 0;
+		err = xino_fwrite(sbinfo->si_xwrite, file, sbinfo->si_xib_buf,
+				  PAGE_SIZE, &pos);
+		if (unlikely(err != PAGE_SIZE))
+			goto out_free;
+	}
+	err = 0;
+	goto out; /* success */
+
+ out_free:
+	free_page((unsigned long)sbinfo->si_xib_buf);
+	sbinfo->si_xib_buf = NULL;
+	if (err >= 0)
+		err = -EIO;
+ out_unset:
+	fput(sbinfo->si_xib);
+	sbinfo->si_xib = NULL;
+	sbinfo->si_xread = NULL;
+	sbinfo->si_xwrite = NULL;
+ out:
+	AuTraceErr(err);
+	return err;
+}
+
+/* xino for each branch */
+static void xino_clear_br(struct super_block *sb)
+{
+	aufs_bindex_t bindex, bend;
+	struct au_branch *br;
+
+	AuTraceEnter();
+	SiMustWriteLock(sb);
+
+	bend = au_sbend(sb);
+	for (bindex = 0; bindex <= bend; bindex++) {
+		br = au_sbr(sb, bindex);
+		if (!br || !br->br_xino.xi_file)
+			continue;
+
+		fput(br->br_xino.xi_file);
+		br->br_xino.xi_file = NULL;
+	}
+}
+
+static int au_xino_set_br(struct super_block *sb, struct file *base)
+{
+	int err;
+	aufs_bindex_t bindex, bend, bshared;
+	struct {
+		struct file *old, *new;
+	} *fpair, *p;
+	struct au_branch *br;
+	struct au_xino_entry xinoe;
+	struct inode *inode;
+	au_writef_t writef;
+
+	LKTRTrace("%.*s\n", AuDLNPair(base->f_dentry));
+	SiMustWriteLock(sb);
+
+	err = -ENOMEM;
+	bend = au_sbend(sb);
+	fpair = kcalloc(bend + 1, sizeof(*fpair), GFP_NOFS);
+	if (unlikely(!fpair))
+		goto out;
+
+	inode = sb->s_root->d_inode;
+	xinoe.ino = AUFS_ROOT_INO;
+	writef = au_sbi(sb)->si_xwrite;
+	for (bindex = 0, p = fpair; bindex <= bend; bindex++, p++) {
+		br = au_sbr(sb, bindex);
+		bshared = is_sb_shared(sb, bindex, bindex - 1);
+		if (bshared >= 0) {
+			/* shared xino */
+			*p = fpair[bshared];
+			get_file(p->new);
+		}
+
+		if (!p->new) {
+			/* new xino */
+			p->old = br->br_xino.xi_file;
+			p->new = au_xino_create2(sb, base, br->br_xino.xi_file);
+			err = PTR_ERR(p->new);
+			if (IS_ERR(p->new)) {
+				p->new = NULL;
+				goto out_pair;
+			}
+		}
+
+		err = au_xino_do_write(writef, p->new,
+				       au_h_iptr(inode, bindex)->i_ino, &xinoe);
+		if (unlikely(err))
+			goto out_pair;
+	}
+
+	for (bindex = 0, p = fpair; bindex <= bend; bindex++, p++) {
+		br = au_sbr(sb, bindex);
+		AuDebugOn(p->old != br->br_xino.xi_file);
+		if (br->br_xino.xi_file)
+			fput(br->br_xino.xi_file);
+		get_file(p->new);
+		br->br_xino.xi_file = p->new;
+	}
+
+ out_pair:
+	for (bindex = 0, p = fpair; bindex <= bend; bindex++, p++)
+		if (p->new)
+			fput(p->new);
+		else
+			break;
+	kfree(fpair);
+ out:
+	AuTraceErr(err);
+	return err;
+}
+
+void au_xino_clr(struct super_block *sb)
+{
+	struct au_sbinfo *sbinfo;
+
+	AuTraceEnter();
+	SiMustWriteLock(sb);
+
+	au_xigen_clr(sb);
+	xino_clear_xib(sb);
+	xino_clear_br(sb);
+	sbinfo = au_sbi(sb);
+	/* lvalue, do not call au_mntflags() */
+	au_opt_clr(sbinfo->si_mntflags, XINO);
+	au_xino_def_br_set(NULL, sbinfo);
+}
+
+int au_xino_set(struct super_block *sb, struct au_opt_xino *xino, int remount)
+{
+	int err, skip;
+	struct dentry *parent, *cur_parent;
+	struct qstr *dname, *cur_name;
+	struct file *cur_xino;
+	struct inode *dir;
+	struct au_sbinfo *sbinfo;
+
+	LKTRTrace("remount %d\n", remount);
+	SiMustWriteLock(sb);
+
+	err = 0;
+	sbinfo = au_sbi(sb);
+	parent = dget_parent(xino->file->f_dentry);
+	if (remount) {
+		skip = 0;
+		dname = &xino->file->f_dentry->d_name;
+		cur_xino = sbinfo->si_xib;
+		if (cur_xino) {
+			cur_parent = dget_parent(cur_xino->f_dentry);
+			cur_name = &cur_xino->f_dentry->d_name;
+			skip = (cur_parent == parent
+				&& dname->len == cur_name->len
+				&& !memcmp(dname->name, cur_name->name,
+					   dname->len));
+			dput(cur_parent);
+		}
+		if (skip)
+			goto out;
+	}
+
+	au_opt_set(sbinfo->si_mntflags, XINO);
+	au_xino_def_br_set(NULL, sbinfo);
+	dir = parent->d_inode;
+	mutex_lock_nested(&dir->i_mutex, AuLsc_I_PARENT);
+	/* mnt_want_write() is unnecessary here */
+	err = au_xino_set_xib(sb, xino->file);
+	if (!err)
+		err = au_xigen_set(sb, xino->file);
+	if (!err)
+		err = au_xino_set_br(sb, xino->file);
+	mutex_unlock(&dir->i_mutex);
+	if (!err)
+		goto out; /* success */
+
+	/* reset all */
+	AuIOErr("failed creating xino(%d).\n", err);
+
+ out:
+	dput(parent);
+	AuTraceErr(err);
+	return err;
+}
+
+int au_xino_trunc(struct super_block *sb, aufs_bindex_t bindex)
+{
+	int err;
+	struct au_branch *br;
+	struct file *new_xino;
+	struct super_block *h_sb;
+	aufs_bindex_t bi, bend;
+	struct dentry *parent;
+	struct inode *dir;
+
+	LKTRTrace("b%d\n", bindex);
+	SiMustWriteLock(sb);
+
+	err = -EINVAL;
+	bend = au_sbend(sb);
+	if (unlikely(bindex < 0 || bend < bindex))
+		goto out;
+	br = au_sbr(sb, bindex);
+	if (!br->br_xino.xi_file)
+		goto out;
+
+	parent = dget_parent(br->br_xino.xi_file->f_dentry);
+	dir = parent->d_inode;
+	mutex_lock_nested(&dir->i_mutex, AuLsc_I_PARENT);
+	/* mnt_want_write() is unnecessary here */
+	new_xino = au_xino_create2(sb, br->br_xino.xi_file,
+				   br->br_xino.xi_file);
+	mutex_unlock(&dir->i_mutex);
+	dput(parent);
+	err = PTR_ERR(new_xino);
+	if (IS_ERR(new_xino))
+		goto out;
+	err = 0;
+	fput(br->br_xino.xi_file);
+	br->br_xino.xi_file = new_xino;
+
+	h_sb = br->br_mnt->mnt_sb;
+	for (bi = 0; bi <= bend; bi++) {
+		if (unlikely(bi == bindex))
+			continue;
+		br = au_sbr(sb, bi);
+		if (br->br_mnt->mnt_sb != h_sb)
+			continue;
+
+		fput(br->br_xino.xi_file);
+		br->br_xino.xi_file = new_xino;
+		get_file(new_xino);
+	}
+
+ out:
+	AuTraceErr(err);
+	return err;
+}
+
+/* ---------------------------------------------------------------------- */
+
+/*
+ * create a xinofile at the default place/path.
+ */
+struct file *au_xino_def(struct super_block *sb)
+{
+	struct file *file;
+	aufs_bindex_t bend, bindex, bwr;
+	char *page, *p;
+	struct path path;
+	struct dentry *root;
+
+	AuTraceEnter();
+
+	root = sb->s_root;
+	bend = au_sbend(sb);
+	bwr = -1;
+	for (bindex = 0; bindex <= bend; bindex++)
+		if (au_br_writable(au_sbr_perm(sb, bindex))
+		    && !au_test_nfs(au_h_dptr(root, bindex)->d_sb)) {
+			bwr = bindex;
+			break;
+		}
+
+	if (bwr >= 0) {
+		file = ERR_PTR(-ENOMEM);
+		page = __getname();
+		if (unlikely(!page))
+			goto out;
+		path.mnt = au_sbr_mnt(sb, bwr);
+		path.dentry = au_h_dptr(root, bwr);
+		p = d_path(&path, page, PATH_MAX - sizeof(AUFS_XINO_FNAME));
+		file = (void *)p;
+		if (!IS_ERR(p)) {
+			strcat(p, "/" AUFS_XINO_FNAME);
+			LKTRTrace("%s\n", p);
+			file = au_xino_create(sb, p, /*silent*/0);
+			if (!IS_ERR(file))
+				au_xino_def_br_set(au_sbr(sb, bwr), au_sbi(sb));
+		}
+		__putname(page);
+	} else {
+		file = au_xino_create(sb, AUFS_XINO_DEFPATH, /*silent*/0);
+		if (unlikely(au_test_nfs(file->f_dentry->d_sb))) {
+			AuErr("xino or noxino option is required "
+			      "since %s is NFS\n", AUFS_XINO_DEFPATH);
+			fput(file);
+			file = ERR_PTR(-EINVAL);
+		}
+		if (!IS_ERR(file))
+			au_xino_def_br_set(NULL, au_sbi(sb));
+	}
+
+ out:
+	AuTraceErrPtr(file);
+	return file;
+}
diff -Nurp linux-2.6.27.orig/fs/Kconfig linux-2.6.27/fs/Kconfig
--- linux-2.6.27.orig/fs/Kconfig	2008-10-10 00:13:53.000000000 +0200
+++ linux-2.6.27/fs/Kconfig	2008-12-14 11:10:54.000000000 +0100
@@ -6,6 +6,8 @@ menu "File systems"
 
 if BLOCK
 
+source "fs/aufs/Kconfig"
+
 config EXT2_FS
 	tristate "Second extended fs support"
 	help
diff -Nurp linux-2.6.27.orig/fs/Makefile linux-2.6.27/fs/Makefile
--- linux-2.6.27.orig/fs/Makefile	2008-10-10 00:13:53.000000000 +0200
+++ linux-2.6.27/fs/Makefile	2008-12-14 11:08:39.000000000 +0100
@@ -122,3 +122,4 @@ obj-$(CONFIG_HPPFS)		+= hppfs/
 obj-$(CONFIG_DEBUG_FS)		+= debugfs/
 obj-$(CONFIG_OCFS2_FS)		+= ocfs2/
 obj-$(CONFIG_GFS2_FS)           += gfs2/
+obj-$(CONFIG_AUFS)		+= aufs/
diff -Nurp linux-2.6.27.orig/include/linux/aufs_type.h linux-2.6.27/include/linux/aufs_type.h
--- linux-2.6.27.orig/include/linux/aufs_type.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.27/include/linux/aufs_type.h	2008-12-14 11:08:07.000000000 +0100
@@ -0,0 +1,127 @@
+/*
+ * Copyright (C) 2005-2008 Junjiro Okajima
+ *
+ * This program, aufs is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+ */
+
+/* $Id: aufs_type.h,v 1.133 2008/12/08 06:12:34 sfjro Exp $ */
+
+#include <linux/ioctl.h>
+
+#ifndef __AUFS_TYPE_H__
+#define __AUFS_TYPE_H__
+
+#define AUFS_VERSION	"20081208"
+
+/* move this to linux-2.6.19/include/magic.h */
+#define AUFS_SUPER_MAGIC	('a' << 24 | 'u' << 16 | 'f' << 8 | 's')
+
+/* ---------------------------------------------------------------------- */
+
+#ifdef CONFIG_AUFS_BRANCH_MAX_127
+/* some environments treat 'char' as 'unsigned char' by default */
+typedef signed char aufs_bindex_t;
+#define AUFS_BRANCH_MAX 127
+#else
+typedef short aufs_bindex_t;
+#ifdef CONFIG_AUFS_BRANCH_MAX_511
+#define AUFS_BRANCH_MAX 511
+#elif defined(CONFIG_AUFS_BRANCH_MAX_1023)
+#define AUFS_BRANCH_MAX 1023
+#elif defined(CONFIG_AUFS_BRANCH_MAX_32767)
+#define AUFS_BRANCH_MAX 32767
+#else
+#error unknown CONFIG_AUFS_BRANCH_MAX value
+#endif
+#endif
+
+#define AUFS_NAME		"aufs"
+#define AUFS_FSTYPE		AUFS_NAME
+
+#define AUFS_ROOT_INO		2
+#define AUFS_FIRST_INO		11
+
+#define AUFS_WH_PFX		".wh."
+#define AUFS_WH_PFX_LEN		((int)sizeof(AUFS_WH_PFX) - 1)
+#define AUFS_XINO_FNAME		"." AUFS_NAME ".xino"
+#define AUFS_XINO_DEFPATH	"/tmp/" AUFS_XINO_FNAME
+#define AUFS_XINO_TRUNC_INIT	64 /* blocks */
+#define AUFS_XINO_TRUNC_STEP	4  /* blocks */
+#define AUFS_DIRWH_DEF		3
+#define AUFS_RDCACHE_DEF	10 /* seconds */
+#define AUFS_WKQ_NAME		AUFS_NAME "d"
+#define AUFS_NWKQ_DEF		4
+#define AUFS_MFS_SECOND_DEF	30 /* seconds */
+#define AUFS_PLINK_WARN		100 /* number of plinks */
+
+#ifdef CONFIG_AUFS_COMPAT
+#define AUFS_DIROPQ_NAME	"__dir_opaque"
+#else
+#define AUFS_DIROPQ_NAME	AUFS_WH_PFX ".opq" /* whiteouted doubly */
+#endif
+#define AUFS_WH_DIROPQ		AUFS_WH_PFX AUFS_DIROPQ_NAME
+
+#define AUFS_BASE_NAME		AUFS_WH_PFX AUFS_NAME
+#define AUFS_PLINKDIR_NAME	AUFS_WH_PFX "plnk"
+#define AUFS_TMPDIR_NAME	AUFS_WH_PFX ".tmp"
+
+/* doubly whiteouted */
+#define AUFS_WH_BASE		AUFS_WH_PFX AUFS_BASE_NAME
+#define AUFS_WH_PLINKDIR	AUFS_WH_PFX AUFS_PLINKDIR_NAME
+#define AUFS_WH_TMPDIR		AUFS_WH_PFX AUFS_TMPDIR_NAME
+
+/* ---------------------------------------------------------------------- */
+
+/* ioctl */
+#if 0 /* reserved for future use */
+enum {
+	AuCtlErr,
+	AuCtlErr_Last
+};
+enum {
+	AuCtl_DIROPQ_GET, AuCtl_DIROPQ_SET,
+	AuCtl_MOVE,
+	AuCtl_MVDOWN,
+
+	/* unimplmented */
+	AuCtl_REFRESH, AuCtl_REFRESHV,
+	AuCtl_FLUSH_PLINK,
+	AuCtl_CPUP,
+	AuCtl_CPDOWN
+};
+
+struct aufs_ctl {
+	int err;
+	aufs_bindex_t bsrc, bdst;
+	char *path;
+};
+
+#define AuCtlType		'A'
+#define AUFS_CTL_DIROPQ_GET	_IO(AuCtlType, AuCtl_DIROPQ_GET)
+#define AUFS_CTL_DIROPQ_SET	_IOW(AuCtlType, AuCtl_DIROPQ_SET, aufs_bindex_t)
+#define AUFS_CTL_MOVE \
+	_IOW(AuCtlType, AuCtl_MVDOWN, aufs_bindex_t)
+#define AUFS_CTL_MVDOWN \
+	_IOWR(AuCtlType, AuCtl_MVDOWN, struct aufs_ctl)
+
+#define AUFS_CTL_REFRESH	_IO(AuCtlType, AuCtl_REFRESH)
+#define AUFS_CTL_REFRESHV	_IO(AuCtlType, AuCtl_REFRESHV)
+#define AUFS_CTL_FLUSH_PLINK	_IOR(AuCtlType, AuCtl_FLUSH_PLINK)
+#define AUFS_CTL_CPUP		_IOWR(AuCtlType, AuCtl_CPUP, struct aufs_ctl)
+#define AUFS_CTL_CPDOWN \
+	_IOWR(AuCtlType, AuCtl_CPDOWN, struct aufs_ctl_cp)
+#endif
+
+#endif /* __AUFS_TYPE_H__ */
